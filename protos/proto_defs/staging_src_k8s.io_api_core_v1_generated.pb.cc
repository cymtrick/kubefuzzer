// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: staging_src_k8s.io_api_core_v1_generated.proto

#include "staging_src_k8s.io_api_core_v1_generated.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace k8s {
namespace io {
namespace api {
namespace core {
namespace v1 {
PROTOBUF_CONSTEXPR PodOrNode::PodOrNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.pod_)*/nullptr
  , /*decltype(_impl_.node_)*/nullptr} {}
struct PodOrNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PodOrNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PodOrNodeDefaultTypeInternal() {}
  union {
    PodOrNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PodOrNodeDefaultTypeInternal _PodOrNode_default_instance_;
PROTOBUF_CONSTEXPR AWSElasticBlockStoreVolumeSource::AWSElasticBlockStoreVolumeSource(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.volumeid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.fstype_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.partition_)*/0
  , /*decltype(_impl_.readonly_)*/false} {}
struct AWSElasticBlockStoreVolumeSourceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AWSElasticBlockStoreVolumeSourceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AWSElasticBlockStoreVolumeSourceDefaultTypeInternal() {}
  union {
    AWSElasticBlockStoreVolumeSource _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AWSElasticBlockStoreVolumeSourceDefaultTypeInternal _AWSElasticBlockStoreVolumeSource_default_instance_;
PROTOBUF_CONSTEXPR Affinity::Affinity(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.nodeaffinity_)*/nullptr
  , /*decltype(_impl_.podaffinity_)*/nullptr
  , /*decltype(_impl_.podantiaffinity_)*/nullptr} {}
struct AffinityDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AffinityDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AffinityDefaultTypeInternal() {}
  union {
    Affinity _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AffinityDefaultTypeInternal _Affinity_default_instance_;
PROTOBUF_CONSTEXPR AttachedVolume::AttachedVolume(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.devicepath_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct AttachedVolumeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AttachedVolumeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AttachedVolumeDefaultTypeInternal() {}
  union {
    AttachedVolume _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AttachedVolumeDefaultTypeInternal _AttachedVolume_default_instance_;
PROTOBUF_CONSTEXPR AvoidPods::AvoidPods(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.preferavoidpods_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AvoidPodsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AvoidPodsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AvoidPodsDefaultTypeInternal() {}
  union {
    AvoidPods _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AvoidPodsDefaultTypeInternal _AvoidPods_default_instance_;
PROTOBUF_CONSTEXPR AzureDiskVolumeSource::AzureDiskVolumeSource(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.diskname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.diskuri_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.cachingmode_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.fstype_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.kind_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.readonly_)*/false} {}
struct AzureDiskVolumeSourceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AzureDiskVolumeSourceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AzureDiskVolumeSourceDefaultTypeInternal() {}
  union {
    AzureDiskVolumeSource _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AzureDiskVolumeSourceDefaultTypeInternal _AzureDiskVolumeSource_default_instance_;
PROTOBUF_CONSTEXPR AzureFilePersistentVolumeSource::AzureFilePersistentVolumeSource(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.secretname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.sharename_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.secretnamespace_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.readonly_)*/false} {}
struct AzureFilePersistentVolumeSourceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AzureFilePersistentVolumeSourceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AzureFilePersistentVolumeSourceDefaultTypeInternal() {}
  union {
    AzureFilePersistentVolumeSource _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AzureFilePersistentVolumeSourceDefaultTypeInternal _AzureFilePersistentVolumeSource_default_instance_;
PROTOBUF_CONSTEXPR AzureFileVolumeSource::AzureFileVolumeSource(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.secretname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.sharename_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.readonly_)*/false} {}
struct AzureFileVolumeSourceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AzureFileVolumeSourceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AzureFileVolumeSourceDefaultTypeInternal() {}
  union {
    AzureFileVolumeSource _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AzureFileVolumeSourceDefaultTypeInternal _AzureFileVolumeSource_default_instance_;
PROTOBUF_CONSTEXPR Binding::Binding(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.metadata_)*/nullptr
  , /*decltype(_impl_.target_)*/nullptr} {}
struct BindingDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BindingDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BindingDefaultTypeInternal() {}
  union {
    Binding _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BindingDefaultTypeInternal _Binding_default_instance_;
PROTOBUF_CONSTEXPR CSIPersistentVolumeSource_VolumeAttributesEntry_DoNotUse::CSIPersistentVolumeSource_VolumeAttributesEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct CSIPersistentVolumeSource_VolumeAttributesEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSIPersistentVolumeSource_VolumeAttributesEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSIPersistentVolumeSource_VolumeAttributesEntry_DoNotUseDefaultTypeInternal() {}
  union {
    CSIPersistentVolumeSource_VolumeAttributesEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSIPersistentVolumeSource_VolumeAttributesEntry_DoNotUseDefaultTypeInternal _CSIPersistentVolumeSource_VolumeAttributesEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR CSIPersistentVolumeSource::CSIPersistentVolumeSource(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.volumeattributes_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.driver_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.volumehandle_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.fstype_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.controllerpublishsecretref_)*/nullptr
  , /*decltype(_impl_.nodestagesecretref_)*/nullptr
  , /*decltype(_impl_.nodepublishsecretref_)*/nullptr
  , /*decltype(_impl_.controllerexpandsecretref_)*/nullptr
  , /*decltype(_impl_.nodeexpandsecretref_)*/nullptr
  , /*decltype(_impl_.readonly_)*/false} {}
struct CSIPersistentVolumeSourceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSIPersistentVolumeSourceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSIPersistentVolumeSourceDefaultTypeInternal() {}
  union {
    CSIPersistentVolumeSource _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSIPersistentVolumeSourceDefaultTypeInternal _CSIPersistentVolumeSource_default_instance_;
PROTOBUF_CONSTEXPR CSIVolumeSource_VolumeAttributesEntry_DoNotUse::CSIVolumeSource_VolumeAttributesEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct CSIVolumeSource_VolumeAttributesEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSIVolumeSource_VolumeAttributesEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSIVolumeSource_VolumeAttributesEntry_DoNotUseDefaultTypeInternal() {}
  union {
    CSIVolumeSource_VolumeAttributesEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSIVolumeSource_VolumeAttributesEntry_DoNotUseDefaultTypeInternal _CSIVolumeSource_VolumeAttributesEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR CSIVolumeSource::CSIVolumeSource(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.volumeattributes_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.driver_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.fstype_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.nodepublishsecretref_)*/nullptr
  , /*decltype(_impl_.readonly_)*/false} {}
struct CSIVolumeSourceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSIVolumeSourceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSIVolumeSourceDefaultTypeInternal() {}
  union {
    CSIVolumeSource _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSIVolumeSourceDefaultTypeInternal _CSIVolumeSource_default_instance_;
PROTOBUF_CONSTEXPR Capabilities::Capabilities(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.add_)*/{}
  , /*decltype(_impl_.drop_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CapabilitiesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CapabilitiesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CapabilitiesDefaultTypeInternal() {}
  union {
    Capabilities _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CapabilitiesDefaultTypeInternal _Capabilities_default_instance_;
PROTOBUF_CONSTEXPR CephFSPersistentVolumeSource::CephFSPersistentVolumeSource(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.monitors_)*/{}
  , /*decltype(_impl_.path_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.user_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.secretfile_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.secretref_)*/nullptr
  , /*decltype(_impl_.readonly_)*/false} {}
struct CephFSPersistentVolumeSourceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CephFSPersistentVolumeSourceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CephFSPersistentVolumeSourceDefaultTypeInternal() {}
  union {
    CephFSPersistentVolumeSource _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CephFSPersistentVolumeSourceDefaultTypeInternal _CephFSPersistentVolumeSource_default_instance_;
PROTOBUF_CONSTEXPR CephFSVolumeSource::CephFSVolumeSource(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.monitors_)*/{}
  , /*decltype(_impl_.path_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.user_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.secretfile_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.secretref_)*/nullptr
  , /*decltype(_impl_.readonly_)*/false} {}
struct CephFSVolumeSourceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CephFSVolumeSourceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CephFSVolumeSourceDefaultTypeInternal() {}
  union {
    CephFSVolumeSource _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CephFSVolumeSourceDefaultTypeInternal _CephFSVolumeSource_default_instance_;
PROTOBUF_CONSTEXPR CinderPersistentVolumeSource::CinderPersistentVolumeSource(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.volumeid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.fstype_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.secretref_)*/nullptr
  , /*decltype(_impl_.readonly_)*/false} {}
struct CinderPersistentVolumeSourceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CinderPersistentVolumeSourceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CinderPersistentVolumeSourceDefaultTypeInternal() {}
  union {
    CinderPersistentVolumeSource _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CinderPersistentVolumeSourceDefaultTypeInternal _CinderPersistentVolumeSource_default_instance_;
PROTOBUF_CONSTEXPR CinderVolumeSource::CinderVolumeSource(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.volumeid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.fstype_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.secretref_)*/nullptr
  , /*decltype(_impl_.readonly_)*/false} {}
struct CinderVolumeSourceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CinderVolumeSourceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CinderVolumeSourceDefaultTypeInternal() {}
  union {
    CinderVolumeSource _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CinderVolumeSourceDefaultTypeInternal _CinderVolumeSource_default_instance_;
PROTOBUF_CONSTEXPR ClaimSource::ClaimSource(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.resourceclaimname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.resourceclaimtemplatename_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct ClaimSourceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClaimSourceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClaimSourceDefaultTypeInternal() {}
  union {
    ClaimSource _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClaimSourceDefaultTypeInternal _ClaimSource_default_instance_;
PROTOBUF_CONSTEXPR ClientIPConfig::ClientIPConfig(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.timeoutseconds_)*/0} {}
struct ClientIPConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientIPConfigDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientIPConfigDefaultTypeInternal() {}
  union {
    ClientIPConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientIPConfigDefaultTypeInternal _ClientIPConfig_default_instance_;
PROTOBUF_CONSTEXPR ClusterTrustBundleProjection::ClusterTrustBundleProjection(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.signername_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.path_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.labelselector_)*/nullptr
  , /*decltype(_impl_.optional_)*/false} {}
struct ClusterTrustBundleProjectionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClusterTrustBundleProjectionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClusterTrustBundleProjectionDefaultTypeInternal() {}
  union {
    ClusterTrustBundleProjection _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClusterTrustBundleProjectionDefaultTypeInternal _ClusterTrustBundleProjection_default_instance_;
PROTOBUF_CONSTEXPR ComponentCondition::ComponentCondition(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.type_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.status_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.message_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.error_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct ComponentConditionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ComponentConditionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ComponentConditionDefaultTypeInternal() {}
  union {
    ComponentCondition _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ComponentConditionDefaultTypeInternal _ComponentCondition_default_instance_;
PROTOBUF_CONSTEXPR ComponentStatus::ComponentStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.conditions_)*/{}
  , /*decltype(_impl_.metadata_)*/nullptr} {}
struct ComponentStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ComponentStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ComponentStatusDefaultTypeInternal() {}
  union {
    ComponentStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ComponentStatusDefaultTypeInternal _ComponentStatus_default_instance_;
PROTOBUF_CONSTEXPR ComponentStatusList::ComponentStatusList(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.items_)*/{}
  , /*decltype(_impl_.metadata_)*/nullptr} {}
struct ComponentStatusListDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ComponentStatusListDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ComponentStatusListDefaultTypeInternal() {}
  union {
    ComponentStatusList _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ComponentStatusListDefaultTypeInternal _ComponentStatusList_default_instance_;
PROTOBUF_CONSTEXPR ConfigMap_DataEntry_DoNotUse::ConfigMap_DataEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct ConfigMap_DataEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConfigMap_DataEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConfigMap_DataEntry_DoNotUseDefaultTypeInternal() {}
  union {
    ConfigMap_DataEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConfigMap_DataEntry_DoNotUseDefaultTypeInternal _ConfigMap_DataEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR ConfigMap_BinaryDataEntry_DoNotUse::ConfigMap_BinaryDataEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct ConfigMap_BinaryDataEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConfigMap_BinaryDataEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConfigMap_BinaryDataEntry_DoNotUseDefaultTypeInternal() {}
  union {
    ConfigMap_BinaryDataEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConfigMap_BinaryDataEntry_DoNotUseDefaultTypeInternal _ConfigMap_BinaryDataEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR ConfigMap::ConfigMap(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.data_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.binarydata_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.metadata_)*/nullptr
  , /*decltype(_impl_.immutable_)*/false} {}
struct ConfigMapDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConfigMapDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConfigMapDefaultTypeInternal() {}
  union {
    ConfigMap _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConfigMapDefaultTypeInternal _ConfigMap_default_instance_;
PROTOBUF_CONSTEXPR ConfigMapEnvSource::ConfigMapEnvSource(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.localobjectreference_)*/nullptr
  , /*decltype(_impl_.optional_)*/false} {}
struct ConfigMapEnvSourceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConfigMapEnvSourceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConfigMapEnvSourceDefaultTypeInternal() {}
  union {
    ConfigMapEnvSource _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConfigMapEnvSourceDefaultTypeInternal _ConfigMapEnvSource_default_instance_;
PROTOBUF_CONSTEXPR ConfigMapKeySelector::ConfigMapKeySelector(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.localobjectreference_)*/nullptr
  , /*decltype(_impl_.optional_)*/false} {}
struct ConfigMapKeySelectorDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConfigMapKeySelectorDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConfigMapKeySelectorDefaultTypeInternal() {}
  union {
    ConfigMapKeySelector _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConfigMapKeySelectorDefaultTypeInternal _ConfigMapKeySelector_default_instance_;
PROTOBUF_CONSTEXPR ConfigMapList::ConfigMapList(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.items_)*/{}
  , /*decltype(_impl_.metadata_)*/nullptr} {}
struct ConfigMapListDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConfigMapListDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConfigMapListDefaultTypeInternal() {}
  union {
    ConfigMapList _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConfigMapListDefaultTypeInternal _ConfigMapList_default_instance_;
PROTOBUF_CONSTEXPR ConfigMapNodeConfigSource::ConfigMapNodeConfigSource(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.namespace__)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.uid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.resourceversion_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.kubeletconfigkey_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct ConfigMapNodeConfigSourceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConfigMapNodeConfigSourceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConfigMapNodeConfigSourceDefaultTypeInternal() {}
  union {
    ConfigMapNodeConfigSource _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConfigMapNodeConfigSourceDefaultTypeInternal _ConfigMapNodeConfigSource_default_instance_;
PROTOBUF_CONSTEXPR ConfigMapProjection::ConfigMapProjection(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.items_)*/{}
  , /*decltype(_impl_.localobjectreference_)*/nullptr
  , /*decltype(_impl_.optional_)*/false} {}
struct ConfigMapProjectionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConfigMapProjectionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConfigMapProjectionDefaultTypeInternal() {}
  union {
    ConfigMapProjection _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConfigMapProjectionDefaultTypeInternal _ConfigMapProjection_default_instance_;
PROTOBUF_CONSTEXPR ConfigMapVolumeSource::ConfigMapVolumeSource(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.items_)*/{}
  , /*decltype(_impl_.localobjectreference_)*/nullptr
  , /*decltype(_impl_.defaultmode_)*/0
  , /*decltype(_impl_.optional_)*/false} {}
struct ConfigMapVolumeSourceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConfigMapVolumeSourceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConfigMapVolumeSourceDefaultTypeInternal() {}
  union {
    ConfigMapVolumeSource _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConfigMapVolumeSourceDefaultTypeInternal _ConfigMapVolumeSource_default_instance_;
PROTOBUF_CONSTEXPR Container::Container(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.command_)*/{}
  , /*decltype(_impl_.args_)*/{}
  , /*decltype(_impl_.ports_)*/{}
  , /*decltype(_impl_.env_)*/{}
  , /*decltype(_impl_.volumemounts_)*/{}
  , /*decltype(_impl_.envfrom_)*/{}
  , /*decltype(_impl_.volumedevices_)*/{}
  , /*decltype(_impl_.resizepolicy_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.image_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.workingdir_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.terminationmessagepath_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.imagepullpolicy_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.terminationmessagepolicy_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.restartpolicy_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.resources_)*/nullptr
  , /*decltype(_impl_.livenessprobe_)*/nullptr
  , /*decltype(_impl_.readinessprobe_)*/nullptr
  , /*decltype(_impl_.lifecycle_)*/nullptr
  , /*decltype(_impl_.securitycontext_)*/nullptr
  , /*decltype(_impl_.startupprobe_)*/nullptr
  , /*decltype(_impl_.stdin_)*/false
  , /*decltype(_impl_.stdinonce_)*/false
  , /*decltype(_impl_.tty_)*/false} {}
struct ContainerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ContainerDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ContainerDefaultTypeInternal() {}
  union {
    Container _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContainerDefaultTypeInternal _Container_default_instance_;
PROTOBUF_CONSTEXPR ContainerImage::ContainerImage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.names_)*/{}
  , /*decltype(_impl_.sizebytes_)*/int64_t{0}} {}
struct ContainerImageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ContainerImageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ContainerImageDefaultTypeInternal() {}
  union {
    ContainerImage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContainerImageDefaultTypeInternal _ContainerImage_default_instance_;
PROTOBUF_CONSTEXPR ContainerPort::ContainerPort(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.protocol_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.hostip_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.hostport_)*/0
  , /*decltype(_impl_.containerport_)*/0} {}
struct ContainerPortDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ContainerPortDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ContainerPortDefaultTypeInternal() {}
  union {
    ContainerPort _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContainerPortDefaultTypeInternal _ContainerPort_default_instance_;
PROTOBUF_CONSTEXPR ContainerResizePolicy::ContainerResizePolicy(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.resourcename_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.restartpolicy_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct ContainerResizePolicyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ContainerResizePolicyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ContainerResizePolicyDefaultTypeInternal() {}
  union {
    ContainerResizePolicy _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContainerResizePolicyDefaultTypeInternal _ContainerResizePolicy_default_instance_;
PROTOBUF_CONSTEXPR ContainerState::ContainerState(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.waiting_)*/nullptr
  , /*decltype(_impl_.running_)*/nullptr
  , /*decltype(_impl_.terminated_)*/nullptr} {}
struct ContainerStateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ContainerStateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ContainerStateDefaultTypeInternal() {}
  union {
    ContainerState _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContainerStateDefaultTypeInternal _ContainerState_default_instance_;
PROTOBUF_CONSTEXPR ContainerStateRunning::ContainerStateRunning(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.startedat_)*/nullptr} {}
struct ContainerStateRunningDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ContainerStateRunningDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ContainerStateRunningDefaultTypeInternal() {}
  union {
    ContainerStateRunning _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContainerStateRunningDefaultTypeInternal _ContainerStateRunning_default_instance_;
PROTOBUF_CONSTEXPR ContainerStateTerminated::ContainerStateTerminated(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.reason_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.message_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.containerid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.startedat_)*/nullptr
  , /*decltype(_impl_.finishedat_)*/nullptr
  , /*decltype(_impl_.exitcode_)*/0
  , /*decltype(_impl_.signal_)*/0} {}
struct ContainerStateTerminatedDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ContainerStateTerminatedDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ContainerStateTerminatedDefaultTypeInternal() {}
  union {
    ContainerStateTerminated _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContainerStateTerminatedDefaultTypeInternal _ContainerStateTerminated_default_instance_;
PROTOBUF_CONSTEXPR ContainerStateWaiting::ContainerStateWaiting(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.reason_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.message_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct ContainerStateWaitingDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ContainerStateWaitingDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ContainerStateWaitingDefaultTypeInternal() {}
  union {
    ContainerStateWaiting _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContainerStateWaitingDefaultTypeInternal _ContainerStateWaiting_default_instance_;
PROTOBUF_CONSTEXPR ContainerStatus_AllocatedResourcesEntry_DoNotUse::ContainerStatus_AllocatedResourcesEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct ContainerStatus_AllocatedResourcesEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ContainerStatus_AllocatedResourcesEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ContainerStatus_AllocatedResourcesEntry_DoNotUseDefaultTypeInternal() {}
  union {
    ContainerStatus_AllocatedResourcesEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContainerStatus_AllocatedResourcesEntry_DoNotUseDefaultTypeInternal _ContainerStatus_AllocatedResourcesEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR ContainerStatus::ContainerStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.allocatedresources_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.image_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.imageid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.containerid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.state_)*/nullptr
  , /*decltype(_impl_.laststate_)*/nullptr
  , /*decltype(_impl_.resources_)*/nullptr
  , /*decltype(_impl_.restartcount_)*/0
  , /*decltype(_impl_.ready_)*/false
  , /*decltype(_impl_.started_)*/false} {}
struct ContainerStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ContainerStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ContainerStatusDefaultTypeInternal() {}
  union {
    ContainerStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContainerStatusDefaultTypeInternal _ContainerStatus_default_instance_;
PROTOBUF_CONSTEXPR DaemonEndpoint::DaemonEndpoint(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.port_)*/0} {}
struct DaemonEndpointDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DaemonEndpointDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DaemonEndpointDefaultTypeInternal() {}
  union {
    DaemonEndpoint _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DaemonEndpointDefaultTypeInternal _DaemonEndpoint_default_instance_;
PROTOBUF_CONSTEXPR DownwardAPIProjection::DownwardAPIProjection(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.items_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DownwardAPIProjectionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DownwardAPIProjectionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DownwardAPIProjectionDefaultTypeInternal() {}
  union {
    DownwardAPIProjection _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DownwardAPIProjectionDefaultTypeInternal _DownwardAPIProjection_default_instance_;
PROTOBUF_CONSTEXPR DownwardAPIVolumeFile::DownwardAPIVolumeFile(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.path_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.fieldref_)*/nullptr
  , /*decltype(_impl_.resourcefieldref_)*/nullptr
  , /*decltype(_impl_.mode_)*/0} {}
struct DownwardAPIVolumeFileDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DownwardAPIVolumeFileDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DownwardAPIVolumeFileDefaultTypeInternal() {}
  union {
    DownwardAPIVolumeFile _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DownwardAPIVolumeFileDefaultTypeInternal _DownwardAPIVolumeFile_default_instance_;
PROTOBUF_CONSTEXPR DownwardAPIVolumeSource::DownwardAPIVolumeSource(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.items_)*/{}
  , /*decltype(_impl_.defaultmode_)*/0} {}
struct DownwardAPIVolumeSourceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DownwardAPIVolumeSourceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DownwardAPIVolumeSourceDefaultTypeInternal() {}
  union {
    DownwardAPIVolumeSource _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DownwardAPIVolumeSourceDefaultTypeInternal _DownwardAPIVolumeSource_default_instance_;
PROTOBUF_CONSTEXPR EmptyDirVolumeSource::EmptyDirVolumeSource(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.medium_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.sizelimit_)*/nullptr} {}
struct EmptyDirVolumeSourceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EmptyDirVolumeSourceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EmptyDirVolumeSourceDefaultTypeInternal() {}
  union {
    EmptyDirVolumeSource _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EmptyDirVolumeSourceDefaultTypeInternal _EmptyDirVolumeSource_default_instance_;
PROTOBUF_CONSTEXPR EndpointAddress::EndpointAddress(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ip_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.hostname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.nodename_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.targetref_)*/nullptr} {}
struct EndpointAddressDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EndpointAddressDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EndpointAddressDefaultTypeInternal() {}
  union {
    EndpointAddress _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EndpointAddressDefaultTypeInternal _EndpointAddress_default_instance_;
PROTOBUF_CONSTEXPR EndpointPort::EndpointPort(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.protocol_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.appprotocol_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.port_)*/0} {}
struct EndpointPortDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EndpointPortDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EndpointPortDefaultTypeInternal() {}
  union {
    EndpointPort _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EndpointPortDefaultTypeInternal _EndpointPort_default_instance_;
PROTOBUF_CONSTEXPR EndpointSubset::EndpointSubset(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.addresses_)*/{}
  , /*decltype(_impl_.notreadyaddresses_)*/{}
  , /*decltype(_impl_.ports_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct EndpointSubsetDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EndpointSubsetDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EndpointSubsetDefaultTypeInternal() {}
  union {
    EndpointSubset _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EndpointSubsetDefaultTypeInternal _EndpointSubset_default_instance_;
PROTOBUF_CONSTEXPR Endpoints::Endpoints(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.subsets_)*/{}
  , /*decltype(_impl_.metadata_)*/nullptr} {}
struct EndpointsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EndpointsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EndpointsDefaultTypeInternal() {}
  union {
    Endpoints _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EndpointsDefaultTypeInternal _Endpoints_default_instance_;
PROTOBUF_CONSTEXPR EndpointsList::EndpointsList(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.items_)*/{}
  , /*decltype(_impl_.metadata_)*/nullptr} {}
struct EndpointsListDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EndpointsListDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EndpointsListDefaultTypeInternal() {}
  union {
    EndpointsList _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EndpointsListDefaultTypeInternal _EndpointsList_default_instance_;
PROTOBUF_CONSTEXPR EnvFromSource::EnvFromSource(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.prefix_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.configmapref_)*/nullptr
  , /*decltype(_impl_.secretref_)*/nullptr} {}
struct EnvFromSourceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EnvFromSourceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EnvFromSourceDefaultTypeInternal() {}
  union {
    EnvFromSource _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EnvFromSourceDefaultTypeInternal _EnvFromSource_default_instance_;
PROTOBUF_CONSTEXPR EnvVar::EnvVar(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.value_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.valuefrom_)*/nullptr} {}
struct EnvVarDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EnvVarDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EnvVarDefaultTypeInternal() {}
  union {
    EnvVar _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EnvVarDefaultTypeInternal _EnvVar_default_instance_;
PROTOBUF_CONSTEXPR EnvVarSource::EnvVarSource(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.fieldref_)*/nullptr
  , /*decltype(_impl_.resourcefieldref_)*/nullptr
  , /*decltype(_impl_.configmapkeyref_)*/nullptr
  , /*decltype(_impl_.secretkeyref_)*/nullptr} {}
struct EnvVarSourceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EnvVarSourceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EnvVarSourceDefaultTypeInternal() {}
  union {
    EnvVarSource _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EnvVarSourceDefaultTypeInternal _EnvVarSource_default_instance_;
PROTOBUF_CONSTEXPR EphemeralContainer::EphemeralContainer(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.targetcontainername_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.ephemeralcontainercommon_)*/nullptr} {}
struct EphemeralContainerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EphemeralContainerDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EphemeralContainerDefaultTypeInternal() {}
  union {
    EphemeralContainer _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EphemeralContainerDefaultTypeInternal _EphemeralContainer_default_instance_;
PROTOBUF_CONSTEXPR EphemeralContainerCommon::EphemeralContainerCommon(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.command_)*/{}
  , /*decltype(_impl_.args_)*/{}
  , /*decltype(_impl_.ports_)*/{}
  , /*decltype(_impl_.env_)*/{}
  , /*decltype(_impl_.volumemounts_)*/{}
  , /*decltype(_impl_.envfrom_)*/{}
  , /*decltype(_impl_.volumedevices_)*/{}
  , /*decltype(_impl_.resizepolicy_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.image_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.workingdir_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.terminationmessagepath_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.imagepullpolicy_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.terminationmessagepolicy_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.restartpolicy_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.resources_)*/nullptr
  , /*decltype(_impl_.livenessprobe_)*/nullptr
  , /*decltype(_impl_.readinessprobe_)*/nullptr
  , /*decltype(_impl_.lifecycle_)*/nullptr
  , /*decltype(_impl_.securitycontext_)*/nullptr
  , /*decltype(_impl_.startupprobe_)*/nullptr
  , /*decltype(_impl_.stdin_)*/false
  , /*decltype(_impl_.stdinonce_)*/false
  , /*decltype(_impl_.tty_)*/false} {}
struct EphemeralContainerCommonDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EphemeralContainerCommonDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EphemeralContainerCommonDefaultTypeInternal() {}
  union {
    EphemeralContainerCommon _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EphemeralContainerCommonDefaultTypeInternal _EphemeralContainerCommon_default_instance_;
PROTOBUF_CONSTEXPR EphemeralVolumeSource::EphemeralVolumeSource(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.volumeclaimtemplate_)*/nullptr} {}
struct EphemeralVolumeSourceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EphemeralVolumeSourceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EphemeralVolumeSourceDefaultTypeInternal() {}
  union {
    EphemeralVolumeSource _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EphemeralVolumeSourceDefaultTypeInternal _EphemeralVolumeSource_default_instance_;
PROTOBUF_CONSTEXPR Event::Event(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.reason_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.message_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.type_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.action_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.reportingcomponent_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.reportinginstance_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.metadata_)*/nullptr
  , /*decltype(_impl_.involvedobject_)*/nullptr
  , /*decltype(_impl_.source_)*/nullptr
  , /*decltype(_impl_.firsttimestamp_)*/nullptr
  , /*decltype(_impl_.lasttimestamp_)*/nullptr
  , /*decltype(_impl_.eventtime_)*/nullptr
  , /*decltype(_impl_.series_)*/nullptr
  , /*decltype(_impl_.related_)*/nullptr
  , /*decltype(_impl_.count_)*/0} {}
struct EventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EventDefaultTypeInternal() {}
  union {
    Event _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EventDefaultTypeInternal _Event_default_instance_;
PROTOBUF_CONSTEXPR EventList::EventList(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.items_)*/{}
  , /*decltype(_impl_.metadata_)*/nullptr} {}
struct EventListDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EventListDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EventListDefaultTypeInternal() {}
  union {
    EventList _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EventListDefaultTypeInternal _EventList_default_instance_;
PROTOBUF_CONSTEXPR EventSeries::EventSeries(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.lastobservedtime_)*/nullptr
  , /*decltype(_impl_.count_)*/0} {}
struct EventSeriesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EventSeriesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EventSeriesDefaultTypeInternal() {}
  union {
    EventSeries _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EventSeriesDefaultTypeInternal _EventSeries_default_instance_;
PROTOBUF_CONSTEXPR EventSource::EventSource(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.component_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.host_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct EventSourceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EventSourceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EventSourceDefaultTypeInternal() {}
  union {
    EventSource _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EventSourceDefaultTypeInternal _EventSource_default_instance_;
PROTOBUF_CONSTEXPR ExecAction::ExecAction(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.command_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ExecActionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ExecActionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ExecActionDefaultTypeInternal() {}
  union {
    ExecAction _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ExecActionDefaultTypeInternal _ExecAction_default_instance_;
PROTOBUF_CONSTEXPR FCVolumeSource::FCVolumeSource(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.targetwwns_)*/{}
  , /*decltype(_impl_.wwids_)*/{}
  , /*decltype(_impl_.fstype_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.lun_)*/0
  , /*decltype(_impl_.readonly_)*/false} {}
struct FCVolumeSourceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FCVolumeSourceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FCVolumeSourceDefaultTypeInternal() {}
  union {
    FCVolumeSource _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FCVolumeSourceDefaultTypeInternal _FCVolumeSource_default_instance_;
PROTOBUF_CONSTEXPR FlexPersistentVolumeSource_OptionsEntry_DoNotUse::FlexPersistentVolumeSource_OptionsEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct FlexPersistentVolumeSource_OptionsEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FlexPersistentVolumeSource_OptionsEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FlexPersistentVolumeSource_OptionsEntry_DoNotUseDefaultTypeInternal() {}
  union {
    FlexPersistentVolumeSource_OptionsEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FlexPersistentVolumeSource_OptionsEntry_DoNotUseDefaultTypeInternal _FlexPersistentVolumeSource_OptionsEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR FlexPersistentVolumeSource::FlexPersistentVolumeSource(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.options_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.driver_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.fstype_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.secretref_)*/nullptr
  , /*decltype(_impl_.readonly_)*/false} {}
struct FlexPersistentVolumeSourceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FlexPersistentVolumeSourceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FlexPersistentVolumeSourceDefaultTypeInternal() {}
  union {
    FlexPersistentVolumeSource _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FlexPersistentVolumeSourceDefaultTypeInternal _FlexPersistentVolumeSource_default_instance_;
PROTOBUF_CONSTEXPR FlexVolumeSource_OptionsEntry_DoNotUse::FlexVolumeSource_OptionsEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct FlexVolumeSource_OptionsEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FlexVolumeSource_OptionsEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FlexVolumeSource_OptionsEntry_DoNotUseDefaultTypeInternal() {}
  union {
    FlexVolumeSource_OptionsEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FlexVolumeSource_OptionsEntry_DoNotUseDefaultTypeInternal _FlexVolumeSource_OptionsEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR FlexVolumeSource::FlexVolumeSource(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.options_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.driver_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.fstype_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.secretref_)*/nullptr
  , /*decltype(_impl_.readonly_)*/false} {}
struct FlexVolumeSourceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FlexVolumeSourceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FlexVolumeSourceDefaultTypeInternal() {}
  union {
    FlexVolumeSource _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FlexVolumeSourceDefaultTypeInternal _FlexVolumeSource_default_instance_;
PROTOBUF_CONSTEXPR FlockerVolumeSource::FlockerVolumeSource(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.datasetname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.datasetuuid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct FlockerVolumeSourceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FlockerVolumeSourceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FlockerVolumeSourceDefaultTypeInternal() {}
  union {
    FlockerVolumeSource _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FlockerVolumeSourceDefaultTypeInternal _FlockerVolumeSource_default_instance_;
PROTOBUF_CONSTEXPR GCEPersistentDiskVolumeSource::GCEPersistentDiskVolumeSource(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.pdname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.fstype_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.partition_)*/0
  , /*decltype(_impl_.readonly_)*/false} {}
struct GCEPersistentDiskVolumeSourceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GCEPersistentDiskVolumeSourceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GCEPersistentDiskVolumeSourceDefaultTypeInternal() {}
  union {
    GCEPersistentDiskVolumeSource _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GCEPersistentDiskVolumeSourceDefaultTypeInternal _GCEPersistentDiskVolumeSource_default_instance_;
PROTOBUF_CONSTEXPR GRPCAction::GRPCAction(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.service_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.port_)*/0} {}
struct GRPCActionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GRPCActionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GRPCActionDefaultTypeInternal() {}
  union {
    GRPCAction _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GRPCActionDefaultTypeInternal _GRPCAction_default_instance_;
PROTOBUF_CONSTEXPR GitRepoVolumeSource::GitRepoVolumeSource(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.repository_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.revision_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.directory_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct GitRepoVolumeSourceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GitRepoVolumeSourceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GitRepoVolumeSourceDefaultTypeInternal() {}
  union {
    GitRepoVolumeSource _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GitRepoVolumeSourceDefaultTypeInternal _GitRepoVolumeSource_default_instance_;
PROTOBUF_CONSTEXPR GlusterfsPersistentVolumeSource::GlusterfsPersistentVolumeSource(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.endpoints_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.path_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.endpointsnamespace_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.readonly_)*/false} {}
struct GlusterfsPersistentVolumeSourceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GlusterfsPersistentVolumeSourceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GlusterfsPersistentVolumeSourceDefaultTypeInternal() {}
  union {
    GlusterfsPersistentVolumeSource _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GlusterfsPersistentVolumeSourceDefaultTypeInternal _GlusterfsPersistentVolumeSource_default_instance_;
PROTOBUF_CONSTEXPR GlusterfsVolumeSource::GlusterfsVolumeSource(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.endpoints_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.path_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.readonly_)*/false} {}
struct GlusterfsVolumeSourceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GlusterfsVolumeSourceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GlusterfsVolumeSourceDefaultTypeInternal() {}
  union {
    GlusterfsVolumeSource _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GlusterfsVolumeSourceDefaultTypeInternal _GlusterfsVolumeSource_default_instance_;
PROTOBUF_CONSTEXPR HTTPGetAction::HTTPGetAction(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.httpheaders_)*/{}
  , /*decltype(_impl_.path_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.host_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.scheme_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.port_)*/nullptr} {}
struct HTTPGetActionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HTTPGetActionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~HTTPGetActionDefaultTypeInternal() {}
  union {
    HTTPGetAction _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HTTPGetActionDefaultTypeInternal _HTTPGetAction_default_instance_;
PROTOBUF_CONSTEXPR HTTPHeader::HTTPHeader(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.value_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct HTTPHeaderDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HTTPHeaderDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~HTTPHeaderDefaultTypeInternal() {}
  union {
    HTTPHeader _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HTTPHeaderDefaultTypeInternal _HTTPHeader_default_instance_;
PROTOBUF_CONSTEXPR HostAlias::HostAlias(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.hostnames_)*/{}
  , /*decltype(_impl_.ip_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct HostAliasDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HostAliasDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~HostAliasDefaultTypeInternal() {}
  union {
    HostAlias _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HostAliasDefaultTypeInternal _HostAlias_default_instance_;
PROTOBUF_CONSTEXPR HostIP::HostIP(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ip_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct HostIPDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HostIPDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~HostIPDefaultTypeInternal() {}
  union {
    HostIP _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HostIPDefaultTypeInternal _HostIP_default_instance_;
PROTOBUF_CONSTEXPR HostPathVolumeSource::HostPathVolumeSource(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.path_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.type_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct HostPathVolumeSourceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HostPathVolumeSourceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~HostPathVolumeSourceDefaultTypeInternal() {}
  union {
    HostPathVolumeSource _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HostPathVolumeSourceDefaultTypeInternal _HostPathVolumeSource_default_instance_;
PROTOBUF_CONSTEXPR ISCSIPersistentVolumeSource::ISCSIPersistentVolumeSource(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.portals_)*/{}
  , /*decltype(_impl_.targetportal_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.iqn_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.iscsiinterface_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.fstype_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.initiatorname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.secretref_)*/nullptr
  , /*decltype(_impl_.lun_)*/0
  , /*decltype(_impl_.readonly_)*/false
  , /*decltype(_impl_.chapauthdiscovery_)*/false
  , /*decltype(_impl_.chapauthsession_)*/false} {}
struct ISCSIPersistentVolumeSourceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ISCSIPersistentVolumeSourceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ISCSIPersistentVolumeSourceDefaultTypeInternal() {}
  union {
    ISCSIPersistentVolumeSource _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ISCSIPersistentVolumeSourceDefaultTypeInternal _ISCSIPersistentVolumeSource_default_instance_;
PROTOBUF_CONSTEXPR ISCSIVolumeSource::ISCSIVolumeSource(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.portals_)*/{}
  , /*decltype(_impl_.targetportal_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.iqn_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.iscsiinterface_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.fstype_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.initiatorname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.secretref_)*/nullptr
  , /*decltype(_impl_.lun_)*/0
  , /*decltype(_impl_.readonly_)*/false
  , /*decltype(_impl_.chapauthdiscovery_)*/false
  , /*decltype(_impl_.chapauthsession_)*/false} {}
struct ISCSIVolumeSourceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ISCSIVolumeSourceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ISCSIVolumeSourceDefaultTypeInternal() {}
  union {
    ISCSIVolumeSource _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ISCSIVolumeSourceDefaultTypeInternal _ISCSIVolumeSource_default_instance_;
PROTOBUF_CONSTEXPR KeyToPath::KeyToPath(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.path_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.mode_)*/0} {}
struct KeyToPathDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KeyToPathDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KeyToPathDefaultTypeInternal() {}
  union {
    KeyToPath _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KeyToPathDefaultTypeInternal _KeyToPath_default_instance_;
PROTOBUF_CONSTEXPR Lifecycle::Lifecycle(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.poststart_)*/nullptr
  , /*decltype(_impl_.prestop_)*/nullptr} {}
struct LifecycleDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LifecycleDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LifecycleDefaultTypeInternal() {}
  union {
    Lifecycle _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LifecycleDefaultTypeInternal _Lifecycle_default_instance_;
PROTOBUF_CONSTEXPR LifecycleHandler::LifecycleHandler(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.exec_)*/nullptr
  , /*decltype(_impl_.httpget_)*/nullptr
  , /*decltype(_impl_.tcpsocket_)*/nullptr
  , /*decltype(_impl_.sleep_)*/nullptr} {}
struct LifecycleHandlerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LifecycleHandlerDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LifecycleHandlerDefaultTypeInternal() {}
  union {
    LifecycleHandler _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LifecycleHandlerDefaultTypeInternal _LifecycleHandler_default_instance_;
PROTOBUF_CONSTEXPR LimitRange::LimitRange(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.metadata_)*/nullptr
  , /*decltype(_impl_.spec_)*/nullptr} {}
struct LimitRangeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LimitRangeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LimitRangeDefaultTypeInternal() {}
  union {
    LimitRange _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LimitRangeDefaultTypeInternal _LimitRange_default_instance_;
PROTOBUF_CONSTEXPR LimitRangeItem_MaxEntry_DoNotUse::LimitRangeItem_MaxEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct LimitRangeItem_MaxEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LimitRangeItem_MaxEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LimitRangeItem_MaxEntry_DoNotUseDefaultTypeInternal() {}
  union {
    LimitRangeItem_MaxEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LimitRangeItem_MaxEntry_DoNotUseDefaultTypeInternal _LimitRangeItem_MaxEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR LimitRangeItem_MinEntry_DoNotUse::LimitRangeItem_MinEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct LimitRangeItem_MinEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LimitRangeItem_MinEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LimitRangeItem_MinEntry_DoNotUseDefaultTypeInternal() {}
  union {
    LimitRangeItem_MinEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LimitRangeItem_MinEntry_DoNotUseDefaultTypeInternal _LimitRangeItem_MinEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR LimitRangeItem_DefaultEntry_DoNotUse::LimitRangeItem_DefaultEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct LimitRangeItem_DefaultEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LimitRangeItem_DefaultEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LimitRangeItem_DefaultEntry_DoNotUseDefaultTypeInternal() {}
  union {
    LimitRangeItem_DefaultEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LimitRangeItem_DefaultEntry_DoNotUseDefaultTypeInternal _LimitRangeItem_DefaultEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR LimitRangeItem_DefaultRequestEntry_DoNotUse::LimitRangeItem_DefaultRequestEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct LimitRangeItem_DefaultRequestEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LimitRangeItem_DefaultRequestEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LimitRangeItem_DefaultRequestEntry_DoNotUseDefaultTypeInternal() {}
  union {
    LimitRangeItem_DefaultRequestEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LimitRangeItem_DefaultRequestEntry_DoNotUseDefaultTypeInternal _LimitRangeItem_DefaultRequestEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR LimitRangeItem_MaxLimitRequestRatioEntry_DoNotUse::LimitRangeItem_MaxLimitRequestRatioEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct LimitRangeItem_MaxLimitRequestRatioEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LimitRangeItem_MaxLimitRequestRatioEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LimitRangeItem_MaxLimitRequestRatioEntry_DoNotUseDefaultTypeInternal() {}
  union {
    LimitRangeItem_MaxLimitRequestRatioEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LimitRangeItem_MaxLimitRequestRatioEntry_DoNotUseDefaultTypeInternal _LimitRangeItem_MaxLimitRequestRatioEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR LimitRangeItem::LimitRangeItem(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.max_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.min_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.default__)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.defaultrequest_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.maxlimitrequestratio_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.type_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct LimitRangeItemDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LimitRangeItemDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LimitRangeItemDefaultTypeInternal() {}
  union {
    LimitRangeItem _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LimitRangeItemDefaultTypeInternal _LimitRangeItem_default_instance_;
PROTOBUF_CONSTEXPR LimitRangeList::LimitRangeList(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.items_)*/{}
  , /*decltype(_impl_.metadata_)*/nullptr} {}
struct LimitRangeListDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LimitRangeListDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LimitRangeListDefaultTypeInternal() {}
  union {
    LimitRangeList _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LimitRangeListDefaultTypeInternal _LimitRangeList_default_instance_;
PROTOBUF_CONSTEXPR LimitRangeSpec::LimitRangeSpec(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.limits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct LimitRangeSpecDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LimitRangeSpecDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LimitRangeSpecDefaultTypeInternal() {}
  union {
    LimitRangeSpec _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LimitRangeSpecDefaultTypeInternal _LimitRangeSpec_default_instance_;
PROTOBUF_CONSTEXPR List::List(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.items_)*/{}
  , /*decltype(_impl_.metadata_)*/nullptr} {}
struct ListDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ListDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ListDefaultTypeInternal() {}
  union {
    List _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ListDefaultTypeInternal _List_default_instance_;
PROTOBUF_CONSTEXPR LoadBalancerIngress::LoadBalancerIngress(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ports_)*/{}
  , /*decltype(_impl_.ip_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.hostname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.ipmode_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct LoadBalancerIngressDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LoadBalancerIngressDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LoadBalancerIngressDefaultTypeInternal() {}
  union {
    LoadBalancerIngress _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LoadBalancerIngressDefaultTypeInternal _LoadBalancerIngress_default_instance_;
PROTOBUF_CONSTEXPR LoadBalancerStatus::LoadBalancerStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.ingress_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct LoadBalancerStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LoadBalancerStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LoadBalancerStatusDefaultTypeInternal() {}
  union {
    LoadBalancerStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LoadBalancerStatusDefaultTypeInternal _LoadBalancerStatus_default_instance_;
PROTOBUF_CONSTEXPR LocalObjectReference::LocalObjectReference(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct LocalObjectReferenceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LocalObjectReferenceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LocalObjectReferenceDefaultTypeInternal() {}
  union {
    LocalObjectReference _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LocalObjectReferenceDefaultTypeInternal _LocalObjectReference_default_instance_;
PROTOBUF_CONSTEXPR LocalVolumeSource::LocalVolumeSource(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.path_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.fstype_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct LocalVolumeSourceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LocalVolumeSourceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LocalVolumeSourceDefaultTypeInternal() {}
  union {
    LocalVolumeSource _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LocalVolumeSourceDefaultTypeInternal _LocalVolumeSource_default_instance_;
PROTOBUF_CONSTEXPR ModifyVolumeStatus::ModifyVolumeStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.targetvolumeattributesclassname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.status_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct ModifyVolumeStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModifyVolumeStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModifyVolumeStatusDefaultTypeInternal() {}
  union {
    ModifyVolumeStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModifyVolumeStatusDefaultTypeInternal _ModifyVolumeStatus_default_instance_;
PROTOBUF_CONSTEXPR NFSVolumeSource::NFSVolumeSource(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.server_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.path_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.readonly_)*/false} {}
struct NFSVolumeSourceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NFSVolumeSourceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NFSVolumeSourceDefaultTypeInternal() {}
  union {
    NFSVolumeSource _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NFSVolumeSourceDefaultTypeInternal _NFSVolumeSource_default_instance_;
PROTOBUF_CONSTEXPR Namespace::Namespace(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.metadata_)*/nullptr
  , /*decltype(_impl_.spec_)*/nullptr
  , /*decltype(_impl_.status_)*/nullptr} {}
struct NamespaceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NamespaceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NamespaceDefaultTypeInternal() {}
  union {
    Namespace _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NamespaceDefaultTypeInternal _Namespace_default_instance_;
PROTOBUF_CONSTEXPR NamespaceCondition::NamespaceCondition(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.type_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.status_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.reason_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.message_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.lasttransitiontime_)*/nullptr} {}
struct NamespaceConditionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NamespaceConditionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NamespaceConditionDefaultTypeInternal() {}
  union {
    NamespaceCondition _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NamespaceConditionDefaultTypeInternal _NamespaceCondition_default_instance_;
PROTOBUF_CONSTEXPR NamespaceList::NamespaceList(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.items_)*/{}
  , /*decltype(_impl_.metadata_)*/nullptr} {}
struct NamespaceListDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NamespaceListDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NamespaceListDefaultTypeInternal() {}
  union {
    NamespaceList _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NamespaceListDefaultTypeInternal _NamespaceList_default_instance_;
PROTOBUF_CONSTEXPR NamespaceSpec::NamespaceSpec(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.finalizers_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct NamespaceSpecDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NamespaceSpecDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NamespaceSpecDefaultTypeInternal() {}
  union {
    NamespaceSpec _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NamespaceSpecDefaultTypeInternal _NamespaceSpec_default_instance_;
PROTOBUF_CONSTEXPR NamespaceStatus::NamespaceStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.conditions_)*/{}
  , /*decltype(_impl_.phase_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct NamespaceStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NamespaceStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NamespaceStatusDefaultTypeInternal() {}
  union {
    NamespaceStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NamespaceStatusDefaultTypeInternal _NamespaceStatus_default_instance_;
PROTOBUF_CONSTEXPR Node::Node(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.metadata_)*/nullptr
  , /*decltype(_impl_.spec_)*/nullptr
  , /*decltype(_impl_.status_)*/nullptr} {}
struct NodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NodeDefaultTypeInternal() {}
  union {
    Node _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NodeDefaultTypeInternal _Node_default_instance_;
PROTOBUF_CONSTEXPR NodeAddress::NodeAddress(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.type_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.address_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct NodeAddressDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NodeAddressDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NodeAddressDefaultTypeInternal() {}
  union {
    NodeAddress _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NodeAddressDefaultTypeInternal _NodeAddress_default_instance_;
PROTOBUF_CONSTEXPR NodeAffinity::NodeAffinity(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.preferredduringschedulingignoredduringexecution_)*/{}
  , /*decltype(_impl_.requiredduringschedulingignoredduringexecution_)*/nullptr} {}
struct NodeAffinityDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NodeAffinityDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NodeAffinityDefaultTypeInternal() {}
  union {
    NodeAffinity _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NodeAffinityDefaultTypeInternal _NodeAffinity_default_instance_;
PROTOBUF_CONSTEXPR NodeCondition::NodeCondition(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.type_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.status_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.reason_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.message_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.lastheartbeattime_)*/nullptr
  , /*decltype(_impl_.lasttransitiontime_)*/nullptr} {}
struct NodeConditionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NodeConditionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NodeConditionDefaultTypeInternal() {}
  union {
    NodeCondition _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NodeConditionDefaultTypeInternal _NodeCondition_default_instance_;
PROTOBUF_CONSTEXPR NodeConfigSource::NodeConfigSource(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.configmap_)*/nullptr} {}
struct NodeConfigSourceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NodeConfigSourceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NodeConfigSourceDefaultTypeInternal() {}
  union {
    NodeConfigSource _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NodeConfigSourceDefaultTypeInternal _NodeConfigSource_default_instance_;
PROTOBUF_CONSTEXPR NodeConfigStatus::NodeConfigStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.error_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.assigned_)*/nullptr
  , /*decltype(_impl_.active_)*/nullptr
  , /*decltype(_impl_.lastknowngood_)*/nullptr} {}
struct NodeConfigStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NodeConfigStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NodeConfigStatusDefaultTypeInternal() {}
  union {
    NodeConfigStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NodeConfigStatusDefaultTypeInternal _NodeConfigStatus_default_instance_;
PROTOBUF_CONSTEXPR NodeDaemonEndpoints::NodeDaemonEndpoints(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.kubeletendpoint_)*/nullptr} {}
struct NodeDaemonEndpointsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NodeDaemonEndpointsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NodeDaemonEndpointsDefaultTypeInternal() {}
  union {
    NodeDaemonEndpoints _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NodeDaemonEndpointsDefaultTypeInternal _NodeDaemonEndpoints_default_instance_;
PROTOBUF_CONSTEXPR NodeList::NodeList(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.items_)*/{}
  , /*decltype(_impl_.metadata_)*/nullptr} {}
struct NodeListDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NodeListDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NodeListDefaultTypeInternal() {}
  union {
    NodeList _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NodeListDefaultTypeInternal _NodeList_default_instance_;
PROTOBUF_CONSTEXPR NodeProxyOptions::NodeProxyOptions(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.path_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct NodeProxyOptionsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NodeProxyOptionsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NodeProxyOptionsDefaultTypeInternal() {}
  union {
    NodeProxyOptions _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NodeProxyOptionsDefaultTypeInternal _NodeProxyOptions_default_instance_;
PROTOBUF_CONSTEXPR NodeResources_CapacityEntry_DoNotUse::NodeResources_CapacityEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct NodeResources_CapacityEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NodeResources_CapacityEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NodeResources_CapacityEntry_DoNotUseDefaultTypeInternal() {}
  union {
    NodeResources_CapacityEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NodeResources_CapacityEntry_DoNotUseDefaultTypeInternal _NodeResources_CapacityEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR NodeResources::NodeResources(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.capacity_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct NodeResourcesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NodeResourcesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NodeResourcesDefaultTypeInternal() {}
  union {
    NodeResources _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NodeResourcesDefaultTypeInternal _NodeResources_default_instance_;
PROTOBUF_CONSTEXPR NodeSelector::NodeSelector(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.nodeselectorterms_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct NodeSelectorDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NodeSelectorDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NodeSelectorDefaultTypeInternal() {}
  union {
    NodeSelector _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NodeSelectorDefaultTypeInternal _NodeSelector_default_instance_;
PROTOBUF_CONSTEXPR NodeSelectorRequirement::NodeSelectorRequirement(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.values_)*/{}
  , /*decltype(_impl_.key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.operator__)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct NodeSelectorRequirementDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NodeSelectorRequirementDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NodeSelectorRequirementDefaultTypeInternal() {}
  union {
    NodeSelectorRequirement _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NodeSelectorRequirementDefaultTypeInternal _NodeSelectorRequirement_default_instance_;
PROTOBUF_CONSTEXPR NodeSelectorTerm::NodeSelectorTerm(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.matchexpressions_)*/{}
  , /*decltype(_impl_.matchfields_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct NodeSelectorTermDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NodeSelectorTermDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NodeSelectorTermDefaultTypeInternal() {}
  union {
    NodeSelectorTerm _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NodeSelectorTermDefaultTypeInternal _NodeSelectorTerm_default_instance_;
PROTOBUF_CONSTEXPR NodeSpec::NodeSpec(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.taints_)*/{}
  , /*decltype(_impl_.podcidrs_)*/{}
  , /*decltype(_impl_.podcidr_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.externalid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.providerid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.configsource_)*/nullptr
  , /*decltype(_impl_.unschedulable_)*/false} {}
struct NodeSpecDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NodeSpecDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NodeSpecDefaultTypeInternal() {}
  union {
    NodeSpec _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NodeSpecDefaultTypeInternal _NodeSpec_default_instance_;
PROTOBUF_CONSTEXPR NodeStatus_CapacityEntry_DoNotUse::NodeStatus_CapacityEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct NodeStatus_CapacityEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NodeStatus_CapacityEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NodeStatus_CapacityEntry_DoNotUseDefaultTypeInternal() {}
  union {
    NodeStatus_CapacityEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NodeStatus_CapacityEntry_DoNotUseDefaultTypeInternal _NodeStatus_CapacityEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR NodeStatus_AllocatableEntry_DoNotUse::NodeStatus_AllocatableEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct NodeStatus_AllocatableEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NodeStatus_AllocatableEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NodeStatus_AllocatableEntry_DoNotUseDefaultTypeInternal() {}
  union {
    NodeStatus_AllocatableEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NodeStatus_AllocatableEntry_DoNotUseDefaultTypeInternal _NodeStatus_AllocatableEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR NodeStatus::NodeStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.capacity_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.allocatable_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.conditions_)*/{}
  , /*decltype(_impl_.addresses_)*/{}
  , /*decltype(_impl_.images_)*/{}
  , /*decltype(_impl_.volumesinuse_)*/{}
  , /*decltype(_impl_.volumesattached_)*/{}
  , /*decltype(_impl_.phase_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.daemonendpoints_)*/nullptr
  , /*decltype(_impl_.nodeinfo_)*/nullptr
  , /*decltype(_impl_.config_)*/nullptr} {}
struct NodeStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NodeStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NodeStatusDefaultTypeInternal() {}
  union {
    NodeStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NodeStatusDefaultTypeInternal _NodeStatus_default_instance_;
PROTOBUF_CONSTEXPR NodeSystemInfo::NodeSystemInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.machineid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.systemuuid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.bootid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.kernelversion_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.osimage_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.containerruntimeversion_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.kubeletversion_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.kubeproxyversion_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.operatingsystem_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.architecture_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct NodeSystemInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NodeSystemInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NodeSystemInfoDefaultTypeInternal() {}
  union {
    NodeSystemInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NodeSystemInfoDefaultTypeInternal _NodeSystemInfo_default_instance_;
PROTOBUF_CONSTEXPR ObjectFieldSelector::ObjectFieldSelector(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.apiversion_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.fieldpath_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct ObjectFieldSelectorDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ObjectFieldSelectorDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ObjectFieldSelectorDefaultTypeInternal() {}
  union {
    ObjectFieldSelector _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ObjectFieldSelectorDefaultTypeInternal _ObjectFieldSelector_default_instance_;
PROTOBUF_CONSTEXPR ObjectReference::ObjectReference(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.kind_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.namespace__)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.uid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.apiversion_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.resourceversion_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.fieldpath_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct ObjectReferenceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ObjectReferenceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ObjectReferenceDefaultTypeInternal() {}
  union {
    ObjectReference _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ObjectReferenceDefaultTypeInternal _ObjectReference_default_instance_;
PROTOBUF_CONSTEXPR PersistentVolume::PersistentVolume(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.metadata_)*/nullptr
  , /*decltype(_impl_.spec_)*/nullptr
  , /*decltype(_impl_.status_)*/nullptr} {}
struct PersistentVolumeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PersistentVolumeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PersistentVolumeDefaultTypeInternal() {}
  union {
    PersistentVolume _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PersistentVolumeDefaultTypeInternal _PersistentVolume_default_instance_;
PROTOBUF_CONSTEXPR PersistentVolumeClaim::PersistentVolumeClaim(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.metadata_)*/nullptr
  , /*decltype(_impl_.spec_)*/nullptr
  , /*decltype(_impl_.status_)*/nullptr} {}
struct PersistentVolumeClaimDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PersistentVolumeClaimDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PersistentVolumeClaimDefaultTypeInternal() {}
  union {
    PersistentVolumeClaim _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PersistentVolumeClaimDefaultTypeInternal _PersistentVolumeClaim_default_instance_;
PROTOBUF_CONSTEXPR PersistentVolumeClaimCondition::PersistentVolumeClaimCondition(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.type_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.status_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.reason_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.message_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.lastprobetime_)*/nullptr
  , /*decltype(_impl_.lasttransitiontime_)*/nullptr} {}
struct PersistentVolumeClaimConditionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PersistentVolumeClaimConditionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PersistentVolumeClaimConditionDefaultTypeInternal() {}
  union {
    PersistentVolumeClaimCondition _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PersistentVolumeClaimConditionDefaultTypeInternal _PersistentVolumeClaimCondition_default_instance_;
PROTOBUF_CONSTEXPR PersistentVolumeClaimList::PersistentVolumeClaimList(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.items_)*/{}
  , /*decltype(_impl_.metadata_)*/nullptr} {}
struct PersistentVolumeClaimListDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PersistentVolumeClaimListDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PersistentVolumeClaimListDefaultTypeInternal() {}
  union {
    PersistentVolumeClaimList _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PersistentVolumeClaimListDefaultTypeInternal _PersistentVolumeClaimList_default_instance_;
PROTOBUF_CONSTEXPR PersistentVolumeClaimSpec::PersistentVolumeClaimSpec(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.accessmodes_)*/{}
  , /*decltype(_impl_.volumename_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.storageclassname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.volumemode_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.volumeattributesclassname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.resources_)*/nullptr
  , /*decltype(_impl_.selector_)*/nullptr
  , /*decltype(_impl_.datasource_)*/nullptr
  , /*decltype(_impl_.datasourceref_)*/nullptr} {}
struct PersistentVolumeClaimSpecDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PersistentVolumeClaimSpecDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PersistentVolumeClaimSpecDefaultTypeInternal() {}
  union {
    PersistentVolumeClaimSpec _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PersistentVolumeClaimSpecDefaultTypeInternal _PersistentVolumeClaimSpec_default_instance_;
PROTOBUF_CONSTEXPR PersistentVolumeClaimStatus_CapacityEntry_DoNotUse::PersistentVolumeClaimStatus_CapacityEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct PersistentVolumeClaimStatus_CapacityEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PersistentVolumeClaimStatus_CapacityEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PersistentVolumeClaimStatus_CapacityEntry_DoNotUseDefaultTypeInternal() {}
  union {
    PersistentVolumeClaimStatus_CapacityEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PersistentVolumeClaimStatus_CapacityEntry_DoNotUseDefaultTypeInternal _PersistentVolumeClaimStatus_CapacityEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR PersistentVolumeClaimStatus_AllocatedResourcesEntry_DoNotUse::PersistentVolumeClaimStatus_AllocatedResourcesEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct PersistentVolumeClaimStatus_AllocatedResourcesEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PersistentVolumeClaimStatus_AllocatedResourcesEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PersistentVolumeClaimStatus_AllocatedResourcesEntry_DoNotUseDefaultTypeInternal() {}
  union {
    PersistentVolumeClaimStatus_AllocatedResourcesEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PersistentVolumeClaimStatus_AllocatedResourcesEntry_DoNotUseDefaultTypeInternal _PersistentVolumeClaimStatus_AllocatedResourcesEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR PersistentVolumeClaimStatus_AllocatedResourceStatusesEntry_DoNotUse::PersistentVolumeClaimStatus_AllocatedResourceStatusesEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct PersistentVolumeClaimStatus_AllocatedResourceStatusesEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PersistentVolumeClaimStatus_AllocatedResourceStatusesEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PersistentVolumeClaimStatus_AllocatedResourceStatusesEntry_DoNotUseDefaultTypeInternal() {}
  union {
    PersistentVolumeClaimStatus_AllocatedResourceStatusesEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PersistentVolumeClaimStatus_AllocatedResourceStatusesEntry_DoNotUseDefaultTypeInternal _PersistentVolumeClaimStatus_AllocatedResourceStatusesEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR PersistentVolumeClaimStatus::PersistentVolumeClaimStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.accessmodes_)*/{}
  , /*decltype(_impl_.capacity_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.conditions_)*/{}
  , /*decltype(_impl_.allocatedresources_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.allocatedresourcestatuses_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.phase_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.currentvolumeattributesclassname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.modifyvolumestatus_)*/nullptr} {}
struct PersistentVolumeClaimStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PersistentVolumeClaimStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PersistentVolumeClaimStatusDefaultTypeInternal() {}
  union {
    PersistentVolumeClaimStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PersistentVolumeClaimStatusDefaultTypeInternal _PersistentVolumeClaimStatus_default_instance_;
PROTOBUF_CONSTEXPR PersistentVolumeClaimTemplate::PersistentVolumeClaimTemplate(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.metadata_)*/nullptr
  , /*decltype(_impl_.spec_)*/nullptr} {}
struct PersistentVolumeClaimTemplateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PersistentVolumeClaimTemplateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PersistentVolumeClaimTemplateDefaultTypeInternal() {}
  union {
    PersistentVolumeClaimTemplate _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PersistentVolumeClaimTemplateDefaultTypeInternal _PersistentVolumeClaimTemplate_default_instance_;
PROTOBUF_CONSTEXPR PersistentVolumeClaimVolumeSource::PersistentVolumeClaimVolumeSource(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.claimname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.readonly_)*/false} {}
struct PersistentVolumeClaimVolumeSourceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PersistentVolumeClaimVolumeSourceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PersistentVolumeClaimVolumeSourceDefaultTypeInternal() {}
  union {
    PersistentVolumeClaimVolumeSource _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PersistentVolumeClaimVolumeSourceDefaultTypeInternal _PersistentVolumeClaimVolumeSource_default_instance_;
PROTOBUF_CONSTEXPR PersistentVolumeList::PersistentVolumeList(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.items_)*/{}
  , /*decltype(_impl_.metadata_)*/nullptr} {}
struct PersistentVolumeListDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PersistentVolumeListDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PersistentVolumeListDefaultTypeInternal() {}
  union {
    PersistentVolumeList _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PersistentVolumeListDefaultTypeInternal _PersistentVolumeList_default_instance_;
PROTOBUF_CONSTEXPR PersistentVolumeSource::PersistentVolumeSource(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.gcepersistentdisk_)*/nullptr
  , /*decltype(_impl_.awselasticblockstore_)*/nullptr
  , /*decltype(_impl_.hostpath_)*/nullptr
  , /*decltype(_impl_.glusterfs_)*/nullptr
  , /*decltype(_impl_.nfs_)*/nullptr
  , /*decltype(_impl_.rbd_)*/nullptr
  , /*decltype(_impl_.iscsi_)*/nullptr
  , /*decltype(_impl_.cinder_)*/nullptr
  , /*decltype(_impl_.cephfs_)*/nullptr
  , /*decltype(_impl_.fc_)*/nullptr
  , /*decltype(_impl_.flocker_)*/nullptr
  , /*decltype(_impl_.flexvolume_)*/nullptr
  , /*decltype(_impl_.azurefile_)*/nullptr
  , /*decltype(_impl_.vspherevolume_)*/nullptr
  , /*decltype(_impl_.quobyte_)*/nullptr
  , /*decltype(_impl_.azuredisk_)*/nullptr
  , /*decltype(_impl_.photonpersistentdisk_)*/nullptr
  , /*decltype(_impl_.portworxvolume_)*/nullptr
  , /*decltype(_impl_.scaleio_)*/nullptr
  , /*decltype(_impl_.local_)*/nullptr
  , /*decltype(_impl_.storageos_)*/nullptr
  , /*decltype(_impl_.csi_)*/nullptr} {}
struct PersistentVolumeSourceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PersistentVolumeSourceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PersistentVolumeSourceDefaultTypeInternal() {}
  union {
    PersistentVolumeSource _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PersistentVolumeSourceDefaultTypeInternal _PersistentVolumeSource_default_instance_;
PROTOBUF_CONSTEXPR PersistentVolumeSpec_CapacityEntry_DoNotUse::PersistentVolumeSpec_CapacityEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct PersistentVolumeSpec_CapacityEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PersistentVolumeSpec_CapacityEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PersistentVolumeSpec_CapacityEntry_DoNotUseDefaultTypeInternal() {}
  union {
    PersistentVolumeSpec_CapacityEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PersistentVolumeSpec_CapacityEntry_DoNotUseDefaultTypeInternal _PersistentVolumeSpec_CapacityEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR PersistentVolumeSpec::PersistentVolumeSpec(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.capacity_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.accessmodes_)*/{}
  , /*decltype(_impl_.mountoptions_)*/{}
  , /*decltype(_impl_.persistentvolumereclaimpolicy_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.storageclassname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.volumemode_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.volumeattributesclassname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.persistentvolumesource_)*/nullptr
  , /*decltype(_impl_.claimref_)*/nullptr
  , /*decltype(_impl_.nodeaffinity_)*/nullptr} {}
struct PersistentVolumeSpecDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PersistentVolumeSpecDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PersistentVolumeSpecDefaultTypeInternal() {}
  union {
    PersistentVolumeSpec _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PersistentVolumeSpecDefaultTypeInternal _PersistentVolumeSpec_default_instance_;
PROTOBUF_CONSTEXPR PersistentVolumeStatus::PersistentVolumeStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.phase_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.message_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.reason_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.lastphasetransitiontime_)*/nullptr} {}
struct PersistentVolumeStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PersistentVolumeStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PersistentVolumeStatusDefaultTypeInternal() {}
  union {
    PersistentVolumeStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PersistentVolumeStatusDefaultTypeInternal _PersistentVolumeStatus_default_instance_;
PROTOBUF_CONSTEXPR PhotonPersistentDiskVolumeSource::PhotonPersistentDiskVolumeSource(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.pdid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.fstype_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct PhotonPersistentDiskVolumeSourceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PhotonPersistentDiskVolumeSourceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PhotonPersistentDiskVolumeSourceDefaultTypeInternal() {}
  union {
    PhotonPersistentDiskVolumeSource _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PhotonPersistentDiskVolumeSourceDefaultTypeInternal _PhotonPersistentDiskVolumeSource_default_instance_;
PROTOBUF_CONSTEXPR Pod::Pod(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.metadata_)*/nullptr
  , /*decltype(_impl_.spec_)*/nullptr
  , /*decltype(_impl_.status_)*/nullptr} {}
struct PodDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PodDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PodDefaultTypeInternal() {}
  union {
    Pod _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PodDefaultTypeInternal _Pod_default_instance_;
PROTOBUF_CONSTEXPR PodAffinity::PodAffinity(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.requiredduringschedulingignoredduringexecution_)*/{}
  , /*decltype(_impl_.preferredduringschedulingignoredduringexecution_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PodAffinityDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PodAffinityDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PodAffinityDefaultTypeInternal() {}
  union {
    PodAffinity _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PodAffinityDefaultTypeInternal _PodAffinity_default_instance_;
PROTOBUF_CONSTEXPR PodAffinityTerm::PodAffinityTerm(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.namespaces_)*/{}
  , /*decltype(_impl_.matchlabelkeys_)*/{}
  , /*decltype(_impl_.mismatchlabelkeys_)*/{}
  , /*decltype(_impl_.topologykey_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.labelselector_)*/nullptr
  , /*decltype(_impl_.namespaceselector_)*/nullptr} {}
struct PodAffinityTermDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PodAffinityTermDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PodAffinityTermDefaultTypeInternal() {}
  union {
    PodAffinityTerm _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PodAffinityTermDefaultTypeInternal _PodAffinityTerm_default_instance_;
PROTOBUF_CONSTEXPR PodAntiAffinity::PodAntiAffinity(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.requiredduringschedulingignoredduringexecution_)*/{}
  , /*decltype(_impl_.preferredduringschedulingignoredduringexecution_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PodAntiAffinityDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PodAntiAffinityDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PodAntiAffinityDefaultTypeInternal() {}
  union {
    PodAntiAffinity _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PodAntiAffinityDefaultTypeInternal _PodAntiAffinity_default_instance_;
PROTOBUF_CONSTEXPR PodAttachOptions::PodAttachOptions(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.container_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.stdin_)*/false
  , /*decltype(_impl_.stdout_)*/false
  , /*decltype(_impl_.stderr_)*/false
  , /*decltype(_impl_.tty_)*/false} {}
struct PodAttachOptionsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PodAttachOptionsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PodAttachOptionsDefaultTypeInternal() {}
  union {
    PodAttachOptions _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PodAttachOptionsDefaultTypeInternal _PodAttachOptions_default_instance_;
PROTOBUF_CONSTEXPR PodCondition::PodCondition(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.type_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.status_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.reason_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.message_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.lastprobetime_)*/nullptr
  , /*decltype(_impl_.lasttransitiontime_)*/nullptr} {}
struct PodConditionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PodConditionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PodConditionDefaultTypeInternal() {}
  union {
    PodCondition _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PodConditionDefaultTypeInternal _PodCondition_default_instance_;
PROTOBUF_CONSTEXPR PodDNSConfig::PodDNSConfig(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.nameservers_)*/{}
  , /*decltype(_impl_.searches_)*/{}
  , /*decltype(_impl_.options_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PodDNSConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PodDNSConfigDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PodDNSConfigDefaultTypeInternal() {}
  union {
    PodDNSConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PodDNSConfigDefaultTypeInternal _PodDNSConfig_default_instance_;
PROTOBUF_CONSTEXPR PodDNSConfigOption::PodDNSConfigOption(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.value_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct PodDNSConfigOptionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PodDNSConfigOptionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PodDNSConfigOptionDefaultTypeInternal() {}
  union {
    PodDNSConfigOption _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PodDNSConfigOptionDefaultTypeInternal _PodDNSConfigOption_default_instance_;
PROTOBUF_CONSTEXPR PodExecOptions::PodExecOptions(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.command_)*/{}
  , /*decltype(_impl_.container_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.stdin_)*/false
  , /*decltype(_impl_.stdout_)*/false
  , /*decltype(_impl_.stderr_)*/false
  , /*decltype(_impl_.tty_)*/false} {}
struct PodExecOptionsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PodExecOptionsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PodExecOptionsDefaultTypeInternal() {}
  union {
    PodExecOptions _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PodExecOptionsDefaultTypeInternal _PodExecOptions_default_instance_;
PROTOBUF_CONSTEXPR PodIP::PodIP(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ip_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct PodIPDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PodIPDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PodIPDefaultTypeInternal() {}
  union {
    PodIP _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PodIPDefaultTypeInternal _PodIP_default_instance_;
PROTOBUF_CONSTEXPR PodList::PodList(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.items_)*/{}
  , /*decltype(_impl_.metadata_)*/nullptr} {}
struct PodListDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PodListDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PodListDefaultTypeInternal() {}
  union {
    PodList _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PodListDefaultTypeInternal _PodList_default_instance_;
PROTOBUF_CONSTEXPR PodLogOptions::PodLogOptions(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.container_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.sincetime_)*/nullptr
  , /*decltype(_impl_.sinceseconds_)*/int64_t{0}
  , /*decltype(_impl_.taillines_)*/int64_t{0}
  , /*decltype(_impl_.limitbytes_)*/int64_t{0}
  , /*decltype(_impl_.follow_)*/false
  , /*decltype(_impl_.previous_)*/false
  , /*decltype(_impl_.timestamps_)*/false
  , /*decltype(_impl_.insecureskiptlsverifybackend_)*/false} {}
struct PodLogOptionsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PodLogOptionsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PodLogOptionsDefaultTypeInternal() {}
  union {
    PodLogOptions _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PodLogOptionsDefaultTypeInternal _PodLogOptions_default_instance_;
PROTOBUF_CONSTEXPR PodOS::PodOS(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct PodOSDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PodOSDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PodOSDefaultTypeInternal() {}
  union {
    PodOS _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PodOSDefaultTypeInternal _PodOS_default_instance_;
PROTOBUF_CONSTEXPR PodPortForwardOptions::PodPortForwardOptions(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.ports_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PodPortForwardOptionsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PodPortForwardOptionsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PodPortForwardOptionsDefaultTypeInternal() {}
  union {
    PodPortForwardOptions _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PodPortForwardOptionsDefaultTypeInternal _PodPortForwardOptions_default_instance_;
PROTOBUF_CONSTEXPR PodProxyOptions::PodProxyOptions(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.path_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct PodProxyOptionsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PodProxyOptionsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PodProxyOptionsDefaultTypeInternal() {}
  union {
    PodProxyOptions _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PodProxyOptionsDefaultTypeInternal _PodProxyOptions_default_instance_;
PROTOBUF_CONSTEXPR PodReadinessGate::PodReadinessGate(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.conditiontype_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct PodReadinessGateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PodReadinessGateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PodReadinessGateDefaultTypeInternal() {}
  union {
    PodReadinessGate _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PodReadinessGateDefaultTypeInternal _PodReadinessGate_default_instance_;
PROTOBUF_CONSTEXPR PodResourceClaim::PodResourceClaim(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.source_)*/nullptr} {}
struct PodResourceClaimDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PodResourceClaimDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PodResourceClaimDefaultTypeInternal() {}
  union {
    PodResourceClaim _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PodResourceClaimDefaultTypeInternal _PodResourceClaim_default_instance_;
PROTOBUF_CONSTEXPR PodResourceClaimStatus::PodResourceClaimStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.resourceclaimname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct PodResourceClaimStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PodResourceClaimStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PodResourceClaimStatusDefaultTypeInternal() {}
  union {
    PodResourceClaimStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PodResourceClaimStatusDefaultTypeInternal _PodResourceClaimStatus_default_instance_;
PROTOBUF_CONSTEXPR PodSchedulingGate::PodSchedulingGate(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct PodSchedulingGateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PodSchedulingGateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PodSchedulingGateDefaultTypeInternal() {}
  union {
    PodSchedulingGate _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PodSchedulingGateDefaultTypeInternal _PodSchedulingGate_default_instance_;
PROTOBUF_CONSTEXPR PodSecurityContext::PodSecurityContext(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.supplementalgroups_)*/{}
  , /*decltype(_impl_.sysctls_)*/{}
  , /*decltype(_impl_.fsgroupchangepolicy_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.selinuxoptions_)*/nullptr
  , /*decltype(_impl_.windowsoptions_)*/nullptr
  , /*decltype(_impl_.seccompprofile_)*/nullptr
  , /*decltype(_impl_.runasuser_)*/int64_t{0}
  , /*decltype(_impl_.fsgroup_)*/int64_t{0}
  , /*decltype(_impl_.runasgroup_)*/int64_t{0}
  , /*decltype(_impl_.runasnonroot_)*/false} {}
struct PodSecurityContextDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PodSecurityContextDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PodSecurityContextDefaultTypeInternal() {}
  union {
    PodSecurityContext _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PodSecurityContextDefaultTypeInternal _PodSecurityContext_default_instance_;
PROTOBUF_CONSTEXPR PodSignature::PodSignature(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.podcontroller_)*/nullptr} {}
struct PodSignatureDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PodSignatureDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PodSignatureDefaultTypeInternal() {}
  union {
    PodSignature _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PodSignatureDefaultTypeInternal _PodSignature_default_instance_;
PROTOBUF_CONSTEXPR PodSpec_NodeSelectorEntry_DoNotUse::PodSpec_NodeSelectorEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct PodSpec_NodeSelectorEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PodSpec_NodeSelectorEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PodSpec_NodeSelectorEntry_DoNotUseDefaultTypeInternal() {}
  union {
    PodSpec_NodeSelectorEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PodSpec_NodeSelectorEntry_DoNotUseDefaultTypeInternal _PodSpec_NodeSelectorEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR PodSpec_OverheadEntry_DoNotUse::PodSpec_OverheadEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct PodSpec_OverheadEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PodSpec_OverheadEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PodSpec_OverheadEntry_DoNotUseDefaultTypeInternal() {}
  union {
    PodSpec_OverheadEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PodSpec_OverheadEntry_DoNotUseDefaultTypeInternal _PodSpec_OverheadEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR PodSpec::PodSpec(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.volumes_)*/{}
  , /*decltype(_impl_.containers_)*/{}
  , /*decltype(_impl_.nodeselector_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.imagepullsecrets_)*/{}
  , /*decltype(_impl_.initcontainers_)*/{}
  , /*decltype(_impl_.tolerations_)*/{}
  , /*decltype(_impl_.hostaliases_)*/{}
  , /*decltype(_impl_.readinessgates_)*/{}
  , /*decltype(_impl_.overhead_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.topologyspreadconstraints_)*/{}
  , /*decltype(_impl_.ephemeralcontainers_)*/{}
  , /*decltype(_impl_.schedulinggates_)*/{}
  , /*decltype(_impl_.resourceclaims_)*/{}
  , /*decltype(_impl_.restartpolicy_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.dnspolicy_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.serviceaccountname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.serviceaccount_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.nodename_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.hostname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.subdomain_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.schedulername_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.priorityclassname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.runtimeclassname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.preemptionpolicy_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.securitycontext_)*/nullptr
  , /*decltype(_impl_.affinity_)*/nullptr
  , /*decltype(_impl_.dnsconfig_)*/nullptr
  , /*decltype(_impl_.os_)*/nullptr
  , /*decltype(_impl_.terminationgraceperiodseconds_)*/int64_t{0}
  , /*decltype(_impl_.activedeadlineseconds_)*/int64_t{0}
  , /*decltype(_impl_.automountserviceaccounttoken_)*/false
  , /*decltype(_impl_.hostnetwork_)*/false
  , /*decltype(_impl_.hostpid_)*/false
  , /*decltype(_impl_.hostipc_)*/false
  , /*decltype(_impl_.priority_)*/0
  , /*decltype(_impl_.shareprocessnamespace_)*/false
  , /*decltype(_impl_.enableservicelinks_)*/false
  , /*decltype(_impl_.sethostnameasfqdn_)*/false
  , /*decltype(_impl_.hostusers_)*/false} {}
struct PodSpecDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PodSpecDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PodSpecDefaultTypeInternal() {}
  union {
    PodSpec _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PodSpecDefaultTypeInternal _PodSpec_default_instance_;
PROTOBUF_CONSTEXPR PodStatus::PodStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.conditions_)*/{}
  , /*decltype(_impl_.containerstatuses_)*/{}
  , /*decltype(_impl_.initcontainerstatuses_)*/{}
  , /*decltype(_impl_.podips_)*/{}
  , /*decltype(_impl_.ephemeralcontainerstatuses_)*/{}
  , /*decltype(_impl_.resourceclaimstatuses_)*/{}
  , /*decltype(_impl_.hostips_)*/{}
  , /*decltype(_impl_.phase_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.message_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.reason_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.hostip_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.podip_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.qosclass_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.nominatednodename_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.resize_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.starttime_)*/nullptr} {}
struct PodStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PodStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PodStatusDefaultTypeInternal() {}
  union {
    PodStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PodStatusDefaultTypeInternal _PodStatus_default_instance_;
PROTOBUF_CONSTEXPR PodStatusResult::PodStatusResult(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.metadata_)*/nullptr
  , /*decltype(_impl_.status_)*/nullptr} {}
struct PodStatusResultDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PodStatusResultDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PodStatusResultDefaultTypeInternal() {}
  union {
    PodStatusResult _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PodStatusResultDefaultTypeInternal _PodStatusResult_default_instance_;
PROTOBUF_CONSTEXPR PodTemplate::PodTemplate(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.metadata_)*/nullptr
  , /*decltype(_impl_.template__)*/nullptr} {}
struct PodTemplateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PodTemplateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PodTemplateDefaultTypeInternal() {}
  union {
    PodTemplate _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PodTemplateDefaultTypeInternal _PodTemplate_default_instance_;
PROTOBUF_CONSTEXPR PodTemplateList::PodTemplateList(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.items_)*/{}
  , /*decltype(_impl_.metadata_)*/nullptr} {}
struct PodTemplateListDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PodTemplateListDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PodTemplateListDefaultTypeInternal() {}
  union {
    PodTemplateList _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PodTemplateListDefaultTypeInternal _PodTemplateList_default_instance_;
PROTOBUF_CONSTEXPR PodTemplateSpec::PodTemplateSpec(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.metadata_)*/nullptr
  , /*decltype(_impl_.spec_)*/nullptr} {}
struct PodTemplateSpecDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PodTemplateSpecDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PodTemplateSpecDefaultTypeInternal() {}
  union {
    PodTemplateSpec _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PodTemplateSpecDefaultTypeInternal _PodTemplateSpec_default_instance_;
PROTOBUF_CONSTEXPR PortStatus::PortStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.protocol_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.error_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.port_)*/0} {}
struct PortStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PortStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PortStatusDefaultTypeInternal() {}
  union {
    PortStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PortStatusDefaultTypeInternal _PortStatus_default_instance_;
PROTOBUF_CONSTEXPR PortworxVolumeSource::PortworxVolumeSource(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.volumeid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.fstype_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.readonly_)*/false} {}
struct PortworxVolumeSourceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PortworxVolumeSourceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PortworxVolumeSourceDefaultTypeInternal() {}
  union {
    PortworxVolumeSource _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PortworxVolumeSourceDefaultTypeInternal _PortworxVolumeSource_default_instance_;
PROTOBUF_CONSTEXPR Preconditions::Preconditions(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.uid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct PreconditionsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PreconditionsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PreconditionsDefaultTypeInternal() {}
  union {
    Preconditions _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PreconditionsDefaultTypeInternal _Preconditions_default_instance_;
PROTOBUF_CONSTEXPR PreferAvoidPodsEntry::PreferAvoidPodsEntry(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.reason_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.message_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.podsignature_)*/nullptr
  , /*decltype(_impl_.evictiontime_)*/nullptr} {}
struct PreferAvoidPodsEntryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PreferAvoidPodsEntryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PreferAvoidPodsEntryDefaultTypeInternal() {}
  union {
    PreferAvoidPodsEntry _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PreferAvoidPodsEntryDefaultTypeInternal _PreferAvoidPodsEntry_default_instance_;
PROTOBUF_CONSTEXPR PreferredSchedulingTerm::PreferredSchedulingTerm(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.preference_)*/nullptr
  , /*decltype(_impl_.weight_)*/0} {}
struct PreferredSchedulingTermDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PreferredSchedulingTermDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PreferredSchedulingTermDefaultTypeInternal() {}
  union {
    PreferredSchedulingTerm _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PreferredSchedulingTermDefaultTypeInternal _PreferredSchedulingTerm_default_instance_;
PROTOBUF_CONSTEXPR Probe::Probe(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.handler_)*/nullptr
  , /*decltype(_impl_.initialdelayseconds_)*/0
  , /*decltype(_impl_.timeoutseconds_)*/0
  , /*decltype(_impl_.periodseconds_)*/0
  , /*decltype(_impl_.successthreshold_)*/0
  , /*decltype(_impl_.terminationgraceperiodseconds_)*/int64_t{0}
  , /*decltype(_impl_.failurethreshold_)*/0} {}
struct ProbeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ProbeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ProbeDefaultTypeInternal() {}
  union {
    Probe _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ProbeDefaultTypeInternal _Probe_default_instance_;
PROTOBUF_CONSTEXPR ProbeHandler::ProbeHandler(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.exec_)*/nullptr
  , /*decltype(_impl_.httpget_)*/nullptr
  , /*decltype(_impl_.tcpsocket_)*/nullptr
  , /*decltype(_impl_.grpc_)*/nullptr} {}
struct ProbeHandlerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ProbeHandlerDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ProbeHandlerDefaultTypeInternal() {}
  union {
    ProbeHandler _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ProbeHandlerDefaultTypeInternal _ProbeHandler_default_instance_;
PROTOBUF_CONSTEXPR ProjectedVolumeSource::ProjectedVolumeSource(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.sources_)*/{}
  , /*decltype(_impl_.defaultmode_)*/0} {}
struct ProjectedVolumeSourceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ProjectedVolumeSourceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ProjectedVolumeSourceDefaultTypeInternal() {}
  union {
    ProjectedVolumeSource _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ProjectedVolumeSourceDefaultTypeInternal _ProjectedVolumeSource_default_instance_;
PROTOBUF_CONSTEXPR QuobyteVolumeSource::QuobyteVolumeSource(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.registry_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.volume_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.user_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.group_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.tenant_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.readonly_)*/false} {}
struct QuobyteVolumeSourceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR QuobyteVolumeSourceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~QuobyteVolumeSourceDefaultTypeInternal() {}
  union {
    QuobyteVolumeSource _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 QuobyteVolumeSourceDefaultTypeInternal _QuobyteVolumeSource_default_instance_;
PROTOBUF_CONSTEXPR RBDPersistentVolumeSource::RBDPersistentVolumeSource(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.monitors_)*/{}
  , /*decltype(_impl_.image_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.fstype_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.pool_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.user_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.keyring_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.secretref_)*/nullptr
  , /*decltype(_impl_.readonly_)*/false} {}
struct RBDPersistentVolumeSourceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RBDPersistentVolumeSourceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RBDPersistentVolumeSourceDefaultTypeInternal() {}
  union {
    RBDPersistentVolumeSource _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RBDPersistentVolumeSourceDefaultTypeInternal _RBDPersistentVolumeSource_default_instance_;
PROTOBUF_CONSTEXPR RBDVolumeSource::RBDVolumeSource(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.monitors_)*/{}
  , /*decltype(_impl_.image_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.fstype_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.pool_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.user_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.keyring_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.secretref_)*/nullptr
  , /*decltype(_impl_.readonly_)*/false} {}
struct RBDVolumeSourceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RBDVolumeSourceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RBDVolumeSourceDefaultTypeInternal() {}
  union {
    RBDVolumeSource _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RBDVolumeSourceDefaultTypeInternal _RBDVolumeSource_default_instance_;
PROTOBUF_CONSTEXPR RangeAllocation::RangeAllocation(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.range_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.metadata_)*/nullptr} {}
struct RangeAllocationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RangeAllocationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RangeAllocationDefaultTypeInternal() {}
  union {
    RangeAllocation _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RangeAllocationDefaultTypeInternal _RangeAllocation_default_instance_;
PROTOBUF_CONSTEXPR ReplicationController::ReplicationController(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.metadata_)*/nullptr
  , /*decltype(_impl_.spec_)*/nullptr
  , /*decltype(_impl_.status_)*/nullptr} {}
struct ReplicationControllerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReplicationControllerDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReplicationControllerDefaultTypeInternal() {}
  union {
    ReplicationController _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReplicationControllerDefaultTypeInternal _ReplicationController_default_instance_;
PROTOBUF_CONSTEXPR ReplicationControllerCondition::ReplicationControllerCondition(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.type_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.status_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.reason_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.message_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.lasttransitiontime_)*/nullptr} {}
struct ReplicationControllerConditionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReplicationControllerConditionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReplicationControllerConditionDefaultTypeInternal() {}
  union {
    ReplicationControllerCondition _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReplicationControllerConditionDefaultTypeInternal _ReplicationControllerCondition_default_instance_;
PROTOBUF_CONSTEXPR ReplicationControllerList::ReplicationControllerList(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.items_)*/{}
  , /*decltype(_impl_.metadata_)*/nullptr} {}
struct ReplicationControllerListDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReplicationControllerListDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReplicationControllerListDefaultTypeInternal() {}
  union {
    ReplicationControllerList _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReplicationControllerListDefaultTypeInternal _ReplicationControllerList_default_instance_;
PROTOBUF_CONSTEXPR ReplicationControllerSpec_SelectorEntry_DoNotUse::ReplicationControllerSpec_SelectorEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct ReplicationControllerSpec_SelectorEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReplicationControllerSpec_SelectorEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReplicationControllerSpec_SelectorEntry_DoNotUseDefaultTypeInternal() {}
  union {
    ReplicationControllerSpec_SelectorEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReplicationControllerSpec_SelectorEntry_DoNotUseDefaultTypeInternal _ReplicationControllerSpec_SelectorEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR ReplicationControllerSpec::ReplicationControllerSpec(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.selector_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.template__)*/nullptr
  , /*decltype(_impl_.replicas_)*/0
  , /*decltype(_impl_.minreadyseconds_)*/0} {}
struct ReplicationControllerSpecDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReplicationControllerSpecDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReplicationControllerSpecDefaultTypeInternal() {}
  union {
    ReplicationControllerSpec _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReplicationControllerSpecDefaultTypeInternal _ReplicationControllerSpec_default_instance_;
PROTOBUF_CONSTEXPR ReplicationControllerStatus::ReplicationControllerStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.conditions_)*/{}
  , /*decltype(_impl_.replicas_)*/0
  , /*decltype(_impl_.fullylabeledreplicas_)*/0
  , /*decltype(_impl_.observedgeneration_)*/int64_t{0}
  , /*decltype(_impl_.readyreplicas_)*/0
  , /*decltype(_impl_.availablereplicas_)*/0} {}
struct ReplicationControllerStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReplicationControllerStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReplicationControllerStatusDefaultTypeInternal() {}
  union {
    ReplicationControllerStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReplicationControllerStatusDefaultTypeInternal _ReplicationControllerStatus_default_instance_;
PROTOBUF_CONSTEXPR ResourceClaim::ResourceClaim(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct ResourceClaimDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ResourceClaimDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ResourceClaimDefaultTypeInternal() {}
  union {
    ResourceClaim _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ResourceClaimDefaultTypeInternal _ResourceClaim_default_instance_;
PROTOBUF_CONSTEXPR ResourceFieldSelector::ResourceFieldSelector(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.containername_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.resource_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.divisor_)*/nullptr} {}
struct ResourceFieldSelectorDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ResourceFieldSelectorDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ResourceFieldSelectorDefaultTypeInternal() {}
  union {
    ResourceFieldSelector _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ResourceFieldSelectorDefaultTypeInternal _ResourceFieldSelector_default_instance_;
PROTOBUF_CONSTEXPR ResourceQuota::ResourceQuota(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.metadata_)*/nullptr
  , /*decltype(_impl_.spec_)*/nullptr
  , /*decltype(_impl_.status_)*/nullptr} {}
struct ResourceQuotaDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ResourceQuotaDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ResourceQuotaDefaultTypeInternal() {}
  union {
    ResourceQuota _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ResourceQuotaDefaultTypeInternal _ResourceQuota_default_instance_;
PROTOBUF_CONSTEXPR ResourceQuotaList::ResourceQuotaList(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.items_)*/{}
  , /*decltype(_impl_.metadata_)*/nullptr} {}
struct ResourceQuotaListDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ResourceQuotaListDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ResourceQuotaListDefaultTypeInternal() {}
  union {
    ResourceQuotaList _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ResourceQuotaListDefaultTypeInternal _ResourceQuotaList_default_instance_;
PROTOBUF_CONSTEXPR ResourceQuotaSpec_HardEntry_DoNotUse::ResourceQuotaSpec_HardEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct ResourceQuotaSpec_HardEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ResourceQuotaSpec_HardEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ResourceQuotaSpec_HardEntry_DoNotUseDefaultTypeInternal() {}
  union {
    ResourceQuotaSpec_HardEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ResourceQuotaSpec_HardEntry_DoNotUseDefaultTypeInternal _ResourceQuotaSpec_HardEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR ResourceQuotaSpec::ResourceQuotaSpec(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.hard_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.scopes_)*/{}
  , /*decltype(_impl_.scopeselector_)*/nullptr} {}
struct ResourceQuotaSpecDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ResourceQuotaSpecDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ResourceQuotaSpecDefaultTypeInternal() {}
  union {
    ResourceQuotaSpec _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ResourceQuotaSpecDefaultTypeInternal _ResourceQuotaSpec_default_instance_;
PROTOBUF_CONSTEXPR ResourceQuotaStatus_HardEntry_DoNotUse::ResourceQuotaStatus_HardEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct ResourceQuotaStatus_HardEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ResourceQuotaStatus_HardEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ResourceQuotaStatus_HardEntry_DoNotUseDefaultTypeInternal() {}
  union {
    ResourceQuotaStatus_HardEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ResourceQuotaStatus_HardEntry_DoNotUseDefaultTypeInternal _ResourceQuotaStatus_HardEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR ResourceQuotaStatus_UsedEntry_DoNotUse::ResourceQuotaStatus_UsedEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct ResourceQuotaStatus_UsedEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ResourceQuotaStatus_UsedEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ResourceQuotaStatus_UsedEntry_DoNotUseDefaultTypeInternal() {}
  union {
    ResourceQuotaStatus_UsedEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ResourceQuotaStatus_UsedEntry_DoNotUseDefaultTypeInternal _ResourceQuotaStatus_UsedEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR ResourceQuotaStatus::ResourceQuotaStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.hard_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.used_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ResourceQuotaStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ResourceQuotaStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ResourceQuotaStatusDefaultTypeInternal() {}
  union {
    ResourceQuotaStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ResourceQuotaStatusDefaultTypeInternal _ResourceQuotaStatus_default_instance_;
PROTOBUF_CONSTEXPR ResourceRequirements_LimitsEntry_DoNotUse::ResourceRequirements_LimitsEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct ResourceRequirements_LimitsEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ResourceRequirements_LimitsEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ResourceRequirements_LimitsEntry_DoNotUseDefaultTypeInternal() {}
  union {
    ResourceRequirements_LimitsEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ResourceRequirements_LimitsEntry_DoNotUseDefaultTypeInternal _ResourceRequirements_LimitsEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR ResourceRequirements_RequestsEntry_DoNotUse::ResourceRequirements_RequestsEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct ResourceRequirements_RequestsEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ResourceRequirements_RequestsEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ResourceRequirements_RequestsEntry_DoNotUseDefaultTypeInternal() {}
  union {
    ResourceRequirements_RequestsEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ResourceRequirements_RequestsEntry_DoNotUseDefaultTypeInternal _ResourceRequirements_RequestsEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR ResourceRequirements::ResourceRequirements(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.limits_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.requests_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.claims_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ResourceRequirementsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ResourceRequirementsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ResourceRequirementsDefaultTypeInternal() {}
  union {
    ResourceRequirements _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ResourceRequirementsDefaultTypeInternal _ResourceRequirements_default_instance_;
PROTOBUF_CONSTEXPR SELinuxOptions::SELinuxOptions(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.user_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.role_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.type_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.level_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct SELinuxOptionsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SELinuxOptionsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SELinuxOptionsDefaultTypeInternal() {}
  union {
    SELinuxOptions _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SELinuxOptionsDefaultTypeInternal _SELinuxOptions_default_instance_;
PROTOBUF_CONSTEXPR ScaleIOPersistentVolumeSource::ScaleIOPersistentVolumeSource(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.gateway_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.system_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.protectiondomain_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.storagepool_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.storagemode_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.volumename_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.fstype_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.secretref_)*/nullptr
  , /*decltype(_impl_.sslenabled_)*/false
  , /*decltype(_impl_.readonly_)*/false} {}
struct ScaleIOPersistentVolumeSourceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ScaleIOPersistentVolumeSourceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ScaleIOPersistentVolumeSourceDefaultTypeInternal() {}
  union {
    ScaleIOPersistentVolumeSource _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ScaleIOPersistentVolumeSourceDefaultTypeInternal _ScaleIOPersistentVolumeSource_default_instance_;
PROTOBUF_CONSTEXPR ScaleIOVolumeSource::ScaleIOVolumeSource(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.gateway_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.system_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.protectiondomain_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.storagepool_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.storagemode_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.volumename_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.fstype_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.secretref_)*/nullptr
  , /*decltype(_impl_.sslenabled_)*/false
  , /*decltype(_impl_.readonly_)*/false} {}
struct ScaleIOVolumeSourceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ScaleIOVolumeSourceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ScaleIOVolumeSourceDefaultTypeInternal() {}
  union {
    ScaleIOVolumeSource _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ScaleIOVolumeSourceDefaultTypeInternal _ScaleIOVolumeSource_default_instance_;
PROTOBUF_CONSTEXPR ScopeSelector::ScopeSelector(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.matchexpressions_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ScopeSelectorDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ScopeSelectorDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ScopeSelectorDefaultTypeInternal() {}
  union {
    ScopeSelector _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ScopeSelectorDefaultTypeInternal _ScopeSelector_default_instance_;
PROTOBUF_CONSTEXPR ScopedResourceSelectorRequirement::ScopedResourceSelectorRequirement(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.values_)*/{}
  , /*decltype(_impl_.scopename_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.operator__)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct ScopedResourceSelectorRequirementDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ScopedResourceSelectorRequirementDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ScopedResourceSelectorRequirementDefaultTypeInternal() {}
  union {
    ScopedResourceSelectorRequirement _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ScopedResourceSelectorRequirementDefaultTypeInternal _ScopedResourceSelectorRequirement_default_instance_;
PROTOBUF_CONSTEXPR SeccompProfile::SeccompProfile(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.type_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.localhostprofile_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct SeccompProfileDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SeccompProfileDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SeccompProfileDefaultTypeInternal() {}
  union {
    SeccompProfile _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SeccompProfileDefaultTypeInternal _SeccompProfile_default_instance_;
PROTOBUF_CONSTEXPR Secret_DataEntry_DoNotUse::Secret_DataEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct Secret_DataEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Secret_DataEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Secret_DataEntry_DoNotUseDefaultTypeInternal() {}
  union {
    Secret_DataEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Secret_DataEntry_DoNotUseDefaultTypeInternal _Secret_DataEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR Secret_StringDataEntry_DoNotUse::Secret_StringDataEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct Secret_StringDataEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Secret_StringDataEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Secret_StringDataEntry_DoNotUseDefaultTypeInternal() {}
  union {
    Secret_StringDataEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Secret_StringDataEntry_DoNotUseDefaultTypeInternal _Secret_StringDataEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR Secret::Secret(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.data_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.stringdata_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.type_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.metadata_)*/nullptr
  , /*decltype(_impl_.immutable_)*/false} {}
struct SecretDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SecretDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SecretDefaultTypeInternal() {}
  union {
    Secret _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SecretDefaultTypeInternal _Secret_default_instance_;
PROTOBUF_CONSTEXPR SecretEnvSource::SecretEnvSource(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.localobjectreference_)*/nullptr
  , /*decltype(_impl_.optional_)*/false} {}
struct SecretEnvSourceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SecretEnvSourceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SecretEnvSourceDefaultTypeInternal() {}
  union {
    SecretEnvSource _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SecretEnvSourceDefaultTypeInternal _SecretEnvSource_default_instance_;
PROTOBUF_CONSTEXPR SecretKeySelector::SecretKeySelector(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.localobjectreference_)*/nullptr
  , /*decltype(_impl_.optional_)*/false} {}
struct SecretKeySelectorDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SecretKeySelectorDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SecretKeySelectorDefaultTypeInternal() {}
  union {
    SecretKeySelector _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SecretKeySelectorDefaultTypeInternal _SecretKeySelector_default_instance_;
PROTOBUF_CONSTEXPR SecretList::SecretList(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.items_)*/{}
  , /*decltype(_impl_.metadata_)*/nullptr} {}
struct SecretListDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SecretListDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SecretListDefaultTypeInternal() {}
  union {
    SecretList _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SecretListDefaultTypeInternal _SecretList_default_instance_;
PROTOBUF_CONSTEXPR SecretProjection::SecretProjection(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.items_)*/{}
  , /*decltype(_impl_.localobjectreference_)*/nullptr
  , /*decltype(_impl_.optional_)*/false} {}
struct SecretProjectionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SecretProjectionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SecretProjectionDefaultTypeInternal() {}
  union {
    SecretProjection _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SecretProjectionDefaultTypeInternal _SecretProjection_default_instance_;
PROTOBUF_CONSTEXPR SecretReference::SecretReference(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.namespace__)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct SecretReferenceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SecretReferenceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SecretReferenceDefaultTypeInternal() {}
  union {
    SecretReference _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SecretReferenceDefaultTypeInternal _SecretReference_default_instance_;
PROTOBUF_CONSTEXPR SecretVolumeSource::SecretVolumeSource(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.items_)*/{}
  , /*decltype(_impl_.secretname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.defaultmode_)*/0
  , /*decltype(_impl_.optional_)*/false} {}
struct SecretVolumeSourceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SecretVolumeSourceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SecretVolumeSourceDefaultTypeInternal() {}
  union {
    SecretVolumeSource _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SecretVolumeSourceDefaultTypeInternal _SecretVolumeSource_default_instance_;
PROTOBUF_CONSTEXPR SecurityContext::SecurityContext(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.procmount_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.capabilities_)*/nullptr
  , /*decltype(_impl_.selinuxoptions_)*/nullptr
  , /*decltype(_impl_.windowsoptions_)*/nullptr
  , /*decltype(_impl_.seccompprofile_)*/nullptr
  , /*decltype(_impl_.runasuser_)*/int64_t{0}
  , /*decltype(_impl_.runasgroup_)*/int64_t{0}
  , /*decltype(_impl_.privileged_)*/false
  , /*decltype(_impl_.runasnonroot_)*/false
  , /*decltype(_impl_.readonlyrootfilesystem_)*/false
  , /*decltype(_impl_.allowprivilegeescalation_)*/false} {}
struct SecurityContextDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SecurityContextDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SecurityContextDefaultTypeInternal() {}
  union {
    SecurityContext _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SecurityContextDefaultTypeInternal _SecurityContext_default_instance_;
PROTOBUF_CONSTEXPR SerializedReference::SerializedReference(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.reference_)*/nullptr} {}
struct SerializedReferenceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SerializedReferenceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SerializedReferenceDefaultTypeInternal() {}
  union {
    SerializedReference _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SerializedReferenceDefaultTypeInternal _SerializedReference_default_instance_;
PROTOBUF_CONSTEXPR Service::Service(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.metadata_)*/nullptr
  , /*decltype(_impl_.spec_)*/nullptr
  , /*decltype(_impl_.status_)*/nullptr} {}
struct ServiceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ServiceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ServiceDefaultTypeInternal() {}
  union {
    Service _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ServiceDefaultTypeInternal _Service_default_instance_;
PROTOBUF_CONSTEXPR ServiceAccount::ServiceAccount(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.secrets_)*/{}
  , /*decltype(_impl_.imagepullsecrets_)*/{}
  , /*decltype(_impl_.metadata_)*/nullptr
  , /*decltype(_impl_.automountserviceaccounttoken_)*/false} {}
struct ServiceAccountDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ServiceAccountDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ServiceAccountDefaultTypeInternal() {}
  union {
    ServiceAccount _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ServiceAccountDefaultTypeInternal _ServiceAccount_default_instance_;
PROTOBUF_CONSTEXPR ServiceAccountList::ServiceAccountList(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.items_)*/{}
  , /*decltype(_impl_.metadata_)*/nullptr} {}
struct ServiceAccountListDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ServiceAccountListDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ServiceAccountListDefaultTypeInternal() {}
  union {
    ServiceAccountList _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ServiceAccountListDefaultTypeInternal _ServiceAccountList_default_instance_;
PROTOBUF_CONSTEXPR ServiceAccountTokenProjection::ServiceAccountTokenProjection(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.audience_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.path_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.expirationseconds_)*/int64_t{0}} {}
struct ServiceAccountTokenProjectionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ServiceAccountTokenProjectionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ServiceAccountTokenProjectionDefaultTypeInternal() {}
  union {
    ServiceAccountTokenProjection _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ServiceAccountTokenProjectionDefaultTypeInternal _ServiceAccountTokenProjection_default_instance_;
PROTOBUF_CONSTEXPR ServiceList::ServiceList(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.items_)*/{}
  , /*decltype(_impl_.metadata_)*/nullptr} {}
struct ServiceListDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ServiceListDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ServiceListDefaultTypeInternal() {}
  union {
    ServiceList _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ServiceListDefaultTypeInternal _ServiceList_default_instance_;
PROTOBUF_CONSTEXPR ServicePort::ServicePort(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.protocol_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.appprotocol_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.targetport_)*/nullptr
  , /*decltype(_impl_.port_)*/0
  , /*decltype(_impl_.nodeport_)*/0} {}
struct ServicePortDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ServicePortDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ServicePortDefaultTypeInternal() {}
  union {
    ServicePort _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ServicePortDefaultTypeInternal _ServicePort_default_instance_;
PROTOBUF_CONSTEXPR ServiceProxyOptions::ServiceProxyOptions(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.path_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct ServiceProxyOptionsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ServiceProxyOptionsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ServiceProxyOptionsDefaultTypeInternal() {}
  union {
    ServiceProxyOptions _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ServiceProxyOptionsDefaultTypeInternal _ServiceProxyOptions_default_instance_;
PROTOBUF_CONSTEXPR ServiceSpec_SelectorEntry_DoNotUse::ServiceSpec_SelectorEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct ServiceSpec_SelectorEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ServiceSpec_SelectorEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ServiceSpec_SelectorEntry_DoNotUseDefaultTypeInternal() {}
  union {
    ServiceSpec_SelectorEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ServiceSpec_SelectorEntry_DoNotUseDefaultTypeInternal _ServiceSpec_SelectorEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR ServiceSpec::ServiceSpec(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ports_)*/{}
  , /*decltype(_impl_.selector_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.externalips_)*/{}
  , /*decltype(_impl_.loadbalancersourceranges_)*/{}
  , /*decltype(_impl_.clusterips_)*/{}
  , /*decltype(_impl_.ipfamilies_)*/{}
  , /*decltype(_impl_.clusterip_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.type_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.sessionaffinity_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.loadbalancerip_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.externalname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.externaltrafficpolicy_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.ipfamilypolicy_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.loadbalancerclass_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.internaltrafficpolicy_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.sessionaffinityconfig_)*/nullptr
  , /*decltype(_impl_.healthchecknodeport_)*/0
  , /*decltype(_impl_.publishnotreadyaddresses_)*/false
  , /*decltype(_impl_.allocateloadbalancernodeports_)*/false} {}
struct ServiceSpecDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ServiceSpecDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ServiceSpecDefaultTypeInternal() {}
  union {
    ServiceSpec _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ServiceSpecDefaultTypeInternal _ServiceSpec_default_instance_;
PROTOBUF_CONSTEXPR ServiceStatus::ServiceStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.conditions_)*/{}
  , /*decltype(_impl_.loadbalancer_)*/nullptr} {}
struct ServiceStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ServiceStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ServiceStatusDefaultTypeInternal() {}
  union {
    ServiceStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ServiceStatusDefaultTypeInternal _ServiceStatus_default_instance_;
PROTOBUF_CONSTEXPR SessionAffinityConfig::SessionAffinityConfig(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.clientip_)*/nullptr} {}
struct SessionAffinityConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SessionAffinityConfigDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SessionAffinityConfigDefaultTypeInternal() {}
  union {
    SessionAffinityConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SessionAffinityConfigDefaultTypeInternal _SessionAffinityConfig_default_instance_;
PROTOBUF_CONSTEXPR SleepAction::SleepAction(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.seconds_)*/int64_t{0}} {}
struct SleepActionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SleepActionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SleepActionDefaultTypeInternal() {}
  union {
    SleepAction _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SleepActionDefaultTypeInternal _SleepAction_default_instance_;
PROTOBUF_CONSTEXPR StorageOSPersistentVolumeSource::StorageOSPersistentVolumeSource(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.volumename_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.volumenamespace_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.fstype_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.secretref_)*/nullptr
  , /*decltype(_impl_.readonly_)*/false} {}
struct StorageOSPersistentVolumeSourceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StorageOSPersistentVolumeSourceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StorageOSPersistentVolumeSourceDefaultTypeInternal() {}
  union {
    StorageOSPersistentVolumeSource _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StorageOSPersistentVolumeSourceDefaultTypeInternal _StorageOSPersistentVolumeSource_default_instance_;
PROTOBUF_CONSTEXPR StorageOSVolumeSource::StorageOSVolumeSource(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.volumename_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.volumenamespace_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.fstype_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.secretref_)*/nullptr
  , /*decltype(_impl_.readonly_)*/false} {}
struct StorageOSVolumeSourceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StorageOSVolumeSourceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StorageOSVolumeSourceDefaultTypeInternal() {}
  union {
    StorageOSVolumeSource _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StorageOSVolumeSourceDefaultTypeInternal _StorageOSVolumeSource_default_instance_;
PROTOBUF_CONSTEXPR Sysctl::Sysctl(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.value_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct SysctlDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SysctlDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SysctlDefaultTypeInternal() {}
  union {
    Sysctl _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SysctlDefaultTypeInternal _Sysctl_default_instance_;
PROTOBUF_CONSTEXPR TCPSocketAction::TCPSocketAction(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.host_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.port_)*/nullptr} {}
struct TCPSocketActionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TCPSocketActionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TCPSocketActionDefaultTypeInternal() {}
  union {
    TCPSocketAction _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TCPSocketActionDefaultTypeInternal _TCPSocketAction_default_instance_;
PROTOBUF_CONSTEXPR Taint::Taint(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.value_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.effect_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.timeadded_)*/nullptr} {}
struct TaintDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TaintDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TaintDefaultTypeInternal() {}
  union {
    Taint _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TaintDefaultTypeInternal _Taint_default_instance_;
PROTOBUF_CONSTEXPR Toleration::Toleration(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.operator__)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.value_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.effect_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.tolerationseconds_)*/int64_t{0}} {}
struct TolerationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TolerationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TolerationDefaultTypeInternal() {}
  union {
    Toleration _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TolerationDefaultTypeInternal _Toleration_default_instance_;
PROTOBUF_CONSTEXPR TopologySelectorLabelRequirement::TopologySelectorLabelRequirement(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.values_)*/{}
  , /*decltype(_impl_.key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct TopologySelectorLabelRequirementDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TopologySelectorLabelRequirementDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TopologySelectorLabelRequirementDefaultTypeInternal() {}
  union {
    TopologySelectorLabelRequirement _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TopologySelectorLabelRequirementDefaultTypeInternal _TopologySelectorLabelRequirement_default_instance_;
PROTOBUF_CONSTEXPR TopologySelectorTerm::TopologySelectorTerm(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.matchlabelexpressions_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TopologySelectorTermDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TopologySelectorTermDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TopologySelectorTermDefaultTypeInternal() {}
  union {
    TopologySelectorTerm _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TopologySelectorTermDefaultTypeInternal _TopologySelectorTerm_default_instance_;
PROTOBUF_CONSTEXPR TopologySpreadConstraint::TopologySpreadConstraint(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.matchlabelkeys_)*/{}
  , /*decltype(_impl_.topologykey_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.whenunsatisfiable_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.nodeaffinitypolicy_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.nodetaintspolicy_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.labelselector_)*/nullptr
  , /*decltype(_impl_.maxskew_)*/0
  , /*decltype(_impl_.mindomains_)*/0} {}
struct TopologySpreadConstraintDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TopologySpreadConstraintDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TopologySpreadConstraintDefaultTypeInternal() {}
  union {
    TopologySpreadConstraint _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TopologySpreadConstraintDefaultTypeInternal _TopologySpreadConstraint_default_instance_;
PROTOBUF_CONSTEXPR TypedLocalObjectReference::TypedLocalObjectReference(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.apigroup_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.kind_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct TypedLocalObjectReferenceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TypedLocalObjectReferenceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TypedLocalObjectReferenceDefaultTypeInternal() {}
  union {
    TypedLocalObjectReference _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TypedLocalObjectReferenceDefaultTypeInternal _TypedLocalObjectReference_default_instance_;
PROTOBUF_CONSTEXPR TypedObjectReference::TypedObjectReference(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.apigroup_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.kind_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.namespace__)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct TypedObjectReferenceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TypedObjectReferenceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TypedObjectReferenceDefaultTypeInternal() {}
  union {
    TypedObjectReference _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TypedObjectReferenceDefaultTypeInternal _TypedObjectReference_default_instance_;
PROTOBUF_CONSTEXPR Volume::Volume(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.volumesource_)*/nullptr} {}
struct VolumeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VolumeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VolumeDefaultTypeInternal() {}
  union {
    Volume _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VolumeDefaultTypeInternal _Volume_default_instance_;
PROTOBUF_CONSTEXPR VolumeDevice::VolumeDevice(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.devicepath_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct VolumeDeviceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VolumeDeviceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VolumeDeviceDefaultTypeInternal() {}
  union {
    VolumeDevice _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VolumeDeviceDefaultTypeInternal _VolumeDevice_default_instance_;
PROTOBUF_CONSTEXPR VolumeMount::VolumeMount(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.mountpath_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.subpath_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.mountpropagation_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.subpathexpr_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.readonly_)*/false} {}
struct VolumeMountDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VolumeMountDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VolumeMountDefaultTypeInternal() {}
  union {
    VolumeMount _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VolumeMountDefaultTypeInternal _VolumeMount_default_instance_;
PROTOBUF_CONSTEXPR VolumeNodeAffinity::VolumeNodeAffinity(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.required_)*/nullptr} {}
struct VolumeNodeAffinityDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VolumeNodeAffinityDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VolumeNodeAffinityDefaultTypeInternal() {}
  union {
    VolumeNodeAffinity _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VolumeNodeAffinityDefaultTypeInternal _VolumeNodeAffinity_default_instance_;
PROTOBUF_CONSTEXPR VolumeProjection::VolumeProjection(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.secret_)*/nullptr
  , /*decltype(_impl_.downwardapi_)*/nullptr
  , /*decltype(_impl_.configmap_)*/nullptr
  , /*decltype(_impl_.serviceaccounttoken_)*/nullptr
  , /*decltype(_impl_.clustertrustbundle_)*/nullptr} {}
struct VolumeProjectionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VolumeProjectionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VolumeProjectionDefaultTypeInternal() {}
  union {
    VolumeProjection _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VolumeProjectionDefaultTypeInternal _VolumeProjection_default_instance_;
PROTOBUF_CONSTEXPR VolumeResourceRequirements_LimitsEntry_DoNotUse::VolumeResourceRequirements_LimitsEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct VolumeResourceRequirements_LimitsEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VolumeResourceRequirements_LimitsEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VolumeResourceRequirements_LimitsEntry_DoNotUseDefaultTypeInternal() {}
  union {
    VolumeResourceRequirements_LimitsEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VolumeResourceRequirements_LimitsEntry_DoNotUseDefaultTypeInternal _VolumeResourceRequirements_LimitsEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR VolumeResourceRequirements_RequestsEntry_DoNotUse::VolumeResourceRequirements_RequestsEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct VolumeResourceRequirements_RequestsEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VolumeResourceRequirements_RequestsEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VolumeResourceRequirements_RequestsEntry_DoNotUseDefaultTypeInternal() {}
  union {
    VolumeResourceRequirements_RequestsEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VolumeResourceRequirements_RequestsEntry_DoNotUseDefaultTypeInternal _VolumeResourceRequirements_RequestsEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR VolumeResourceRequirements::VolumeResourceRequirements(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.limits_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.requests_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct VolumeResourceRequirementsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VolumeResourceRequirementsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VolumeResourceRequirementsDefaultTypeInternal() {}
  union {
    VolumeResourceRequirements _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VolumeResourceRequirementsDefaultTypeInternal _VolumeResourceRequirements_default_instance_;
PROTOBUF_CONSTEXPR VolumeSource::VolumeSource(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.hostpath_)*/nullptr
  , /*decltype(_impl_.emptydir_)*/nullptr
  , /*decltype(_impl_.gcepersistentdisk_)*/nullptr
  , /*decltype(_impl_.awselasticblockstore_)*/nullptr
  , /*decltype(_impl_.gitrepo_)*/nullptr
  , /*decltype(_impl_.secret_)*/nullptr
  , /*decltype(_impl_.nfs_)*/nullptr
  , /*decltype(_impl_.iscsi_)*/nullptr
  , /*decltype(_impl_.glusterfs_)*/nullptr
  , /*decltype(_impl_.persistentvolumeclaim_)*/nullptr
  , /*decltype(_impl_.rbd_)*/nullptr
  , /*decltype(_impl_.flexvolume_)*/nullptr
  , /*decltype(_impl_.cinder_)*/nullptr
  , /*decltype(_impl_.cephfs_)*/nullptr
  , /*decltype(_impl_.flocker_)*/nullptr
  , /*decltype(_impl_.downwardapi_)*/nullptr
  , /*decltype(_impl_.fc_)*/nullptr
  , /*decltype(_impl_.azurefile_)*/nullptr
  , /*decltype(_impl_.configmap_)*/nullptr
  , /*decltype(_impl_.vspherevolume_)*/nullptr
  , /*decltype(_impl_.quobyte_)*/nullptr
  , /*decltype(_impl_.azuredisk_)*/nullptr
  , /*decltype(_impl_.photonpersistentdisk_)*/nullptr
  , /*decltype(_impl_.portworxvolume_)*/nullptr
  , /*decltype(_impl_.scaleio_)*/nullptr
  , /*decltype(_impl_.projected_)*/nullptr
  , /*decltype(_impl_.storageos_)*/nullptr
  , /*decltype(_impl_.csi_)*/nullptr
  , /*decltype(_impl_.ephemeral_)*/nullptr} {}
struct VolumeSourceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VolumeSourceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VolumeSourceDefaultTypeInternal() {}
  union {
    VolumeSource _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VolumeSourceDefaultTypeInternal _VolumeSource_default_instance_;
PROTOBUF_CONSTEXPR VsphereVirtualDiskVolumeSource::VsphereVirtualDiskVolumeSource(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.volumepath_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.fstype_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.storagepolicyname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.storagepolicyid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct VsphereVirtualDiskVolumeSourceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VsphereVirtualDiskVolumeSourceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VsphereVirtualDiskVolumeSourceDefaultTypeInternal() {}
  union {
    VsphereVirtualDiskVolumeSource _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VsphereVirtualDiskVolumeSourceDefaultTypeInternal _VsphereVirtualDiskVolumeSource_default_instance_;
PROTOBUF_CONSTEXPR WeightedPodAffinityTerm::WeightedPodAffinityTerm(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.podaffinityterm_)*/nullptr
  , /*decltype(_impl_.weight_)*/0} {}
struct WeightedPodAffinityTermDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WeightedPodAffinityTermDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~WeightedPodAffinityTermDefaultTypeInternal() {}
  union {
    WeightedPodAffinityTerm _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WeightedPodAffinityTermDefaultTypeInternal _WeightedPodAffinityTerm_default_instance_;
PROTOBUF_CONSTEXPR WindowsSecurityContextOptions::WindowsSecurityContextOptions(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.gmsacredentialspecname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.gmsacredentialspec_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.runasusername_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.hostprocess_)*/false} {}
struct WindowsSecurityContextOptionsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WindowsSecurityContextOptionsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~WindowsSecurityContextOptionsDefaultTypeInternal() {}
  union {
    WindowsSecurityContextOptions _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WindowsSecurityContextOptionsDefaultTypeInternal _WindowsSecurityContextOptions_default_instance_;
}  // namespace v1
}  // namespace core
}  // namespace api
}  // namespace io
}  // namespace k8s
static ::_pb::Metadata file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[255];
static constexpr ::_pb::EnumDescriptor const** file_level_enum_descriptors_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto = nullptr;
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto = nullptr;

const uint32_t TableStruct_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodOrNode, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodOrNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodOrNode, _impl_.pod_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodOrNode, _impl_.node_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::AWSElasticBlockStoreVolumeSource, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::AWSElasticBlockStoreVolumeSource, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::AWSElasticBlockStoreVolumeSource, _impl_.volumeid_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::AWSElasticBlockStoreVolumeSource, _impl_.fstype_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::AWSElasticBlockStoreVolumeSource, _impl_.partition_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::AWSElasticBlockStoreVolumeSource, _impl_.readonly_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Affinity, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Affinity, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Affinity, _impl_.nodeaffinity_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Affinity, _impl_.podaffinity_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Affinity, _impl_.podantiaffinity_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::AttachedVolume, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::AttachedVolume, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::AttachedVolume, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::AttachedVolume, _impl_.devicepath_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::AvoidPods, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::AvoidPods, _impl_.preferavoidpods_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::AzureDiskVolumeSource, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::AzureDiskVolumeSource, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::AzureDiskVolumeSource, _impl_.diskname_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::AzureDiskVolumeSource, _impl_.diskuri_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::AzureDiskVolumeSource, _impl_.cachingmode_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::AzureDiskVolumeSource, _impl_.fstype_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::AzureDiskVolumeSource, _impl_.readonly_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::AzureDiskVolumeSource, _impl_.kind_),
  0,
  1,
  2,
  3,
  5,
  4,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::AzureFilePersistentVolumeSource, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::AzureFilePersistentVolumeSource, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::AzureFilePersistentVolumeSource, _impl_.secretname_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::AzureFilePersistentVolumeSource, _impl_.sharename_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::AzureFilePersistentVolumeSource, _impl_.readonly_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::AzureFilePersistentVolumeSource, _impl_.secretnamespace_),
  0,
  1,
  3,
  2,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::AzureFileVolumeSource, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::AzureFileVolumeSource, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::AzureFileVolumeSource, _impl_.secretname_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::AzureFileVolumeSource, _impl_.sharename_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::AzureFileVolumeSource, _impl_.readonly_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Binding, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Binding, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Binding, _impl_.metadata_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Binding, _impl_.target_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::CSIPersistentVolumeSource_VolumeAttributesEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::CSIPersistentVolumeSource_VolumeAttributesEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::CSIPersistentVolumeSource_VolumeAttributesEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::CSIPersistentVolumeSource_VolumeAttributesEntry_DoNotUse, value_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::CSIPersistentVolumeSource, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::CSIPersistentVolumeSource, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::CSIPersistentVolumeSource, _impl_.driver_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::CSIPersistentVolumeSource, _impl_.volumehandle_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::CSIPersistentVolumeSource, _impl_.readonly_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::CSIPersistentVolumeSource, _impl_.fstype_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::CSIPersistentVolumeSource, _impl_.volumeattributes_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::CSIPersistentVolumeSource, _impl_.controllerpublishsecretref_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::CSIPersistentVolumeSource, _impl_.nodestagesecretref_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::CSIPersistentVolumeSource, _impl_.nodepublishsecretref_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::CSIPersistentVolumeSource, _impl_.controllerexpandsecretref_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::CSIPersistentVolumeSource, _impl_.nodeexpandsecretref_),
  0,
  1,
  8,
  2,
  ~0u,
  3,
  4,
  5,
  6,
  7,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::CSIVolumeSource_VolumeAttributesEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::CSIVolumeSource_VolumeAttributesEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::CSIVolumeSource_VolumeAttributesEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::CSIVolumeSource_VolumeAttributesEntry_DoNotUse, value_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::CSIVolumeSource, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::CSIVolumeSource, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::CSIVolumeSource, _impl_.driver_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::CSIVolumeSource, _impl_.readonly_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::CSIVolumeSource, _impl_.fstype_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::CSIVolumeSource, _impl_.volumeattributes_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::CSIVolumeSource, _impl_.nodepublishsecretref_),
  0,
  3,
  1,
  ~0u,
  2,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Capabilities, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Capabilities, _impl_.add_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Capabilities, _impl_.drop_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::CephFSPersistentVolumeSource, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::CephFSPersistentVolumeSource, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::CephFSPersistentVolumeSource, _impl_.monitors_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::CephFSPersistentVolumeSource, _impl_.path_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::CephFSPersistentVolumeSource, _impl_.user_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::CephFSPersistentVolumeSource, _impl_.secretfile_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::CephFSPersistentVolumeSource, _impl_.secretref_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::CephFSPersistentVolumeSource, _impl_.readonly_),
  ~0u,
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::CephFSVolumeSource, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::CephFSVolumeSource, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::CephFSVolumeSource, _impl_.monitors_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::CephFSVolumeSource, _impl_.path_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::CephFSVolumeSource, _impl_.user_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::CephFSVolumeSource, _impl_.secretfile_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::CephFSVolumeSource, _impl_.secretref_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::CephFSVolumeSource, _impl_.readonly_),
  ~0u,
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::CinderPersistentVolumeSource, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::CinderPersistentVolumeSource, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::CinderPersistentVolumeSource, _impl_.volumeid_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::CinderPersistentVolumeSource, _impl_.fstype_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::CinderPersistentVolumeSource, _impl_.readonly_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::CinderPersistentVolumeSource, _impl_.secretref_),
  0,
  1,
  3,
  2,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::CinderVolumeSource, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::CinderVolumeSource, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::CinderVolumeSource, _impl_.volumeid_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::CinderVolumeSource, _impl_.fstype_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::CinderVolumeSource, _impl_.readonly_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::CinderVolumeSource, _impl_.secretref_),
  0,
  1,
  3,
  2,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ClaimSource, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ClaimSource, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ClaimSource, _impl_.resourceclaimname_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ClaimSource, _impl_.resourceclaimtemplatename_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ClientIPConfig, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ClientIPConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ClientIPConfig, _impl_.timeoutseconds_),
  0,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ClusterTrustBundleProjection, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ClusterTrustBundleProjection, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ClusterTrustBundleProjection, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ClusterTrustBundleProjection, _impl_.signername_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ClusterTrustBundleProjection, _impl_.labelselector_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ClusterTrustBundleProjection, _impl_.optional_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ClusterTrustBundleProjection, _impl_.path_),
  0,
  1,
  3,
  4,
  2,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ComponentCondition, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ComponentCondition, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ComponentCondition, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ComponentCondition, _impl_.status_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ComponentCondition, _impl_.message_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ComponentCondition, _impl_.error_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ComponentStatus, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ComponentStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ComponentStatus, _impl_.metadata_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ComponentStatus, _impl_.conditions_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ComponentStatusList, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ComponentStatusList, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ComponentStatusList, _impl_.metadata_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ComponentStatusList, _impl_.items_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ConfigMap_DataEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ConfigMap_DataEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ConfigMap_DataEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ConfigMap_DataEntry_DoNotUse, value_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ConfigMap_BinaryDataEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ConfigMap_BinaryDataEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ConfigMap_BinaryDataEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ConfigMap_BinaryDataEntry_DoNotUse, value_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ConfigMap, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ConfigMap, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ConfigMap, _impl_.metadata_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ConfigMap, _impl_.immutable_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ConfigMap, _impl_.data_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ConfigMap, _impl_.binarydata_),
  0,
  1,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ConfigMapEnvSource, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ConfigMapEnvSource, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ConfigMapEnvSource, _impl_.localobjectreference_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ConfigMapEnvSource, _impl_.optional_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ConfigMapKeySelector, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ConfigMapKeySelector, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ConfigMapKeySelector, _impl_.localobjectreference_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ConfigMapKeySelector, _impl_.key_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ConfigMapKeySelector, _impl_.optional_),
  1,
  0,
  2,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ConfigMapList, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ConfigMapList, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ConfigMapList, _impl_.metadata_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ConfigMapList, _impl_.items_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ConfigMapNodeConfigSource, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ConfigMapNodeConfigSource, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ConfigMapNodeConfigSource, _impl_.namespace__),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ConfigMapNodeConfigSource, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ConfigMapNodeConfigSource, _impl_.uid_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ConfigMapNodeConfigSource, _impl_.resourceversion_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ConfigMapNodeConfigSource, _impl_.kubeletconfigkey_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ConfigMapProjection, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ConfigMapProjection, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ConfigMapProjection, _impl_.localobjectreference_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ConfigMapProjection, _impl_.items_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ConfigMapProjection, _impl_.optional_),
  0,
  ~0u,
  1,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ConfigMapVolumeSource, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ConfigMapVolumeSource, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ConfigMapVolumeSource, _impl_.localobjectreference_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ConfigMapVolumeSource, _impl_.items_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ConfigMapVolumeSource, _impl_.defaultmode_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ConfigMapVolumeSource, _impl_.optional_),
  0,
  ~0u,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Container, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Container, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Container, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Container, _impl_.image_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Container, _impl_.command_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Container, _impl_.args_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Container, _impl_.workingdir_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Container, _impl_.ports_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Container, _impl_.envfrom_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Container, _impl_.env_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Container, _impl_.resources_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Container, _impl_.resizepolicy_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Container, _impl_.restartpolicy_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Container, _impl_.volumemounts_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Container, _impl_.volumedevices_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Container, _impl_.livenessprobe_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Container, _impl_.readinessprobe_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Container, _impl_.startupprobe_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Container, _impl_.lifecycle_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Container, _impl_.terminationmessagepath_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Container, _impl_.terminationmessagepolicy_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Container, _impl_.imagepullpolicy_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Container, _impl_.securitycontext_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Container, _impl_.stdin_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Container, _impl_.stdinonce_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Container, _impl_.tty_),
  0,
  1,
  ~0u,
  ~0u,
  2,
  ~0u,
  ~0u,
  ~0u,
  7,
  ~0u,
  6,
  ~0u,
  ~0u,
  8,
  9,
  12,
  10,
  3,
  5,
  4,
  11,
  13,
  14,
  15,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ContainerImage, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ContainerImage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ContainerImage, _impl_.names_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ContainerImage, _impl_.sizebytes_),
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ContainerPort, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ContainerPort, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ContainerPort, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ContainerPort, _impl_.hostport_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ContainerPort, _impl_.containerport_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ContainerPort, _impl_.protocol_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ContainerPort, _impl_.hostip_),
  0,
  3,
  4,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ContainerResizePolicy, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ContainerResizePolicy, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ContainerResizePolicy, _impl_.resourcename_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ContainerResizePolicy, _impl_.restartpolicy_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ContainerState, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ContainerState, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ContainerState, _impl_.waiting_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ContainerState, _impl_.running_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ContainerState, _impl_.terminated_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ContainerStateRunning, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ContainerStateRunning, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ContainerStateRunning, _impl_.startedat_),
  0,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ContainerStateTerminated, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ContainerStateTerminated, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ContainerStateTerminated, _impl_.exitcode_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ContainerStateTerminated, _impl_.signal_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ContainerStateTerminated, _impl_.reason_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ContainerStateTerminated, _impl_.message_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ContainerStateTerminated, _impl_.startedat_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ContainerStateTerminated, _impl_.finishedat_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ContainerStateTerminated, _impl_.containerid_),
  5,
  6,
  0,
  1,
  3,
  4,
  2,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ContainerStateWaiting, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ContainerStateWaiting, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ContainerStateWaiting, _impl_.reason_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ContainerStateWaiting, _impl_.message_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ContainerStatus_AllocatedResourcesEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ContainerStatus_AllocatedResourcesEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ContainerStatus_AllocatedResourcesEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ContainerStatus_AllocatedResourcesEntry_DoNotUse, value_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ContainerStatus, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ContainerStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ContainerStatus, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ContainerStatus, _impl_.state_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ContainerStatus, _impl_.laststate_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ContainerStatus, _impl_.ready_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ContainerStatus, _impl_.restartcount_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ContainerStatus, _impl_.image_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ContainerStatus, _impl_.imageid_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ContainerStatus, _impl_.containerid_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ContainerStatus, _impl_.started_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ContainerStatus, _impl_.allocatedresources_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ContainerStatus, _impl_.resources_),
  0,
  4,
  5,
  8,
  7,
  1,
  2,
  3,
  9,
  ~0u,
  6,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::DaemonEndpoint, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::DaemonEndpoint, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::DaemonEndpoint, _impl_.port_),
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::DownwardAPIProjection, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::DownwardAPIProjection, _impl_.items_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::DownwardAPIVolumeFile, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::DownwardAPIVolumeFile, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::DownwardAPIVolumeFile, _impl_.path_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::DownwardAPIVolumeFile, _impl_.fieldref_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::DownwardAPIVolumeFile, _impl_.resourcefieldref_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::DownwardAPIVolumeFile, _impl_.mode_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::DownwardAPIVolumeSource, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::DownwardAPIVolumeSource, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::DownwardAPIVolumeSource, _impl_.items_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::DownwardAPIVolumeSource, _impl_.defaultmode_),
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EmptyDirVolumeSource, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EmptyDirVolumeSource, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EmptyDirVolumeSource, _impl_.medium_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EmptyDirVolumeSource, _impl_.sizelimit_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EndpointAddress, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EndpointAddress, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EndpointAddress, _impl_.ip_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EndpointAddress, _impl_.hostname_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EndpointAddress, _impl_.nodename_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EndpointAddress, _impl_.targetref_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EndpointPort, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EndpointPort, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EndpointPort, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EndpointPort, _impl_.port_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EndpointPort, _impl_.protocol_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EndpointPort, _impl_.appprotocol_),
  0,
  3,
  1,
  2,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EndpointSubset, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EndpointSubset, _impl_.addresses_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EndpointSubset, _impl_.notreadyaddresses_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EndpointSubset, _impl_.ports_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Endpoints, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Endpoints, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Endpoints, _impl_.metadata_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Endpoints, _impl_.subsets_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EndpointsList, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EndpointsList, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EndpointsList, _impl_.metadata_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EndpointsList, _impl_.items_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EnvFromSource, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EnvFromSource, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EnvFromSource, _impl_.prefix_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EnvFromSource, _impl_.configmapref_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EnvFromSource, _impl_.secretref_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EnvVar, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EnvVar, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EnvVar, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EnvVar, _impl_.value_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EnvVar, _impl_.valuefrom_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EnvVarSource, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EnvVarSource, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EnvVarSource, _impl_.fieldref_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EnvVarSource, _impl_.resourcefieldref_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EnvVarSource, _impl_.configmapkeyref_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EnvVarSource, _impl_.secretkeyref_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EphemeralContainer, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EphemeralContainer, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EphemeralContainer, _impl_.ephemeralcontainercommon_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EphemeralContainer, _impl_.targetcontainername_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EphemeralContainerCommon, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EphemeralContainerCommon, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EphemeralContainerCommon, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EphemeralContainerCommon, _impl_.image_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EphemeralContainerCommon, _impl_.command_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EphemeralContainerCommon, _impl_.args_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EphemeralContainerCommon, _impl_.workingdir_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EphemeralContainerCommon, _impl_.ports_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EphemeralContainerCommon, _impl_.envfrom_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EphemeralContainerCommon, _impl_.env_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EphemeralContainerCommon, _impl_.resources_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EphemeralContainerCommon, _impl_.resizepolicy_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EphemeralContainerCommon, _impl_.restartpolicy_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EphemeralContainerCommon, _impl_.volumemounts_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EphemeralContainerCommon, _impl_.volumedevices_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EphemeralContainerCommon, _impl_.livenessprobe_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EphemeralContainerCommon, _impl_.readinessprobe_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EphemeralContainerCommon, _impl_.startupprobe_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EphemeralContainerCommon, _impl_.lifecycle_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EphemeralContainerCommon, _impl_.terminationmessagepath_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EphemeralContainerCommon, _impl_.terminationmessagepolicy_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EphemeralContainerCommon, _impl_.imagepullpolicy_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EphemeralContainerCommon, _impl_.securitycontext_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EphemeralContainerCommon, _impl_.stdin_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EphemeralContainerCommon, _impl_.stdinonce_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EphemeralContainerCommon, _impl_.tty_),
  0,
  1,
  ~0u,
  ~0u,
  2,
  ~0u,
  ~0u,
  ~0u,
  7,
  ~0u,
  6,
  ~0u,
  ~0u,
  8,
  9,
  12,
  10,
  3,
  5,
  4,
  11,
  13,
  14,
  15,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EphemeralVolumeSource, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EphemeralVolumeSource, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EphemeralVolumeSource, _impl_.volumeclaimtemplate_),
  0,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Event, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Event, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Event, _impl_.metadata_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Event, _impl_.involvedobject_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Event, _impl_.reason_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Event, _impl_.message_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Event, _impl_.source_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Event, _impl_.firsttimestamp_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Event, _impl_.lasttimestamp_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Event, _impl_.count_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Event, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Event, _impl_.eventtime_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Event, _impl_.series_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Event, _impl_.action_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Event, _impl_.related_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Event, _impl_.reportingcomponent_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Event, _impl_.reportinginstance_),
  6,
  7,
  0,
  1,
  8,
  9,
  10,
  14,
  2,
  11,
  12,
  3,
  13,
  4,
  5,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EventList, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EventList, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EventList, _impl_.metadata_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EventList, _impl_.items_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EventSeries, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EventSeries, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EventSeries, _impl_.count_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EventSeries, _impl_.lastobservedtime_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EventSource, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EventSource, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EventSource, _impl_.component_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::EventSource, _impl_.host_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ExecAction, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ExecAction, _impl_.command_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::FCVolumeSource, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::FCVolumeSource, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::FCVolumeSource, _impl_.targetwwns_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::FCVolumeSource, _impl_.lun_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::FCVolumeSource, _impl_.fstype_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::FCVolumeSource, _impl_.readonly_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::FCVolumeSource, _impl_.wwids_),
  ~0u,
  1,
  0,
  2,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::FlexPersistentVolumeSource_OptionsEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::FlexPersistentVolumeSource_OptionsEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::FlexPersistentVolumeSource_OptionsEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::FlexPersistentVolumeSource_OptionsEntry_DoNotUse, value_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::FlexPersistentVolumeSource, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::FlexPersistentVolumeSource, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::FlexPersistentVolumeSource, _impl_.driver_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::FlexPersistentVolumeSource, _impl_.fstype_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::FlexPersistentVolumeSource, _impl_.secretref_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::FlexPersistentVolumeSource, _impl_.readonly_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::FlexPersistentVolumeSource, _impl_.options_),
  0,
  1,
  2,
  3,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::FlexVolumeSource_OptionsEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::FlexVolumeSource_OptionsEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::FlexVolumeSource_OptionsEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::FlexVolumeSource_OptionsEntry_DoNotUse, value_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::FlexVolumeSource, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::FlexVolumeSource, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::FlexVolumeSource, _impl_.driver_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::FlexVolumeSource, _impl_.fstype_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::FlexVolumeSource, _impl_.secretref_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::FlexVolumeSource, _impl_.readonly_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::FlexVolumeSource, _impl_.options_),
  0,
  1,
  2,
  3,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::FlockerVolumeSource, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::FlockerVolumeSource, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::FlockerVolumeSource, _impl_.datasetname_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::FlockerVolumeSource, _impl_.datasetuuid_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::GCEPersistentDiskVolumeSource, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::GCEPersistentDiskVolumeSource, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::GCEPersistentDiskVolumeSource, _impl_.pdname_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::GCEPersistentDiskVolumeSource, _impl_.fstype_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::GCEPersistentDiskVolumeSource, _impl_.partition_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::GCEPersistentDiskVolumeSource, _impl_.readonly_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::GRPCAction, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::GRPCAction, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::GRPCAction, _impl_.port_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::GRPCAction, _impl_.service_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::GitRepoVolumeSource, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::GitRepoVolumeSource, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::GitRepoVolumeSource, _impl_.repository_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::GitRepoVolumeSource, _impl_.revision_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::GitRepoVolumeSource, _impl_.directory_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::GlusterfsPersistentVolumeSource, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::GlusterfsPersistentVolumeSource, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::GlusterfsPersistentVolumeSource, _impl_.endpoints_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::GlusterfsPersistentVolumeSource, _impl_.path_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::GlusterfsPersistentVolumeSource, _impl_.readonly_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::GlusterfsPersistentVolumeSource, _impl_.endpointsnamespace_),
  0,
  1,
  3,
  2,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::GlusterfsVolumeSource, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::GlusterfsVolumeSource, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::GlusterfsVolumeSource, _impl_.endpoints_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::GlusterfsVolumeSource, _impl_.path_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::GlusterfsVolumeSource, _impl_.readonly_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::HTTPGetAction, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::HTTPGetAction, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::HTTPGetAction, _impl_.path_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::HTTPGetAction, _impl_.port_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::HTTPGetAction, _impl_.host_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::HTTPGetAction, _impl_.scheme_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::HTTPGetAction, _impl_.httpheaders_),
  0,
  3,
  1,
  2,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::HTTPHeader, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::HTTPHeader, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::HTTPHeader, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::HTTPHeader, _impl_.value_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::HostAlias, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::HostAlias, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::HostAlias, _impl_.ip_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::HostAlias, _impl_.hostnames_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::HostIP, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::HostIP, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::HostIP, _impl_.ip_),
  0,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::HostPathVolumeSource, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::HostPathVolumeSource, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::HostPathVolumeSource, _impl_.path_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::HostPathVolumeSource, _impl_.type_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ISCSIPersistentVolumeSource, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ISCSIPersistentVolumeSource, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ISCSIPersistentVolumeSource, _impl_.targetportal_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ISCSIPersistentVolumeSource, _impl_.iqn_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ISCSIPersistentVolumeSource, _impl_.lun_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ISCSIPersistentVolumeSource, _impl_.iscsiinterface_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ISCSIPersistentVolumeSource, _impl_.fstype_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ISCSIPersistentVolumeSource, _impl_.readonly_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ISCSIPersistentVolumeSource, _impl_.portals_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ISCSIPersistentVolumeSource, _impl_.chapauthdiscovery_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ISCSIPersistentVolumeSource, _impl_.chapauthsession_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ISCSIPersistentVolumeSource, _impl_.secretref_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ISCSIPersistentVolumeSource, _impl_.initiatorname_),
  0,
  1,
  6,
  2,
  3,
  7,
  ~0u,
  8,
  9,
  5,
  4,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ISCSIVolumeSource, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ISCSIVolumeSource, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ISCSIVolumeSource, _impl_.targetportal_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ISCSIVolumeSource, _impl_.iqn_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ISCSIVolumeSource, _impl_.lun_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ISCSIVolumeSource, _impl_.iscsiinterface_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ISCSIVolumeSource, _impl_.fstype_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ISCSIVolumeSource, _impl_.readonly_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ISCSIVolumeSource, _impl_.portals_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ISCSIVolumeSource, _impl_.chapauthdiscovery_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ISCSIVolumeSource, _impl_.chapauthsession_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ISCSIVolumeSource, _impl_.secretref_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ISCSIVolumeSource, _impl_.initiatorname_),
  0,
  1,
  6,
  2,
  3,
  7,
  ~0u,
  8,
  9,
  5,
  4,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::KeyToPath, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::KeyToPath, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::KeyToPath, _impl_.key_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::KeyToPath, _impl_.path_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::KeyToPath, _impl_.mode_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Lifecycle, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Lifecycle, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Lifecycle, _impl_.poststart_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Lifecycle, _impl_.prestop_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::LifecycleHandler, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::LifecycleHandler, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::LifecycleHandler, _impl_.exec_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::LifecycleHandler, _impl_.httpget_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::LifecycleHandler, _impl_.tcpsocket_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::LifecycleHandler, _impl_.sleep_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::LimitRange, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::LimitRange, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::LimitRange, _impl_.metadata_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::LimitRange, _impl_.spec_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::LimitRangeItem_MaxEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::LimitRangeItem_MaxEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::LimitRangeItem_MaxEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::LimitRangeItem_MaxEntry_DoNotUse, value_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::LimitRangeItem_MinEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::LimitRangeItem_MinEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::LimitRangeItem_MinEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::LimitRangeItem_MinEntry_DoNotUse, value_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::LimitRangeItem_DefaultEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::LimitRangeItem_DefaultEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::LimitRangeItem_DefaultEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::LimitRangeItem_DefaultEntry_DoNotUse, value_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::LimitRangeItem_DefaultRequestEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::LimitRangeItem_DefaultRequestEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::LimitRangeItem_DefaultRequestEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::LimitRangeItem_DefaultRequestEntry_DoNotUse, value_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::LimitRangeItem_MaxLimitRequestRatioEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::LimitRangeItem_MaxLimitRequestRatioEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::LimitRangeItem_MaxLimitRequestRatioEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::LimitRangeItem_MaxLimitRequestRatioEntry_DoNotUse, value_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::LimitRangeItem, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::LimitRangeItem, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::LimitRangeItem, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::LimitRangeItem, _impl_.max_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::LimitRangeItem, _impl_.min_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::LimitRangeItem, _impl_.default__),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::LimitRangeItem, _impl_.defaultrequest_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::LimitRangeItem, _impl_.maxlimitrequestratio_),
  0,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::LimitRangeList, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::LimitRangeList, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::LimitRangeList, _impl_.metadata_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::LimitRangeList, _impl_.items_),
  0,
  ~0u,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::LimitRangeSpec, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::LimitRangeSpec, _impl_.limits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::List, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::List, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::List, _impl_.metadata_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::List, _impl_.items_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::LoadBalancerIngress, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::LoadBalancerIngress, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::LoadBalancerIngress, _impl_.ip_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::LoadBalancerIngress, _impl_.hostname_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::LoadBalancerIngress, _impl_.ipmode_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::LoadBalancerIngress, _impl_.ports_),
  0,
  1,
  2,
  ~0u,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::LoadBalancerStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::LoadBalancerStatus, _impl_.ingress_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::LocalObjectReference, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::LocalObjectReference, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::LocalObjectReference, _impl_.name_),
  0,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::LocalVolumeSource, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::LocalVolumeSource, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::LocalVolumeSource, _impl_.path_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::LocalVolumeSource, _impl_.fstype_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ModifyVolumeStatus, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ModifyVolumeStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ModifyVolumeStatus, _impl_.targetvolumeattributesclassname_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ModifyVolumeStatus, _impl_.status_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NFSVolumeSource, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NFSVolumeSource, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NFSVolumeSource, _impl_.server_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NFSVolumeSource, _impl_.path_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NFSVolumeSource, _impl_.readonly_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Namespace, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Namespace, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Namespace, _impl_.metadata_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Namespace, _impl_.spec_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Namespace, _impl_.status_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NamespaceCondition, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NamespaceCondition, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NamespaceCondition, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NamespaceCondition, _impl_.status_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NamespaceCondition, _impl_.lasttransitiontime_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NamespaceCondition, _impl_.reason_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NamespaceCondition, _impl_.message_),
  0,
  1,
  4,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NamespaceList, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NamespaceList, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NamespaceList, _impl_.metadata_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NamespaceList, _impl_.items_),
  0,
  ~0u,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NamespaceSpec, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NamespaceSpec, _impl_.finalizers_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NamespaceStatus, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NamespaceStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NamespaceStatus, _impl_.phase_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NamespaceStatus, _impl_.conditions_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Node, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Node, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Node, _impl_.metadata_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Node, _impl_.spec_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Node, _impl_.status_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeAddress, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeAddress, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeAddress, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeAddress, _impl_.address_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeAffinity, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeAffinity, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeAffinity, _impl_.requiredduringschedulingignoredduringexecution_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeAffinity, _impl_.preferredduringschedulingignoredduringexecution_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeCondition, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeCondition, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeCondition, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeCondition, _impl_.status_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeCondition, _impl_.lastheartbeattime_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeCondition, _impl_.lasttransitiontime_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeCondition, _impl_.reason_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeCondition, _impl_.message_),
  0,
  1,
  4,
  5,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeConfigSource, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeConfigSource, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeConfigSource, _impl_.configmap_),
  0,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeConfigStatus, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeConfigStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeConfigStatus, _impl_.assigned_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeConfigStatus, _impl_.active_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeConfigStatus, _impl_.lastknowngood_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeConfigStatus, _impl_.error_),
  1,
  2,
  3,
  0,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeDaemonEndpoints, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeDaemonEndpoints, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeDaemonEndpoints, _impl_.kubeletendpoint_),
  0,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeList, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeList, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeList, _impl_.metadata_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeList, _impl_.items_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeProxyOptions, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeProxyOptions, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeProxyOptions, _impl_.path_),
  0,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeResources_CapacityEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeResources_CapacityEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeResources_CapacityEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeResources_CapacityEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeResources, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeResources, _impl_.capacity_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeSelector, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeSelector, _impl_.nodeselectorterms_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeSelectorRequirement, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeSelectorRequirement, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeSelectorRequirement, _impl_.key_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeSelectorRequirement, _impl_.operator__),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeSelectorRequirement, _impl_.values_),
  0,
  1,
  ~0u,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeSelectorTerm, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeSelectorTerm, _impl_.matchexpressions_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeSelectorTerm, _impl_.matchfields_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeSpec, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeSpec, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeSpec, _impl_.podcidr_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeSpec, _impl_.podcidrs_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeSpec, _impl_.providerid_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeSpec, _impl_.unschedulable_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeSpec, _impl_.taints_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeSpec, _impl_.configsource_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeSpec, _impl_.externalid_),
  0,
  ~0u,
  2,
  4,
  ~0u,
  3,
  1,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeStatus_CapacityEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeStatus_CapacityEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeStatus_CapacityEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeStatus_CapacityEntry_DoNotUse, value_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeStatus_AllocatableEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeStatus_AllocatableEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeStatus_AllocatableEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeStatus_AllocatableEntry_DoNotUse, value_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeStatus, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeStatus, _impl_.capacity_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeStatus, _impl_.allocatable_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeStatus, _impl_.phase_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeStatus, _impl_.conditions_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeStatus, _impl_.addresses_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeStatus, _impl_.daemonendpoints_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeStatus, _impl_.nodeinfo_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeStatus, _impl_.images_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeStatus, _impl_.volumesinuse_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeStatus, _impl_.volumesattached_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeStatus, _impl_.config_),
  ~0u,
  ~0u,
  0,
  ~0u,
  ~0u,
  1,
  2,
  ~0u,
  ~0u,
  ~0u,
  3,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeSystemInfo, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeSystemInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeSystemInfo, _impl_.machineid_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeSystemInfo, _impl_.systemuuid_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeSystemInfo, _impl_.bootid_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeSystemInfo, _impl_.kernelversion_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeSystemInfo, _impl_.osimage_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeSystemInfo, _impl_.containerruntimeversion_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeSystemInfo, _impl_.kubeletversion_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeSystemInfo, _impl_.kubeproxyversion_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeSystemInfo, _impl_.operatingsystem_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::NodeSystemInfo, _impl_.architecture_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ObjectFieldSelector, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ObjectFieldSelector, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ObjectFieldSelector, _impl_.apiversion_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ObjectFieldSelector, _impl_.fieldpath_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ObjectReference, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ObjectReference, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ObjectReference, _impl_.kind_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ObjectReference, _impl_.namespace__),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ObjectReference, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ObjectReference, _impl_.uid_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ObjectReference, _impl_.apiversion_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ObjectReference, _impl_.resourceversion_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ObjectReference, _impl_.fieldpath_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolume, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolume, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolume, _impl_.metadata_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolume, _impl_.spec_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolume, _impl_.status_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeClaim, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeClaim, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeClaim, _impl_.metadata_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeClaim, _impl_.spec_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeClaim, _impl_.status_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeClaimCondition, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeClaimCondition, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeClaimCondition, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeClaimCondition, _impl_.status_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeClaimCondition, _impl_.lastprobetime_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeClaimCondition, _impl_.lasttransitiontime_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeClaimCondition, _impl_.reason_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeClaimCondition, _impl_.message_),
  0,
  1,
  4,
  5,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeClaimList, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeClaimList, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeClaimList, _impl_.metadata_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeClaimList, _impl_.items_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeClaimSpec, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeClaimSpec, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeClaimSpec, _impl_.accessmodes_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeClaimSpec, _impl_.selector_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeClaimSpec, _impl_.resources_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeClaimSpec, _impl_.volumename_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeClaimSpec, _impl_.storageclassname_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeClaimSpec, _impl_.volumemode_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeClaimSpec, _impl_.datasource_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeClaimSpec, _impl_.datasourceref_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeClaimSpec, _impl_.volumeattributesclassname_),
  ~0u,
  5,
  4,
  0,
  1,
  2,
  6,
  7,
  3,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeClaimStatus_CapacityEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeClaimStatus_CapacityEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeClaimStatus_CapacityEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeClaimStatus_CapacityEntry_DoNotUse, value_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeClaimStatus_AllocatedResourcesEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeClaimStatus_AllocatedResourcesEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeClaimStatus_AllocatedResourcesEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeClaimStatus_AllocatedResourcesEntry_DoNotUse, value_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeClaimStatus_AllocatedResourceStatusesEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeClaimStatus_AllocatedResourceStatusesEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeClaimStatus_AllocatedResourceStatusesEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeClaimStatus_AllocatedResourceStatusesEntry_DoNotUse, value_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeClaimStatus, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeClaimStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeClaimStatus, _impl_.phase_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeClaimStatus, _impl_.accessmodes_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeClaimStatus, _impl_.capacity_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeClaimStatus, _impl_.conditions_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeClaimStatus, _impl_.allocatedresources_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeClaimStatus, _impl_.allocatedresourcestatuses_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeClaimStatus, _impl_.currentvolumeattributesclassname_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeClaimStatus, _impl_.modifyvolumestatus_),
  0,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeClaimTemplate, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeClaimTemplate, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeClaimTemplate, _impl_.metadata_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeClaimTemplate, _impl_.spec_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeClaimVolumeSource, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeClaimVolumeSource, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeClaimVolumeSource, _impl_.claimname_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeClaimVolumeSource, _impl_.readonly_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeList, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeList, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeList, _impl_.metadata_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeList, _impl_.items_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeSource, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeSource, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeSource, _impl_.gcepersistentdisk_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeSource, _impl_.awselasticblockstore_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeSource, _impl_.hostpath_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeSource, _impl_.glusterfs_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeSource, _impl_.nfs_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeSource, _impl_.rbd_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeSource, _impl_.iscsi_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeSource, _impl_.cinder_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeSource, _impl_.cephfs_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeSource, _impl_.fc_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeSource, _impl_.flocker_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeSource, _impl_.flexvolume_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeSource, _impl_.azurefile_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeSource, _impl_.vspherevolume_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeSource, _impl_.quobyte_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeSource, _impl_.azuredisk_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeSource, _impl_.photonpersistentdisk_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeSource, _impl_.portworxvolume_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeSource, _impl_.scaleio_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeSource, _impl_.local_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeSource, _impl_.storageos_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeSource, _impl_.csi_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeSpec_CapacityEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeSpec_CapacityEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeSpec_CapacityEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeSpec_CapacityEntry_DoNotUse, value_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeSpec, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeSpec, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeSpec, _impl_.capacity_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeSpec, _impl_.persistentvolumesource_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeSpec, _impl_.accessmodes_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeSpec, _impl_.claimref_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeSpec, _impl_.persistentvolumereclaimpolicy_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeSpec, _impl_.storageclassname_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeSpec, _impl_.mountoptions_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeSpec, _impl_.volumemode_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeSpec, _impl_.nodeaffinity_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeSpec, _impl_.volumeattributesclassname_),
  ~0u,
  4,
  ~0u,
  5,
  0,
  1,
  ~0u,
  2,
  6,
  3,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeStatus, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeStatus, _impl_.phase_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeStatus, _impl_.message_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeStatus, _impl_.reason_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PersistentVolumeStatus, _impl_.lastphasetransitiontime_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PhotonPersistentDiskVolumeSource, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PhotonPersistentDiskVolumeSource, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PhotonPersistentDiskVolumeSource, _impl_.pdid_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PhotonPersistentDiskVolumeSource, _impl_.fstype_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Pod, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Pod, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Pod, _impl_.metadata_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Pod, _impl_.spec_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Pod, _impl_.status_),
  0,
  1,
  2,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodAffinity, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodAffinity, _impl_.requiredduringschedulingignoredduringexecution_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodAffinity, _impl_.preferredduringschedulingignoredduringexecution_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodAffinityTerm, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodAffinityTerm, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodAffinityTerm, _impl_.labelselector_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodAffinityTerm, _impl_.namespaces_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodAffinityTerm, _impl_.topologykey_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodAffinityTerm, _impl_.namespaceselector_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodAffinityTerm, _impl_.matchlabelkeys_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodAffinityTerm, _impl_.mismatchlabelkeys_),
  1,
  ~0u,
  0,
  2,
  ~0u,
  ~0u,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodAntiAffinity, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodAntiAffinity, _impl_.requiredduringschedulingignoredduringexecution_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodAntiAffinity, _impl_.preferredduringschedulingignoredduringexecution_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodAttachOptions, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodAttachOptions, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodAttachOptions, _impl_.stdin_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodAttachOptions, _impl_.stdout_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodAttachOptions, _impl_.stderr_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodAttachOptions, _impl_.tty_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodAttachOptions, _impl_.container_),
  1,
  2,
  3,
  4,
  0,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodCondition, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodCondition, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodCondition, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodCondition, _impl_.status_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodCondition, _impl_.lastprobetime_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodCondition, _impl_.lasttransitiontime_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodCondition, _impl_.reason_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodCondition, _impl_.message_),
  0,
  1,
  4,
  5,
  2,
  3,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodDNSConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodDNSConfig, _impl_.nameservers_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodDNSConfig, _impl_.searches_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodDNSConfig, _impl_.options_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodDNSConfigOption, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodDNSConfigOption, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodDNSConfigOption, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodDNSConfigOption, _impl_.value_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodExecOptions, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodExecOptions, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodExecOptions, _impl_.stdin_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodExecOptions, _impl_.stdout_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodExecOptions, _impl_.stderr_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodExecOptions, _impl_.tty_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodExecOptions, _impl_.container_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodExecOptions, _impl_.command_),
  1,
  2,
  3,
  4,
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodIP, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodIP, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodIP, _impl_.ip_),
  0,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodList, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodList, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodList, _impl_.metadata_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodList, _impl_.items_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodLogOptions, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodLogOptions, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodLogOptions, _impl_.container_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodLogOptions, _impl_.follow_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodLogOptions, _impl_.previous_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodLogOptions, _impl_.sinceseconds_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodLogOptions, _impl_.sincetime_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodLogOptions, _impl_.timestamps_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodLogOptions, _impl_.taillines_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodLogOptions, _impl_.limitbytes_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodLogOptions, _impl_.insecureskiptlsverifybackend_),
  0,
  5,
  6,
  2,
  1,
  7,
  3,
  4,
  8,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodOS, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodOS, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodOS, _impl_.name_),
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodPortForwardOptions, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodPortForwardOptions, _impl_.ports_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodProxyOptions, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodProxyOptions, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodProxyOptions, _impl_.path_),
  0,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodReadinessGate, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodReadinessGate, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodReadinessGate, _impl_.conditiontype_),
  0,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodResourceClaim, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodResourceClaim, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodResourceClaim, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodResourceClaim, _impl_.source_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodResourceClaimStatus, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodResourceClaimStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodResourceClaimStatus, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodResourceClaimStatus, _impl_.resourceclaimname_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodSchedulingGate, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodSchedulingGate, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodSchedulingGate, _impl_.name_),
  0,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodSecurityContext, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodSecurityContext, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodSecurityContext, _impl_.selinuxoptions_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodSecurityContext, _impl_.windowsoptions_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodSecurityContext, _impl_.runasuser_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodSecurityContext, _impl_.runasgroup_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodSecurityContext, _impl_.runasnonroot_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodSecurityContext, _impl_.supplementalgroups_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodSecurityContext, _impl_.fsgroup_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodSecurityContext, _impl_.sysctls_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodSecurityContext, _impl_.fsgroupchangepolicy_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodSecurityContext, _impl_.seccompprofile_),
  1,
  2,
  4,
  6,
  7,
  ~0u,
  5,
  ~0u,
  0,
  3,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodSignature, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodSignature, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodSignature, _impl_.podcontroller_),
  0,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodSpec_NodeSelectorEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodSpec_NodeSelectorEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodSpec_NodeSelectorEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodSpec_NodeSelectorEntry_DoNotUse, value_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodSpec_OverheadEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodSpec_OverheadEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodSpec_OverheadEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodSpec_OverheadEntry_DoNotUse, value_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodSpec, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodSpec, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodSpec, _impl_.volumes_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodSpec, _impl_.initcontainers_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodSpec, _impl_.containers_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodSpec, _impl_.ephemeralcontainers_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodSpec, _impl_.restartpolicy_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodSpec, _impl_.terminationgraceperiodseconds_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodSpec, _impl_.activedeadlineseconds_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodSpec, _impl_.dnspolicy_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodSpec, _impl_.nodeselector_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodSpec, _impl_.serviceaccountname_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodSpec, _impl_.serviceaccount_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodSpec, _impl_.automountserviceaccounttoken_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodSpec, _impl_.nodename_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodSpec, _impl_.hostnetwork_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodSpec, _impl_.hostpid_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodSpec, _impl_.hostipc_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodSpec, _impl_.shareprocessnamespace_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodSpec, _impl_.securitycontext_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodSpec, _impl_.imagepullsecrets_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodSpec, _impl_.hostname_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodSpec, _impl_.subdomain_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodSpec, _impl_.affinity_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodSpec, _impl_.schedulername_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodSpec, _impl_.tolerations_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodSpec, _impl_.hostaliases_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodSpec, _impl_.priorityclassname_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodSpec, _impl_.priority_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodSpec, _impl_.dnsconfig_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodSpec, _impl_.readinessgates_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodSpec, _impl_.runtimeclassname_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodSpec, _impl_.enableservicelinks_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodSpec, _impl_.preemptionpolicy_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodSpec, _impl_.overhead_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodSpec, _impl_.topologyspreadconstraints_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodSpec, _impl_.sethostnameasfqdn_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodSpec, _impl_.os_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodSpec, _impl_.hostusers_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodSpec, _impl_.schedulinggates_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodSpec, _impl_.resourceclaims_),
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  0,
  15,
  16,
  1,
  ~0u,
  2,
  3,
  17,
  4,
  18,
  19,
  20,
  22,
  11,
  ~0u,
  5,
  6,
  12,
  7,
  ~0u,
  ~0u,
  8,
  21,
  13,
  ~0u,
  9,
  23,
  10,
  ~0u,
  ~0u,
  24,
  14,
  25,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodStatus, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodStatus, _impl_.phase_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodStatus, _impl_.conditions_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodStatus, _impl_.message_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodStatus, _impl_.reason_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodStatus, _impl_.nominatednodename_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodStatus, _impl_.hostip_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodStatus, _impl_.hostips_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodStatus, _impl_.podip_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodStatus, _impl_.podips_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodStatus, _impl_.starttime_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodStatus, _impl_.initcontainerstatuses_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodStatus, _impl_.containerstatuses_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodStatus, _impl_.qosclass_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodStatus, _impl_.ephemeralcontainerstatuses_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodStatus, _impl_.resize_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodStatus, _impl_.resourceclaimstatuses_),
  0,
  ~0u,
  1,
  2,
  6,
  3,
  ~0u,
  4,
  ~0u,
  8,
  ~0u,
  ~0u,
  5,
  ~0u,
  7,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodStatusResult, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodStatusResult, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodStatusResult, _impl_.metadata_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodStatusResult, _impl_.status_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodTemplate, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodTemplate, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodTemplate, _impl_.metadata_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodTemplate, _impl_.template__),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodTemplateList, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodTemplateList, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodTemplateList, _impl_.metadata_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodTemplateList, _impl_.items_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodTemplateSpec, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodTemplateSpec, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodTemplateSpec, _impl_.metadata_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PodTemplateSpec, _impl_.spec_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PortStatus, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PortStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PortStatus, _impl_.port_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PortStatus, _impl_.protocol_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PortStatus, _impl_.error_),
  2,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PortworxVolumeSource, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PortworxVolumeSource, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PortworxVolumeSource, _impl_.volumeid_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PortworxVolumeSource, _impl_.fstype_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PortworxVolumeSource, _impl_.readonly_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Preconditions, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Preconditions, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Preconditions, _impl_.uid_),
  0,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PreferAvoidPodsEntry, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PreferAvoidPodsEntry, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PreferAvoidPodsEntry, _impl_.podsignature_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PreferAvoidPodsEntry, _impl_.evictiontime_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PreferAvoidPodsEntry, _impl_.reason_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PreferAvoidPodsEntry, _impl_.message_),
  2,
  3,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PreferredSchedulingTerm, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PreferredSchedulingTerm, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PreferredSchedulingTerm, _impl_.weight_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::PreferredSchedulingTerm, _impl_.preference_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Probe, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Probe, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Probe, _impl_.handler_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Probe, _impl_.initialdelayseconds_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Probe, _impl_.timeoutseconds_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Probe, _impl_.periodseconds_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Probe, _impl_.successthreshold_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Probe, _impl_.failurethreshold_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Probe, _impl_.terminationgraceperiodseconds_),
  0,
  1,
  2,
  3,
  4,
  6,
  5,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ProbeHandler, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ProbeHandler, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ProbeHandler, _impl_.exec_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ProbeHandler, _impl_.httpget_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ProbeHandler, _impl_.tcpsocket_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ProbeHandler, _impl_.grpc_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ProjectedVolumeSource, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ProjectedVolumeSource, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ProjectedVolumeSource, _impl_.sources_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ProjectedVolumeSource, _impl_.defaultmode_),
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::QuobyteVolumeSource, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::QuobyteVolumeSource, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::QuobyteVolumeSource, _impl_.registry_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::QuobyteVolumeSource, _impl_.volume_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::QuobyteVolumeSource, _impl_.readonly_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::QuobyteVolumeSource, _impl_.user_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::QuobyteVolumeSource, _impl_.group_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::QuobyteVolumeSource, _impl_.tenant_),
  0,
  1,
  5,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::RBDPersistentVolumeSource, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::RBDPersistentVolumeSource, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::RBDPersistentVolumeSource, _impl_.monitors_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::RBDPersistentVolumeSource, _impl_.image_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::RBDPersistentVolumeSource, _impl_.fstype_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::RBDPersistentVolumeSource, _impl_.pool_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::RBDPersistentVolumeSource, _impl_.user_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::RBDPersistentVolumeSource, _impl_.keyring_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::RBDPersistentVolumeSource, _impl_.secretref_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::RBDPersistentVolumeSource, _impl_.readonly_),
  ~0u,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::RBDVolumeSource, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::RBDVolumeSource, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::RBDVolumeSource, _impl_.monitors_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::RBDVolumeSource, _impl_.image_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::RBDVolumeSource, _impl_.fstype_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::RBDVolumeSource, _impl_.pool_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::RBDVolumeSource, _impl_.user_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::RBDVolumeSource, _impl_.keyring_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::RBDVolumeSource, _impl_.secretref_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::RBDVolumeSource, _impl_.readonly_),
  ~0u,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::RangeAllocation, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::RangeAllocation, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::RangeAllocation, _impl_.metadata_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::RangeAllocation, _impl_.range_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::RangeAllocation, _impl_.data_),
  2,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ReplicationController, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ReplicationController, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ReplicationController, _impl_.metadata_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ReplicationController, _impl_.spec_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ReplicationController, _impl_.status_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ReplicationControllerCondition, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ReplicationControllerCondition, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ReplicationControllerCondition, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ReplicationControllerCondition, _impl_.status_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ReplicationControllerCondition, _impl_.lasttransitiontime_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ReplicationControllerCondition, _impl_.reason_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ReplicationControllerCondition, _impl_.message_),
  0,
  1,
  4,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ReplicationControllerList, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ReplicationControllerList, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ReplicationControllerList, _impl_.metadata_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ReplicationControllerList, _impl_.items_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ReplicationControllerSpec_SelectorEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ReplicationControllerSpec_SelectorEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ReplicationControllerSpec_SelectorEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ReplicationControllerSpec_SelectorEntry_DoNotUse, value_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ReplicationControllerSpec, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ReplicationControllerSpec, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ReplicationControllerSpec, _impl_.replicas_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ReplicationControllerSpec, _impl_.minreadyseconds_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ReplicationControllerSpec, _impl_.selector_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ReplicationControllerSpec, _impl_.template__),
  1,
  2,
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ReplicationControllerStatus, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ReplicationControllerStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ReplicationControllerStatus, _impl_.replicas_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ReplicationControllerStatus, _impl_.fullylabeledreplicas_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ReplicationControllerStatus, _impl_.readyreplicas_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ReplicationControllerStatus, _impl_.availablereplicas_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ReplicationControllerStatus, _impl_.observedgeneration_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ReplicationControllerStatus, _impl_.conditions_),
  0,
  1,
  3,
  4,
  2,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ResourceClaim, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ResourceClaim, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ResourceClaim, _impl_.name_),
  0,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ResourceFieldSelector, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ResourceFieldSelector, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ResourceFieldSelector, _impl_.containername_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ResourceFieldSelector, _impl_.resource_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ResourceFieldSelector, _impl_.divisor_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ResourceQuota, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ResourceQuota, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ResourceQuota, _impl_.metadata_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ResourceQuota, _impl_.spec_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ResourceQuota, _impl_.status_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ResourceQuotaList, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ResourceQuotaList, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ResourceQuotaList, _impl_.metadata_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ResourceQuotaList, _impl_.items_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ResourceQuotaSpec_HardEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ResourceQuotaSpec_HardEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ResourceQuotaSpec_HardEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ResourceQuotaSpec_HardEntry_DoNotUse, value_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ResourceQuotaSpec, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ResourceQuotaSpec, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ResourceQuotaSpec, _impl_.hard_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ResourceQuotaSpec, _impl_.scopes_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ResourceQuotaSpec, _impl_.scopeselector_),
  ~0u,
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ResourceQuotaStatus_HardEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ResourceQuotaStatus_HardEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ResourceQuotaStatus_HardEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ResourceQuotaStatus_HardEntry_DoNotUse, value_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ResourceQuotaStatus_UsedEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ResourceQuotaStatus_UsedEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ResourceQuotaStatus_UsedEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ResourceQuotaStatus_UsedEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ResourceQuotaStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ResourceQuotaStatus, _impl_.hard_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ResourceQuotaStatus, _impl_.used_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ResourceRequirements_LimitsEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ResourceRequirements_LimitsEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ResourceRequirements_LimitsEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ResourceRequirements_LimitsEntry_DoNotUse, value_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ResourceRequirements_RequestsEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ResourceRequirements_RequestsEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ResourceRequirements_RequestsEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ResourceRequirements_RequestsEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ResourceRequirements, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ResourceRequirements, _impl_.limits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ResourceRequirements, _impl_.requests_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ResourceRequirements, _impl_.claims_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::SELinuxOptions, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::SELinuxOptions, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::SELinuxOptions, _impl_.user_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::SELinuxOptions, _impl_.role_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::SELinuxOptions, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::SELinuxOptions, _impl_.level_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ScaleIOPersistentVolumeSource, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ScaleIOPersistentVolumeSource, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ScaleIOPersistentVolumeSource, _impl_.gateway_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ScaleIOPersistentVolumeSource, _impl_.system_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ScaleIOPersistentVolumeSource, _impl_.secretref_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ScaleIOPersistentVolumeSource, _impl_.sslenabled_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ScaleIOPersistentVolumeSource, _impl_.protectiondomain_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ScaleIOPersistentVolumeSource, _impl_.storagepool_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ScaleIOPersistentVolumeSource, _impl_.storagemode_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ScaleIOPersistentVolumeSource, _impl_.volumename_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ScaleIOPersistentVolumeSource, _impl_.fstype_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ScaleIOPersistentVolumeSource, _impl_.readonly_),
  0,
  1,
  7,
  8,
  2,
  3,
  4,
  5,
  6,
  9,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ScaleIOVolumeSource, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ScaleIOVolumeSource, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ScaleIOVolumeSource, _impl_.gateway_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ScaleIOVolumeSource, _impl_.system_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ScaleIOVolumeSource, _impl_.secretref_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ScaleIOVolumeSource, _impl_.sslenabled_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ScaleIOVolumeSource, _impl_.protectiondomain_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ScaleIOVolumeSource, _impl_.storagepool_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ScaleIOVolumeSource, _impl_.storagemode_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ScaleIOVolumeSource, _impl_.volumename_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ScaleIOVolumeSource, _impl_.fstype_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ScaleIOVolumeSource, _impl_.readonly_),
  0,
  1,
  7,
  8,
  2,
  3,
  4,
  5,
  6,
  9,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ScopeSelector, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ScopeSelector, _impl_.matchexpressions_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ScopedResourceSelectorRequirement, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ScopedResourceSelectorRequirement, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ScopedResourceSelectorRequirement, _impl_.scopename_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ScopedResourceSelectorRequirement, _impl_.operator__),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ScopedResourceSelectorRequirement, _impl_.values_),
  0,
  1,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::SeccompProfile, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::SeccompProfile, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::SeccompProfile, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::SeccompProfile, _impl_.localhostprofile_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Secret_DataEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Secret_DataEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Secret_DataEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Secret_DataEntry_DoNotUse, value_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Secret_StringDataEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Secret_StringDataEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Secret_StringDataEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Secret_StringDataEntry_DoNotUse, value_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Secret, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Secret, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Secret, _impl_.metadata_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Secret, _impl_.immutable_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Secret, _impl_.data_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Secret, _impl_.stringdata_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Secret, _impl_.type_),
  1,
  2,
  ~0u,
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::SecretEnvSource, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::SecretEnvSource, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::SecretEnvSource, _impl_.localobjectreference_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::SecretEnvSource, _impl_.optional_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::SecretKeySelector, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::SecretKeySelector, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::SecretKeySelector, _impl_.localobjectreference_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::SecretKeySelector, _impl_.key_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::SecretKeySelector, _impl_.optional_),
  1,
  0,
  2,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::SecretList, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::SecretList, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::SecretList, _impl_.metadata_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::SecretList, _impl_.items_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::SecretProjection, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::SecretProjection, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::SecretProjection, _impl_.localobjectreference_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::SecretProjection, _impl_.items_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::SecretProjection, _impl_.optional_),
  0,
  ~0u,
  1,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::SecretReference, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::SecretReference, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::SecretReference, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::SecretReference, _impl_.namespace__),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::SecretVolumeSource, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::SecretVolumeSource, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::SecretVolumeSource, _impl_.secretname_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::SecretVolumeSource, _impl_.items_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::SecretVolumeSource, _impl_.defaultmode_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::SecretVolumeSource, _impl_.optional_),
  0,
  ~0u,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::SecurityContext, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::SecurityContext, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::SecurityContext, _impl_.capabilities_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::SecurityContext, _impl_.privileged_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::SecurityContext, _impl_.selinuxoptions_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::SecurityContext, _impl_.windowsoptions_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::SecurityContext, _impl_.runasuser_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::SecurityContext, _impl_.runasgroup_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::SecurityContext, _impl_.runasnonroot_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::SecurityContext, _impl_.readonlyrootfilesystem_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::SecurityContext, _impl_.allowprivilegeescalation_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::SecurityContext, _impl_.procmount_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::SecurityContext, _impl_.seccompprofile_),
  1,
  7,
  2,
  3,
  5,
  6,
  8,
  9,
  10,
  0,
  4,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::SerializedReference, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::SerializedReference, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::SerializedReference, _impl_.reference_),
  0,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Service, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Service, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Service, _impl_.metadata_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Service, _impl_.spec_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Service, _impl_.status_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ServiceAccount, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ServiceAccount, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ServiceAccount, _impl_.metadata_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ServiceAccount, _impl_.secrets_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ServiceAccount, _impl_.imagepullsecrets_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ServiceAccount, _impl_.automountserviceaccounttoken_),
  0,
  ~0u,
  ~0u,
  1,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ServiceAccountList, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ServiceAccountList, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ServiceAccountList, _impl_.metadata_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ServiceAccountList, _impl_.items_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ServiceAccountTokenProjection, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ServiceAccountTokenProjection, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ServiceAccountTokenProjection, _impl_.audience_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ServiceAccountTokenProjection, _impl_.expirationseconds_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ServiceAccountTokenProjection, _impl_.path_),
  0,
  2,
  1,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ServiceList, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ServiceList, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ServiceList, _impl_.metadata_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ServiceList, _impl_.items_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ServicePort, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ServicePort, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ServicePort, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ServicePort, _impl_.protocol_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ServicePort, _impl_.appprotocol_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ServicePort, _impl_.port_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ServicePort, _impl_.targetport_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ServicePort, _impl_.nodeport_),
  0,
  1,
  2,
  4,
  3,
  5,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ServiceProxyOptions, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ServiceProxyOptions, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ServiceProxyOptions, _impl_.path_),
  0,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ServiceSpec_SelectorEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ServiceSpec_SelectorEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ServiceSpec_SelectorEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ServiceSpec_SelectorEntry_DoNotUse, value_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ServiceSpec, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ServiceSpec, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ServiceSpec, _impl_.ports_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ServiceSpec, _impl_.selector_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ServiceSpec, _impl_.clusterip_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ServiceSpec, _impl_.clusterips_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ServiceSpec, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ServiceSpec, _impl_.externalips_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ServiceSpec, _impl_.sessionaffinity_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ServiceSpec, _impl_.loadbalancerip_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ServiceSpec, _impl_.loadbalancersourceranges_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ServiceSpec, _impl_.externalname_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ServiceSpec, _impl_.externaltrafficpolicy_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ServiceSpec, _impl_.healthchecknodeport_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ServiceSpec, _impl_.publishnotreadyaddresses_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ServiceSpec, _impl_.sessionaffinityconfig_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ServiceSpec, _impl_.ipfamilies_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ServiceSpec, _impl_.ipfamilypolicy_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ServiceSpec, _impl_.allocateloadbalancernodeports_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ServiceSpec, _impl_.loadbalancerclass_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ServiceSpec, _impl_.internaltrafficpolicy_),
  ~0u,
  ~0u,
  0,
  ~0u,
  1,
  ~0u,
  2,
  3,
  ~0u,
  4,
  5,
  10,
  11,
  9,
  ~0u,
  6,
  12,
  7,
  8,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ServiceStatus, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ServiceStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ServiceStatus, _impl_.loadbalancer_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::ServiceStatus, _impl_.conditions_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::SessionAffinityConfig, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::SessionAffinityConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::SessionAffinityConfig, _impl_.clientip_),
  0,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::SleepAction, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::SleepAction, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::SleepAction, _impl_.seconds_),
  0,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::StorageOSPersistentVolumeSource, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::StorageOSPersistentVolumeSource, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::StorageOSPersistentVolumeSource, _impl_.volumename_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::StorageOSPersistentVolumeSource, _impl_.volumenamespace_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::StorageOSPersistentVolumeSource, _impl_.fstype_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::StorageOSPersistentVolumeSource, _impl_.readonly_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::StorageOSPersistentVolumeSource, _impl_.secretref_),
  0,
  1,
  2,
  4,
  3,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::StorageOSVolumeSource, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::StorageOSVolumeSource, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::StorageOSVolumeSource, _impl_.volumename_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::StorageOSVolumeSource, _impl_.volumenamespace_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::StorageOSVolumeSource, _impl_.fstype_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::StorageOSVolumeSource, _impl_.readonly_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::StorageOSVolumeSource, _impl_.secretref_),
  0,
  1,
  2,
  4,
  3,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Sysctl, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Sysctl, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Sysctl, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Sysctl, _impl_.value_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::TCPSocketAction, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::TCPSocketAction, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::TCPSocketAction, _impl_.port_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::TCPSocketAction, _impl_.host_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Taint, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Taint, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Taint, _impl_.key_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Taint, _impl_.value_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Taint, _impl_.effect_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Taint, _impl_.timeadded_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Toleration, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Toleration, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Toleration, _impl_.key_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Toleration, _impl_.operator__),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Toleration, _impl_.value_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Toleration, _impl_.effect_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Toleration, _impl_.tolerationseconds_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::TopologySelectorLabelRequirement, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::TopologySelectorLabelRequirement, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::TopologySelectorLabelRequirement, _impl_.key_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::TopologySelectorLabelRequirement, _impl_.values_),
  0,
  ~0u,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::TopologySelectorTerm, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::TopologySelectorTerm, _impl_.matchlabelexpressions_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::TopologySpreadConstraint, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::TopologySpreadConstraint, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::TopologySpreadConstraint, _impl_.maxskew_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::TopologySpreadConstraint, _impl_.topologykey_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::TopologySpreadConstraint, _impl_.whenunsatisfiable_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::TopologySpreadConstraint, _impl_.labelselector_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::TopologySpreadConstraint, _impl_.mindomains_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::TopologySpreadConstraint, _impl_.nodeaffinitypolicy_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::TopologySpreadConstraint, _impl_.nodetaintspolicy_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::TopologySpreadConstraint, _impl_.matchlabelkeys_),
  5,
  0,
  1,
  4,
  6,
  2,
  3,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::TypedLocalObjectReference, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::TypedLocalObjectReference, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::TypedLocalObjectReference, _impl_.apigroup_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::TypedLocalObjectReference, _impl_.kind_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::TypedLocalObjectReference, _impl_.name_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::TypedObjectReference, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::TypedObjectReference, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::TypedObjectReference, _impl_.apigroup_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::TypedObjectReference, _impl_.kind_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::TypedObjectReference, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::TypedObjectReference, _impl_.namespace__),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Volume, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Volume, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Volume, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::Volume, _impl_.volumesource_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::VolumeDevice, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::VolumeDevice, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::VolumeDevice, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::VolumeDevice, _impl_.devicepath_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::VolumeMount, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::VolumeMount, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::VolumeMount, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::VolumeMount, _impl_.readonly_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::VolumeMount, _impl_.mountpath_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::VolumeMount, _impl_.subpath_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::VolumeMount, _impl_.mountpropagation_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::VolumeMount, _impl_.subpathexpr_),
  0,
  5,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::VolumeNodeAffinity, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::VolumeNodeAffinity, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::VolumeNodeAffinity, _impl_.required_),
  0,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::VolumeProjection, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::VolumeProjection, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::VolumeProjection, _impl_.secret_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::VolumeProjection, _impl_.downwardapi_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::VolumeProjection, _impl_.configmap_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::VolumeProjection, _impl_.serviceaccounttoken_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::VolumeProjection, _impl_.clustertrustbundle_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::VolumeResourceRequirements_LimitsEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::VolumeResourceRequirements_LimitsEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::VolumeResourceRequirements_LimitsEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::VolumeResourceRequirements_LimitsEntry_DoNotUse, value_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::VolumeResourceRequirements_RequestsEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::VolumeResourceRequirements_RequestsEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::VolumeResourceRequirements_RequestsEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::VolumeResourceRequirements_RequestsEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::VolumeResourceRequirements, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::VolumeResourceRequirements, _impl_.limits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::VolumeResourceRequirements, _impl_.requests_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::VolumeSource, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::VolumeSource, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::VolumeSource, _impl_.hostpath_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::VolumeSource, _impl_.emptydir_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::VolumeSource, _impl_.gcepersistentdisk_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::VolumeSource, _impl_.awselasticblockstore_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::VolumeSource, _impl_.gitrepo_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::VolumeSource, _impl_.secret_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::VolumeSource, _impl_.nfs_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::VolumeSource, _impl_.iscsi_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::VolumeSource, _impl_.glusterfs_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::VolumeSource, _impl_.persistentvolumeclaim_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::VolumeSource, _impl_.rbd_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::VolumeSource, _impl_.flexvolume_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::VolumeSource, _impl_.cinder_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::VolumeSource, _impl_.cephfs_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::VolumeSource, _impl_.flocker_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::VolumeSource, _impl_.downwardapi_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::VolumeSource, _impl_.fc_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::VolumeSource, _impl_.azurefile_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::VolumeSource, _impl_.configmap_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::VolumeSource, _impl_.vspherevolume_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::VolumeSource, _impl_.quobyte_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::VolumeSource, _impl_.azuredisk_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::VolumeSource, _impl_.photonpersistentdisk_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::VolumeSource, _impl_.projected_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::VolumeSource, _impl_.portworxvolume_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::VolumeSource, _impl_.scaleio_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::VolumeSource, _impl_.storageos_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::VolumeSource, _impl_.csi_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::VolumeSource, _impl_.ephemeral_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  25,
  23,
  24,
  26,
  27,
  28,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::VsphereVirtualDiskVolumeSource, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::VsphereVirtualDiskVolumeSource, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::VsphereVirtualDiskVolumeSource, _impl_.volumepath_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::VsphereVirtualDiskVolumeSource, _impl_.fstype_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::VsphereVirtualDiskVolumeSource, _impl_.storagepolicyname_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::VsphereVirtualDiskVolumeSource, _impl_.storagepolicyid_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::WeightedPodAffinityTerm, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::WeightedPodAffinityTerm, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::WeightedPodAffinityTerm, _impl_.weight_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::WeightedPodAffinityTerm, _impl_.podaffinityterm_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::WindowsSecurityContextOptions, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::WindowsSecurityContextOptions, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::WindowsSecurityContextOptions, _impl_.gmsacredentialspecname_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::WindowsSecurityContextOptions, _impl_.gmsacredentialspec_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::WindowsSecurityContextOptions, _impl_.runasusername_),
  PROTOBUF_FIELD_OFFSET(::k8s::io::api::core::v1::WindowsSecurityContextOptions, _impl_.hostprocess_),
  0,
  1,
  2,
  3,
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 8, -1, sizeof(::k8s::io::api::core::v1::PodOrNode)},
  { 10, 20, -1, sizeof(::k8s::io::api::core::v1::AWSElasticBlockStoreVolumeSource)},
  { 24, 33, -1, sizeof(::k8s::io::api::core::v1::Affinity)},
  { 36, 44, -1, sizeof(::k8s::io::api::core::v1::AttachedVolume)},
  { 46, -1, -1, sizeof(::k8s::io::api::core::v1::AvoidPods)},
  { 53, 65, -1, sizeof(::k8s::io::api::core::v1::AzureDiskVolumeSource)},
  { 71, 81, -1, sizeof(::k8s::io::api::core::v1::AzureFilePersistentVolumeSource)},
  { 85, 94, -1, sizeof(::k8s::io::api::core::v1::AzureFileVolumeSource)},
  { 97, 105, -1, sizeof(::k8s::io::api::core::v1::Binding)},
  { 107, 115, -1, sizeof(::k8s::io::api::core::v1::CSIPersistentVolumeSource_VolumeAttributesEntry_DoNotUse)},
  { 117, 133, -1, sizeof(::k8s::io::api::core::v1::CSIPersistentVolumeSource)},
  { 143, 151, -1, sizeof(::k8s::io::api::core::v1::CSIVolumeSource_VolumeAttributesEntry_DoNotUse)},
  { 153, 164, -1, sizeof(::k8s::io::api::core::v1::CSIVolumeSource)},
  { 169, -1, -1, sizeof(::k8s::io::api::core::v1::Capabilities)},
  { 177, 189, -1, sizeof(::k8s::io::api::core::v1::CephFSPersistentVolumeSource)},
  { 195, 207, -1, sizeof(::k8s::io::api::core::v1::CephFSVolumeSource)},
  { 213, 223, -1, sizeof(::k8s::io::api::core::v1::CinderPersistentVolumeSource)},
  { 227, 237, -1, sizeof(::k8s::io::api::core::v1::CinderVolumeSource)},
  { 241, 249, -1, sizeof(::k8s::io::api::core::v1::ClaimSource)},
  { 251, 258, -1, sizeof(::k8s::io::api::core::v1::ClientIPConfig)},
  { 259, 270, -1, sizeof(::k8s::io::api::core::v1::ClusterTrustBundleProjection)},
  { 275, 285, -1, sizeof(::k8s::io::api::core::v1::ComponentCondition)},
  { 289, 297, -1, sizeof(::k8s::io::api::core::v1::ComponentStatus)},
  { 299, 307, -1, sizeof(::k8s::io::api::core::v1::ComponentStatusList)},
  { 309, 317, -1, sizeof(::k8s::io::api::core::v1::ConfigMap_DataEntry_DoNotUse)},
  { 319, 327, -1, sizeof(::k8s::io::api::core::v1::ConfigMap_BinaryDataEntry_DoNotUse)},
  { 329, 339, -1, sizeof(::k8s::io::api::core::v1::ConfigMap)},
  { 343, 351, -1, sizeof(::k8s::io::api::core::v1::ConfigMapEnvSource)},
  { 353, 362, -1, sizeof(::k8s::io::api::core::v1::ConfigMapKeySelector)},
  { 365, 373, -1, sizeof(::k8s::io::api::core::v1::ConfigMapList)},
  { 375, 386, -1, sizeof(::k8s::io::api::core::v1::ConfigMapNodeConfigSource)},
  { 391, 400, -1, sizeof(::k8s::io::api::core::v1::ConfigMapProjection)},
  { 403, 413, -1, sizeof(::k8s::io::api::core::v1::ConfigMapVolumeSource)},
  { 417, 447, -1, sizeof(::k8s::io::api::core::v1::Container)},
  { 471, 479, -1, sizeof(::k8s::io::api::core::v1::ContainerImage)},
  { 481, 492, -1, sizeof(::k8s::io::api::core::v1::ContainerPort)},
  { 497, 505, -1, sizeof(::k8s::io::api::core::v1::ContainerResizePolicy)},
  { 507, 516, -1, sizeof(::k8s::io::api::core::v1::ContainerState)},
  { 519, 526, -1, sizeof(::k8s::io::api::core::v1::ContainerStateRunning)},
  { 527, 540, -1, sizeof(::k8s::io::api::core::v1::ContainerStateTerminated)},
  { 547, 555, -1, sizeof(::k8s::io::api::core::v1::ContainerStateWaiting)},
  { 557, 565, -1, sizeof(::k8s::io::api::core::v1::ContainerStatus_AllocatedResourcesEntry_DoNotUse)},
  { 567, 584, -1, sizeof(::k8s::io::api::core::v1::ContainerStatus)},
  { 595, 602, -1, sizeof(::k8s::io::api::core::v1::DaemonEndpoint)},
  { 603, -1, -1, sizeof(::k8s::io::api::core::v1::DownwardAPIProjection)},
  { 610, 620, -1, sizeof(::k8s::io::api::core::v1::DownwardAPIVolumeFile)},
  { 624, 632, -1, sizeof(::k8s::io::api::core::v1::DownwardAPIVolumeSource)},
  { 634, 642, -1, sizeof(::k8s::io::api::core::v1::EmptyDirVolumeSource)},
  { 644, 654, -1, sizeof(::k8s::io::api::core::v1::EndpointAddress)},
  { 658, 668, -1, sizeof(::k8s::io::api::core::v1::EndpointPort)},
  { 672, -1, -1, sizeof(::k8s::io::api::core::v1::EndpointSubset)},
  { 681, 689, -1, sizeof(::k8s::io::api::core::v1::Endpoints)},
  { 691, 699, -1, sizeof(::k8s::io::api::core::v1::EndpointsList)},
  { 701, 710, -1, sizeof(::k8s::io::api::core::v1::EnvFromSource)},
  { 713, 722, -1, sizeof(::k8s::io::api::core::v1::EnvVar)},
  { 725, 735, -1, sizeof(::k8s::io::api::core::v1::EnvVarSource)},
  { 739, 747, -1, sizeof(::k8s::io::api::core::v1::EphemeralContainer)},
  { 749, 779, -1, sizeof(::k8s::io::api::core::v1::EphemeralContainerCommon)},
  { 803, 810, -1, sizeof(::k8s::io::api::core::v1::EphemeralVolumeSource)},
  { 811, 832, -1, sizeof(::k8s::io::api::core::v1::Event)},
  { 847, 855, -1, sizeof(::k8s::io::api::core::v1::EventList)},
  { 857, 865, -1, sizeof(::k8s::io::api::core::v1::EventSeries)},
  { 867, 875, -1, sizeof(::k8s::io::api::core::v1::EventSource)},
  { 877, -1, -1, sizeof(::k8s::io::api::core::v1::ExecAction)},
  { 884, 895, -1, sizeof(::k8s::io::api::core::v1::FCVolumeSource)},
  { 900, 908, -1, sizeof(::k8s::io::api::core::v1::FlexPersistentVolumeSource_OptionsEntry_DoNotUse)},
  { 910, 921, -1, sizeof(::k8s::io::api::core::v1::FlexPersistentVolumeSource)},
  { 926, 934, -1, sizeof(::k8s::io::api::core::v1::FlexVolumeSource_OptionsEntry_DoNotUse)},
  { 936, 947, -1, sizeof(::k8s::io::api::core::v1::FlexVolumeSource)},
  { 952, 960, -1, sizeof(::k8s::io::api::core::v1::FlockerVolumeSource)},
  { 962, 972, -1, sizeof(::k8s::io::api::core::v1::GCEPersistentDiskVolumeSource)},
  { 976, 984, -1, sizeof(::k8s::io::api::core::v1::GRPCAction)},
  { 986, 995, -1, sizeof(::k8s::io::api::core::v1::GitRepoVolumeSource)},
  { 998, 1008, -1, sizeof(::k8s::io::api::core::v1::GlusterfsPersistentVolumeSource)},
  { 1012, 1021, -1, sizeof(::k8s::io::api::core::v1::GlusterfsVolumeSource)},
  { 1024, 1035, -1, sizeof(::k8s::io::api::core::v1::HTTPGetAction)},
  { 1040, 1048, -1, sizeof(::k8s::io::api::core::v1::HTTPHeader)},
  { 1050, 1058, -1, sizeof(::k8s::io::api::core::v1::HostAlias)},
  { 1060, 1067, -1, sizeof(::k8s::io::api::core::v1::HostIP)},
  { 1068, 1076, -1, sizeof(::k8s::io::api::core::v1::HostPathVolumeSource)},
  { 1078, 1095, -1, sizeof(::k8s::io::api::core::v1::ISCSIPersistentVolumeSource)},
  { 1106, 1123, -1, sizeof(::k8s::io::api::core::v1::ISCSIVolumeSource)},
  { 1134, 1143, -1, sizeof(::k8s::io::api::core::v1::KeyToPath)},
  { 1146, 1154, -1, sizeof(::k8s::io::api::core::v1::Lifecycle)},
  { 1156, 1166, -1, sizeof(::k8s::io::api::core::v1::LifecycleHandler)},
  { 1170, 1178, -1, sizeof(::k8s::io::api::core::v1::LimitRange)},
  { 1180, 1188, -1, sizeof(::k8s::io::api::core::v1::LimitRangeItem_MaxEntry_DoNotUse)},
  { 1190, 1198, -1, sizeof(::k8s::io::api::core::v1::LimitRangeItem_MinEntry_DoNotUse)},
  { 1200, 1208, -1, sizeof(::k8s::io::api::core::v1::LimitRangeItem_DefaultEntry_DoNotUse)},
  { 1210, 1218, -1, sizeof(::k8s::io::api::core::v1::LimitRangeItem_DefaultRequestEntry_DoNotUse)},
  { 1220, 1228, -1, sizeof(::k8s::io::api::core::v1::LimitRangeItem_MaxLimitRequestRatioEntry_DoNotUse)},
  { 1230, 1242, -1, sizeof(::k8s::io::api::core::v1::LimitRangeItem)},
  { 1248, 1256, -1, sizeof(::k8s::io::api::core::v1::LimitRangeList)},
  { 1258, -1, -1, sizeof(::k8s::io::api::core::v1::LimitRangeSpec)},
  { 1265, 1273, -1, sizeof(::k8s::io::api::core::v1::List)},
  { 1275, 1285, -1, sizeof(::k8s::io::api::core::v1::LoadBalancerIngress)},
  { 1289, -1, -1, sizeof(::k8s::io::api::core::v1::LoadBalancerStatus)},
  { 1296, 1303, -1, sizeof(::k8s::io::api::core::v1::LocalObjectReference)},
  { 1304, 1312, -1, sizeof(::k8s::io::api::core::v1::LocalVolumeSource)},
  { 1314, 1322, -1, sizeof(::k8s::io::api::core::v1::ModifyVolumeStatus)},
  { 1324, 1333, -1, sizeof(::k8s::io::api::core::v1::NFSVolumeSource)},
  { 1336, 1345, -1, sizeof(::k8s::io::api::core::v1::Namespace)},
  { 1348, 1359, -1, sizeof(::k8s::io::api::core::v1::NamespaceCondition)},
  { 1364, 1372, -1, sizeof(::k8s::io::api::core::v1::NamespaceList)},
  { 1374, -1, -1, sizeof(::k8s::io::api::core::v1::NamespaceSpec)},
  { 1381, 1389, -1, sizeof(::k8s::io::api::core::v1::NamespaceStatus)},
  { 1391, 1400, -1, sizeof(::k8s::io::api::core::v1::Node)},
  { 1403, 1411, -1, sizeof(::k8s::io::api::core::v1::NodeAddress)},
  { 1413, 1421, -1, sizeof(::k8s::io::api::core::v1::NodeAffinity)},
  { 1423, 1435, -1, sizeof(::k8s::io::api::core::v1::NodeCondition)},
  { 1441, 1448, -1, sizeof(::k8s::io::api::core::v1::NodeConfigSource)},
  { 1449, 1459, -1, sizeof(::k8s::io::api::core::v1::NodeConfigStatus)},
  { 1463, 1470, -1, sizeof(::k8s::io::api::core::v1::NodeDaemonEndpoints)},
  { 1471, 1479, -1, sizeof(::k8s::io::api::core::v1::NodeList)},
  { 1481, 1488, -1, sizeof(::k8s::io::api::core::v1::NodeProxyOptions)},
  { 1489, 1497, -1, sizeof(::k8s::io::api::core::v1::NodeResources_CapacityEntry_DoNotUse)},
  { 1499, -1, -1, sizeof(::k8s::io::api::core::v1::NodeResources)},
  { 1506, -1, -1, sizeof(::k8s::io::api::core::v1::NodeSelector)},
  { 1513, 1522, -1, sizeof(::k8s::io::api::core::v1::NodeSelectorRequirement)},
  { 1525, -1, -1, sizeof(::k8s::io::api::core::v1::NodeSelectorTerm)},
  { 1533, 1546, -1, sizeof(::k8s::io::api::core::v1::NodeSpec)},
  { 1553, 1561, -1, sizeof(::k8s::io::api::core::v1::NodeStatus_CapacityEntry_DoNotUse)},
  { 1563, 1571, -1, sizeof(::k8s::io::api::core::v1::NodeStatus_AllocatableEntry_DoNotUse)},
  { 1573, 1590, -1, sizeof(::k8s::io::api::core::v1::NodeStatus)},
  { 1601, 1617, -1, sizeof(::k8s::io::api::core::v1::NodeSystemInfo)},
  { 1627, 1635, -1, sizeof(::k8s::io::api::core::v1::ObjectFieldSelector)},
  { 1637, 1650, -1, sizeof(::k8s::io::api::core::v1::ObjectReference)},
  { 1657, 1666, -1, sizeof(::k8s::io::api::core::v1::PersistentVolume)},
  { 1669, 1678, -1, sizeof(::k8s::io::api::core::v1::PersistentVolumeClaim)},
  { 1681, 1693, -1, sizeof(::k8s::io::api::core::v1::PersistentVolumeClaimCondition)},
  { 1699, 1707, -1, sizeof(::k8s::io::api::core::v1::PersistentVolumeClaimList)},
  { 1709, 1724, -1, sizeof(::k8s::io::api::core::v1::PersistentVolumeClaimSpec)},
  { 1733, 1741, -1, sizeof(::k8s::io::api::core::v1::PersistentVolumeClaimStatus_CapacityEntry_DoNotUse)},
  { 1743, 1751, -1, sizeof(::k8s::io::api::core::v1::PersistentVolumeClaimStatus_AllocatedResourcesEntry_DoNotUse)},
  { 1753, 1761, -1, sizeof(::k8s::io::api::core::v1::PersistentVolumeClaimStatus_AllocatedResourceStatusesEntry_DoNotUse)},
  { 1763, 1777, -1, sizeof(::k8s::io::api::core::v1::PersistentVolumeClaimStatus)},
  { 1785, 1793, -1, sizeof(::k8s::io::api::core::v1::PersistentVolumeClaimTemplate)},
  { 1795, 1803, -1, sizeof(::k8s::io::api::core::v1::PersistentVolumeClaimVolumeSource)},
  { 1805, 1813, -1, sizeof(::k8s::io::api::core::v1::PersistentVolumeList)},
  { 1815, 1843, -1, sizeof(::k8s::io::api::core::v1::PersistentVolumeSource)},
  { 1865, 1873, -1, sizeof(::k8s::io::api::core::v1::PersistentVolumeSpec_CapacityEntry_DoNotUse)},
  { 1875, 1891, -1, sizeof(::k8s::io::api::core::v1::PersistentVolumeSpec)},
  { 1901, 1911, -1, sizeof(::k8s::io::api::core::v1::PersistentVolumeStatus)},
  { 1915, 1923, -1, sizeof(::k8s::io::api::core::v1::PhotonPersistentDiskVolumeSource)},
  { 1925, 1934, -1, sizeof(::k8s::io::api::core::v1::Pod)},
  { 1937, -1, -1, sizeof(::k8s::io::api::core::v1::PodAffinity)},
  { 1945, 1957, -1, sizeof(::k8s::io::api::core::v1::PodAffinityTerm)},
  { 1963, -1, -1, sizeof(::k8s::io::api::core::v1::PodAntiAffinity)},
  { 1971, 1982, -1, sizeof(::k8s::io::api::core::v1::PodAttachOptions)},
  { 1987, 1999, -1, sizeof(::k8s::io::api::core::v1::PodCondition)},
  { 2005, -1, -1, sizeof(::k8s::io::api::core::v1::PodDNSConfig)},
  { 2014, 2022, -1, sizeof(::k8s::io::api::core::v1::PodDNSConfigOption)},
  { 2024, 2036, -1, sizeof(::k8s::io::api::core::v1::PodExecOptions)},
  { 2042, 2049, -1, sizeof(::k8s::io::api::core::v1::PodIP)},
  { 2050, 2058, -1, sizeof(::k8s::io::api::core::v1::PodList)},
  { 2060, 2075, -1, sizeof(::k8s::io::api::core::v1::PodLogOptions)},
  { 2084, 2091, -1, sizeof(::k8s::io::api::core::v1::PodOS)},
  { 2092, -1, -1, sizeof(::k8s::io::api::core::v1::PodPortForwardOptions)},
  { 2099, 2106, -1, sizeof(::k8s::io::api::core::v1::PodProxyOptions)},
  { 2107, 2114, -1, sizeof(::k8s::io::api::core::v1::PodReadinessGate)},
  { 2115, 2123, -1, sizeof(::k8s::io::api::core::v1::PodResourceClaim)},
  { 2125, 2133, -1, sizeof(::k8s::io::api::core::v1::PodResourceClaimStatus)},
  { 2135, 2142, -1, sizeof(::k8s::io::api::core::v1::PodSchedulingGate)},
  { 2143, 2159, -1, sizeof(::k8s::io::api::core::v1::PodSecurityContext)},
  { 2169, 2176, -1, sizeof(::k8s::io::api::core::v1::PodSignature)},
  { 2177, 2185, -1, sizeof(::k8s::io::api::core::v1::PodSpec_NodeSelectorEntry_DoNotUse)},
  { 2187, 2195, -1, sizeof(::k8s::io::api::core::v1::PodSpec_OverheadEntry_DoNotUse)},
  { 2197, 2242, -1, sizeof(::k8s::io::api::core::v1::PodSpec)},
  { 2281, 2303, -1, sizeof(::k8s::io::api::core::v1::PodStatus)},
  { 2319, 2327, -1, sizeof(::k8s::io::api::core::v1::PodStatusResult)},
  { 2329, 2337, -1, sizeof(::k8s::io::api::core::v1::PodTemplate)},
  { 2339, 2347, -1, sizeof(::k8s::io::api::core::v1::PodTemplateList)},
  { 2349, 2357, -1, sizeof(::k8s::io::api::core::v1::PodTemplateSpec)},
  { 2359, 2368, -1, sizeof(::k8s::io::api::core::v1::PortStatus)},
  { 2371, 2380, -1, sizeof(::k8s::io::api::core::v1::PortworxVolumeSource)},
  { 2383, 2390, -1, sizeof(::k8s::io::api::core::v1::Preconditions)},
  { 2391, 2401, -1, sizeof(::k8s::io::api::core::v1::PreferAvoidPodsEntry)},
  { 2405, 2413, -1, sizeof(::k8s::io::api::core::v1::PreferredSchedulingTerm)},
  { 2415, 2428, -1, sizeof(::k8s::io::api::core::v1::Probe)},
  { 2435, 2445, -1, sizeof(::k8s::io::api::core::v1::ProbeHandler)},
  { 2449, 2457, -1, sizeof(::k8s::io::api::core::v1::ProjectedVolumeSource)},
  { 2459, 2471, -1, sizeof(::k8s::io::api::core::v1::QuobyteVolumeSource)},
  { 2477, 2491, -1, sizeof(::k8s::io::api::core::v1::RBDPersistentVolumeSource)},
  { 2499, 2513, -1, sizeof(::k8s::io::api::core::v1::RBDVolumeSource)},
  { 2521, 2530, -1, sizeof(::k8s::io::api::core::v1::RangeAllocation)},
  { 2533, 2542, -1, sizeof(::k8s::io::api::core::v1::ReplicationController)},
  { 2545, 2556, -1, sizeof(::k8s::io::api::core::v1::ReplicationControllerCondition)},
  { 2561, 2569, -1, sizeof(::k8s::io::api::core::v1::ReplicationControllerList)},
  { 2571, 2579, -1, sizeof(::k8s::io::api::core::v1::ReplicationControllerSpec_SelectorEntry_DoNotUse)},
  { 2581, 2591, -1, sizeof(::k8s::io::api::core::v1::ReplicationControllerSpec)},
  { 2595, 2607, -1, sizeof(::k8s::io::api::core::v1::ReplicationControllerStatus)},
  { 2613, 2620, -1, sizeof(::k8s::io::api::core::v1::ResourceClaim)},
  { 2621, 2630, -1, sizeof(::k8s::io::api::core::v1::ResourceFieldSelector)},
  { 2633, 2642, -1, sizeof(::k8s::io::api::core::v1::ResourceQuota)},
  { 2645, 2653, -1, sizeof(::k8s::io::api::core::v1::ResourceQuotaList)},
  { 2655, 2663, -1, sizeof(::k8s::io::api::core::v1::ResourceQuotaSpec_HardEntry_DoNotUse)},
  { 2665, 2674, -1, sizeof(::k8s::io::api::core::v1::ResourceQuotaSpec)},
  { 2677, 2685, -1, sizeof(::k8s::io::api::core::v1::ResourceQuotaStatus_HardEntry_DoNotUse)},
  { 2687, 2695, -1, sizeof(::k8s::io::api::core::v1::ResourceQuotaStatus_UsedEntry_DoNotUse)},
  { 2697, -1, -1, sizeof(::k8s::io::api::core::v1::ResourceQuotaStatus)},
  { 2705, 2713, -1, sizeof(::k8s::io::api::core::v1::ResourceRequirements_LimitsEntry_DoNotUse)},
  { 2715, 2723, -1, sizeof(::k8s::io::api::core::v1::ResourceRequirements_RequestsEntry_DoNotUse)},
  { 2725, -1, -1, sizeof(::k8s::io::api::core::v1::ResourceRequirements)},
  { 2734, 2744, -1, sizeof(::k8s::io::api::core::v1::SELinuxOptions)},
  { 2748, 2764, -1, sizeof(::k8s::io::api::core::v1::ScaleIOPersistentVolumeSource)},
  { 2774, 2790, -1, sizeof(::k8s::io::api::core::v1::ScaleIOVolumeSource)},
  { 2800, -1, -1, sizeof(::k8s::io::api::core::v1::ScopeSelector)},
  { 2807, 2816, -1, sizeof(::k8s::io::api::core::v1::ScopedResourceSelectorRequirement)},
  { 2819, 2827, -1, sizeof(::k8s::io::api::core::v1::SeccompProfile)},
  { 2829, 2837, -1, sizeof(::k8s::io::api::core::v1::Secret_DataEntry_DoNotUse)},
  { 2839, 2847, -1, sizeof(::k8s::io::api::core::v1::Secret_StringDataEntry_DoNotUse)},
  { 2849, 2860, -1, sizeof(::k8s::io::api::core::v1::Secret)},
  { 2865, 2873, -1, sizeof(::k8s::io::api::core::v1::SecretEnvSource)},
  { 2875, 2884, -1, sizeof(::k8s::io::api::core::v1::SecretKeySelector)},
  { 2887, 2895, -1, sizeof(::k8s::io::api::core::v1::SecretList)},
  { 2897, 2906, -1, sizeof(::k8s::io::api::core::v1::SecretProjection)},
  { 2909, 2917, -1, sizeof(::k8s::io::api::core::v1::SecretReference)},
  { 2919, 2929, -1, sizeof(::k8s::io::api::core::v1::SecretVolumeSource)},
  { 2933, 2950, -1, sizeof(::k8s::io::api::core::v1::SecurityContext)},
  { 2961, 2968, -1, sizeof(::k8s::io::api::core::v1::SerializedReference)},
  { 2969, 2978, -1, sizeof(::k8s::io::api::core::v1::Service)},
  { 2981, 2991, -1, sizeof(::k8s::io::api::core::v1::ServiceAccount)},
  { 2995, 3003, -1, sizeof(::k8s::io::api::core::v1::ServiceAccountList)},
  { 3005, 3014, -1, sizeof(::k8s::io::api::core::v1::ServiceAccountTokenProjection)},
  { 3017, 3025, -1, sizeof(::k8s::io::api::core::v1::ServiceList)},
  { 3027, 3039, -1, sizeof(::k8s::io::api::core::v1::ServicePort)},
  { 3045, 3052, -1, sizeof(::k8s::io::api::core::v1::ServiceProxyOptions)},
  { 3053, 3061, -1, sizeof(::k8s::io::api::core::v1::ServiceSpec_SelectorEntry_DoNotUse)},
  { 3063, 3088, -1, sizeof(::k8s::io::api::core::v1::ServiceSpec)},
  { 3107, 3115, -1, sizeof(::k8s::io::api::core::v1::ServiceStatus)},
  { 3117, 3124, -1, sizeof(::k8s::io::api::core::v1::SessionAffinityConfig)},
  { 3125, 3132, -1, sizeof(::k8s::io::api::core::v1::SleepAction)},
  { 3133, 3144, -1, sizeof(::k8s::io::api::core::v1::StorageOSPersistentVolumeSource)},
  { 3149, 3160, -1, sizeof(::k8s::io::api::core::v1::StorageOSVolumeSource)},
  { 3165, 3173, -1, sizeof(::k8s::io::api::core::v1::Sysctl)},
  { 3175, 3183, -1, sizeof(::k8s::io::api::core::v1::TCPSocketAction)},
  { 3185, 3195, -1, sizeof(::k8s::io::api::core::v1::Taint)},
  { 3199, 3210, -1, sizeof(::k8s::io::api::core::v1::Toleration)},
  { 3215, 3223, -1, sizeof(::k8s::io::api::core::v1::TopologySelectorLabelRequirement)},
  { 3225, -1, -1, sizeof(::k8s::io::api::core::v1::TopologySelectorTerm)},
  { 3232, 3246, -1, sizeof(::k8s::io::api::core::v1::TopologySpreadConstraint)},
  { 3254, 3263, -1, sizeof(::k8s::io::api::core::v1::TypedLocalObjectReference)},
  { 3266, 3276, -1, sizeof(::k8s::io::api::core::v1::TypedObjectReference)},
  { 3280, 3288, -1, sizeof(::k8s::io::api::core::v1::Volume)},
  { 3290, 3298, -1, sizeof(::k8s::io::api::core::v1::VolumeDevice)},
  { 3300, 3312, -1, sizeof(::k8s::io::api::core::v1::VolumeMount)},
  { 3318, 3325, -1, sizeof(::k8s::io::api::core::v1::VolumeNodeAffinity)},
  { 3326, 3337, -1, sizeof(::k8s::io::api::core::v1::VolumeProjection)},
  { 3342, 3350, -1, sizeof(::k8s::io::api::core::v1::VolumeResourceRequirements_LimitsEntry_DoNotUse)},
  { 3352, 3360, -1, sizeof(::k8s::io::api::core::v1::VolumeResourceRequirements_RequestsEntry_DoNotUse)},
  { 3362, -1, -1, sizeof(::k8s::io::api::core::v1::VolumeResourceRequirements)},
  { 3370, 3405, -1, sizeof(::k8s::io::api::core::v1::VolumeSource)},
  { 3434, 3444, -1, sizeof(::k8s::io::api::core::v1::VsphereVirtualDiskVolumeSource)},
  { 3448, 3456, -1, sizeof(::k8s::io::api::core::v1::WeightedPodAffinityTerm)},
  { 3458, 3468, -1, sizeof(::k8s::io::api::core::v1::WindowsSecurityContextOptions)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::k8s::io::api::core::v1::_PodOrNode_default_instance_._instance,
  &::k8s::io::api::core::v1::_AWSElasticBlockStoreVolumeSource_default_instance_._instance,
  &::k8s::io::api::core::v1::_Affinity_default_instance_._instance,
  &::k8s::io::api::core::v1::_AttachedVolume_default_instance_._instance,
  &::k8s::io::api::core::v1::_AvoidPods_default_instance_._instance,
  &::k8s::io::api::core::v1::_AzureDiskVolumeSource_default_instance_._instance,
  &::k8s::io::api::core::v1::_AzureFilePersistentVolumeSource_default_instance_._instance,
  &::k8s::io::api::core::v1::_AzureFileVolumeSource_default_instance_._instance,
  &::k8s::io::api::core::v1::_Binding_default_instance_._instance,
  &::k8s::io::api::core::v1::_CSIPersistentVolumeSource_VolumeAttributesEntry_DoNotUse_default_instance_._instance,
  &::k8s::io::api::core::v1::_CSIPersistentVolumeSource_default_instance_._instance,
  &::k8s::io::api::core::v1::_CSIVolumeSource_VolumeAttributesEntry_DoNotUse_default_instance_._instance,
  &::k8s::io::api::core::v1::_CSIVolumeSource_default_instance_._instance,
  &::k8s::io::api::core::v1::_Capabilities_default_instance_._instance,
  &::k8s::io::api::core::v1::_CephFSPersistentVolumeSource_default_instance_._instance,
  &::k8s::io::api::core::v1::_CephFSVolumeSource_default_instance_._instance,
  &::k8s::io::api::core::v1::_CinderPersistentVolumeSource_default_instance_._instance,
  &::k8s::io::api::core::v1::_CinderVolumeSource_default_instance_._instance,
  &::k8s::io::api::core::v1::_ClaimSource_default_instance_._instance,
  &::k8s::io::api::core::v1::_ClientIPConfig_default_instance_._instance,
  &::k8s::io::api::core::v1::_ClusterTrustBundleProjection_default_instance_._instance,
  &::k8s::io::api::core::v1::_ComponentCondition_default_instance_._instance,
  &::k8s::io::api::core::v1::_ComponentStatus_default_instance_._instance,
  &::k8s::io::api::core::v1::_ComponentStatusList_default_instance_._instance,
  &::k8s::io::api::core::v1::_ConfigMap_DataEntry_DoNotUse_default_instance_._instance,
  &::k8s::io::api::core::v1::_ConfigMap_BinaryDataEntry_DoNotUse_default_instance_._instance,
  &::k8s::io::api::core::v1::_ConfigMap_default_instance_._instance,
  &::k8s::io::api::core::v1::_ConfigMapEnvSource_default_instance_._instance,
  &::k8s::io::api::core::v1::_ConfigMapKeySelector_default_instance_._instance,
  &::k8s::io::api::core::v1::_ConfigMapList_default_instance_._instance,
  &::k8s::io::api::core::v1::_ConfigMapNodeConfigSource_default_instance_._instance,
  &::k8s::io::api::core::v1::_ConfigMapProjection_default_instance_._instance,
  &::k8s::io::api::core::v1::_ConfigMapVolumeSource_default_instance_._instance,
  &::k8s::io::api::core::v1::_Container_default_instance_._instance,
  &::k8s::io::api::core::v1::_ContainerImage_default_instance_._instance,
  &::k8s::io::api::core::v1::_ContainerPort_default_instance_._instance,
  &::k8s::io::api::core::v1::_ContainerResizePolicy_default_instance_._instance,
  &::k8s::io::api::core::v1::_ContainerState_default_instance_._instance,
  &::k8s::io::api::core::v1::_ContainerStateRunning_default_instance_._instance,
  &::k8s::io::api::core::v1::_ContainerStateTerminated_default_instance_._instance,
  &::k8s::io::api::core::v1::_ContainerStateWaiting_default_instance_._instance,
  &::k8s::io::api::core::v1::_ContainerStatus_AllocatedResourcesEntry_DoNotUse_default_instance_._instance,
  &::k8s::io::api::core::v1::_ContainerStatus_default_instance_._instance,
  &::k8s::io::api::core::v1::_DaemonEndpoint_default_instance_._instance,
  &::k8s::io::api::core::v1::_DownwardAPIProjection_default_instance_._instance,
  &::k8s::io::api::core::v1::_DownwardAPIVolumeFile_default_instance_._instance,
  &::k8s::io::api::core::v1::_DownwardAPIVolumeSource_default_instance_._instance,
  &::k8s::io::api::core::v1::_EmptyDirVolumeSource_default_instance_._instance,
  &::k8s::io::api::core::v1::_EndpointAddress_default_instance_._instance,
  &::k8s::io::api::core::v1::_EndpointPort_default_instance_._instance,
  &::k8s::io::api::core::v1::_EndpointSubset_default_instance_._instance,
  &::k8s::io::api::core::v1::_Endpoints_default_instance_._instance,
  &::k8s::io::api::core::v1::_EndpointsList_default_instance_._instance,
  &::k8s::io::api::core::v1::_EnvFromSource_default_instance_._instance,
  &::k8s::io::api::core::v1::_EnvVar_default_instance_._instance,
  &::k8s::io::api::core::v1::_EnvVarSource_default_instance_._instance,
  &::k8s::io::api::core::v1::_EphemeralContainer_default_instance_._instance,
  &::k8s::io::api::core::v1::_EphemeralContainerCommon_default_instance_._instance,
  &::k8s::io::api::core::v1::_EphemeralVolumeSource_default_instance_._instance,
  &::k8s::io::api::core::v1::_Event_default_instance_._instance,
  &::k8s::io::api::core::v1::_EventList_default_instance_._instance,
  &::k8s::io::api::core::v1::_EventSeries_default_instance_._instance,
  &::k8s::io::api::core::v1::_EventSource_default_instance_._instance,
  &::k8s::io::api::core::v1::_ExecAction_default_instance_._instance,
  &::k8s::io::api::core::v1::_FCVolumeSource_default_instance_._instance,
  &::k8s::io::api::core::v1::_FlexPersistentVolumeSource_OptionsEntry_DoNotUse_default_instance_._instance,
  &::k8s::io::api::core::v1::_FlexPersistentVolumeSource_default_instance_._instance,
  &::k8s::io::api::core::v1::_FlexVolumeSource_OptionsEntry_DoNotUse_default_instance_._instance,
  &::k8s::io::api::core::v1::_FlexVolumeSource_default_instance_._instance,
  &::k8s::io::api::core::v1::_FlockerVolumeSource_default_instance_._instance,
  &::k8s::io::api::core::v1::_GCEPersistentDiskVolumeSource_default_instance_._instance,
  &::k8s::io::api::core::v1::_GRPCAction_default_instance_._instance,
  &::k8s::io::api::core::v1::_GitRepoVolumeSource_default_instance_._instance,
  &::k8s::io::api::core::v1::_GlusterfsPersistentVolumeSource_default_instance_._instance,
  &::k8s::io::api::core::v1::_GlusterfsVolumeSource_default_instance_._instance,
  &::k8s::io::api::core::v1::_HTTPGetAction_default_instance_._instance,
  &::k8s::io::api::core::v1::_HTTPHeader_default_instance_._instance,
  &::k8s::io::api::core::v1::_HostAlias_default_instance_._instance,
  &::k8s::io::api::core::v1::_HostIP_default_instance_._instance,
  &::k8s::io::api::core::v1::_HostPathVolumeSource_default_instance_._instance,
  &::k8s::io::api::core::v1::_ISCSIPersistentVolumeSource_default_instance_._instance,
  &::k8s::io::api::core::v1::_ISCSIVolumeSource_default_instance_._instance,
  &::k8s::io::api::core::v1::_KeyToPath_default_instance_._instance,
  &::k8s::io::api::core::v1::_Lifecycle_default_instance_._instance,
  &::k8s::io::api::core::v1::_LifecycleHandler_default_instance_._instance,
  &::k8s::io::api::core::v1::_LimitRange_default_instance_._instance,
  &::k8s::io::api::core::v1::_LimitRangeItem_MaxEntry_DoNotUse_default_instance_._instance,
  &::k8s::io::api::core::v1::_LimitRangeItem_MinEntry_DoNotUse_default_instance_._instance,
  &::k8s::io::api::core::v1::_LimitRangeItem_DefaultEntry_DoNotUse_default_instance_._instance,
  &::k8s::io::api::core::v1::_LimitRangeItem_DefaultRequestEntry_DoNotUse_default_instance_._instance,
  &::k8s::io::api::core::v1::_LimitRangeItem_MaxLimitRequestRatioEntry_DoNotUse_default_instance_._instance,
  &::k8s::io::api::core::v1::_LimitRangeItem_default_instance_._instance,
  &::k8s::io::api::core::v1::_LimitRangeList_default_instance_._instance,
  &::k8s::io::api::core::v1::_LimitRangeSpec_default_instance_._instance,
  &::k8s::io::api::core::v1::_List_default_instance_._instance,
  &::k8s::io::api::core::v1::_LoadBalancerIngress_default_instance_._instance,
  &::k8s::io::api::core::v1::_LoadBalancerStatus_default_instance_._instance,
  &::k8s::io::api::core::v1::_LocalObjectReference_default_instance_._instance,
  &::k8s::io::api::core::v1::_LocalVolumeSource_default_instance_._instance,
  &::k8s::io::api::core::v1::_ModifyVolumeStatus_default_instance_._instance,
  &::k8s::io::api::core::v1::_NFSVolumeSource_default_instance_._instance,
  &::k8s::io::api::core::v1::_Namespace_default_instance_._instance,
  &::k8s::io::api::core::v1::_NamespaceCondition_default_instance_._instance,
  &::k8s::io::api::core::v1::_NamespaceList_default_instance_._instance,
  &::k8s::io::api::core::v1::_NamespaceSpec_default_instance_._instance,
  &::k8s::io::api::core::v1::_NamespaceStatus_default_instance_._instance,
  &::k8s::io::api::core::v1::_Node_default_instance_._instance,
  &::k8s::io::api::core::v1::_NodeAddress_default_instance_._instance,
  &::k8s::io::api::core::v1::_NodeAffinity_default_instance_._instance,
  &::k8s::io::api::core::v1::_NodeCondition_default_instance_._instance,
  &::k8s::io::api::core::v1::_NodeConfigSource_default_instance_._instance,
  &::k8s::io::api::core::v1::_NodeConfigStatus_default_instance_._instance,
  &::k8s::io::api::core::v1::_NodeDaemonEndpoints_default_instance_._instance,
  &::k8s::io::api::core::v1::_NodeList_default_instance_._instance,
  &::k8s::io::api::core::v1::_NodeProxyOptions_default_instance_._instance,
  &::k8s::io::api::core::v1::_NodeResources_CapacityEntry_DoNotUse_default_instance_._instance,
  &::k8s::io::api::core::v1::_NodeResources_default_instance_._instance,
  &::k8s::io::api::core::v1::_NodeSelector_default_instance_._instance,
  &::k8s::io::api::core::v1::_NodeSelectorRequirement_default_instance_._instance,
  &::k8s::io::api::core::v1::_NodeSelectorTerm_default_instance_._instance,
  &::k8s::io::api::core::v1::_NodeSpec_default_instance_._instance,
  &::k8s::io::api::core::v1::_NodeStatus_CapacityEntry_DoNotUse_default_instance_._instance,
  &::k8s::io::api::core::v1::_NodeStatus_AllocatableEntry_DoNotUse_default_instance_._instance,
  &::k8s::io::api::core::v1::_NodeStatus_default_instance_._instance,
  &::k8s::io::api::core::v1::_NodeSystemInfo_default_instance_._instance,
  &::k8s::io::api::core::v1::_ObjectFieldSelector_default_instance_._instance,
  &::k8s::io::api::core::v1::_ObjectReference_default_instance_._instance,
  &::k8s::io::api::core::v1::_PersistentVolume_default_instance_._instance,
  &::k8s::io::api::core::v1::_PersistentVolumeClaim_default_instance_._instance,
  &::k8s::io::api::core::v1::_PersistentVolumeClaimCondition_default_instance_._instance,
  &::k8s::io::api::core::v1::_PersistentVolumeClaimList_default_instance_._instance,
  &::k8s::io::api::core::v1::_PersistentVolumeClaimSpec_default_instance_._instance,
  &::k8s::io::api::core::v1::_PersistentVolumeClaimStatus_CapacityEntry_DoNotUse_default_instance_._instance,
  &::k8s::io::api::core::v1::_PersistentVolumeClaimStatus_AllocatedResourcesEntry_DoNotUse_default_instance_._instance,
  &::k8s::io::api::core::v1::_PersistentVolumeClaimStatus_AllocatedResourceStatusesEntry_DoNotUse_default_instance_._instance,
  &::k8s::io::api::core::v1::_PersistentVolumeClaimStatus_default_instance_._instance,
  &::k8s::io::api::core::v1::_PersistentVolumeClaimTemplate_default_instance_._instance,
  &::k8s::io::api::core::v1::_PersistentVolumeClaimVolumeSource_default_instance_._instance,
  &::k8s::io::api::core::v1::_PersistentVolumeList_default_instance_._instance,
  &::k8s::io::api::core::v1::_PersistentVolumeSource_default_instance_._instance,
  &::k8s::io::api::core::v1::_PersistentVolumeSpec_CapacityEntry_DoNotUse_default_instance_._instance,
  &::k8s::io::api::core::v1::_PersistentVolumeSpec_default_instance_._instance,
  &::k8s::io::api::core::v1::_PersistentVolumeStatus_default_instance_._instance,
  &::k8s::io::api::core::v1::_PhotonPersistentDiskVolumeSource_default_instance_._instance,
  &::k8s::io::api::core::v1::_Pod_default_instance_._instance,
  &::k8s::io::api::core::v1::_PodAffinity_default_instance_._instance,
  &::k8s::io::api::core::v1::_PodAffinityTerm_default_instance_._instance,
  &::k8s::io::api::core::v1::_PodAntiAffinity_default_instance_._instance,
  &::k8s::io::api::core::v1::_PodAttachOptions_default_instance_._instance,
  &::k8s::io::api::core::v1::_PodCondition_default_instance_._instance,
  &::k8s::io::api::core::v1::_PodDNSConfig_default_instance_._instance,
  &::k8s::io::api::core::v1::_PodDNSConfigOption_default_instance_._instance,
  &::k8s::io::api::core::v1::_PodExecOptions_default_instance_._instance,
  &::k8s::io::api::core::v1::_PodIP_default_instance_._instance,
  &::k8s::io::api::core::v1::_PodList_default_instance_._instance,
  &::k8s::io::api::core::v1::_PodLogOptions_default_instance_._instance,
  &::k8s::io::api::core::v1::_PodOS_default_instance_._instance,
  &::k8s::io::api::core::v1::_PodPortForwardOptions_default_instance_._instance,
  &::k8s::io::api::core::v1::_PodProxyOptions_default_instance_._instance,
  &::k8s::io::api::core::v1::_PodReadinessGate_default_instance_._instance,
  &::k8s::io::api::core::v1::_PodResourceClaim_default_instance_._instance,
  &::k8s::io::api::core::v1::_PodResourceClaimStatus_default_instance_._instance,
  &::k8s::io::api::core::v1::_PodSchedulingGate_default_instance_._instance,
  &::k8s::io::api::core::v1::_PodSecurityContext_default_instance_._instance,
  &::k8s::io::api::core::v1::_PodSignature_default_instance_._instance,
  &::k8s::io::api::core::v1::_PodSpec_NodeSelectorEntry_DoNotUse_default_instance_._instance,
  &::k8s::io::api::core::v1::_PodSpec_OverheadEntry_DoNotUse_default_instance_._instance,
  &::k8s::io::api::core::v1::_PodSpec_default_instance_._instance,
  &::k8s::io::api::core::v1::_PodStatus_default_instance_._instance,
  &::k8s::io::api::core::v1::_PodStatusResult_default_instance_._instance,
  &::k8s::io::api::core::v1::_PodTemplate_default_instance_._instance,
  &::k8s::io::api::core::v1::_PodTemplateList_default_instance_._instance,
  &::k8s::io::api::core::v1::_PodTemplateSpec_default_instance_._instance,
  &::k8s::io::api::core::v1::_PortStatus_default_instance_._instance,
  &::k8s::io::api::core::v1::_PortworxVolumeSource_default_instance_._instance,
  &::k8s::io::api::core::v1::_Preconditions_default_instance_._instance,
  &::k8s::io::api::core::v1::_PreferAvoidPodsEntry_default_instance_._instance,
  &::k8s::io::api::core::v1::_PreferredSchedulingTerm_default_instance_._instance,
  &::k8s::io::api::core::v1::_Probe_default_instance_._instance,
  &::k8s::io::api::core::v1::_ProbeHandler_default_instance_._instance,
  &::k8s::io::api::core::v1::_ProjectedVolumeSource_default_instance_._instance,
  &::k8s::io::api::core::v1::_QuobyteVolumeSource_default_instance_._instance,
  &::k8s::io::api::core::v1::_RBDPersistentVolumeSource_default_instance_._instance,
  &::k8s::io::api::core::v1::_RBDVolumeSource_default_instance_._instance,
  &::k8s::io::api::core::v1::_RangeAllocation_default_instance_._instance,
  &::k8s::io::api::core::v1::_ReplicationController_default_instance_._instance,
  &::k8s::io::api::core::v1::_ReplicationControllerCondition_default_instance_._instance,
  &::k8s::io::api::core::v1::_ReplicationControllerList_default_instance_._instance,
  &::k8s::io::api::core::v1::_ReplicationControllerSpec_SelectorEntry_DoNotUse_default_instance_._instance,
  &::k8s::io::api::core::v1::_ReplicationControllerSpec_default_instance_._instance,
  &::k8s::io::api::core::v1::_ReplicationControllerStatus_default_instance_._instance,
  &::k8s::io::api::core::v1::_ResourceClaim_default_instance_._instance,
  &::k8s::io::api::core::v1::_ResourceFieldSelector_default_instance_._instance,
  &::k8s::io::api::core::v1::_ResourceQuota_default_instance_._instance,
  &::k8s::io::api::core::v1::_ResourceQuotaList_default_instance_._instance,
  &::k8s::io::api::core::v1::_ResourceQuotaSpec_HardEntry_DoNotUse_default_instance_._instance,
  &::k8s::io::api::core::v1::_ResourceQuotaSpec_default_instance_._instance,
  &::k8s::io::api::core::v1::_ResourceQuotaStatus_HardEntry_DoNotUse_default_instance_._instance,
  &::k8s::io::api::core::v1::_ResourceQuotaStatus_UsedEntry_DoNotUse_default_instance_._instance,
  &::k8s::io::api::core::v1::_ResourceQuotaStatus_default_instance_._instance,
  &::k8s::io::api::core::v1::_ResourceRequirements_LimitsEntry_DoNotUse_default_instance_._instance,
  &::k8s::io::api::core::v1::_ResourceRequirements_RequestsEntry_DoNotUse_default_instance_._instance,
  &::k8s::io::api::core::v1::_ResourceRequirements_default_instance_._instance,
  &::k8s::io::api::core::v1::_SELinuxOptions_default_instance_._instance,
  &::k8s::io::api::core::v1::_ScaleIOPersistentVolumeSource_default_instance_._instance,
  &::k8s::io::api::core::v1::_ScaleIOVolumeSource_default_instance_._instance,
  &::k8s::io::api::core::v1::_ScopeSelector_default_instance_._instance,
  &::k8s::io::api::core::v1::_ScopedResourceSelectorRequirement_default_instance_._instance,
  &::k8s::io::api::core::v1::_SeccompProfile_default_instance_._instance,
  &::k8s::io::api::core::v1::_Secret_DataEntry_DoNotUse_default_instance_._instance,
  &::k8s::io::api::core::v1::_Secret_StringDataEntry_DoNotUse_default_instance_._instance,
  &::k8s::io::api::core::v1::_Secret_default_instance_._instance,
  &::k8s::io::api::core::v1::_SecretEnvSource_default_instance_._instance,
  &::k8s::io::api::core::v1::_SecretKeySelector_default_instance_._instance,
  &::k8s::io::api::core::v1::_SecretList_default_instance_._instance,
  &::k8s::io::api::core::v1::_SecretProjection_default_instance_._instance,
  &::k8s::io::api::core::v1::_SecretReference_default_instance_._instance,
  &::k8s::io::api::core::v1::_SecretVolumeSource_default_instance_._instance,
  &::k8s::io::api::core::v1::_SecurityContext_default_instance_._instance,
  &::k8s::io::api::core::v1::_SerializedReference_default_instance_._instance,
  &::k8s::io::api::core::v1::_Service_default_instance_._instance,
  &::k8s::io::api::core::v1::_ServiceAccount_default_instance_._instance,
  &::k8s::io::api::core::v1::_ServiceAccountList_default_instance_._instance,
  &::k8s::io::api::core::v1::_ServiceAccountTokenProjection_default_instance_._instance,
  &::k8s::io::api::core::v1::_ServiceList_default_instance_._instance,
  &::k8s::io::api::core::v1::_ServicePort_default_instance_._instance,
  &::k8s::io::api::core::v1::_ServiceProxyOptions_default_instance_._instance,
  &::k8s::io::api::core::v1::_ServiceSpec_SelectorEntry_DoNotUse_default_instance_._instance,
  &::k8s::io::api::core::v1::_ServiceSpec_default_instance_._instance,
  &::k8s::io::api::core::v1::_ServiceStatus_default_instance_._instance,
  &::k8s::io::api::core::v1::_SessionAffinityConfig_default_instance_._instance,
  &::k8s::io::api::core::v1::_SleepAction_default_instance_._instance,
  &::k8s::io::api::core::v1::_StorageOSPersistentVolumeSource_default_instance_._instance,
  &::k8s::io::api::core::v1::_StorageOSVolumeSource_default_instance_._instance,
  &::k8s::io::api::core::v1::_Sysctl_default_instance_._instance,
  &::k8s::io::api::core::v1::_TCPSocketAction_default_instance_._instance,
  &::k8s::io::api::core::v1::_Taint_default_instance_._instance,
  &::k8s::io::api::core::v1::_Toleration_default_instance_._instance,
  &::k8s::io::api::core::v1::_TopologySelectorLabelRequirement_default_instance_._instance,
  &::k8s::io::api::core::v1::_TopologySelectorTerm_default_instance_._instance,
  &::k8s::io::api::core::v1::_TopologySpreadConstraint_default_instance_._instance,
  &::k8s::io::api::core::v1::_TypedLocalObjectReference_default_instance_._instance,
  &::k8s::io::api::core::v1::_TypedObjectReference_default_instance_._instance,
  &::k8s::io::api::core::v1::_Volume_default_instance_._instance,
  &::k8s::io::api::core::v1::_VolumeDevice_default_instance_._instance,
  &::k8s::io::api::core::v1::_VolumeMount_default_instance_._instance,
  &::k8s::io::api::core::v1::_VolumeNodeAffinity_default_instance_._instance,
  &::k8s::io::api::core::v1::_VolumeProjection_default_instance_._instance,
  &::k8s::io::api::core::v1::_VolumeResourceRequirements_LimitsEntry_DoNotUse_default_instance_._instance,
  &::k8s::io::api::core::v1::_VolumeResourceRequirements_RequestsEntry_DoNotUse_default_instance_._instance,
  &::k8s::io::api::core::v1::_VolumeResourceRequirements_default_instance_._instance,
  &::k8s::io::api::core::v1::_VolumeSource_default_instance_._instance,
  &::k8s::io::api::core::v1::_VsphereVirtualDiskVolumeSource_default_instance_._instance,
  &::k8s::io::api::core::v1::_WeightedPodAffinityTerm_default_instance_._instance,
  &::k8s::io::api::core::v1::_WindowsSecurityContextOptions_default_instance_._instance,
};

const char descriptor_table_protodef_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n.staging_src_k8s.io_api_core_v1_generat"
  "ed.proto\022\022k8s.io.api.core.v1\032@staging_sr"
  "c_k8s.io_apimachinery_pkg_api_resource_g"
  "enerated.proto\032@staging_src_k8s.io_apima"
  "chinery_pkg_apis_meta_v1_generated.proto"
  "\032;staging_src_k8s.io_apimachinery_pkg_ru"
  "ntime_generated.proto\032Bstaging_src_k8s.i"
  "o_apimachinery_pkg_runtime_schema_genera"
  "ted.proto\032\?staging_src_k8s.io_apimachine"
  "ry_pkg_util_intstr_generated.proto\"Y\n\tPo"
  "dOrNode\022$\n\003pod\030\001 \002(\0132\027.k8s.io.api.core.v"
  "1.Pod\022&\n\004node\030\002 \002(\0132\030.k8s.io.api.core.v1"
  ".Node\"i\n AWSElasticBlockStoreVolumeSourc"
  "e\022\020\n\010volumeID\030\001 \001(\014\022\016\n\006fsType\030\002 \001(\014\022\021\n\tp"
  "artition\030\003 \001(\005\022\020\n\010readOnly\030\004 \001(\010\"\266\001\n\010Aff"
  "inity\0226\n\014nodeAffinity\030\001 \001(\0132 .k8s.io.api"
  ".core.v1.NodeAffinity\0224\n\013podAffinity\030\002 \001"
  "(\0132\037.k8s.io.api.core.v1.PodAffinity\022<\n\017p"
  "odAntiAffinity\030\003 \001(\0132#.k8s.io.api.core.v"
  "1.PodAntiAffinity\"2\n\016AttachedVolume\022\014\n\004n"
  "ame\030\001 \001(\014\022\022\n\ndevicePath\030\002 \001(\014\"N\n\tAvoidPo"
  "ds\022A\n\017preferAvoidPods\030\001 \003(\0132(.k8s.io.api"
  ".core.v1.PreferAvoidPodsEntry\"\177\n\025AzureDi"
  "skVolumeSource\022\020\n\010diskName\030\001 \001(\014\022\017\n\007disk"
  "URI\030\002 \001(\014\022\023\n\013cachingMode\030\003 \001(\014\022\016\n\006fsType"
  "\030\004 \001(\014\022\020\n\010readOnly\030\005 \001(\010\022\014\n\004kind\030\006 \001(\014\"s"
  "\n\037AzureFilePersistentVolumeSource\022\022\n\nsec"
  "retName\030\001 \001(\014\022\021\n\tshareName\030\002 \001(\014\022\020\n\010read"
  "Only\030\003 \001(\010\022\027\n\017secretNamespace\030\004 \001(\014\"P\n\025A"
  "zureFileVolumeSource\022\022\n\nsecretName\030\001 \001(\014"
  "\022\021\n\tshareName\030\002 \001(\014\022\020\n\010readOnly\030\003 \001(\010\"\202\001"
  "\n\007Binding\022B\n\010metadata\030\001 \001(\01320.k8s.io.api"
  "machinery.pkg.apis.meta.v1.ObjectMeta\0223\n"
  "\006target\030\002 \001(\0132#.k8s.io.api.core.v1.Objec"
  "tReference\"\322\004\n\031CSIPersistentVolumeSource"
  "\022\016\n\006driver\030\001 \001(\014\022\024\n\014volumeHandle\030\002 \001(\014\022\020"
  "\n\010readOnly\030\003 \001(\010\022\016\n\006fsType\030\004 \001(\014\022]\n\020volu"
  "meAttributes\030\005 \003(\0132C.k8s.io.api.core.v1."
  "CSIPersistentVolumeSource.VolumeAttribut"
  "esEntry\022G\n\032controllerPublishSecretRef\030\006 "
  "\001(\0132#.k8s.io.api.core.v1.SecretReference"
  "\022\?\n\022nodeStageSecretRef\030\007 \001(\0132#.k8s.io.ap"
  "i.core.v1.SecretReference\022A\n\024nodePublish"
  "SecretRef\030\010 \001(\0132#.k8s.io.api.core.v1.Sec"
  "retReference\022F\n\031controllerExpandSecretRe"
  "f\030\t \001(\0132#.k8s.io.api.core.v1.SecretRefer"
  "ence\022@\n\023nodeExpandSecretRef\030\n \001(\0132#.k8s."
  "io.api.core.v1.SecretReference\0327\n\025Volume"
  "AttributesEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 "
  "\001(\t:\0028\001\"\231\002\n\017CSIVolumeSource\022\016\n\006driver\030\001 "
  "\001(\014\022\020\n\010readOnly\030\002 \001(\010\022\016\n\006fsType\030\003 \001(\014\022S\n"
  "\020volumeAttributes\030\004 \003(\01329.k8s.io.api.cor"
  "e.v1.CSIVolumeSource.VolumeAttributesEnt"
  "ry\022F\n\024nodePublishSecretRef\030\005 \001(\0132(.k8s.i"
  "o.api.core.v1.LocalObjectReference\0327\n\025Vo"
  "lumeAttributesEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005valu"
  "e\030\002 \001(\t:\0028\001\")\n\014Capabilities\022\013\n\003add\030\001 \003(\t"
  "\022\014\n\004drop\030\002 \003(\t\"\252\001\n\034CephFSPersistentVolum"
  "eSource\022\020\n\010monitors\030\001 \003(\t\022\014\n\004path\030\002 \001(\014\022"
  "\014\n\004user\030\003 \001(\014\022\022\n\nsecretFile\030\004 \001(\014\0226\n\tsec"
  "retRef\030\005 \001(\0132#.k8s.io.api.core.v1.Secret"
  "Reference\022\020\n\010readOnly\030\006 \001(\010\"\245\001\n\022CephFSVo"
  "lumeSource\022\020\n\010monitors\030\001 \003(\t\022\014\n\004path\030\002 \001"
  "(\014\022\014\n\004user\030\003 \001(\014\022\022\n\nsecretFile\030\004 \001(\014\022;\n\t"
  "secretRef\030\005 \001(\0132(.k8s.io.api.core.v1.Loc"
  "alObjectReference\022\020\n\010readOnly\030\006 \001(\010\"\212\001\n\034"
  "CinderPersistentVolumeSource\022\020\n\010volumeID"
  "\030\001 \001(\014\022\016\n\006fsType\030\002 \001(\014\022\020\n\010readOnly\030\003 \001(\010"
  "\0226\n\tsecretRef\030\004 \001(\0132#.k8s.io.api.core.v1"
  ".SecretReference\"\205\001\n\022CinderVolumeSource\022"
  "\020\n\010volumeID\030\001 \001(\014\022\016\n\006fsType\030\002 \001(\014\022\020\n\010rea"
  "dOnly\030\003 \001(\010\022;\n\tsecretRef\030\004 \001(\0132(.k8s.io."
  "api.core.v1.LocalObjectReference\"K\n\013Clai"
  "mSource\022\031\n\021resourceClaimName\030\001 \001(\014\022!\n\031re"
  "sourceClaimTemplateName\030\002 \001(\014\"(\n\016ClientI"
  "PConfig\022\026\n\016timeoutSeconds\030\001 \001(\005\"\254\001\n\034Clus"
  "terTrustBundleProjection\022\014\n\004name\030\001 \001(\014\022\022"
  "\n\nsignerName\030\002 \001(\014\022J\n\rlabelSelector\030\003 \001("
  "\01323.k8s.io.apimachinery.pkg.apis.meta.v1"
  ".LabelSelector\022\020\n\010optional\030\005 \001(\010\022\014\n\004path"
  "\030\004 \001(\014\"R\n\022ComponentCondition\022\014\n\004type\030\001 \001"
  "(\014\022\016\n\006status\030\002 \001(\014\022\017\n\007message\030\003 \001(\014\022\r\n\005e"
  "rror\030\004 \001(\014\"\221\001\n\017ComponentStatus\022B\n\010metada"
  "ta\030\001 \001(\01320.k8s.io.apimachinery.pkg.apis."
  "meta.v1.ObjectMeta\022:\n\nconditions\030\002 \003(\0132&"
  ".k8s.io.api.core.v1.ComponentCondition\"\213"
  "\001\n\023ComponentStatusList\022@\n\010metadata\030\001 \001(\013"
  "2..k8s.io.apimachinery.pkg.apis.meta.v1."
  "ListMeta\0222\n\005items\030\002 \003(\0132#.k8s.io.api.cor"
  "e.v1.ComponentStatus\"\274\002\n\tConfigMap\022B\n\010me"
  "tadata\030\001 \001(\01320.k8s.io.apimachinery.pkg.a"
  "pis.meta.v1.ObjectMeta\022\021\n\timmutable\030\004 \001("
  "\010\0225\n\004data\030\002 \003(\0132\'.k8s.io.api.core.v1.Con"
  "figMap.DataEntry\022A\n\nbinaryData\030\003 \003(\0132-.k"
  "8s.io.api.core.v1.ConfigMap.BinaryDataEn"
  "try\032+\n\tDataEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002"
  " \001(\t:\0028\001\0321\n\017BinaryDataEntry\022\013\n\003key\030\001 \001(\t"
  "\022\r\n\005value\030\002 \001(\014:\0028\001\"n\n\022ConfigMapEnvSourc"
  "e\022F\n\024localObjectReference\030\001 \001(\0132(.k8s.io"
  ".api.core.v1.LocalObjectReference\022\020\n\010opt"
  "ional\030\002 \001(\010\"}\n\024ConfigMapKeySelector\022F\n\024l"
  "ocalObjectReference\030\001 \001(\0132(.k8s.io.api.c"
  "ore.v1.LocalObjectReference\022\013\n\003key\030\002 \001(\014"
  "\022\020\n\010optional\030\003 \001(\010\"\177\n\rConfigMapList\022@\n\010m"
  "etadata\030\001 \001(\0132..k8s.io.apimachinery.pkg."
  "apis.meta.v1.ListMeta\022,\n\005items\030\002 \003(\0132\035.k"
  "8s.io.api.core.v1.ConfigMap\"|\n\031ConfigMap"
  "NodeConfigSource\022\021\n\tnamespace\030\001 \001(\014\022\014\n\004n"
  "ame\030\002 \001(\014\022\013\n\003uid\030\003 \001(\014\022\027\n\017resourceVersio"
  "n\030\004 \001(\014\022\030\n\020kubeletConfigKey\030\005 \001(\014\"\235\001\n\023Co"
  "nfigMapProjection\022F\n\024localObjectReferenc"
  "e\030\001 \001(\0132(.k8s.io.api.core.v1.LocalObject"
  "Reference\022,\n\005items\030\002 \003(\0132\035.k8s.io.api.co"
  "re.v1.KeyToPath\022\020\n\010optional\030\004 \001(\010\"\264\001\n\025Co"
  "nfigMapVolumeSource\022F\n\024localObjectRefere"
  "nce\030\001 \001(\0132(.k8s.io.api.core.v1.LocalObje"
  "ctReference\022,\n\005items\030\002 \003(\0132\035.k8s.io.api."
  "core.v1.KeyToPath\022\023\n\013defaultMode\030\003 \001(\005\022\020"
  "\n\010optional\030\004 \001(\010\"\377\006\n\tContainer\022\014\n\004name\030\001"
  " \001(\014\022\r\n\005image\030\002 \001(\014\022\017\n\007command\030\003 \003(\t\022\014\n\004"
  "args\030\004 \003(\t\022\022\n\nworkingDir\030\005 \001(\014\0220\n\005ports\030"
  "\006 \003(\0132!.k8s.io.api.core.v1.ContainerPort"
  "\0222\n\007envFrom\030\023 \003(\0132!.k8s.io.api.core.v1.E"
  "nvFromSource\022\'\n\003env\030\007 \003(\0132\032.k8s.io.api.c"
  "ore.v1.EnvVar\022;\n\tresources\030\010 \001(\0132(.k8s.i"
  "o.api.core.v1.ResourceRequirements\022\?\n\014re"
  "sizePolicy\030\027 \003(\0132).k8s.io.api.core.v1.Co"
  "ntainerResizePolicy\022\025\n\rrestartPolicy\030\030 \001"
  "(\014\0225\n\014volumeMounts\030\t \003(\0132\037.k8s.io.api.co"
  "re.v1.VolumeMount\0227\n\rvolumeDevices\030\025 \003(\013"
  "2 .k8s.io.api.core.v1.VolumeDevice\0220\n\rli"
  "venessProbe\030\n \001(\0132\031.k8s.io.api.core.v1.P"
  "robe\0221\n\016readinessProbe\030\013 \001(\0132\031.k8s.io.ap"
  "i.core.v1.Probe\022/\n\014startupProbe\030\026 \001(\0132\031."
  "k8s.io.api.core.v1.Probe\0220\n\tlifecycle\030\014 "
  "\001(\0132\035.k8s.io.api.core.v1.Lifecycle\022\036\n\026te"
  "rminationMessagePath\030\r \001(\014\022 \n\030terminatio"
  "nMessagePolicy\030\024 \001(\014\022\027\n\017imagePullPolicy\030"
  "\016 \001(\014\022<\n\017securityContext\030\017 \001(\0132#.k8s.io."
  "api.core.v1.SecurityContext\022\r\n\005stdin\030\020 \001"
  "(\010\022\021\n\tstdinOnce\030\021 \001(\010\022\013\n\003tty\030\022 \001(\010\"2\n\016Co"
  "ntainerImage\022\r\n\005names\030\001 \003(\t\022\021\n\tsizeBytes"
  "\030\002 \001(\003\"h\n\rContainerPort\022\014\n\004name\030\001 \001(\014\022\020\n"
  "\010hostPort\030\002 \001(\005\022\025\n\rcontainerPort\030\003 \001(\005\022\020"
  "\n\010protocol\030\004 \001(\014\022\016\n\006hostIP\030\005 \001(\014\"D\n\025Cont"
  "ainerResizePolicy\022\024\n\014resourceName\030\001 \001(\014\022"
  "\025\n\rrestartPolicy\030\002 \001(\014\"\312\001\n\016ContainerStat"
  "e\022:\n\007waiting\030\001 \001(\0132).k8s.io.api.core.v1."
  "ContainerStateWaiting\022:\n\007running\030\002 \001(\0132)"
  ".k8s.io.api.core.v1.ContainerStateRunnin"
  "g\022@\n\nterminated\030\003 \001(\0132,.k8s.io.api.core."
  "v1.ContainerStateTerminated\"V\n\025Container"
  "StateRunning\022=\n\tstartedAt\030\001 \001(\0132*.k8s.io"
  ".apimachinery.pkg.apis.meta.v1.Time\"\361\001\n\030"
  "ContainerStateTerminated\022\020\n\010exitCode\030\001 \001"
  "(\005\022\016\n\006signal\030\002 \001(\005\022\016\n\006reason\030\003 \001(\014\022\017\n\007me"
  "ssage\030\004 \001(\014\022=\n\tstartedAt\030\005 \001(\0132*.k8s.io."
  "apimachinery.pkg.apis.meta.v1.Time\022>\n\nfi"
  "nishedAt\030\006 \001(\0132*.k8s.io.apimachinery.pkg"
  ".apis.meta.v1.Time\022\023\n\013containerID\030\007 \001(\014\""
  "8\n\025ContainerStateWaiting\022\016\n\006reason\030\001 \001(\014"
  "\022\017\n\007message\030\002 \001(\014\"\365\003\n\017ContainerStatus\022\014\n"
  "\004name\030\001 \001(\014\0221\n\005state\030\002 \001(\0132\".k8s.io.api."
  "core.v1.ContainerState\0225\n\tlastState\030\003 \001("
  "\0132\".k8s.io.api.core.v1.ContainerState\022\r\n"
  "\005ready\030\004 \001(\010\022\024\n\014restartCount\030\005 \001(\005\022\r\n\005im"
  "age\030\006 \001(\014\022\017\n\007imageID\030\007 \001(\014\022\023\n\013containerI"
  "D\030\010 \001(\014\022\017\n\007started\030\t \001(\010\022W\n\022allocatedRes"
  "ources\030\n \003(\0132;.k8s.io.api.core.v1.Contai"
  "nerStatus.AllocatedResourcesEntry\022;\n\tres"
  "ources\030\013 \001(\0132(.k8s.io.api.core.v1.Resour"
  "ceRequirements\032i\n\027AllocatedResourcesEntr"
  "y\022\013\n\003key\030\001 \001(\t\022=\n\005value\030\002 \001(\0132..k8s.io.a"
  "pimachinery.pkg.api.resource.Quantity:\0028"
  "\001\"\036\n\016DaemonEndpoint\022\014\n\004Port\030\001 \001(\005\"Q\n\025Dow"
  "nwardAPIProjection\0228\n\005items\030\001 \003(\0132).k8s."
  "io.api.core.v1.DownwardAPIVolumeFile\"\263\001\n"
  "\025DownwardAPIVolumeFile\022\014\n\004path\030\001 \001(\014\0229\n\010"
  "fieldRef\030\002 \001(\0132\'.k8s.io.api.core.v1.Obje"
  "ctFieldSelector\022C\n\020resourceFieldRef\030\003 \001("
  "\0132).k8s.io.api.core.v1.ResourceFieldSele"
  "ctor\022\014\n\004mode\030\004 \001(\005\"h\n\027DownwardAPIVolumeS"
  "ource\0228\n\005items\030\001 \003(\0132).k8s.io.api.core.v"
  "1.DownwardAPIVolumeFile\022\023\n\013defaultMode\030\002"
  " \001(\005\"i\n\024EmptyDirVolumeSource\022\016\n\006medium\030\001"
  " \001(\014\022A\n\tsizeLimit\030\002 \001(\0132..k8s.io.apimach"
  "inery.pkg.api.resource.Quantity\"y\n\017Endpo"
  "intAddress\022\n\n\002ip\030\001 \001(\014\022\020\n\010hostname\030\003 \001(\014"
  "\022\020\n\010nodeName\030\004 \001(\014\0226\n\ttargetRef\030\002 \001(\0132#."
  "k8s.io.api.core.v1.ObjectReference\"Q\n\014En"
  "dpointPort\022\014\n\004name\030\001 \001(\014\022\014\n\004port\030\002 \001(\005\022\020"
  "\n\010protocol\030\003 \001(\014\022\023\n\013appProtocol\030\004 \001(\014\"\271\001"
  "\n\016EndpointSubset\0226\n\taddresses\030\001 \003(\0132#.k8"
  "s.io.api.core.v1.EndpointAddress\022>\n\021notR"
  "eadyAddresses\030\002 \003(\0132#.k8s.io.api.core.v1"
  ".EndpointAddress\022/\n\005ports\030\003 \003(\0132 .k8s.io"
  ".api.core.v1.EndpointPort\"\204\001\n\tEndpoints\022"
  "B\n\010metadata\030\001 \001(\01320.k8s.io.apimachinery."
  "pkg.apis.meta.v1.ObjectMeta\0223\n\007subsets\030\002"
  " \003(\0132\".k8s.io.api.core.v1.EndpointSubset"
  "\"\177\n\rEndpointsList\022@\n\010metadata\030\001 \001(\0132..k8"
  "s.io.apimachinery.pkg.apis.meta.v1.ListM"
  "eta\022,\n\005items\030\002 \003(\0132\035.k8s.io.api.core.v1."
  "Endpoints\"\225\001\n\rEnvFromSource\022\016\n\006prefix\030\001 "
  "\001(\014\022<\n\014configMapRef\030\002 \001(\0132&.k8s.io.api.c"
  "ore.v1.ConfigMapEnvSource\0226\n\tsecretRef\030\003"
  " \001(\0132#.k8s.io.api.core.v1.SecretEnvSourc"
  "e\"Z\n\006EnvVar\022\014\n\004name\030\001 \001(\014\022\r\n\005value\030\002 \001(\014"
  "\0223\n\tvalueFrom\030\003 \001(\0132 .k8s.io.api.core.v1"
  ".EnvVarSource\"\216\002\n\014EnvVarSource\0229\n\010fieldR"
  "ef\030\001 \001(\0132\'.k8s.io.api.core.v1.ObjectFiel"
  "dSelector\022C\n\020resourceFieldRef\030\002 \001(\0132).k8"
  "s.io.api.core.v1.ResourceFieldSelector\022A"
  "\n\017configMapKeyRef\030\003 \001(\0132(.k8s.io.api.cor"
  "e.v1.ConfigMapKeySelector\022;\n\014secretKeyRe"
  "f\030\004 \001(\0132%.k8s.io.api.core.v1.SecretKeySe"
  "lector\"\201\001\n\022EphemeralContainer\022N\n\030ephemer"
  "alContainerCommon\030\001 \001(\0132,.k8s.io.api.cor"
  "e.v1.EphemeralContainerCommon\022\033\n\023targetC"
  "ontainerName\030\002 \001(\014\"\216\007\n\030EphemeralContaine"
  "rCommon\022\014\n\004name\030\001 \001(\014\022\r\n\005image\030\002 \001(\014\022\017\n\007"
  "command\030\003 \003(\t\022\014\n\004args\030\004 \003(\t\022\022\n\nworkingDi"
  "r\030\005 \001(\014\0220\n\005ports\030\006 \003(\0132!.k8s.io.api.core"
  ".v1.ContainerPort\0222\n\007envFrom\030\023 \003(\0132!.k8s"
  ".io.api.core.v1.EnvFromSource\022\'\n\003env\030\007 \003"
  "(\0132\032.k8s.io.api.core.v1.EnvVar\022;\n\tresour"
  "ces\030\010 \001(\0132(.k8s.io.api.core.v1.ResourceR"
  "equirements\022\?\n\014resizePolicy\030\027 \003(\0132).k8s."
  "io.api.core.v1.ContainerResizePolicy\022\025\n\r"
  "restartPolicy\030\030 \001(\014\0225\n\014volumeMounts\030\t \003("
  "\0132\037.k8s.io.api.core.v1.VolumeMount\0227\n\rvo"
  "lumeDevices\030\025 \003(\0132 .k8s.io.api.core.v1.V"
  "olumeDevice\0220\n\rlivenessProbe\030\n \001(\0132\031.k8s"
  ".io.api.core.v1.Probe\0221\n\016readinessProbe\030"
  "\013 \001(\0132\031.k8s.io.api.core.v1.Probe\022/\n\014star"
  "tupProbe\030\026 \001(\0132\031.k8s.io.api.core.v1.Prob"
  "e\0220\n\tlifecycle\030\014 \001(\0132\035.k8s.io.api.core.v"
  "1.Lifecycle\022\036\n\026terminationMessagePath\030\r "
  "\001(\014\022 \n\030terminationMessagePolicy\030\024 \001(\014\022\027\n"
  "\017imagePullPolicy\030\016 \001(\014\022<\n\017securityContex"
  "t\030\017 \001(\0132#.k8s.io.api.core.v1.SecurityCon"
  "text\022\r\n\005stdin\030\020 \001(\010\022\021\n\tstdinOnce\030\021 \001(\010\022\013"
  "\n\003tty\030\022 \001(\010\"g\n\025EphemeralVolumeSource\022N\n\023"
  "volumeClaimTemplate\030\001 \001(\01321.k8s.io.api.c"
  "ore.v1.PersistentVolumeClaimTemplate\"\360\004\n"
  "\005Event\022B\n\010metadata\030\001 \001(\01320.k8s.io.apimac"
  "hinery.pkg.apis.meta.v1.ObjectMeta\022;\n\016in"
  "volvedObject\030\002 \001(\0132#.k8s.io.api.core.v1."
  "ObjectReference\022\016\n\006reason\030\003 \001(\014\022\017\n\007messa"
  "ge\030\004 \001(\014\022/\n\006source\030\005 \001(\0132\037.k8s.io.api.co"
  "re.v1.EventSource\022B\n\016firstTimestamp\030\006 \001("
  "\0132*.k8s.io.apimachinery.pkg.apis.meta.v1"
  ".Time\022A\n\rlastTimestamp\030\007 \001(\0132*.k8s.io.ap"
  "imachinery.pkg.apis.meta.v1.Time\022\r\n\005coun"
  "t\030\010 \001(\005\022\014\n\004type\030\t \001(\014\022B\n\teventTime\030\n \001(\013"
  "2/.k8s.io.apimachinery.pkg.apis.meta.v1."
  "MicroTime\022/\n\006series\030\013 \001(\0132\037.k8s.io.api.c"
  "ore.v1.EventSeries\022\016\n\006action\030\014 \001(\014\0224\n\007re"
  "lated\030\r \001(\0132#.k8s.io.api.core.v1.ObjectR"
  "eference\022\032\n\022reportingComponent\030\016 \001(\014\022\031\n\021"
  "reportingInstance\030\017 \001(\014\"w\n\tEventList\022@\n\010"
  "metadata\030\001 \001(\0132..k8s.io.apimachinery.pkg"
  ".apis.meta.v1.ListMeta\022(\n\005items\030\002 \003(\0132\031."
  "k8s.io.api.core.v1.Event\"g\n\013EventSeries\022"
  "\r\n\005count\030\001 \001(\005\022I\n\020lastObservedTime\030\002 \001(\013"
  "2/.k8s.io.apimachinery.pkg.apis.meta.v1."
  "MicroTime\".\n\013EventSource\022\021\n\tcomponent\030\001 "
  "\001(\014\022\014\n\004host\030\002 \001(\014\"\035\n\nExecAction\022\017\n\007comma"
  "nd\030\001 \003(\t\"b\n\016FCVolumeSource\022\022\n\ntargetWWNs"
  "\030\001 \003(\t\022\013\n\003lun\030\002 \001(\005\022\016\n\006fsType\030\003 \001(\014\022\020\n\010r"
  "eadOnly\030\004 \001(\010\022\r\n\005wwids\030\005 \003(\t\"\204\002\n\032FlexPer"
  "sistentVolumeSource\022\016\n\006driver\030\001 \001(\014\022\016\n\006f"
  "sType\030\002 \001(\014\0226\n\tsecretRef\030\003 \001(\0132#.k8s.io."
  "api.core.v1.SecretReference\022\020\n\010readOnly\030"
  "\004 \001(\010\022L\n\007options\030\005 \003(\0132;.k8s.io.api.core"
  ".v1.FlexPersistentVolumeSource.OptionsEn"
  "try\032.\n\014OptionsEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005valu"
  "e\030\002 \001(\t:\0028\001\"\365\001\n\020FlexVolumeSource\022\016\n\006driv"
  "er\030\001 \001(\014\022\016\n\006fsType\030\002 \001(\014\022;\n\tsecretRef\030\003 "
  "\001(\0132(.k8s.io.api.core.v1.LocalObjectRefe"
  "rence\022\020\n\010readOnly\030\004 \001(\010\022B\n\007options\030\005 \003(\013"
  "21.k8s.io.api.core.v1.FlexVolumeSource.O"
  "ptionsEntry\032.\n\014OptionsEntry\022\013\n\003key\030\001 \001(\t"
  "\022\r\n\005value\030\002 \001(\t:\0028\001\"\?\n\023FlockerVolumeSour"
  "ce\022\023\n\013datasetName\030\001 \001(\014\022\023\n\013datasetUUID\030\002"
  " \001(\014\"d\n\035GCEPersistentDiskVolumeSource\022\016\n"
  "\006pdName\030\001 \001(\014\022\016\n\006fsType\030\002 \001(\014\022\021\n\tpartiti"
  "on\030\003 \001(\005\022\020\n\010readOnly\030\004 \001(\010\"+\n\nGRPCAction"
  "\022\014\n\004port\030\001 \001(\005\022\017\n\007service\030\002 \001(\014\"N\n\023GitRe"
  "poVolumeSource\022\022\n\nrepository\030\001 \001(\014\022\020\n\010re"
  "vision\030\002 \001(\014\022\021\n\tdirectory\030\003 \001(\014\"p\n\037Glust"
  "erfsPersistentVolumeSource\022\021\n\tendpoints\030"
  "\001 \001(\014\022\014\n\004path\030\002 \001(\014\022\020\n\010readOnly\030\003 \001(\010\022\032\n"
  "\022endpointsNamespace\030\004 \001(\014\"J\n\025GlusterfsVo"
  "lumeSource\022\021\n\tendpoints\030\001 \001(\014\022\014\n\004path\030\002 "
  "\001(\014\022\020\n\010readOnly\030\003 \001(\010\"\260\001\n\rHTTPGetAction\022"
  "\014\n\004path\030\001 \001(\014\022>\n\004port\030\002 \001(\01320.k8s.io.api"
  "machinery.pkg.util.intstr.IntOrString\022\014\n"
  "\004host\030\003 \001(\014\022\016\n\006scheme\030\004 \001(\014\0223\n\013httpHeade"
  "rs\030\005 \003(\0132\036.k8s.io.api.core.v1.HTTPHeader"
  "\")\n\nHTTPHeader\022\014\n\004name\030\001 \001(\014\022\r\n\005value\030\002 "
  "\001(\014\"*\n\tHostAlias\022\n\n\002ip\030\001 \001(\014\022\021\n\thostname"
  "s\030\002 \003(\t\"\024\n\006HostIP\022\n\n\002ip\030\001 \001(\014\"2\n\024HostPat"
  "hVolumeSource\022\014\n\004path\030\001 \001(\014\022\014\n\004type\030\002 \001("
  "\014\"\233\002\n\033ISCSIPersistentVolumeSource\022\024\n\014tar"
  "getPortal\030\001 \001(\014\022\013\n\003iqn\030\002 \001(\014\022\013\n\003lun\030\003 \001("
  "\005\022\026\n\016iscsiInterface\030\004 \001(\014\022\016\n\006fsType\030\005 \001("
  "\014\022\020\n\010readOnly\030\006 \001(\010\022\017\n\007portals\030\007 \003(\t\022\031\n\021"
  "chapAuthDiscovery\030\010 \001(\010\022\027\n\017chapAuthSessi"
  "on\030\013 \001(\010\0226\n\tsecretRef\030\n \001(\0132#.k8s.io.api"
  ".core.v1.SecretReference\022\025\n\rinitiatorNam"
  "e\030\014 \001(\014\"\226\002\n\021ISCSIVolumeSource\022\024\n\014targetP"
  "ortal\030\001 \001(\014\022\013\n\003iqn\030\002 \001(\014\022\013\n\003lun\030\003 \001(\005\022\026\n"
  "\016iscsiInterface\030\004 \001(\014\022\016\n\006fsType\030\005 \001(\014\022\020\n"
  "\010readOnly\030\006 \001(\010\022\017\n\007portals\030\007 \003(\t\022\031\n\021chap"
  "AuthDiscovery\030\010 \001(\010\022\027\n\017chapAuthSession\030\013"
  " \001(\010\022;\n\tsecretRef\030\n \001(\0132(.k8s.io.api.cor"
  "e.v1.LocalObjectReference\022\025\n\rinitiatorNa"
  "me\030\014 \001(\014\"4\n\tKeyToPath\022\013\n\003key\030\001 \001(\014\022\014\n\004pa"
  "th\030\002 \001(\014\022\014\n\004mode\030\003 \001(\005\"{\n\tLifecycle\0227\n\tp"
  "ostStart\030\001 \001(\0132$.k8s.io.api.core.v1.Life"
  "cycleHandler\0225\n\007preStop\030\002 \001(\0132$.k8s.io.a"
  "pi.core.v1.LifecycleHandler\"\334\001\n\020Lifecycl"
  "eHandler\022,\n\004exec\030\001 \001(\0132\036.k8s.io.api.core"
  ".v1.ExecAction\0222\n\007httpGet\030\002 \001(\0132!.k8s.io"
  ".api.core.v1.HTTPGetAction\0226\n\ttcpSocket\030"
  "\003 \001(\0132#.k8s.io.api.core.v1.TCPSocketActi"
  "on\022.\n\005sleep\030\004 \001(\0132\037.k8s.io.api.core.v1.S"
  "leepAction\"\202\001\n\nLimitRange\022B\n\010metadata\030\001 "
  "\001(\01320.k8s.io.apimachinery.pkg.apis.meta."
  "v1.ObjectMeta\0220\n\004spec\030\002 \001(\0132\".k8s.io.api"
  ".core.v1.LimitRangeSpec\"\354\006\n\016LimitRangeIt"
  "em\022\014\n\004type\030\001 \001(\014\0228\n\003max\030\002 \003(\0132+.k8s.io.a"
  "pi.core.v1.LimitRangeItem.MaxEntry\0228\n\003mi"
  "n\030\003 \003(\0132+.k8s.io.api.core.v1.LimitRangeI"
  "tem.MinEntry\022@\n\007default\030\004 \003(\0132/.k8s.io.a"
  "pi.core.v1.LimitRangeItem.DefaultEntry\022N"
  "\n\016defaultRequest\030\005 \003(\01326.k8s.io.api.core"
  ".v1.LimitRangeItem.DefaultRequestEntry\022Z"
  "\n\024maxLimitRequestRatio\030\006 \003(\0132<.k8s.io.ap"
  "i.core.v1.LimitRangeItem.MaxLimitRequest"
  "RatioEntry\032Z\n\010MaxEntry\022\013\n\003key\030\001 \001(\t\022=\n\005v"
  "alue\030\002 \001(\0132..k8s.io.apimachinery.pkg.api"
  ".resource.Quantity:\0028\001\032Z\n\010MinEntry\022\013\n\003ke"
  "y\030\001 \001(\t\022=\n\005value\030\002 \001(\0132..k8s.io.apimachi"
  "nery.pkg.api.resource.Quantity:\0028\001\032^\n\014De"
  "faultEntry\022\013\n\003key\030\001 \001(\t\022=\n\005value\030\002 \001(\0132."
  ".k8s.io.apimachinery.pkg.api.resource.Qu"
  "antity:\0028\001\032e\n\023DefaultRequestEntry\022\013\n\003key"
  "\030\001 \001(\t\022=\n\005value\030\002 \001(\0132..k8s.io.apimachin"
  "ery.pkg.api.resource.Quantity:\0028\001\032k\n\031Max"
  "LimitRequestRatioEntry\022\013\n\003key\030\001 \001(\t\022=\n\005v"
  "alue\030\002 \001(\0132..k8s.io.apimachinery.pkg.api"
  ".resource.Quantity:\0028\001\"\201\001\n\016LimitRangeLis"
  "t\022@\n\010metadata\030\001 \001(\0132..k8s.io.apimachiner"
  "y.pkg.apis.meta.v1.ListMeta\022-\n\005items\030\002 \003"
  "(\0132\036.k8s.io.api.core.v1.LimitRange\"D\n\016Li"
  "mitRangeSpec\0222\n\006limits\030\001 \003(\0132\".k8s.io.ap"
  "i.core.v1.LimitRangeItem\"\206\001\n\004List\022@\n\010met"
  "adata\030\001 \001(\0132..k8s.io.apimachinery.pkg.ap"
  "is.meta.v1.ListMeta\022<\n\005items\030\002 \003(\0132-.k8s"
  ".io.apimachinery.pkg.runtime.RawExtensio"
  "n\"r\n\023LoadBalancerIngress\022\n\n\002ip\030\001 \001(\014\022\020\n\010"
  "hostname\030\002 \001(\014\022\016\n\006ipMode\030\003 \001(\014\022-\n\005ports\030"
  "\004 \003(\0132\036.k8s.io.api.core.v1.PortStatus\"N\n"
  "\022LoadBalancerStatus\0228\n\007ingress\030\001 \003(\0132\'.k"
  "8s.io.api.core.v1.LoadBalancerIngress\"$\n"
  "\024LocalObjectReference\022\014\n\004name\030\001 \001(\014\"1\n\021L"
  "ocalVolumeSource\022\014\n\004path\030\001 \001(\014\022\016\n\006fsType"
  "\030\002 \001(\014\"M\n\022ModifyVolumeStatus\022\'\n\037targetVo"
  "lumeAttributesClassName\030\001 \001(\014\022\016\n\006status\030"
  "\002 \001(\014\"A\n\017NFSVolumeSource\022\016\n\006server\030\001 \001(\014"
  "\022\014\n\004path\030\002 \001(\014\022\020\n\010readOnly\030\003 \001(\010\"\265\001\n\tNam"
  "espace\022B\n\010metadata\030\001 \001(\01320.k8s.io.apimac"
  "hinery.pkg.apis.meta.v1.ObjectMeta\022/\n\004sp"
  "ec\030\002 \001(\0132!.k8s.io.api.core.v1.NamespaceS"
  "pec\0223\n\006status\030\003 \001(\0132#.k8s.io.api.core.v1"
  ".NamespaceStatus\"\233\001\n\022NamespaceCondition\022"
  "\014\n\004type\030\001 \001(\014\022\016\n\006status\030\002 \001(\014\022F\n\022lastTra"
  "nsitionTime\030\004 \001(\0132*.k8s.io.apimachinery."
  "pkg.apis.meta.v1.Time\022\016\n\006reason\030\005 \001(\014\022\017\n"
  "\007message\030\006 \001(\014\"\177\n\rNamespaceList\022@\n\010metad"
  "ata\030\001 \001(\0132..k8s.io.apimachinery.pkg.apis"
  ".meta.v1.ListMeta\022,\n\005items\030\002 \003(\0132\035.k8s.i"
  "o.api.core.v1.Namespace\"#\n\rNamespaceSpec"
  "\022\022\n\nfinalizers\030\001 \003(\t\"\\\n\017NamespaceStatus\022"
  "\r\n\005phase\030\001 \001(\014\022:\n\nconditions\030\002 \003(\0132&.k8s"
  ".io.api.core.v1.NamespaceCondition\"\246\001\n\004N"
  "ode\022B\n\010metadata\030\001 \001(\01320.k8s.io.apimachin"
  "ery.pkg.apis.meta.v1.ObjectMeta\022*\n\004spec\030"
  "\002 \001(\0132\034.k8s.io.api.core.v1.NodeSpec\022.\n\006s"
  "tatus\030\003 \001(\0132\036.k8s.io.api.core.v1.NodeSta"
  "tus\",\n\013NodeAddress\022\014\n\004type\030\001 \001(\014\022\017\n\007addr"
  "ess\030\002 \001(\014\"\316\001\n\014NodeAffinity\022X\n.requiredDu"
  "ringSchedulingIgnoredDuringExecution\030\001 \001"
  "(\0132 .k8s.io.api.core.v1.NodeSelector\022d\n/"
  "preferredDuringSchedulingIgnoredDuringEx"
  "ecution\030\002 \003(\0132+.k8s.io.api.core.v1.Prefe"
  "rredSchedulingTerm\"\335\001\n\rNodeCondition\022\014\n\004"
  "type\030\001 \001(\014\022\016\n\006status\030\002 \001(\014\022E\n\021lastHeartb"
  "eatTime\030\003 \001(\0132*.k8s.io.apimachinery.pkg."
  "apis.meta.v1.Time\022F\n\022lastTransitionTime\030"
  "\004 \001(\0132*.k8s.io.apimachinery.pkg.apis.met"
  "a.v1.Time\022\016\n\006reason\030\005 \001(\014\022\017\n\007message\030\006 \001"
  "(\014\"T\n\020NodeConfigSource\022@\n\tconfigMap\030\002 \001("
  "\0132-.k8s.io.api.core.v1.ConfigMapNodeConf"
  "igSource\"\314\001\n\020NodeConfigStatus\0226\n\010assigne"
  "d\030\001 \001(\0132$.k8s.io.api.core.v1.NodeConfigS"
  "ource\0224\n\006active\030\002 \001(\0132$.k8s.io.api.core."
  "v1.NodeConfigSource\022;\n\rlastKnownGood\030\003 \001"
  "(\0132$.k8s.io.api.core.v1.NodeConfigSource"
  "\022\r\n\005error\030\004 \001(\014\"R\n\023NodeDaemonEndpoints\022;"
  "\n\017kubeletEndpoint\030\001 \001(\0132\".k8s.io.api.cor"
  "e.v1.DaemonEndpoint\"u\n\010NodeList\022@\n\010metad"
  "ata\030\001 \001(\0132..k8s.io.apimachinery.pkg.apis"
  ".meta.v1.ListMeta\022\'\n\005items\030\002 \003(\0132\030.k8s.i"
  "o.api.core.v1.Node\" \n\020NodeProxyOptions\022\014"
  "\n\004path\030\001 \001(\014\"\263\001\n\rNodeResources\022A\n\010capaci"
  "ty\030\001 \003(\0132/.k8s.io.api.core.v1.NodeResour"
  "ces.CapacityEntry\032_\n\rCapacityEntry\022\013\n\003ke"
  "y\030\001 \001(\t\022=\n\005value\030\002 \001(\0132..k8s.io.apimachi"
  "nery.pkg.api.resource.Quantity:\0028\001\"O\n\014No"
  "deSelector\022\?\n\021nodeSelectorTerms\030\001 \003(\0132$."
  "k8s.io.api.core.v1.NodeSelectorTerm\"H\n\027N"
  "odeSelectorRequirement\022\013\n\003key\030\001 \001(\014\022\020\n\010o"
  "perator\030\002 \001(\014\022\016\n\006values\030\003 \003(\t\"\233\001\n\020NodeSe"
  "lectorTerm\022E\n\020matchExpressions\030\001 \003(\0132+.k"
  "8s.io.api.core.v1.NodeSelectorRequiremen"
  "t\022@\n\013matchFields\030\002 \003(\0132+.k8s.io.api.core"
  ".v1.NodeSelectorRequirement\"\323\001\n\010NodeSpec"
  "\022\017\n\007podCIDR\030\001 \001(\014\022\020\n\010podCIDRs\030\007 \003(\t\022\022\n\np"
  "roviderID\030\003 \001(\014\022\025\n\runschedulable\030\004 \001(\010\022)"
  "\n\006taints\030\005 \003(\0132\031.k8s.io.api.core.v1.Tain"
  "t\022:\n\014configSource\030\006 \001(\0132$.k8s.io.api.cor"
  "e.v1.NodeConfigSource\022\022\n\nexternalID\030\002 \001("
  "\014\"\206\006\n\nNodeStatus\022>\n\010capacity\030\001 \003(\0132,.k8s"
  ".io.api.core.v1.NodeStatus.CapacityEntry"
  "\022D\n\013allocatable\030\002 \003(\0132/.k8s.io.api.core."
  "v1.NodeStatus.AllocatableEntry\022\r\n\005phase\030"
  "\003 \001(\014\0225\n\nconditions\030\004 \003(\0132!.k8s.io.api.c"
  "ore.v1.NodeCondition\0222\n\taddresses\030\005 \003(\0132"
  "\037.k8s.io.api.core.v1.NodeAddress\022@\n\017daem"
  "onEndpoints\030\006 \001(\0132\'.k8s.io.api.core.v1.N"
  "odeDaemonEndpoints\0224\n\010nodeInfo\030\007 \001(\0132\".k"
  "8s.io.api.core.v1.NodeSystemInfo\0222\n\006imag"
  "es\030\010 \003(\0132\".k8s.io.api.core.v1.ContainerI"
  "mage\022\024\n\014volumesInUse\030\t \003(\t\022;\n\017volumesAtt"
  "ached\030\n \003(\0132\".k8s.io.api.core.v1.Attache"
  "dVolume\0224\n\006config\030\013 \001(\0132$.k8s.io.api.cor"
  "e.v1.NodeConfigStatus\032_\n\rCapacityEntry\022\013"
  "\n\003key\030\001 \001(\t\022=\n\005value\030\002 \001(\0132..k8s.io.apim"
  "achinery.pkg.api.resource.Quantity:\0028\001\032b"
  "\n\020AllocatableEntry\022\013\n\003key\030\001 \001(\t\022=\n\005value"
  "\030\002 \001(\0132..k8s.io.apimachinery.pkg.api.res"
  "ource.Quantity:\0028\001\"\361\001\n\016NodeSystemInfo\022\021\n"
  "\tmachineID\030\001 \001(\014\022\022\n\nsystemUUID\030\002 \001(\014\022\016\n\006"
  "bootID\030\003 \001(\014\022\025\n\rkernelVersion\030\004 \001(\014\022\017\n\007o"
  "sImage\030\005 \001(\014\022\037\n\027containerRuntimeVersion\030"
  "\006 \001(\014\022\026\n\016kubeletVersion\030\007 \001(\014\022\030\n\020kubePro"
  "xyVersion\030\010 \001(\014\022\027\n\017operatingSystem\030\t \001(\014"
  "\022\024\n\014architecture\030\n \001(\014\"<\n\023ObjectFieldSel"
  "ector\022\022\n\napiVersion\030\001 \001(\014\022\021\n\tfieldPath\030\002"
  " \001(\014\"\215\001\n\017ObjectReference\022\014\n\004kind\030\001 \001(\014\022\021"
  "\n\tnamespace\030\002 \001(\014\022\014\n\004name\030\003 \001(\014\022\013\n\003uid\030\004"
  " \001(\014\022\022\n\napiVersion\030\005 \001(\014\022\027\n\017resourceVers"
  "ion\030\006 \001(\014\022\021\n\tfieldPath\030\007 \001(\014\"\312\001\n\020Persist"
  "entVolume\022B\n\010metadata\030\001 \001(\01320.k8s.io.api"
  "machinery.pkg.apis.meta.v1.ObjectMeta\0226\n"
  "\004spec\030\002 \001(\0132(.k8s.io.api.core.v1.Persist"
  "entVolumeSpec\022:\n\006status\030\003 \001(\0132*.k8s.io.a"
  "pi.core.v1.PersistentVolumeStatus\"\331\001\n\025Pe"
  "rsistentVolumeClaim\022B\n\010metadata\030\001 \001(\01320."
  "k8s.io.apimachinery.pkg.apis.meta.v1.Obj"
  "ectMeta\022;\n\004spec\030\002 \001(\0132-.k8s.io.api.core."
  "v1.PersistentVolumeClaimSpec\022\?\n\006status\030\003"
  " \001(\0132/.k8s.io.api.core.v1.PersistentVolu"
  "meClaimStatus\"\352\001\n\036PersistentVolumeClaimC"
  "ondition\022\014\n\004type\030\001 \001(\014\022\016\n\006status\030\002 \001(\014\022A"
  "\n\rlastProbeTime\030\003 \001(\0132*.k8s.io.apimachin"
  "ery.pkg.apis.meta.v1.Time\022F\n\022lastTransit"
  "ionTime\030\004 \001(\0132*.k8s.io.apimachinery.pkg."
  "apis.meta.v1.Time\022\016\n\006reason\030\005 \001(\014\022\017\n\007mes"
  "sage\030\006 \001(\014\"\227\001\n\031PersistentVolumeClaimList"
  "\022@\n\010metadata\030\001 \001(\0132..k8s.io.apimachinery"
  ".pkg.apis.meta.v1.ListMeta\0228\n\005items\030\002 \003("
  "\0132).k8s.io.api.core.v1.PersistentVolumeC"
  "laim\"\243\003\n\031PersistentVolumeClaimSpec\022\023\n\013ac"
  "cessModes\030\001 \003(\t\022E\n\010selector\030\004 \001(\01323.k8s."
  "io.apimachinery.pkg.apis.meta.v1.LabelSe"
  "lector\022A\n\tresources\030\002 \001(\0132..k8s.io.api.c"
  "ore.v1.VolumeResourceRequirements\022\022\n\nvol"
  "umeName\030\003 \001(\014\022\030\n\020storageClassName\030\005 \001(\014\022"
  "\022\n\nvolumeMode\030\006 \001(\014\022A\n\ndataSource\030\007 \001(\0132"
  "-.k8s.io.api.core.v1.TypedLocalObjectRef"
  "erence\022\?\n\rdataSourceRef\030\010 \001(\0132(.k8s.io.a"
  "pi.core.v1.TypedObjectReference\022!\n\031volum"
  "eAttributesClassName\030\t \001(\014\"\256\006\n\033Persisten"
  "tVolumeClaimStatus\022\r\n\005phase\030\001 \001(\014\022\023\n\013acc"
  "essModes\030\002 \003(\t\022O\n\010capacity\030\003 \003(\0132=.k8s.i"
  "o.api.core.v1.PersistentVolumeClaimStatu"
  "s.CapacityEntry\022F\n\nconditions\030\004 \003(\01322.k8"
  "s.io.api.core.v1.PersistentVolumeClaimCo"
  "ndition\022c\n\022allocatedResources\030\005 \003(\0132G.k8"
  "s.io.api.core.v1.PersistentVolumeClaimSt"
  "atus.AllocatedResourcesEntry\022q\n\031allocate"
  "dResourceStatuses\030\007 \003(\0132N.k8s.io.api.cor"
  "e.v1.PersistentVolumeClaimStatus.Allocat"
  "edResourceStatusesEntry\022(\n currentVolume"
  "AttributesClassName\030\010 \001(\014\022B\n\022modifyVolum"
  "eStatus\030\t \001(\0132&.k8s.io.api.core.v1.Modif"
  "yVolumeStatus\032_\n\rCapacityEntry\022\013\n\003key\030\001 "
  "\001(\t\022=\n\005value\030\002 \001(\0132..k8s.io.apimachinery"
  ".pkg.api.resource.Quantity:\0028\001\032i\n\027Alloca"
  "tedResourcesEntry\022\013\n\003key\030\001 \001(\t\022=\n\005value\030"
  "\002 \001(\0132..k8s.io.apimachinery.pkg.api.reso"
  "urce.Quantity:\0028\001\032@\n\036AllocatedResourceSt"
  "atusesEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(\t:"
  "\0028\001\"\240\001\n\035PersistentVolumeClaimTemplate\022B\n"
  "\010metadata\030\001 \001(\01320.k8s.io.apimachinery.pk"
  "g.apis.meta.v1.ObjectMeta\022;\n\004spec\030\002 \001(\0132"
  "-.k8s.io.api.core.v1.PersistentVolumeCla"
  "imSpec\"H\n!PersistentVolumeClaimVolumeSou"
  "rce\022\021\n\tclaimName\030\001 \001(\014\022\020\n\010readOnly\030\002 \001(\010"
  "\"\215\001\n\024PersistentVolumeList\022@\n\010metadata\030\001 "
  "\001(\0132..k8s.io.apimachinery.pkg.apis.meta."
  "v1.ListMeta\0223\n\005items\030\002 \003(\0132$.k8s.io.api."
  "core.v1.PersistentVolume\"\275\013\n\026PersistentV"
  "olumeSource\022L\n\021gcePersistentDisk\030\001 \001(\01321"
  ".k8s.io.api.core.v1.GCEPersistentDiskVol"
  "umeSource\022R\n\024awsElasticBlockStore\030\002 \001(\0132"
  "4.k8s.io.api.core.v1.AWSElasticBlockStor"
  "eVolumeSource\022:\n\010hostPath\030\003 \001(\0132(.k8s.io"
  ".api.core.v1.HostPathVolumeSource\022F\n\tglu"
  "sterfs\030\004 \001(\01323.k8s.io.api.core.v1.Gluste"
  "rfsPersistentVolumeSource\0220\n\003nfs\030\005 \001(\0132#"
  ".k8s.io.api.core.v1.NFSVolumeSource\022:\n\003r"
  "bd\030\006 \001(\0132-.k8s.io.api.core.v1.RBDPersist"
  "entVolumeSource\022>\n\005iscsi\030\007 \001(\0132/.k8s.io."
  "api.core.v1.ISCSIPersistentVolumeSource\022"
  "@\n\006cinder\030\010 \001(\01320.k8s.io.api.core.v1.Cin"
  "derPersistentVolumeSource\022@\n\006cephfs\030\t \001("
  "\01320.k8s.io.api.core.v1.CephFSPersistentV"
  "olumeSource\022.\n\002fc\030\n \001(\0132\".k8s.io.api.cor"
  "e.v1.FCVolumeSource\0228\n\007flocker\030\013 \001(\0132\'.k"
  "8s.io.api.core.v1.FlockerVolumeSource\022B\n"
  "\nflexVolume\030\014 \001(\0132..k8s.io.api.core.v1.F"
  "lexPersistentVolumeSource\022F\n\tazureFile\030\r"
  " \001(\01323.k8s.io.api.core.v1.AzureFilePersi"
  "stentVolumeSource\022I\n\rvsphereVolume\030\016 \001(\013"
  "22.k8s.io.api.core.v1.VsphereVirtualDisk"
  "VolumeSource\0228\n\007quobyte\030\017 \001(\0132\'.k8s.io.a"
  "pi.core.v1.QuobyteVolumeSource\022<\n\tazureD"
  "isk\030\020 \001(\0132).k8s.io.api.core.v1.AzureDisk"
  "VolumeSource\022R\n\024photonPersistentDisk\030\021 \001"
  "(\01324.k8s.io.api.core.v1.PhotonPersistent"
  "DiskVolumeSource\022@\n\016portworxVolume\030\022 \001(\013"
  "2(.k8s.io.api.core.v1.PortworxVolumeSour"
  "ce\022B\n\007scaleIO\030\023 \001(\01321.k8s.io.api.core.v1"
  ".ScaleIOPersistentVolumeSource\0224\n\005local\030"
  "\024 \001(\0132%.k8s.io.api.core.v1.LocalVolumeSo"
  "urce\022F\n\tstorageos\030\025 \001(\01323.k8s.io.api.cor"
  "e.v1.StorageOSPersistentVolumeSource\022:\n\003"
  "csi\030\026 \001(\0132-.k8s.io.api.core.v1.CSIPersis"
  "tentVolumeSource\"\245\004\n\024PersistentVolumeSpe"
  "c\022H\n\010capacity\030\001 \003(\01326.k8s.io.api.core.v1"
  ".PersistentVolumeSpec.CapacityEntry\022J\n\026p"
  "ersistentVolumeSource\030\002 \001(\0132*.k8s.io.api"
  ".core.v1.PersistentVolumeSource\022\023\n\013acces"
  "sModes\030\003 \003(\t\0225\n\010claimRef\030\004 \001(\0132#.k8s.io."
  "api.core.v1.ObjectReference\022%\n\035persisten"
  "tVolumeReclaimPolicy\030\005 \001(\014\022\030\n\020storageCla"
  "ssName\030\006 \001(\014\022\024\n\014mountOptions\030\007 \003(\t\022\022\n\nvo"
  "lumeMode\030\010 \001(\014\022<\n\014nodeAffinity\030\t \001(\0132&.k"
  "8s.io.api.core.v1.VolumeNodeAffinity\022!\n\031"
  "volumeAttributesClassName\030\n \001(\014\032_\n\rCapac"
  "ityEntry\022\013\n\003key\030\001 \001(\t\022=\n\005value\030\002 \001(\0132..k"
  "8s.io.apimachinery.pkg.api.resource.Quan"
  "tity:\0028\001\"\225\001\n\026PersistentVolumeStatus\022\r\n\005p"
  "hase\030\001 \001(\014\022\017\n\007message\030\002 \001(\014\022\016\n\006reason\030\003 "
  "\001(\014\022K\n\027lastPhaseTransitionTime\030\004 \001(\0132*.k"
  "8s.io.apimachinery.pkg.apis.meta.v1.Time"
  "\"@\n PhotonPersistentDiskVolumeSource\022\014\n\004"
  "pdID\030\001 \001(\014\022\016\n\006fsType\030\002 \001(\014\"\243\001\n\003Pod\022B\n\010me"
  "tadata\030\001 \001(\01320.k8s.io.apimachinery.pkg.a"
  "pis.meta.v1.ObjectMeta\022)\n\004spec\030\002 \001(\0132\033.k"
  "8s.io.api.core.v1.PodSpec\022-\n\006status\030\003 \001("
  "\0132\035.k8s.io.api.core.v1.PodStatus\"\320\001\n\013Pod"
  "Affinity\022[\n.requiredDuringSchedulingIgno"
  "redDuringExecution\030\001 \003(\0132#.k8s.io.api.co"
  "re.v1.PodAffinityTerm\022d\n/preferredDuring"
  "SchedulingIgnoredDuringExecution\030\002 \003(\0132+"
  ".k8s.io.api.core.v1.WeightedPodAffinityT"
  "erm\"\211\002\n\017PodAffinityTerm\022J\n\rlabelSelector"
  "\030\001 \001(\01323.k8s.io.apimachinery.pkg.apis.me"
  "ta.v1.LabelSelector\022\022\n\nnamespaces\030\002 \003(\t\022"
  "\023\n\013topologyKey\030\003 \001(\014\022N\n\021namespaceSelecto"
  "r\030\004 \001(\01323.k8s.io.apimachinery.pkg.apis.m"
  "eta.v1.LabelSelector\022\026\n\016matchLabelKeys\030\005"
  " \003(\t\022\031\n\021mismatchLabelKeys\030\006 \003(\t\"\324\001\n\017PodA"
  "ntiAffinity\022[\n.requiredDuringSchedulingI"
  "gnoredDuringExecution\030\001 \003(\0132#.k8s.io.api"
  ".core.v1.PodAffinityTerm\022d\n/preferredDur"
  "ingSchedulingIgnoredDuringExecution\030\002 \003("
  "\0132+.k8s.io.api.core.v1.WeightedPodAffini"
  "tyTerm\"a\n\020PodAttachOptions\022\r\n\005stdin\030\001 \001("
  "\010\022\016\n\006stdout\030\002 \001(\010\022\016\n\006stderr\030\003 \001(\010\022\013\n\003tty"
  "\030\004 \001(\010\022\021\n\tcontainer\030\005 \001(\014\"\330\001\n\014PodConditi"
  "on\022\014\n\004type\030\001 \001(\014\022\016\n\006status\030\002 \001(\014\022A\n\rlast"
  "ProbeTime\030\003 \001(\0132*.k8s.io.apimachinery.pk"
  "g.apis.meta.v1.Time\022F\n\022lastTransitionTim"
  "e\030\004 \001(\0132*.k8s.io.apimachinery.pkg.apis.m"
  "eta.v1.Time\022\016\n\006reason\030\005 \001(\014\022\017\n\007message\030\006"
  " \001(\014\"n\n\014PodDNSConfig\022\023\n\013nameservers\030\001 \003("
  "\t\022\020\n\010searches\030\002 \003(\t\0227\n\007options\030\003 \003(\0132&.k"
  "8s.io.api.core.v1.PodDNSConfigOption\"1\n\022"
  "PodDNSConfigOption\022\014\n\004name\030\001 \001(\014\022\r\n\005valu"
  "e\030\002 \001(\014\"p\n\016PodExecOptions\022\r\n\005stdin\030\001 \001(\010"
  "\022\016\n\006stdout\030\002 \001(\010\022\016\n\006stderr\030\003 \001(\010\022\013\n\003tty\030"
  "\004 \001(\010\022\021\n\tcontainer\030\005 \001(\014\022\017\n\007command\030\006 \003("
  "\t\"\023\n\005PodIP\022\n\n\002ip\030\001 \001(\014\"s\n\007PodList\022@\n\010met"
  "adata\030\001 \001(\0132..k8s.io.apimachinery.pkg.ap"
  "is.meta.v1.ListMeta\022&\n\005items\030\002 \003(\0132\027.k8s"
  ".io.api.core.v1.Pod\"\372\001\n\rPodLogOptions\022\021\n"
  "\tcontainer\030\001 \001(\014\022\016\n\006follow\030\002 \001(\010\022\020\n\010prev"
  "ious\030\003 \001(\010\022\024\n\014sinceSeconds\030\004 \001(\003\022=\n\tsinc"
  "eTime\030\005 \001(\0132*.k8s.io.apimachinery.pkg.ap"
  "is.meta.v1.Time\022\022\n\ntimestamps\030\006 \001(\010\022\021\n\tt"
  "ailLines\030\007 \001(\003\022\022\n\nlimitBytes\030\010 \001(\003\022$\n\034in"
  "secureSkipTLSVerifyBackend\030\t \001(\010\"\025\n\005PodO"
  "S\022\014\n\004name\030\001 \001(\014\"&\n\025PodPortForwardOptions"
  "\022\r\n\005ports\030\001 \003(\005\"\037\n\017PodProxyOptions\022\014\n\004pa"
  "th\030\001 \001(\014\")\n\020PodReadinessGate\022\025\n\rconditio"
  "nType\030\001 \001(\014\"Q\n\020PodResourceClaim\022\014\n\004name\030"
  "\001 \001(\014\022/\n\006source\030\002 \001(\0132\037.k8s.io.api.core."
  "v1.ClaimSource\"A\n\026PodResourceClaimStatus"
  "\022\014\n\004name\030\001 \001(\014\022\031\n\021resourceClaimName\030\002 \001("
  "\014\"!\n\021PodSchedulingGate\022\014\n\004name\030\001 \001(\014\"\213\003\n"
  "\022PodSecurityContext\022:\n\016seLinuxOptions\030\001 "
  "\001(\0132\".k8s.io.api.core.v1.SELinuxOptions\022"
  "I\n\016windowsOptions\030\010 \001(\01321.k8s.io.api.cor"
  "e.v1.WindowsSecurityContextOptions\022\021\n\tru"
  "nAsUser\030\002 \001(\003\022\022\n\nrunAsGroup\030\006 \001(\003\022\024\n\014run"
  "AsNonRoot\030\003 \001(\010\022\032\n\022supplementalGroups\030\004 "
  "\003(\003\022\017\n\007fsGroup\030\005 \001(\003\022+\n\007sysctls\030\007 \003(\0132\032."
  "k8s.io.api.core.v1.Sysctl\022\033\n\023fsGroupChan"
  "gePolicy\030\t \001(\014\022:\n\016seccompProfile\030\n \001(\0132\""
  ".k8s.io.api.core.v1.SeccompProfile\"[\n\014Po"
  "dSignature\022K\n\rpodController\030\001 \001(\01324.k8s."
  "io.apimachinery.pkg.apis.meta.v1.OwnerRe"
  "ference\"\235\r\n\007PodSpec\022+\n\007volumes\030\001 \003(\0132\032.k"
  "8s.io.api.core.v1.Volume\0225\n\016initContaine"
  "rs\030\024 \003(\0132\035.k8s.io.api.core.v1.Container\022"
  "1\n\ncontainers\030\002 \003(\0132\035.k8s.io.api.core.v1"
  ".Container\022C\n\023ephemeralContainers\030\" \003(\0132"
  "&.k8s.io.api.core.v1.EphemeralContainer\022"
  "\025\n\rrestartPolicy\030\003 \001(\014\022%\n\035terminationGra"
  "cePeriodSeconds\030\004 \001(\003\022\035\n\025activeDeadlineS"
  "econds\030\005 \001(\003\022\021\n\tdnsPolicy\030\006 \001(\014\022C\n\014nodeS"
  "elector\030\007 \003(\0132-.k8s.io.api.core.v1.PodSp"
  "ec.NodeSelectorEntry\022\032\n\022serviceAccountNa"
  "me\030\010 \001(\014\022\026\n\016serviceAccount\030\t \001(\014\022$\n\034auto"
  "mountServiceAccountToken\030\025 \001(\010\022\020\n\010nodeNa"
  "me\030\n \001(\014\022\023\n\013hostNetwork\030\013 \001(\010\022\017\n\007hostPID"
  "\030\014 \001(\010\022\017\n\007hostIPC\030\r \001(\010\022\035\n\025shareProcessN"
  "amespace\030\033 \001(\010\022\?\n\017securityContext\030\016 \001(\0132"
  "&.k8s.io.api.core.v1.PodSecurityContext\022"
  "B\n\020imagePullSecrets\030\017 \003(\0132(.k8s.io.api.c"
  "ore.v1.LocalObjectReference\022\020\n\010hostname\030"
  "\020 \001(\014\022\021\n\tsubdomain\030\021 \001(\014\022.\n\010affinity\030\022 \001"
  "(\0132\034.k8s.io.api.core.v1.Affinity\022\025\n\rsche"
  "dulerName\030\023 \001(\014\0223\n\013tolerations\030\026 \003(\0132\036.k"
  "8s.io.api.core.v1.Toleration\0222\n\013hostAlia"
  "ses\030\027 \003(\0132\035.k8s.io.api.core.v1.HostAlias"
  "\022\031\n\021priorityClassName\030\030 \001(\014\022\020\n\010priority\030"
  "\031 \001(\005\0223\n\tdnsConfig\030\032 \001(\0132 .k8s.io.api.co"
  "re.v1.PodDNSConfig\022<\n\016readinessGates\030\034 \003"
  "(\0132$.k8s.io.api.core.v1.PodReadinessGate"
  "\022\030\n\020runtimeClassName\030\035 \001(\014\022\032\n\022enableServ"
  "iceLinks\030\036 \001(\010\022\030\n\020preemptionPolicy\030\037 \001(\014"
  "\022;\n\010overhead\030  \003(\0132).k8s.io.api.core.v1."
  "PodSpec.OverheadEntry\022O\n\031topologySpreadC"
  "onstraints\030! \003(\0132,.k8s.io.api.core.v1.To"
  "pologySpreadConstraint\022\031\n\021setHostnameAsF"
  "QDN\030# \001(\010\022%\n\002os\030$ \001(\0132\031.k8s.io.api.core."
  "v1.PodOS\022\021\n\thostUsers\030% \001(\010\022>\n\017schedulin"
  "gGates\030& \003(\0132%.k8s.io.api.core.v1.PodSch"
  "edulingGate\022<\n\016resourceClaims\030\' \003(\0132$.k8"
  "s.io.api.core.v1.PodResourceClaim\0323\n\021Nod"
  "eSelectorEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001"
  "(\t:\0028\001\032_\n\rOverheadEntry\022\013\n\003key\030\001 \001(\t\022=\n\005"
  "value\030\002 \001(\0132..k8s.io.apimachinery.pkg.ap"
  "i.resource.Quantity:\0028\001\"\374\004\n\tPodStatus\022\r\n"
  "\005phase\030\001 \001(\014\0224\n\nconditions\030\002 \003(\0132 .k8s.i"
  "o.api.core.v1.PodCondition\022\017\n\007message\030\003 "
  "\001(\014\022\016\n\006reason\030\004 \001(\014\022\031\n\021nominatedNodeName"
  "\030\013 \001(\014\022\016\n\006hostIP\030\005 \001(\014\022+\n\007hostIPs\030\020 \003(\0132"
  "\032.k8s.io.api.core.v1.HostIP\022\r\n\005podIP\030\006 \001"
  "(\014\022)\n\006podIPs\030\014 \003(\0132\031.k8s.io.api.core.v1."
  "PodIP\022=\n\tstartTime\030\007 \001(\0132*.k8s.io.apimac"
  "hinery.pkg.apis.meta.v1.Time\022B\n\025initCont"
  "ainerStatuses\030\n \003(\0132#.k8s.io.api.core.v1"
  ".ContainerStatus\022>\n\021containerStatuses\030\010 "
  "\003(\0132#.k8s.io.api.core.v1.ContainerStatus"
  "\022\020\n\010qosClass\030\t \001(\014\022G\n\032ephemeralContainer"
  "Statuses\030\r \003(\0132#.k8s.io.api.core.v1.Cont"
  "ainerStatus\022\016\n\006resize\030\016 \001(\014\022I\n\025resourceC"
  "laimStatuses\030\017 \003(\0132*.k8s.io.api.core.v1."
  "PodResourceClaimStatus\"\204\001\n\017PodStatusResu"
  "lt\022B\n\010metadata\030\001 \001(\01320.k8s.io.apimachine"
  "ry.pkg.apis.meta.v1.ObjectMeta\022-\n\006status"
  "\030\002 \001(\0132\035.k8s.io.api.core.v1.PodStatus\"\210\001"
  "\n\013PodTemplate\022B\n\010metadata\030\001 \001(\01320.k8s.io"
  ".apimachinery.pkg.apis.meta.v1.ObjectMet"
  "a\0225\n\010template\030\002 \001(\0132#.k8s.io.api.core.v1"
  ".PodTemplateSpec\"\203\001\n\017PodTemplateList\022@\n\010"
  "metadata\030\001 \001(\0132..k8s.io.apimachinery.pkg"
  ".apis.meta.v1.ListMeta\022.\n\005items\030\002 \003(\0132\037."
  "k8s.io.api.core.v1.PodTemplate\"\200\001\n\017PodTe"
  "mplateSpec\022B\n\010metadata\030\001 \001(\01320.k8s.io.ap"
  "imachinery.pkg.apis.meta.v1.ObjectMeta\022)"
  "\n\004spec\030\002 \001(\0132\033.k8s.io.api.core.v1.PodSpe"
  "c\";\n\nPortStatus\022\014\n\004port\030\001 \001(\005\022\020\n\010protoco"
  "l\030\002 \001(\014\022\r\n\005error\030\003 \001(\014\"J\n\024PortworxVolume"
  "Source\022\020\n\010volumeID\030\001 \001(\014\022\016\n\006fsType\030\002 \001(\014"
  "\022\020\n\010readOnly\030\003 \001(\010\"\034\n\rPreconditions\022\013\n\003u"
  "id\030\001 \001(\014\"\261\001\n\024PreferAvoidPodsEntry\0226\n\014pod"
  "Signature\030\001 \001(\0132 .k8s.io.api.core.v1.Pod"
  "Signature\022@\n\014evictionTime\030\002 \001(\0132*.k8s.io"
  ".apimachinery.pkg.apis.meta.v1.Time\022\016\n\006r"
  "eason\030\003 \001(\014\022\017\n\007message\030\004 \001(\014\"c\n\027Preferre"
  "dSchedulingTerm\022\016\n\006weight\030\001 \001(\005\0228\n\nprefe"
  "rence\030\002 \001(\0132$.k8s.io.api.core.v1.NodeSel"
  "ectorTerm\"\341\001\n\005Probe\0221\n\007handler\030\001 \001(\0132 .k"
  "8s.io.api.core.v1.ProbeHandler\022\033\n\023initia"
  "lDelaySeconds\030\002 \001(\005\022\026\n\016timeoutSeconds\030\003 "
  "\001(\005\022\025\n\rperiodSeconds\030\004 \001(\005\022\030\n\020successThr"
  "eshold\030\005 \001(\005\022\030\n\020failureThreshold\030\006 \001(\005\022%"
  "\n\035terminationGracePeriodSeconds\030\007 \001(\003\"\326\001"
  "\n\014ProbeHandler\022,\n\004exec\030\001 \001(\0132\036.k8s.io.ap"
  "i.core.v1.ExecAction\0222\n\007httpGet\030\002 \001(\0132!."
  "k8s.io.api.core.v1.HTTPGetAction\0226\n\ttcpS"
  "ocket\030\003 \001(\0132#.k8s.io.api.core.v1.TCPSock"
  "etAction\022,\n\004grpc\030\004 \001(\0132\036.k8s.io.api.core"
  ".v1.GRPCAction\"c\n\025ProjectedVolumeSource\022"
  "5\n\007sources\030\001 \003(\0132$.k8s.io.api.core.v1.Vo"
  "lumeProjection\022\023\n\013defaultMode\030\002 \001(\005\"v\n\023Q"
  "uobyteVolumeSource\022\020\n\010registry\030\001 \001(\014\022\016\n\006"
  "volume\030\002 \001(\014\022\020\n\010readOnly\030\003 \001(\010\022\014\n\004user\030\004"
  " \001(\014\022\r\n\005group\030\005 \001(\014\022\016\n\006tenant\030\006 \001(\014\"\303\001\n\031"
  "RBDPersistentVolumeSource\022\020\n\010monitors\030\001 "
  "\003(\t\022\r\n\005image\030\002 \001(\014\022\016\n\006fsType\030\003 \001(\014\022\014\n\004po"
  "ol\030\004 \001(\014\022\014\n\004user\030\005 \001(\014\022\017\n\007keyring\030\006 \001(\014\022"
  "6\n\tsecretRef\030\007 \001(\0132#.k8s.io.api.core.v1."
  "SecretReference\022\020\n\010readOnly\030\010 \001(\010\"\276\001\n\017RB"
  "DVolumeSource\022\020\n\010monitors\030\001 \003(\t\022\r\n\005image"
  "\030\002 \001(\014\022\016\n\006fsType\030\003 \001(\014\022\014\n\004pool\030\004 \001(\014\022\014\n\004"
  "user\030\005 \001(\014\022\017\n\007keyring\030\006 \001(\014\022;\n\tsecretRef"
  "\030\007 \001(\0132(.k8s.io.api.core.v1.LocalObjectR"
  "eference\022\020\n\010readOnly\030\010 \001(\010\"r\n\017RangeAlloc"
  "ation\022B\n\010metadata\030\001 \001(\01320.k8s.io.apimach"
  "inery.pkg.apis.meta.v1.ObjectMeta\022\r\n\005ran"
  "ge\030\002 \001(\014\022\014\n\004data\030\003 \001(\014\"\331\001\n\025ReplicationCo"
  "ntroller\022B\n\010metadata\030\001 \001(\01320.k8s.io.apim"
  "achinery.pkg.apis.meta.v1.ObjectMeta\022;\n\004"
  "spec\030\002 \001(\0132-.k8s.io.api.core.v1.Replicat"
  "ionControllerSpec\022\?\n\006status\030\003 \001(\0132/.k8s."
  "io.api.core.v1.ReplicationControllerStat"
  "us\"\247\001\n\036ReplicationControllerCondition\022\014\n"
  "\004type\030\001 \001(\014\022\016\n\006status\030\002 \001(\014\022F\n\022lastTrans"
  "itionTime\030\003 \001(\0132*.k8s.io.apimachinery.pk"
  "g.apis.meta.v1.Time\022\016\n\006reason\030\004 \001(\014\022\017\n\007m"
  "essage\030\005 \001(\014\"\227\001\n\031ReplicationControllerLi"
  "st\022@\n\010metadata\030\001 \001(\0132..k8s.io.apimachine"
  "ry.pkg.apis.meta.v1.ListMeta\0228\n\005items\030\002 "
  "\003(\0132).k8s.io.api.core.v1.ReplicationCont"
  "roller\"\375\001\n\031ReplicationControllerSpec\022\020\n\010"
  "replicas\030\001 \001(\005\022\027\n\017minReadySeconds\030\004 \001(\005\022"
  "M\n\010selector\030\002 \003(\0132;.k8s.io.api.core.v1.R"
  "eplicationControllerSpec.SelectorEntry\0225"
  "\n\010template\030\003 \001(\0132#.k8s.io.api.core.v1.Po"
  "dTemplateSpec\032/\n\rSelectorEntry\022\013\n\003key\030\001 "
  "\001(\t\022\r\n\005value\030\002 \001(\t:\0028\001\"\343\001\n\033ReplicationCo"
  "ntrollerStatus\022\020\n\010replicas\030\001 \001(\005\022\034\n\024full"
  "yLabeledReplicas\030\002 \001(\005\022\025\n\rreadyReplicas\030"
  "\004 \001(\005\022\031\n\021availableReplicas\030\005 \001(\005\022\032\n\022obse"
  "rvedGeneration\030\003 \001(\003\022F\n\nconditions\030\006 \003(\013"
  "22.k8s.io.api.core.v1.ReplicationControl"
  "lerCondition\"\035\n\rResourceClaim\022\014\n\004name\030\001 "
  "\001(\014\"\201\001\n\025ResourceFieldSelector\022\025\n\rcontain"
  "erName\030\001 \001(\014\022\020\n\010resource\030\002 \001(\014\022\?\n\007diviso"
  "r\030\003 \001(\0132..k8s.io.apimachinery.pkg.api.re"
  "source.Quantity\"\301\001\n\rResourceQuota\022B\n\010met"
  "adata\030\001 \001(\01320.k8s.io.apimachinery.pkg.ap"
  "is.meta.v1.ObjectMeta\0223\n\004spec\030\002 \001(\0132%.k8"
  "s.io.api.core.v1.ResourceQuotaSpec\0227\n\006st"
  "atus\030\003 \001(\0132\'.k8s.io.api.core.v1.Resource"
  "QuotaStatus\"\207\001\n\021ResourceQuotaList\022@\n\010met"
  "adata\030\001 \001(\0132..k8s.io.apimachinery.pkg.ap"
  "is.meta.v1.ListMeta\0220\n\005items\030\002 \003(\0132!.k8s"
  ".io.api.core.v1.ResourceQuota\"\371\001\n\021Resour"
  "ceQuotaSpec\022=\n\004hard\030\001 \003(\0132/.k8s.io.api.c"
  "ore.v1.ResourceQuotaSpec.HardEntry\022\016\n\006sc"
  "opes\030\002 \003(\t\0228\n\rscopeSelector\030\003 \001(\0132!.k8s."
  "io.api.core.v1.ScopeSelector\032[\n\tHardEntr"
  "y\022\013\n\003key\030\001 \001(\t\022=\n\005value\030\002 \001(\0132..k8s.io.a"
  "pimachinery.pkg.api.resource.Quantity:\0028"
  "\001\"\321\002\n\023ResourceQuotaStatus\022\?\n\004hard\030\001 \003(\0132"
  "1.k8s.io.api.core.v1.ResourceQuotaStatus"
  ".HardEntry\022\?\n\004used\030\002 \003(\01321.k8s.io.api.co"
  "re.v1.ResourceQuotaStatus.UsedEntry\032[\n\tH"
  "ardEntry\022\013\n\003key\030\001 \001(\t\022=\n\005value\030\002 \001(\0132..k"
  "8s.io.apimachinery.pkg.api.resource.Quan"
  "tity:\0028\001\032[\n\tUsedEntry\022\013\n\003key\030\001 \001(\t\022=\n\005va"
  "lue\030\002 \001(\0132..k8s.io.apimachinery.pkg.api."
  "resource.Quantity:\0028\001\"\231\003\n\024ResourceRequir"
  "ements\022D\n\006limits\030\001 \003(\01324.k8s.io.api.core"
  ".v1.ResourceRequirements.LimitsEntry\022H\n\010"
  "requests\030\002 \003(\01326.k8s.io.api.core.v1.Reso"
  "urceRequirements.RequestsEntry\0221\n\006claims"
  "\030\003 \003(\0132!.k8s.io.api.core.v1.ResourceClai"
  "m\032]\n\013LimitsEntry\022\013\n\003key\030\001 \001(\t\022=\n\005value\030\002"
  " \001(\0132..k8s.io.apimachinery.pkg.api.resou"
  "rce.Quantity:\0028\001\032_\n\rRequestsEntry\022\013\n\003key"
  "\030\001 \001(\t\022=\n\005value\030\002 \001(\0132..k8s.io.apimachin"
  "ery.pkg.api.resource.Quantity:\0028\001\"I\n\016SEL"
  "inuxOptions\022\014\n\004user\030\001 \001(\014\022\014\n\004role\030\002 \001(\014\022"
  "\014\n\004type\030\003 \001(\014\022\r\n\005level\030\004 \001(\014\"\206\002\n\035ScaleIO"
  "PersistentVolumeSource\022\017\n\007gateway\030\001 \001(\014\022"
  "\016\n\006system\030\002 \001(\014\0226\n\tsecretRef\030\003 \001(\0132#.k8s"
  ".io.api.core.v1.SecretReference\022\022\n\nsslEn"
  "abled\030\004 \001(\010\022\030\n\020protectionDomain\030\005 \001(\014\022\023\n"
  "\013storagePool\030\006 \001(\014\022\023\n\013storageMode\030\007 \001(\014\022"
  "\022\n\nvolumeName\030\010 \001(\014\022\016\n\006fsType\030\t \001(\014\022\020\n\010r"
  "eadOnly\030\n \001(\010\"\201\002\n\023ScaleIOVolumeSource\022\017\n"
  "\007gateway\030\001 \001(\014\022\016\n\006system\030\002 \001(\014\022;\n\tsecret"
  "Ref\030\003 \001(\0132(.k8s.io.api.core.v1.LocalObje"
  "ctReference\022\022\n\nsslEnabled\030\004 \001(\010\022\030\n\020prote"
  "ctionDomain\030\005 \001(\014\022\023\n\013storagePool\030\006 \001(\014\022\023"
  "\n\013storageMode\030\007 \001(\014\022\022\n\nvolumeName\030\010 \001(\014\022"
  "\016\n\006fsType\030\t \001(\014\022\020\n\010readOnly\030\n \001(\010\"`\n\rSco"
  "peSelector\022O\n\020matchExpressions\030\001 \003(\01325.k"
  "8s.io.api.core.v1.ScopedResourceSelector"
  "Requirement\"X\n!ScopedResourceSelectorReq"
  "uirement\022\021\n\tscopeName\030\001 \001(\014\022\020\n\010operator\030"
  "\002 \001(\014\022\016\n\006values\030\003 \003(\t\"8\n\016SeccompProfile\022"
  "\014\n\004type\030\001 \001(\014\022\030\n\020localhostProfile\030\002 \001(\014\""
  "\301\002\n\006Secret\022B\n\010metadata\030\001 \001(\01320.k8s.io.ap"
  "imachinery.pkg.apis.meta.v1.ObjectMeta\022\021"
  "\n\timmutable\030\005 \001(\010\0222\n\004data\030\002 \003(\0132$.k8s.io"
  ".api.core.v1.Secret.DataEntry\022>\n\nstringD"
  "ata\030\004 \003(\0132*.k8s.io.api.core.v1.Secret.St"
  "ringDataEntry\022\014\n\004type\030\003 \001(\014\032+\n\tDataEntry"
  "\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(\014:\0028\001\0321\n\017Stri"
  "ngDataEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(\t:"
  "\0028\001\"k\n\017SecretEnvSource\022F\n\024localObjectRef"
  "erence\030\001 \001(\0132(.k8s.io.api.core.v1.LocalO"
  "bjectReference\022\020\n\010optional\030\002 \001(\010\"z\n\021Secr"
  "etKeySelector\022F\n\024localObjectReference\030\001 "
  "\001(\0132(.k8s.io.api.core.v1.LocalObjectRefe"
  "rence\022\013\n\003key\030\002 \001(\014\022\020\n\010optional\030\003 \001(\010\"y\n\n"
  "SecretList\022@\n\010metadata\030\001 \001(\0132..k8s.io.ap"
  "imachinery.pkg.apis.meta.v1.ListMeta\022)\n\005"
  "items\030\002 \003(\0132\032.k8s.io.api.core.v1.Secret\""
  "\232\001\n\020SecretProjection\022F\n\024localObjectRefer"
  "ence\030\001 \001(\0132(.k8s.io.api.core.v1.LocalObj"
  "ectReference\022,\n\005items\030\002 \003(\0132\035.k8s.io.api"
  ".core.v1.KeyToPath\022\020\n\010optional\030\004 \001(\010\"2\n\017"
  "SecretReference\022\014\n\004name\030\001 \001(\014\022\021\n\tnamespa"
  "ce\030\002 \001(\014\"}\n\022SecretVolumeSource\022\022\n\nsecret"
  "Name\030\001 \001(\014\022,\n\005items\030\002 \003(\0132\035.k8s.io.api.c"
  "ore.v1.KeyToPath\022\023\n\013defaultMode\030\003 \001(\005\022\020\n"
  "\010optional\030\004 \001(\010\"\262\003\n\017SecurityContext\0226\n\014c"
  "apabilities\030\001 \001(\0132 .k8s.io.api.core.v1.C"
  "apabilities\022\022\n\nprivileged\030\002 \001(\010\022:\n\016seLin"
  "uxOptions\030\003 \001(\0132\".k8s.io.api.core.v1.SEL"
  "inuxOptions\022I\n\016windowsOptions\030\n \001(\01321.k8"
  "s.io.api.core.v1.WindowsSecurityContextO"
  "ptions\022\021\n\trunAsUser\030\004 \001(\003\022\022\n\nrunAsGroup\030"
  "\010 \001(\003\022\024\n\014runAsNonRoot\030\005 \001(\010\022\036\n\026readOnlyR"
  "ootFilesystem\030\006 \001(\010\022 \n\030allowPrivilegeEsc"
  "alation\030\007 \001(\010\022\021\n\tprocMount\030\t \001(\014\022:\n\016secc"
  "ompProfile\030\013 \001(\0132\".k8s.io.api.core.v1.Se"
  "ccompProfile\"M\n\023SerializedReference\0226\n\tr"
  "eference\030\001 \001(\0132#.k8s.io.api.core.v1.Obje"
  "ctReference\"\257\001\n\007Service\022B\n\010metadata\030\001 \001("
  "\01320.k8s.io.apimachinery.pkg.apis.meta.v1"
  ".ObjectMeta\022-\n\004spec\030\002 \001(\0132\037.k8s.io.api.c"
  "ore.v1.ServiceSpec\0221\n\006status\030\003 \001(\0132!.k8s"
  ".io.api.core.v1.ServiceStatus\"\364\001\n\016Servic"
  "eAccount\022B\n\010metadata\030\001 \001(\01320.k8s.io.apim"
  "achinery.pkg.apis.meta.v1.ObjectMeta\0224\n\007"
  "secrets\030\002 \003(\0132#.k8s.io.api.core.v1.Objec"
  "tReference\022B\n\020imagePullSecrets\030\003 \003(\0132(.k"
  "8s.io.api.core.v1.LocalObjectReference\022$"
  "\n\034automountServiceAccountToken\030\004 \001(\010\"\211\001\n"
  "\022ServiceAccountList\022@\n\010metadata\030\001 \001(\0132.."
  "k8s.io.apimachinery.pkg.apis.meta.v1.Lis"
  "tMeta\0221\n\005items\030\002 \003(\0132\".k8s.io.api.core.v"
  "1.ServiceAccount\"Z\n\035ServiceAccountTokenP"
  "rojection\022\020\n\010audience\030\001 \001(\014\022\031\n\021expiratio"
  "nSeconds\030\002 \001(\003\022\014\n\004path\030\003 \001(\014\"{\n\013ServiceL"
  "ist\022@\n\010metadata\030\001 \001(\0132..k8s.io.apimachin"
  "ery.pkg.apis.meta.v1.ListMeta\022*\n\005items\030\002"
  " \003(\0132\033.k8s.io.api.core.v1.Service\"\250\001\n\013Se"
  "rvicePort\022\014\n\004name\030\001 \001(\014\022\020\n\010protocol\030\002 \001("
  "\014\022\023\n\013appProtocol\030\006 \001(\014\022\014\n\004port\030\003 \001(\005\022D\n\n"
  "targetPort\030\004 \001(\01320.k8s.io.apimachinery.p"
  "kg.util.intstr.IntOrString\022\020\n\010nodePort\030\005"
  " \001(\005\"#\n\023ServiceProxyOptions\022\014\n\004path\030\001 \001("
  "\014\"\227\005\n\013ServiceSpec\022.\n\005ports\030\001 \003(\0132\037.k8s.i"
  "o.api.core.v1.ServicePort\022\?\n\010selector\030\002 "
  "\003(\0132-.k8s.io.api.core.v1.ServiceSpec.Sel"
  "ectorEntry\022\021\n\tclusterIP\030\003 \001(\014\022\022\n\ncluster"
  "IPs\030\022 \003(\t\022\014\n\004type\030\004 \001(\014\022\023\n\013externalIPs\030\005"
  " \003(\t\022\027\n\017sessionAffinity\030\007 \001(\014\022\026\n\016loadBal"
  "ancerIP\030\010 \001(\014\022 \n\030loadBalancerSourceRange"
  "s\030\t \003(\t\022\024\n\014externalName\030\n \001(\014\022\035\n\025externa"
  "lTrafficPolicy\030\013 \001(\014\022\033\n\023healthCheckNodeP"
  "ort\030\014 \001(\005\022 \n\030publishNotReadyAddresses\030\r "
  "\001(\010\022H\n\025sessionAffinityConfig\030\016 \001(\0132).k8s"
  ".io.api.core.v1.SessionAffinityConfig\022\022\n"
  "\nipFamilies\030\023 \003(\t\022\026\n\016ipFamilyPolicy\030\021 \001("
  "\014\022%\n\035allocateLoadBalancerNodePorts\030\024 \001(\010"
  "\022\031\n\021loadBalancerClass\030\025 \001(\014\022\035\n\025internalT"
  "rafficPolicy\030\026 \001(\014\032/\n\rSelectorEntry\022\013\n\003k"
  "ey\030\001 \001(\t\022\r\n\005value\030\002 \001(\t:\0028\001\"\222\001\n\rServiceS"
  "tatus\022<\n\014loadBalancer\030\001 \001(\0132&.k8s.io.api"
  ".core.v1.LoadBalancerStatus\022C\n\ncondition"
  "s\030\002 \003(\0132/.k8s.io.apimachinery.pkg.apis.m"
  "eta.v1.Condition\"M\n\025SessionAffinityConfi"
  "g\0224\n\010clientIP\030\001 \001(\0132\".k8s.io.api.core.v1"
  ".ClientIPConfig\"\036\n\013SleepAction\022\017\n\007second"
  "s\030\001 \001(\003\"\250\001\n\037StorageOSPersistentVolumeSou"
  "rce\022\022\n\nvolumeName\030\001 \001(\014\022\027\n\017volumeNamespa"
  "ce\030\002 \001(\014\022\016\n\006fsType\030\003 \001(\014\022\020\n\010readOnly\030\004 \001"
  "(\010\0226\n\tsecretRef\030\005 \001(\0132#.k8s.io.api.core."
  "v1.ObjectReference\"\243\001\n\025StorageOSVolumeSo"
  "urce\022\022\n\nvolumeName\030\001 \001(\014\022\027\n\017volumeNamesp"
  "ace\030\002 \001(\014\022\016\n\006fsType\030\003 \001(\014\022\020\n\010readOnly\030\004 "
  "\001(\010\022;\n\tsecretRef\030\005 \001(\0132(.k8s.io.api.core"
  ".v1.LocalObjectReference\"%\n\006Sysctl\022\014\n\004na"
  "me\030\001 \001(\014\022\r\n\005value\030\002 \001(\014\"_\n\017TCPSocketActi"
  "on\022>\n\004port\030\001 \001(\01320.k8s.io.apimachinery.p"
  "kg.util.intstr.IntOrString\022\014\n\004host\030\002 \001(\014"
  "\"r\n\005Taint\022\013\n\003key\030\001 \001(\014\022\r\n\005value\030\002 \001(\014\022\016\n"
  "\006effect\030\003 \001(\014\022=\n\ttimeAdded\030\004 \001(\0132*.k8s.i"
  "o.apimachinery.pkg.apis.meta.v1.Time\"e\n\n"
  "Toleration\022\013\n\003key\030\001 \001(\014\022\020\n\010operator\030\002 \001("
  "\014\022\r\n\005value\030\003 \001(\014\022\016\n\006effect\030\004 \001(\014\022\031\n\021tole"
  "rationSeconds\030\005 \001(\003\"\?\n TopologySelectorL"
  "abelRequirement\022\013\n\003key\030\001 \001(\014\022\016\n\006values\030\002"
  " \003(\t\"k\n\024TopologySelectorTerm\022S\n\025matchLab"
  "elExpressions\030\001 \003(\01324.k8s.io.api.core.v1"
  ".TopologySelectorLabelRequirement\"\211\002\n\030To"
  "pologySpreadConstraint\022\017\n\007maxSkew\030\001 \001(\005\022"
  "\023\n\013topologyKey\030\002 \001(\014\022\031\n\021whenUnsatisfiabl"
  "e\030\003 \001(\014\022J\n\rlabelSelector\030\004 \001(\01323.k8s.io."
  "apimachinery.pkg.apis.meta.v1.LabelSelec"
  "tor\022\022\n\nminDomains\030\005 \001(\005\022\032\n\022nodeAffinityP"
  "olicy\030\006 \001(\014\022\030\n\020nodeTaintsPolicy\030\007 \001(\014\022\026\n"
  "\016matchLabelKeys\030\010 \003(\t\"I\n\031TypedLocalObjec"
  "tReference\022\020\n\010apiGroup\030\001 \001(\014\022\014\n\004kind\030\002 \001"
  "(\014\022\014\n\004name\030\003 \001(\014\"W\n\024TypedObjectReference"
  "\022\020\n\010apiGroup\030\001 \001(\014\022\014\n\004kind\030\002 \001(\014\022\014\n\004name"
  "\030\003 \001(\014\022\021\n\tnamespace\030\004 \001(\014\"N\n\006Volume\022\014\n\004n"
  "ame\030\001 \001(\014\0226\n\014volumeSource\030\002 \001(\0132 .k8s.io"
  ".api.core.v1.VolumeSource\"0\n\014VolumeDevic"
  "e\022\014\n\004name\030\001 \001(\014\022\022\n\ndevicePath\030\002 \001(\014\"\200\001\n\013"
  "VolumeMount\022\014\n\004name\030\001 \001(\014\022\020\n\010readOnly\030\002 "
  "\001(\010\022\021\n\tmountPath\030\003 \001(\014\022\017\n\007subPath\030\004 \001(\014\022"
  "\030\n\020mountPropagation\030\005 \001(\014\022\023\n\013subPathExpr"
  "\030\006 \001(\014\"H\n\022VolumeNodeAffinity\0222\n\010required"
  "\030\001 \001(\0132 .k8s.io.api.core.v1.NodeSelector"
  "\"\342\002\n\020VolumeProjection\0224\n\006secret\030\001 \001(\0132$."
  "k8s.io.api.core.v1.SecretProjection\022>\n\013d"
  "ownwardAPI\030\002 \001(\0132).k8s.io.api.core.v1.Do"
  "wnwardAPIProjection\022:\n\tconfigMap\030\003 \001(\0132\'"
  ".k8s.io.api.core.v1.ConfigMapProjection\022"
  "N\n\023serviceAccountToken\030\004 \001(\01321.k8s.io.ap"
  "i.core.v1.ServiceAccountTokenProjection\022"
  "L\n\022clusterTrustBundle\030\005 \001(\01320.k8s.io.api"
  ".core.v1.ClusterTrustBundleProjection\"\370\002"
  "\n\032VolumeResourceRequirements\022J\n\006limits\030\001"
  " \003(\0132:.k8s.io.api.core.v1.VolumeResource"
  "Requirements.LimitsEntry\022N\n\010requests\030\002 \003"
  "(\0132<.k8s.io.api.core.v1.VolumeResourceRe"
  "quirements.RequestsEntry\032]\n\013LimitsEntry\022"
  "\013\n\003key\030\001 \001(\t\022=\n\005value\030\002 \001(\0132..k8s.io.api"
  "machinery.pkg.api.resource.Quantity:\0028\001\032"
  "_\n\rRequestsEntry\022\013\n\003key\030\001 \001(\t\022=\n\005value\030\002"
  " \001(\0132..k8s.io.apimachinery.pkg.api.resou"
  "rce.Quantity:\0028\001\"\231\016\n\014VolumeSource\022:\n\010hos"
  "tPath\030\001 \001(\0132(.k8s.io.api.core.v1.HostPat"
  "hVolumeSource\022:\n\010emptyDir\030\002 \001(\0132(.k8s.io"
  ".api.core.v1.EmptyDirVolumeSource\022L\n\021gce"
  "PersistentDisk\030\003 \001(\01321.k8s.io.api.core.v"
  "1.GCEPersistentDiskVolumeSource\022R\n\024awsEl"
  "asticBlockStore\030\004 \001(\01324.k8s.io.api.core."
  "v1.AWSElasticBlockStoreVolumeSource\0228\n\007g"
  "itRepo\030\005 \001(\0132\'.k8s.io.api.core.v1.GitRep"
  "oVolumeSource\0226\n\006secret\030\006 \001(\0132&.k8s.io.a"
  "pi.core.v1.SecretVolumeSource\0220\n\003nfs\030\007 \001"
  "(\0132#.k8s.io.api.core.v1.NFSVolumeSource\022"
  "4\n\005iscsi\030\010 \001(\0132%.k8s.io.api.core.v1.ISCS"
  "IVolumeSource\022<\n\tglusterfs\030\t \001(\0132).k8s.i"
  "o.api.core.v1.GlusterfsVolumeSource\022T\n\025p"
  "ersistentVolumeClaim\030\n \001(\01325.k8s.io.api."
  "core.v1.PersistentVolumeClaimVolumeSourc"
  "e\0220\n\003rbd\030\013 \001(\0132#.k8s.io.api.core.v1.RBDV"
  "olumeSource\0228\n\nflexVolume\030\014 \001(\0132$.k8s.io"
  ".api.core.v1.FlexVolumeSource\0226\n\006cinder\030"
  "\r \001(\0132&.k8s.io.api.core.v1.CinderVolumeS"
  "ource\0226\n\006cephfs\030\016 \001(\0132&.k8s.io.api.core."
  "v1.CephFSVolumeSource\0228\n\007flocker\030\017 \001(\0132\'"
  ".k8s.io.api.core.v1.FlockerVolumeSource\022"
  "@\n\013downwardAPI\030\020 \001(\0132+.k8s.io.api.core.v"
  "1.DownwardAPIVolumeSource\022.\n\002fc\030\021 \001(\0132\"."
  "k8s.io.api.core.v1.FCVolumeSource\022<\n\tazu"
  "reFile\030\022 \001(\0132).k8s.io.api.core.v1.AzureF"
  "ileVolumeSource\022<\n\tconfigMap\030\023 \001(\0132).k8s"
  ".io.api.core.v1.ConfigMapVolumeSource\022I\n"
  "\rvsphereVolume\030\024 \001(\01322.k8s.io.api.core.v"
  "1.VsphereVirtualDiskVolumeSource\0228\n\007quob"
  "yte\030\025 \001(\0132\'.k8s.io.api.core.v1.QuobyteVo"
  "lumeSource\022<\n\tazureDisk\030\026 \001(\0132).k8s.io.a"
  "pi.core.v1.AzureDiskVolumeSource\022R\n\024phot"
  "onPersistentDisk\030\027 \001(\01324.k8s.io.api.core"
  ".v1.PhotonPersistentDiskVolumeSource\022<\n\t"
  "projected\030\032 \001(\0132).k8s.io.api.core.v1.Pro"
  "jectedVolumeSource\022@\n\016portworxVolume\030\030 \001"
  "(\0132(.k8s.io.api.core.v1.PortworxVolumeSo"
  "urce\0228\n\007scaleIO\030\031 \001(\0132\'.k8s.io.api.core."
  "v1.ScaleIOVolumeSource\022<\n\tstorageos\030\033 \001("
  "\0132).k8s.io.api.core.v1.StorageOSVolumeSo"
  "urce\0220\n\003csi\030\034 \001(\0132#.k8s.io.api.core.v1.C"
  "SIVolumeSource\022<\n\tephemeral\030\035 \001(\0132).k8s."
  "io.api.core.v1.EphemeralVolumeSource\"x\n\036"
  "VsphereVirtualDiskVolumeSource\022\022\n\nvolume"
  "Path\030\001 \001(\014\022\016\n\006fsType\030\002 \001(\014\022\031\n\021storagePol"
  "icyName\030\003 \001(\014\022\027\n\017storagePolicyID\030\004 \001(\014\"g"
  "\n\027WeightedPodAffinityTerm\022\016\n\006weight\030\001 \001("
  "\005\022<\n\017podAffinityTerm\030\002 \001(\0132#.k8s.io.api."
  "core.v1.PodAffinityTerm\"\207\001\n\035WindowsSecur"
  "ityContextOptions\022\036\n\026gmsaCredentialSpecN"
  "ame\030\001 \001(\014\022\032\n\022gmsaCredentialSpec\030\002 \001(\014\022\025\n"
  "\rrunAsUserName\030\003 \001(\014\022\023\n\013hostProcess\030\004 \001("
  "\010B\024Z\022k8s.io/api/core/v1"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_deps[5] = {
  &::descriptor_table_staging_5fsrc_5fk8s_2eio_5fapimachinery_5fpkg_5fapi_5fresource_5fgenerated_2eproto,
  &::descriptor_table_staging_5fsrc_5fk8s_2eio_5fapimachinery_5fpkg_5fapis_5fmeta_5fv1_5fgenerated_2eproto,
  &::descriptor_table_staging_5fsrc_5fk8s_2eio_5fapimachinery_5fpkg_5fruntime_5fgenerated_2eproto,
  &::descriptor_table_staging_5fsrc_5fk8s_2eio_5fapimachinery_5fpkg_5fruntime_5fschema_5fgenerated_2eproto,
  &::descriptor_table_staging_5fsrc_5fk8s_2eio_5fapimachinery_5fpkg_5futil_5fintstr_5fgenerated_2eproto,
};
static ::_pbi::once_flag descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto = {
    false, false, 41863, descriptor_table_protodef_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto,
    "staging_src_k8s.io_api_core_v1_generated.proto",
    &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once, descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_deps, 5, 255,
    schemas, file_default_instances, TableStruct_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto::offsets,
    file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto, file_level_enum_descriptors_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto,
    file_level_service_descriptors_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter() {
  return &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto(&descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto);
namespace k8s {
namespace io {
namespace api {
namespace core {
namespace v1 {

// ===================================================================

class PodOrNode::_Internal {
 public:
  using HasBits = decltype(std::declval<PodOrNode>()._impl_._has_bits_);
  static const ::k8s::io::api::core::v1::Pod& pod(const PodOrNode* msg);
  static void set_has_pod(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::k8s::io::api::core::v1::Node& node(const PodOrNode* msg);
  static void set_has_node(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

const ::k8s::io::api::core::v1::Pod&
PodOrNode::_Internal::pod(const PodOrNode* msg) {
  return *msg->_impl_.pod_;
}
const ::k8s::io::api::core::v1::Node&
PodOrNode::_Internal::node(const PodOrNode* msg) {
  return *msg->_impl_.node_;
}
PodOrNode::PodOrNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.PodOrNode)
}
PodOrNode::PodOrNode(const PodOrNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PodOrNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pod_){nullptr}
    , decltype(_impl_.node_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_pod()) {
    _this->_impl_.pod_ = new ::k8s::io::api::core::v1::Pod(*from._impl_.pod_);
  }
  if (from._internal_has_node()) {
    _this->_impl_.node_ = new ::k8s::io::api::core::v1::Node(*from._impl_.node_);
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.PodOrNode)
}

inline void PodOrNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pod_){nullptr}
    , decltype(_impl_.node_){nullptr}
  };
}

PodOrNode::~PodOrNode() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.PodOrNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PodOrNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.pod_;
  if (this != internal_default_instance()) delete _impl_.node_;
}

void PodOrNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PodOrNode::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.PodOrNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.pod_ != nullptr);
      _impl_.pod_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.node_ != nullptr);
      _impl_.node_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PodOrNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .k8s.io.api.core.v1.Pod pod = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_pod(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .k8s.io.api.core.v1.Node node = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_node(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PodOrNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.PodOrNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .k8s.io.api.core.v1.Pod pod = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::pod(this),
        _Internal::pod(this).GetCachedSize(), target, stream);
  }

  // required .k8s.io.api.core.v1.Node node = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::node(this),
        _Internal::node(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.PodOrNode)
  return target;
}

size_t PodOrNode::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:k8s.io.api.core.v1.PodOrNode)
  size_t total_size = 0;

  if (_internal_has_pod()) {
    // required .k8s.io.api.core.v1.Pod pod = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.pod_);
  }

  if (_internal_has_node()) {
    // required .k8s.io.api.core.v1.Node node = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.node_);
  }

  return total_size;
}
size_t PodOrNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.PodOrNode)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .k8s.io.api.core.v1.Pod pod = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.pod_);

    // required .k8s.io.api.core.v1.Node node = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.node_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PodOrNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PodOrNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PodOrNode::GetClassData() const { return &_class_data_; }


void PodOrNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PodOrNode*>(&to_msg);
  auto& from = static_cast<const PodOrNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.PodOrNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_pod()->::k8s::io::api::core::v1::Pod::MergeFrom(
          from._internal_pod());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_node()->::k8s::io::api::core::v1::Node::MergeFrom(
          from._internal_node());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PodOrNode::CopyFrom(const PodOrNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.PodOrNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PodOrNode::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void PodOrNode::InternalSwap(PodOrNode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PodOrNode, _impl_.node_)
      + sizeof(PodOrNode::_impl_.node_)
      - PROTOBUF_FIELD_OFFSET(PodOrNode, _impl_.pod_)>(
          reinterpret_cast<char*>(&_impl_.pod_),
          reinterpret_cast<char*>(&other->_impl_.pod_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PodOrNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[0]);
}

// ===================================================================

class AWSElasticBlockStoreVolumeSource::_Internal {
 public:
  using HasBits = decltype(std::declval<AWSElasticBlockStoreVolumeSource>()._impl_._has_bits_);
  static void set_has_volumeid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_fstype(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_partition(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_readonly(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

AWSElasticBlockStoreVolumeSource::AWSElasticBlockStoreVolumeSource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.AWSElasticBlockStoreVolumeSource)
}
AWSElasticBlockStoreVolumeSource::AWSElasticBlockStoreVolumeSource(const AWSElasticBlockStoreVolumeSource& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AWSElasticBlockStoreVolumeSource* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.volumeid_){}
    , decltype(_impl_.fstype_){}
    , decltype(_impl_.partition_){}
    , decltype(_impl_.readonly_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.volumeid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.volumeid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_volumeid()) {
    _this->_impl_.volumeid_.Set(from._internal_volumeid(), 
      _this->GetArenaForAllocation());
  }
  _impl_.fstype_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fstype_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_fstype()) {
    _this->_impl_.fstype_.Set(from._internal_fstype(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.partition_, &from._impl_.partition_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.readonly_) -
    reinterpret_cast<char*>(&_impl_.partition_)) + sizeof(_impl_.readonly_));
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.AWSElasticBlockStoreVolumeSource)
}

inline void AWSElasticBlockStoreVolumeSource::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.volumeid_){}
    , decltype(_impl_.fstype_){}
    , decltype(_impl_.partition_){0}
    , decltype(_impl_.readonly_){false}
  };
  _impl_.volumeid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.volumeid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.fstype_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fstype_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AWSElasticBlockStoreVolumeSource::~AWSElasticBlockStoreVolumeSource() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.AWSElasticBlockStoreVolumeSource)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AWSElasticBlockStoreVolumeSource::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.volumeid_.Destroy();
  _impl_.fstype_.Destroy();
}

void AWSElasticBlockStoreVolumeSource::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AWSElasticBlockStoreVolumeSource::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.AWSElasticBlockStoreVolumeSource)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.volumeid_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.fstype_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&_impl_.partition_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.readonly_) -
        reinterpret_cast<char*>(&_impl_.partition_)) + sizeof(_impl_.readonly_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AWSElasticBlockStoreVolumeSource::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes volumeID = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_volumeid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes fsType = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_fstype();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 partition = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_partition(&has_bits);
          _impl_.partition_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool readOnly = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_readonly(&has_bits);
          _impl_.readonly_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AWSElasticBlockStoreVolumeSource::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.AWSElasticBlockStoreVolumeSource)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes volumeID = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_volumeid(), target);
  }

  // optional bytes fsType = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_fstype(), target);
  }

  // optional int32 partition = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_partition(), target);
  }

  // optional bool readOnly = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_readonly(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.AWSElasticBlockStoreVolumeSource)
  return target;
}

size_t AWSElasticBlockStoreVolumeSource::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.AWSElasticBlockStoreVolumeSource)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional bytes volumeID = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_volumeid());
    }

    // optional bytes fsType = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_fstype());
    }

    // optional int32 partition = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_partition());
    }

    // optional bool readOnly = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AWSElasticBlockStoreVolumeSource::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AWSElasticBlockStoreVolumeSource::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AWSElasticBlockStoreVolumeSource::GetClassData() const { return &_class_data_; }


void AWSElasticBlockStoreVolumeSource::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AWSElasticBlockStoreVolumeSource*>(&to_msg);
  auto& from = static_cast<const AWSElasticBlockStoreVolumeSource&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.AWSElasticBlockStoreVolumeSource)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_volumeid(from._internal_volumeid());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_fstype(from._internal_fstype());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.partition_ = from._impl_.partition_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.readonly_ = from._impl_.readonly_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AWSElasticBlockStoreVolumeSource::CopyFrom(const AWSElasticBlockStoreVolumeSource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.AWSElasticBlockStoreVolumeSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AWSElasticBlockStoreVolumeSource::IsInitialized() const {
  return true;
}

void AWSElasticBlockStoreVolumeSource::InternalSwap(AWSElasticBlockStoreVolumeSource* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.volumeid_, lhs_arena,
      &other->_impl_.volumeid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.fstype_, lhs_arena,
      &other->_impl_.fstype_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AWSElasticBlockStoreVolumeSource, _impl_.readonly_)
      + sizeof(AWSElasticBlockStoreVolumeSource::_impl_.readonly_)
      - PROTOBUF_FIELD_OFFSET(AWSElasticBlockStoreVolumeSource, _impl_.partition_)>(
          reinterpret_cast<char*>(&_impl_.partition_),
          reinterpret_cast<char*>(&other->_impl_.partition_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AWSElasticBlockStoreVolumeSource::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[1]);
}

// ===================================================================

class Affinity::_Internal {
 public:
  using HasBits = decltype(std::declval<Affinity>()._impl_._has_bits_);
  static const ::k8s::io::api::core::v1::NodeAffinity& nodeaffinity(const Affinity* msg);
  static void set_has_nodeaffinity(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::k8s::io::api::core::v1::PodAffinity& podaffinity(const Affinity* msg);
  static void set_has_podaffinity(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::k8s::io::api::core::v1::PodAntiAffinity& podantiaffinity(const Affinity* msg);
  static void set_has_podantiaffinity(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::k8s::io::api::core::v1::NodeAffinity&
Affinity::_Internal::nodeaffinity(const Affinity* msg) {
  return *msg->_impl_.nodeaffinity_;
}
const ::k8s::io::api::core::v1::PodAffinity&
Affinity::_Internal::podaffinity(const Affinity* msg) {
  return *msg->_impl_.podaffinity_;
}
const ::k8s::io::api::core::v1::PodAntiAffinity&
Affinity::_Internal::podantiaffinity(const Affinity* msg) {
  return *msg->_impl_.podantiaffinity_;
}
Affinity::Affinity(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.Affinity)
}
Affinity::Affinity(const Affinity& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Affinity* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.nodeaffinity_){nullptr}
    , decltype(_impl_.podaffinity_){nullptr}
    , decltype(_impl_.podantiaffinity_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_nodeaffinity()) {
    _this->_impl_.nodeaffinity_ = new ::k8s::io::api::core::v1::NodeAffinity(*from._impl_.nodeaffinity_);
  }
  if (from._internal_has_podaffinity()) {
    _this->_impl_.podaffinity_ = new ::k8s::io::api::core::v1::PodAffinity(*from._impl_.podaffinity_);
  }
  if (from._internal_has_podantiaffinity()) {
    _this->_impl_.podantiaffinity_ = new ::k8s::io::api::core::v1::PodAntiAffinity(*from._impl_.podantiaffinity_);
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.Affinity)
}

inline void Affinity::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.nodeaffinity_){nullptr}
    , decltype(_impl_.podaffinity_){nullptr}
    , decltype(_impl_.podantiaffinity_){nullptr}
  };
}

Affinity::~Affinity() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.Affinity)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Affinity::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.nodeaffinity_;
  if (this != internal_default_instance()) delete _impl_.podaffinity_;
  if (this != internal_default_instance()) delete _impl_.podantiaffinity_;
}

void Affinity::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Affinity::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.Affinity)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.nodeaffinity_ != nullptr);
      _impl_.nodeaffinity_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.podaffinity_ != nullptr);
      _impl_.podaffinity_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.podantiaffinity_ != nullptr);
      _impl_.podantiaffinity_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Affinity::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .k8s.io.api.core.v1.NodeAffinity nodeAffinity = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_nodeaffinity(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.PodAffinity podAffinity = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_podaffinity(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.PodAntiAffinity podAntiAffinity = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_podantiaffinity(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Affinity::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.Affinity)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .k8s.io.api.core.v1.NodeAffinity nodeAffinity = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::nodeaffinity(this),
        _Internal::nodeaffinity(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.PodAffinity podAffinity = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::podaffinity(this),
        _Internal::podaffinity(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.PodAntiAffinity podAntiAffinity = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::podantiaffinity(this),
        _Internal::podantiaffinity(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.Affinity)
  return target;
}

size_t Affinity::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.Affinity)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .k8s.io.api.core.v1.NodeAffinity nodeAffinity = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.nodeaffinity_);
    }

    // optional .k8s.io.api.core.v1.PodAffinity podAffinity = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.podaffinity_);
    }

    // optional .k8s.io.api.core.v1.PodAntiAffinity podAntiAffinity = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.podantiaffinity_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Affinity::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Affinity::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Affinity::GetClassData() const { return &_class_data_; }


void Affinity::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Affinity*>(&to_msg);
  auto& from = static_cast<const Affinity&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.Affinity)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_nodeaffinity()->::k8s::io::api::core::v1::NodeAffinity::MergeFrom(
          from._internal_nodeaffinity());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_podaffinity()->::k8s::io::api::core::v1::PodAffinity::MergeFrom(
          from._internal_podaffinity());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_podantiaffinity()->::k8s::io::api::core::v1::PodAntiAffinity::MergeFrom(
          from._internal_podantiaffinity());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Affinity::CopyFrom(const Affinity& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.Affinity)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Affinity::IsInitialized() const {
  return true;
}

void Affinity::InternalSwap(Affinity* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Affinity, _impl_.podantiaffinity_)
      + sizeof(Affinity::_impl_.podantiaffinity_)
      - PROTOBUF_FIELD_OFFSET(Affinity, _impl_.nodeaffinity_)>(
          reinterpret_cast<char*>(&_impl_.nodeaffinity_),
          reinterpret_cast<char*>(&other->_impl_.nodeaffinity_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Affinity::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[2]);
}

// ===================================================================

class AttachedVolume::_Internal {
 public:
  using HasBits = decltype(std::declval<AttachedVolume>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_devicepath(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

AttachedVolume::AttachedVolume(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.AttachedVolume)
}
AttachedVolume::AttachedVolume(const AttachedVolume& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AttachedVolume* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.devicepath_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.devicepath_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.devicepath_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_devicepath()) {
    _this->_impl_.devicepath_.Set(from._internal_devicepath(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.AttachedVolume)
}

inline void AttachedVolume::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.devicepath_){}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.devicepath_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.devicepath_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AttachedVolume::~AttachedVolume() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.AttachedVolume)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AttachedVolume::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.devicepath_.Destroy();
}

void AttachedVolume::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AttachedVolume::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.AttachedVolume)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.devicepath_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AttachedVolume::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes devicePath = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_devicepath();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AttachedVolume::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.AttachedVolume)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional bytes devicePath = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_devicepath(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.AttachedVolume)
  return target;
}

size_t AttachedVolume::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.AttachedVolume)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_name());
    }

    // optional bytes devicePath = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_devicepath());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AttachedVolume::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AttachedVolume::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AttachedVolume::GetClassData() const { return &_class_data_; }


void AttachedVolume::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AttachedVolume*>(&to_msg);
  auto& from = static_cast<const AttachedVolume&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.AttachedVolume)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_devicepath(from._internal_devicepath());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AttachedVolume::CopyFrom(const AttachedVolume& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.AttachedVolume)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AttachedVolume::IsInitialized() const {
  return true;
}

void AttachedVolume::InternalSwap(AttachedVolume* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.devicepath_, lhs_arena,
      &other->_impl_.devicepath_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata AttachedVolume::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[3]);
}

// ===================================================================

class AvoidPods::_Internal {
 public:
};

AvoidPods::AvoidPods(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.AvoidPods)
}
AvoidPods::AvoidPods(const AvoidPods& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AvoidPods* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.preferavoidpods_){from._impl_.preferavoidpods_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.AvoidPods)
}

inline void AvoidPods::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.preferavoidpods_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

AvoidPods::~AvoidPods() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.AvoidPods)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AvoidPods::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.preferavoidpods_.~RepeatedPtrField();
}

void AvoidPods::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AvoidPods::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.AvoidPods)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.preferavoidpods_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AvoidPods::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .k8s.io.api.core.v1.PreferAvoidPodsEntry preferAvoidPods = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_preferavoidpods(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AvoidPods::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.AvoidPods)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .k8s.io.api.core.v1.PreferAvoidPodsEntry preferAvoidPods = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_preferavoidpods_size()); i < n; i++) {
    const auto& repfield = this->_internal_preferavoidpods(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.AvoidPods)
  return target;
}

size_t AvoidPods::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.AvoidPods)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .k8s.io.api.core.v1.PreferAvoidPodsEntry preferAvoidPods = 1;
  total_size += 1UL * this->_internal_preferavoidpods_size();
  for (const auto& msg : this->_impl_.preferavoidpods_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AvoidPods::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AvoidPods::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AvoidPods::GetClassData() const { return &_class_data_; }


void AvoidPods::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AvoidPods*>(&to_msg);
  auto& from = static_cast<const AvoidPods&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.AvoidPods)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.preferavoidpods_.MergeFrom(from._impl_.preferavoidpods_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AvoidPods::CopyFrom(const AvoidPods& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.AvoidPods)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AvoidPods::IsInitialized() const {
  return true;
}

void AvoidPods::InternalSwap(AvoidPods* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.preferavoidpods_.InternalSwap(&other->_impl_.preferavoidpods_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AvoidPods::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[4]);
}

// ===================================================================

class AzureDiskVolumeSource::_Internal {
 public:
  using HasBits = decltype(std::declval<AzureDiskVolumeSource>()._impl_._has_bits_);
  static void set_has_diskname(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_diskuri(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_cachingmode(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_fstype(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_readonly(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_kind(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

AzureDiskVolumeSource::AzureDiskVolumeSource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.AzureDiskVolumeSource)
}
AzureDiskVolumeSource::AzureDiskVolumeSource(const AzureDiskVolumeSource& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AzureDiskVolumeSource* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.diskname_){}
    , decltype(_impl_.diskuri_){}
    , decltype(_impl_.cachingmode_){}
    , decltype(_impl_.fstype_){}
    , decltype(_impl_.kind_){}
    , decltype(_impl_.readonly_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.diskname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.diskname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_diskname()) {
    _this->_impl_.diskname_.Set(from._internal_diskname(), 
      _this->GetArenaForAllocation());
  }
  _impl_.diskuri_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.diskuri_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_diskuri()) {
    _this->_impl_.diskuri_.Set(from._internal_diskuri(), 
      _this->GetArenaForAllocation());
  }
  _impl_.cachingmode_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.cachingmode_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_cachingmode()) {
    _this->_impl_.cachingmode_.Set(from._internal_cachingmode(), 
      _this->GetArenaForAllocation());
  }
  _impl_.fstype_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fstype_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_fstype()) {
    _this->_impl_.fstype_.Set(from._internal_fstype(), 
      _this->GetArenaForAllocation());
  }
  _impl_.kind_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.kind_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_kind()) {
    _this->_impl_.kind_.Set(from._internal_kind(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.readonly_ = from._impl_.readonly_;
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.AzureDiskVolumeSource)
}

inline void AzureDiskVolumeSource::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.diskname_){}
    , decltype(_impl_.diskuri_){}
    , decltype(_impl_.cachingmode_){}
    , decltype(_impl_.fstype_){}
    , decltype(_impl_.kind_){}
    , decltype(_impl_.readonly_){false}
  };
  _impl_.diskname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.diskname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.diskuri_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.diskuri_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.cachingmode_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.cachingmode_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.fstype_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fstype_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.kind_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.kind_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AzureDiskVolumeSource::~AzureDiskVolumeSource() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.AzureDiskVolumeSource)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AzureDiskVolumeSource::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.diskname_.Destroy();
  _impl_.diskuri_.Destroy();
  _impl_.cachingmode_.Destroy();
  _impl_.fstype_.Destroy();
  _impl_.kind_.Destroy();
}

void AzureDiskVolumeSource::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AzureDiskVolumeSource::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.AzureDiskVolumeSource)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.diskname_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.diskuri_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.cachingmode_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.fstype_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.kind_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.readonly_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AzureDiskVolumeSource::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes diskName = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_diskname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes diskURI = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_diskuri();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes cachingMode = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_cachingmode();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes fsType = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_fstype();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool readOnly = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_readonly(&has_bits);
          _impl_.readonly_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes kind = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_kind();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AzureDiskVolumeSource::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.AzureDiskVolumeSource)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes diskName = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_diskname(), target);
  }

  // optional bytes diskURI = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_diskuri(), target);
  }

  // optional bytes cachingMode = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_cachingmode(), target);
  }

  // optional bytes fsType = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_fstype(), target);
  }

  // optional bool readOnly = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_readonly(), target);
  }

  // optional bytes kind = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteBytesMaybeAliased(
        6, this->_internal_kind(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.AzureDiskVolumeSource)
  return target;
}

size_t AzureDiskVolumeSource::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.AzureDiskVolumeSource)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional bytes diskName = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_diskname());
    }

    // optional bytes diskURI = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_diskuri());
    }

    // optional bytes cachingMode = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_cachingmode());
    }

    // optional bytes fsType = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_fstype());
    }

    // optional bytes kind = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_kind());
    }

    // optional bool readOnly = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AzureDiskVolumeSource::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AzureDiskVolumeSource::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AzureDiskVolumeSource::GetClassData() const { return &_class_data_; }


void AzureDiskVolumeSource::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AzureDiskVolumeSource*>(&to_msg);
  auto& from = static_cast<const AzureDiskVolumeSource&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.AzureDiskVolumeSource)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_diskname(from._internal_diskname());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_diskuri(from._internal_diskuri());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_cachingmode(from._internal_cachingmode());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_fstype(from._internal_fstype());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_kind(from._internal_kind());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.readonly_ = from._impl_.readonly_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AzureDiskVolumeSource::CopyFrom(const AzureDiskVolumeSource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.AzureDiskVolumeSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AzureDiskVolumeSource::IsInitialized() const {
  return true;
}

void AzureDiskVolumeSource::InternalSwap(AzureDiskVolumeSource* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.diskname_, lhs_arena,
      &other->_impl_.diskname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.diskuri_, lhs_arena,
      &other->_impl_.diskuri_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.cachingmode_, lhs_arena,
      &other->_impl_.cachingmode_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.fstype_, lhs_arena,
      &other->_impl_.fstype_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.kind_, lhs_arena,
      &other->_impl_.kind_, rhs_arena
  );
  swap(_impl_.readonly_, other->_impl_.readonly_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AzureDiskVolumeSource::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[5]);
}

// ===================================================================

class AzureFilePersistentVolumeSource::_Internal {
 public:
  using HasBits = decltype(std::declval<AzureFilePersistentVolumeSource>()._impl_._has_bits_);
  static void set_has_secretname(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_sharename(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_readonly(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_secretnamespace(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

AzureFilePersistentVolumeSource::AzureFilePersistentVolumeSource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.AzureFilePersistentVolumeSource)
}
AzureFilePersistentVolumeSource::AzureFilePersistentVolumeSource(const AzureFilePersistentVolumeSource& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AzureFilePersistentVolumeSource* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.secretname_){}
    , decltype(_impl_.sharename_){}
    , decltype(_impl_.secretnamespace_){}
    , decltype(_impl_.readonly_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.secretname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.secretname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_secretname()) {
    _this->_impl_.secretname_.Set(from._internal_secretname(), 
      _this->GetArenaForAllocation());
  }
  _impl_.sharename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sharename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_sharename()) {
    _this->_impl_.sharename_.Set(from._internal_sharename(), 
      _this->GetArenaForAllocation());
  }
  _impl_.secretnamespace_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.secretnamespace_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_secretnamespace()) {
    _this->_impl_.secretnamespace_.Set(from._internal_secretnamespace(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.readonly_ = from._impl_.readonly_;
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.AzureFilePersistentVolumeSource)
}

inline void AzureFilePersistentVolumeSource::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.secretname_){}
    , decltype(_impl_.sharename_){}
    , decltype(_impl_.secretnamespace_){}
    , decltype(_impl_.readonly_){false}
  };
  _impl_.secretname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.secretname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.sharename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sharename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.secretnamespace_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.secretnamespace_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AzureFilePersistentVolumeSource::~AzureFilePersistentVolumeSource() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.AzureFilePersistentVolumeSource)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AzureFilePersistentVolumeSource::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.secretname_.Destroy();
  _impl_.sharename_.Destroy();
  _impl_.secretnamespace_.Destroy();
}

void AzureFilePersistentVolumeSource::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AzureFilePersistentVolumeSource::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.AzureFilePersistentVolumeSource)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.secretname_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.sharename_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.secretnamespace_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.readonly_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AzureFilePersistentVolumeSource::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes secretName = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_secretname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes shareName = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_sharename();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool readOnly = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_readonly(&has_bits);
          _impl_.readonly_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes secretNamespace = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_secretnamespace();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AzureFilePersistentVolumeSource::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.AzureFilePersistentVolumeSource)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes secretName = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_secretname(), target);
  }

  // optional bytes shareName = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_sharename(), target);
  }

  // optional bool readOnly = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_readonly(), target);
  }

  // optional bytes secretNamespace = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_secretnamespace(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.AzureFilePersistentVolumeSource)
  return target;
}

size_t AzureFilePersistentVolumeSource::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.AzureFilePersistentVolumeSource)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional bytes secretName = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_secretname());
    }

    // optional bytes shareName = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_sharename());
    }

    // optional bytes secretNamespace = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_secretnamespace());
    }

    // optional bool readOnly = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AzureFilePersistentVolumeSource::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AzureFilePersistentVolumeSource::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AzureFilePersistentVolumeSource::GetClassData() const { return &_class_data_; }


void AzureFilePersistentVolumeSource::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AzureFilePersistentVolumeSource*>(&to_msg);
  auto& from = static_cast<const AzureFilePersistentVolumeSource&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.AzureFilePersistentVolumeSource)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_secretname(from._internal_secretname());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_sharename(from._internal_sharename());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_secretnamespace(from._internal_secretnamespace());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.readonly_ = from._impl_.readonly_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AzureFilePersistentVolumeSource::CopyFrom(const AzureFilePersistentVolumeSource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.AzureFilePersistentVolumeSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AzureFilePersistentVolumeSource::IsInitialized() const {
  return true;
}

void AzureFilePersistentVolumeSource::InternalSwap(AzureFilePersistentVolumeSource* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.secretname_, lhs_arena,
      &other->_impl_.secretname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.sharename_, lhs_arena,
      &other->_impl_.sharename_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.secretnamespace_, lhs_arena,
      &other->_impl_.secretnamespace_, rhs_arena
  );
  swap(_impl_.readonly_, other->_impl_.readonly_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AzureFilePersistentVolumeSource::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[6]);
}

// ===================================================================

class AzureFileVolumeSource::_Internal {
 public:
  using HasBits = decltype(std::declval<AzureFileVolumeSource>()._impl_._has_bits_);
  static void set_has_secretname(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_sharename(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_readonly(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

AzureFileVolumeSource::AzureFileVolumeSource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.AzureFileVolumeSource)
}
AzureFileVolumeSource::AzureFileVolumeSource(const AzureFileVolumeSource& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AzureFileVolumeSource* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.secretname_){}
    , decltype(_impl_.sharename_){}
    , decltype(_impl_.readonly_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.secretname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.secretname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_secretname()) {
    _this->_impl_.secretname_.Set(from._internal_secretname(), 
      _this->GetArenaForAllocation());
  }
  _impl_.sharename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sharename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_sharename()) {
    _this->_impl_.sharename_.Set(from._internal_sharename(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.readonly_ = from._impl_.readonly_;
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.AzureFileVolumeSource)
}

inline void AzureFileVolumeSource::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.secretname_){}
    , decltype(_impl_.sharename_){}
    , decltype(_impl_.readonly_){false}
  };
  _impl_.secretname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.secretname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.sharename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sharename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AzureFileVolumeSource::~AzureFileVolumeSource() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.AzureFileVolumeSource)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AzureFileVolumeSource::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.secretname_.Destroy();
  _impl_.sharename_.Destroy();
}

void AzureFileVolumeSource::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AzureFileVolumeSource::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.AzureFileVolumeSource)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.secretname_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.sharename_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.readonly_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AzureFileVolumeSource::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes secretName = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_secretname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes shareName = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_sharename();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool readOnly = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_readonly(&has_bits);
          _impl_.readonly_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AzureFileVolumeSource::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.AzureFileVolumeSource)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes secretName = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_secretname(), target);
  }

  // optional bytes shareName = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_sharename(), target);
  }

  // optional bool readOnly = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_readonly(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.AzureFileVolumeSource)
  return target;
}

size_t AzureFileVolumeSource::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.AzureFileVolumeSource)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bytes secretName = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_secretname());
    }

    // optional bytes shareName = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_sharename());
    }

    // optional bool readOnly = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AzureFileVolumeSource::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AzureFileVolumeSource::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AzureFileVolumeSource::GetClassData() const { return &_class_data_; }


void AzureFileVolumeSource::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AzureFileVolumeSource*>(&to_msg);
  auto& from = static_cast<const AzureFileVolumeSource&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.AzureFileVolumeSource)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_secretname(from._internal_secretname());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_sharename(from._internal_sharename());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.readonly_ = from._impl_.readonly_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AzureFileVolumeSource::CopyFrom(const AzureFileVolumeSource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.AzureFileVolumeSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AzureFileVolumeSource::IsInitialized() const {
  return true;
}

void AzureFileVolumeSource::InternalSwap(AzureFileVolumeSource* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.secretname_, lhs_arena,
      &other->_impl_.secretname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.sharename_, lhs_arena,
      &other->_impl_.sharename_, rhs_arena
  );
  swap(_impl_.readonly_, other->_impl_.readonly_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AzureFileVolumeSource::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[7]);
}

// ===================================================================

class Binding::_Internal {
 public:
  using HasBits = decltype(std::declval<Binding>()._impl_._has_bits_);
  static const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& metadata(const Binding* msg);
  static void set_has_metadata(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::k8s::io::api::core::v1::ObjectReference& target(const Binding* msg);
  static void set_has_target(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta&
Binding::_Internal::metadata(const Binding* msg) {
  return *msg->_impl_.metadata_;
}
const ::k8s::io::api::core::v1::ObjectReference&
Binding::_Internal::target(const Binding* msg) {
  return *msg->_impl_.target_;
}
void Binding::clear_metadata() {
  if (_impl_.metadata_ != nullptr) _impl_.metadata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
Binding::Binding(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.Binding)
}
Binding::Binding(const Binding& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Binding* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.metadata_){nullptr}
    , decltype(_impl_.target_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_metadata()) {
    _this->_impl_.metadata_ = new ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta(*from._impl_.metadata_);
  }
  if (from._internal_has_target()) {
    _this->_impl_.target_ = new ::k8s::io::api::core::v1::ObjectReference(*from._impl_.target_);
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.Binding)
}

inline void Binding::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.metadata_){nullptr}
    , decltype(_impl_.target_){nullptr}
  };
}

Binding::~Binding() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.Binding)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Binding::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.metadata_;
  if (this != internal_default_instance()) delete _impl_.target_;
}

void Binding::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Binding::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.Binding)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.metadata_ != nullptr);
      _impl_.metadata_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.target_ != nullptr);
      _impl_.target_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Binding::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_metadata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.ObjectReference target = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_target(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Binding::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.Binding)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::metadata(this),
        _Internal::metadata(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.ObjectReference target = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::target(this),
        _Internal::target(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.Binding)
  return target;
}

size_t Binding::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.Binding)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.metadata_);
    }

    // optional .k8s.io.api.core.v1.ObjectReference target = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.target_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Binding::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Binding::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Binding::GetClassData() const { return &_class_data_; }


void Binding::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Binding*>(&to_msg);
  auto& from = static_cast<const Binding&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.Binding)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_metadata()->::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta::MergeFrom(
          from._internal_metadata());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_target()->::k8s::io::api::core::v1::ObjectReference::MergeFrom(
          from._internal_target());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Binding::CopyFrom(const Binding& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.Binding)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Binding::IsInitialized() const {
  return true;
}

void Binding::InternalSwap(Binding* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Binding, _impl_.target_)
      + sizeof(Binding::_impl_.target_)
      - PROTOBUF_FIELD_OFFSET(Binding, _impl_.metadata_)>(
          reinterpret_cast<char*>(&_impl_.metadata_),
          reinterpret_cast<char*>(&other->_impl_.metadata_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Binding::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[8]);
}

// ===================================================================

CSIPersistentVolumeSource_VolumeAttributesEntry_DoNotUse::CSIPersistentVolumeSource_VolumeAttributesEntry_DoNotUse() {}
CSIPersistentVolumeSource_VolumeAttributesEntry_DoNotUse::CSIPersistentVolumeSource_VolumeAttributesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void CSIPersistentVolumeSource_VolumeAttributesEntry_DoNotUse::MergeFrom(const CSIPersistentVolumeSource_VolumeAttributesEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata CSIPersistentVolumeSource_VolumeAttributesEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[9]);
}

// ===================================================================

class CSIPersistentVolumeSource::_Internal {
 public:
  using HasBits = decltype(std::declval<CSIPersistentVolumeSource>()._impl_._has_bits_);
  static void set_has_driver(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_volumehandle(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_readonly(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_fstype(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::k8s::io::api::core::v1::SecretReference& controllerpublishsecretref(const CSIPersistentVolumeSource* msg);
  static void set_has_controllerpublishsecretref(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::k8s::io::api::core::v1::SecretReference& nodestagesecretref(const CSIPersistentVolumeSource* msg);
  static void set_has_nodestagesecretref(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::k8s::io::api::core::v1::SecretReference& nodepublishsecretref(const CSIPersistentVolumeSource* msg);
  static void set_has_nodepublishsecretref(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::k8s::io::api::core::v1::SecretReference& controllerexpandsecretref(const CSIPersistentVolumeSource* msg);
  static void set_has_controllerexpandsecretref(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::k8s::io::api::core::v1::SecretReference& nodeexpandsecretref(const CSIPersistentVolumeSource* msg);
  static void set_has_nodeexpandsecretref(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

const ::k8s::io::api::core::v1::SecretReference&
CSIPersistentVolumeSource::_Internal::controllerpublishsecretref(const CSIPersistentVolumeSource* msg) {
  return *msg->_impl_.controllerpublishsecretref_;
}
const ::k8s::io::api::core::v1::SecretReference&
CSIPersistentVolumeSource::_Internal::nodestagesecretref(const CSIPersistentVolumeSource* msg) {
  return *msg->_impl_.nodestagesecretref_;
}
const ::k8s::io::api::core::v1::SecretReference&
CSIPersistentVolumeSource::_Internal::nodepublishsecretref(const CSIPersistentVolumeSource* msg) {
  return *msg->_impl_.nodepublishsecretref_;
}
const ::k8s::io::api::core::v1::SecretReference&
CSIPersistentVolumeSource::_Internal::controllerexpandsecretref(const CSIPersistentVolumeSource* msg) {
  return *msg->_impl_.controllerexpandsecretref_;
}
const ::k8s::io::api::core::v1::SecretReference&
CSIPersistentVolumeSource::_Internal::nodeexpandsecretref(const CSIPersistentVolumeSource* msg) {
  return *msg->_impl_.nodeexpandsecretref_;
}
CSIPersistentVolumeSource::CSIPersistentVolumeSource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &CSIPersistentVolumeSource::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.CSIPersistentVolumeSource)
}
CSIPersistentVolumeSource::CSIPersistentVolumeSource(const CSIPersistentVolumeSource& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSIPersistentVolumeSource* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_.volumeattributes_)*/{}
    , decltype(_impl_.driver_){}
    , decltype(_impl_.volumehandle_){}
    , decltype(_impl_.fstype_){}
    , decltype(_impl_.controllerpublishsecretref_){nullptr}
    , decltype(_impl_.nodestagesecretref_){nullptr}
    , decltype(_impl_.nodepublishsecretref_){nullptr}
    , decltype(_impl_.controllerexpandsecretref_){nullptr}
    , decltype(_impl_.nodeexpandsecretref_){nullptr}
    , decltype(_impl_.readonly_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.volumeattributes_.MergeFrom(from._impl_.volumeattributes_);
  _impl_.driver_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.driver_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_driver()) {
    _this->_impl_.driver_.Set(from._internal_driver(), 
      _this->GetArenaForAllocation());
  }
  _impl_.volumehandle_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.volumehandle_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_volumehandle()) {
    _this->_impl_.volumehandle_.Set(from._internal_volumehandle(), 
      _this->GetArenaForAllocation());
  }
  _impl_.fstype_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fstype_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_fstype()) {
    _this->_impl_.fstype_.Set(from._internal_fstype(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_controllerpublishsecretref()) {
    _this->_impl_.controllerpublishsecretref_ = new ::k8s::io::api::core::v1::SecretReference(*from._impl_.controllerpublishsecretref_);
  }
  if (from._internal_has_nodestagesecretref()) {
    _this->_impl_.nodestagesecretref_ = new ::k8s::io::api::core::v1::SecretReference(*from._impl_.nodestagesecretref_);
  }
  if (from._internal_has_nodepublishsecretref()) {
    _this->_impl_.nodepublishsecretref_ = new ::k8s::io::api::core::v1::SecretReference(*from._impl_.nodepublishsecretref_);
  }
  if (from._internal_has_controllerexpandsecretref()) {
    _this->_impl_.controllerexpandsecretref_ = new ::k8s::io::api::core::v1::SecretReference(*from._impl_.controllerexpandsecretref_);
  }
  if (from._internal_has_nodeexpandsecretref()) {
    _this->_impl_.nodeexpandsecretref_ = new ::k8s::io::api::core::v1::SecretReference(*from._impl_.nodeexpandsecretref_);
  }
  _this->_impl_.readonly_ = from._impl_.readonly_;
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.CSIPersistentVolumeSource)
}

inline void CSIPersistentVolumeSource::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_.volumeattributes_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.driver_){}
    , decltype(_impl_.volumehandle_){}
    , decltype(_impl_.fstype_){}
    , decltype(_impl_.controllerpublishsecretref_){nullptr}
    , decltype(_impl_.nodestagesecretref_){nullptr}
    , decltype(_impl_.nodepublishsecretref_){nullptr}
    , decltype(_impl_.controllerexpandsecretref_){nullptr}
    , decltype(_impl_.nodeexpandsecretref_){nullptr}
    , decltype(_impl_.readonly_){false}
  };
  _impl_.driver_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.driver_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.volumehandle_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.volumehandle_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.fstype_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fstype_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CSIPersistentVolumeSource::~CSIPersistentVolumeSource() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.CSIPersistentVolumeSource)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void CSIPersistentVolumeSource::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.volumeattributes_.Destruct();
  _impl_.volumeattributes_.~MapField();
  _impl_.driver_.Destroy();
  _impl_.volumehandle_.Destroy();
  _impl_.fstype_.Destroy();
  if (this != internal_default_instance()) delete _impl_.controllerpublishsecretref_;
  if (this != internal_default_instance()) delete _impl_.nodestagesecretref_;
  if (this != internal_default_instance()) delete _impl_.nodepublishsecretref_;
  if (this != internal_default_instance()) delete _impl_.controllerexpandsecretref_;
  if (this != internal_default_instance()) delete _impl_.nodeexpandsecretref_;
}

void CSIPersistentVolumeSource::ArenaDtor(void* object) {
  CSIPersistentVolumeSource* _this = reinterpret_cast< CSIPersistentVolumeSource* >(object);
  _this->_impl_.volumeattributes_.Destruct();
}
void CSIPersistentVolumeSource::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSIPersistentVolumeSource::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.CSIPersistentVolumeSource)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.volumeattributes_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.driver_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.volumehandle_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.fstype_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.controllerpublishsecretref_ != nullptr);
      _impl_.controllerpublishsecretref_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.nodestagesecretref_ != nullptr);
      _impl_.nodestagesecretref_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.nodepublishsecretref_ != nullptr);
      _impl_.nodepublishsecretref_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(_impl_.controllerexpandsecretref_ != nullptr);
      _impl_.controllerexpandsecretref_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(_impl_.nodeexpandsecretref_ != nullptr);
      _impl_.nodeexpandsecretref_->Clear();
    }
  }
  _impl_.readonly_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSIPersistentVolumeSource::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes driver = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_driver();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes volumeHandle = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_volumehandle();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool readOnly = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_readonly(&has_bits);
          _impl_.readonly_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes fsType = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_fstype();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // map<string, string> volumeAttributes = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.volumeattributes_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.SecretReference controllerPublishSecretRef = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_controllerpublishsecretref(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.SecretReference nodeStageSecretRef = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_nodestagesecretref(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.SecretReference nodePublishSecretRef = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_nodepublishsecretref(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.SecretReference controllerExpandSecretRef = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_controllerexpandsecretref(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.SecretReference nodeExpandSecretRef = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_nodeexpandsecretref(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSIPersistentVolumeSource::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.CSIPersistentVolumeSource)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes driver = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_driver(), target);
  }

  // optional bytes volumeHandle = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_volumehandle(), target);
  }

  // optional bool readOnly = 3;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_readonly(), target);
  }

  // optional bytes fsType = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_fstype(), target);
  }

  // map<string, string> volumeAttributes = 5;
  if (!this->_internal_volumeattributes().empty()) {
    using MapType = ::_pb::Map<std::string, std::string>;
    using WireHelper = CSIPersistentVolumeSource_VolumeAttributesEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_volumeattributes();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "k8s.io.api.core.v1.CSIPersistentVolumeSource.VolumeAttributesEntry.key");
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        entry.second.data(), static_cast<int>(entry.second.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "k8s.io.api.core.v1.CSIPersistentVolumeSource.VolumeAttributesEntry.value");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(5, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(5, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  // optional .k8s.io.api.core.v1.SecretReference controllerPublishSecretRef = 6;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::controllerpublishsecretref(this),
        _Internal::controllerpublishsecretref(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.SecretReference nodeStageSecretRef = 7;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::nodestagesecretref(this),
        _Internal::nodestagesecretref(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.SecretReference nodePublishSecretRef = 8;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::nodepublishsecretref(this),
        _Internal::nodepublishsecretref(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.SecretReference controllerExpandSecretRef = 9;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::controllerexpandsecretref(this),
        _Internal::controllerexpandsecretref(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.SecretReference nodeExpandSecretRef = 10;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::nodeexpandsecretref(this),
        _Internal::nodeexpandsecretref(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.CSIPersistentVolumeSource)
  return target;
}

size_t CSIPersistentVolumeSource::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.CSIPersistentVolumeSource)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, string> volumeAttributes = 5;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_volumeattributes_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
      it = this->_internal_volumeattributes().begin();
      it != this->_internal_volumeattributes().end(); ++it) {
    total_size += CSIPersistentVolumeSource_VolumeAttributesEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bytes driver = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_driver());
    }

    // optional bytes volumeHandle = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_volumehandle());
    }

    // optional bytes fsType = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_fstype());
    }

    // optional .k8s.io.api.core.v1.SecretReference controllerPublishSecretRef = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.controllerpublishsecretref_);
    }

    // optional .k8s.io.api.core.v1.SecretReference nodeStageSecretRef = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.nodestagesecretref_);
    }

    // optional .k8s.io.api.core.v1.SecretReference nodePublishSecretRef = 8;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.nodepublishsecretref_);
    }

    // optional .k8s.io.api.core.v1.SecretReference controllerExpandSecretRef = 9;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.controllerexpandsecretref_);
    }

    // optional .k8s.io.api.core.v1.SecretReference nodeExpandSecretRef = 10;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.nodeexpandsecretref_);
    }

  }
  // optional bool readOnly = 3;
  if (cached_has_bits & 0x00000100u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSIPersistentVolumeSource::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSIPersistentVolumeSource::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSIPersistentVolumeSource::GetClassData() const { return &_class_data_; }


void CSIPersistentVolumeSource::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSIPersistentVolumeSource*>(&to_msg);
  auto& from = static_cast<const CSIPersistentVolumeSource&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.CSIPersistentVolumeSource)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.volumeattributes_.MergeFrom(from._impl_.volumeattributes_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_driver(from._internal_driver());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_volumehandle(from._internal_volumehandle());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_fstype(from._internal_fstype());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_controllerpublishsecretref()->::k8s::io::api::core::v1::SecretReference::MergeFrom(
          from._internal_controllerpublishsecretref());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_nodestagesecretref()->::k8s::io::api::core::v1::SecretReference::MergeFrom(
          from._internal_nodestagesecretref());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_nodepublishsecretref()->::k8s::io::api::core::v1::SecretReference::MergeFrom(
          from._internal_nodepublishsecretref());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_controllerexpandsecretref()->::k8s::io::api::core::v1::SecretReference::MergeFrom(
          from._internal_controllerexpandsecretref());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_mutable_nodeexpandsecretref()->::k8s::io::api::core::v1::SecretReference::MergeFrom(
          from._internal_nodeexpandsecretref());
    }
  }
  if (cached_has_bits & 0x00000100u) {
    _this->_internal_set_readonly(from._internal_readonly());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSIPersistentVolumeSource::CopyFrom(const CSIPersistentVolumeSource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.CSIPersistentVolumeSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSIPersistentVolumeSource::IsInitialized() const {
  return true;
}

void CSIPersistentVolumeSource::InternalSwap(CSIPersistentVolumeSource* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.volumeattributes_.InternalSwap(&other->_impl_.volumeattributes_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.driver_, lhs_arena,
      &other->_impl_.driver_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.volumehandle_, lhs_arena,
      &other->_impl_.volumehandle_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.fstype_, lhs_arena,
      &other->_impl_.fstype_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSIPersistentVolumeSource, _impl_.readonly_)
      + sizeof(CSIPersistentVolumeSource::_impl_.readonly_)
      - PROTOBUF_FIELD_OFFSET(CSIPersistentVolumeSource, _impl_.controllerpublishsecretref_)>(
          reinterpret_cast<char*>(&_impl_.controllerpublishsecretref_),
          reinterpret_cast<char*>(&other->_impl_.controllerpublishsecretref_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CSIPersistentVolumeSource::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[10]);
}

// ===================================================================

CSIVolumeSource_VolumeAttributesEntry_DoNotUse::CSIVolumeSource_VolumeAttributesEntry_DoNotUse() {}
CSIVolumeSource_VolumeAttributesEntry_DoNotUse::CSIVolumeSource_VolumeAttributesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void CSIVolumeSource_VolumeAttributesEntry_DoNotUse::MergeFrom(const CSIVolumeSource_VolumeAttributesEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata CSIVolumeSource_VolumeAttributesEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[11]);
}

// ===================================================================

class CSIVolumeSource::_Internal {
 public:
  using HasBits = decltype(std::declval<CSIVolumeSource>()._impl_._has_bits_);
  static void set_has_driver(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_readonly(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_fstype(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::k8s::io::api::core::v1::LocalObjectReference& nodepublishsecretref(const CSIVolumeSource* msg);
  static void set_has_nodepublishsecretref(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::k8s::io::api::core::v1::LocalObjectReference&
CSIVolumeSource::_Internal::nodepublishsecretref(const CSIVolumeSource* msg) {
  return *msg->_impl_.nodepublishsecretref_;
}
CSIVolumeSource::CSIVolumeSource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &CSIVolumeSource::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.CSIVolumeSource)
}
CSIVolumeSource::CSIVolumeSource(const CSIVolumeSource& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSIVolumeSource* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_.volumeattributes_)*/{}
    , decltype(_impl_.driver_){}
    , decltype(_impl_.fstype_){}
    , decltype(_impl_.nodepublishsecretref_){nullptr}
    , decltype(_impl_.readonly_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.volumeattributes_.MergeFrom(from._impl_.volumeattributes_);
  _impl_.driver_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.driver_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_driver()) {
    _this->_impl_.driver_.Set(from._internal_driver(), 
      _this->GetArenaForAllocation());
  }
  _impl_.fstype_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fstype_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_fstype()) {
    _this->_impl_.fstype_.Set(from._internal_fstype(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_nodepublishsecretref()) {
    _this->_impl_.nodepublishsecretref_ = new ::k8s::io::api::core::v1::LocalObjectReference(*from._impl_.nodepublishsecretref_);
  }
  _this->_impl_.readonly_ = from._impl_.readonly_;
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.CSIVolumeSource)
}

inline void CSIVolumeSource::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_.volumeattributes_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.driver_){}
    , decltype(_impl_.fstype_){}
    , decltype(_impl_.nodepublishsecretref_){nullptr}
    , decltype(_impl_.readonly_){false}
  };
  _impl_.driver_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.driver_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.fstype_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fstype_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CSIVolumeSource::~CSIVolumeSource() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.CSIVolumeSource)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void CSIVolumeSource::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.volumeattributes_.Destruct();
  _impl_.volumeattributes_.~MapField();
  _impl_.driver_.Destroy();
  _impl_.fstype_.Destroy();
  if (this != internal_default_instance()) delete _impl_.nodepublishsecretref_;
}

void CSIVolumeSource::ArenaDtor(void* object) {
  CSIVolumeSource* _this = reinterpret_cast< CSIVolumeSource* >(object);
  _this->_impl_.volumeattributes_.Destruct();
}
void CSIVolumeSource::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSIVolumeSource::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.CSIVolumeSource)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.volumeattributes_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.driver_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.fstype_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.nodepublishsecretref_ != nullptr);
      _impl_.nodepublishsecretref_->Clear();
    }
  }
  _impl_.readonly_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSIVolumeSource::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes driver = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_driver();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool readOnly = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_readonly(&has_bits);
          _impl_.readonly_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes fsType = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_fstype();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // map<string, string> volumeAttributes = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.volumeattributes_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.LocalObjectReference nodePublishSecretRef = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_nodepublishsecretref(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSIVolumeSource::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.CSIVolumeSource)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes driver = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_driver(), target);
  }

  // optional bool readOnly = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_readonly(), target);
  }

  // optional bytes fsType = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_fstype(), target);
  }

  // map<string, string> volumeAttributes = 4;
  if (!this->_internal_volumeattributes().empty()) {
    using MapType = ::_pb::Map<std::string, std::string>;
    using WireHelper = CSIVolumeSource_VolumeAttributesEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_volumeattributes();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "k8s.io.api.core.v1.CSIVolumeSource.VolumeAttributesEntry.key");
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        entry.second.data(), static_cast<int>(entry.second.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "k8s.io.api.core.v1.CSIVolumeSource.VolumeAttributesEntry.value");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(4, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(4, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  // optional .k8s.io.api.core.v1.LocalObjectReference nodePublishSecretRef = 5;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::nodepublishsecretref(this),
        _Internal::nodepublishsecretref(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.CSIVolumeSource)
  return target;
}

size_t CSIVolumeSource::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.CSIVolumeSource)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, string> volumeAttributes = 4;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_volumeattributes_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
      it = this->_internal_volumeattributes().begin();
      it != this->_internal_volumeattributes().end(); ++it) {
    total_size += CSIVolumeSource_VolumeAttributesEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional bytes driver = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_driver());
    }

    // optional bytes fsType = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_fstype());
    }

    // optional .k8s.io.api.core.v1.LocalObjectReference nodePublishSecretRef = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.nodepublishsecretref_);
    }

    // optional bool readOnly = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSIVolumeSource::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSIVolumeSource::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSIVolumeSource::GetClassData() const { return &_class_data_; }


void CSIVolumeSource::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSIVolumeSource*>(&to_msg);
  auto& from = static_cast<const CSIVolumeSource&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.CSIVolumeSource)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.volumeattributes_.MergeFrom(from._impl_.volumeattributes_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_driver(from._internal_driver());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_fstype(from._internal_fstype());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_nodepublishsecretref()->::k8s::io::api::core::v1::LocalObjectReference::MergeFrom(
          from._internal_nodepublishsecretref());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.readonly_ = from._impl_.readonly_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSIVolumeSource::CopyFrom(const CSIVolumeSource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.CSIVolumeSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSIVolumeSource::IsInitialized() const {
  return true;
}

void CSIVolumeSource::InternalSwap(CSIVolumeSource* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.volumeattributes_.InternalSwap(&other->_impl_.volumeattributes_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.driver_, lhs_arena,
      &other->_impl_.driver_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.fstype_, lhs_arena,
      &other->_impl_.fstype_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSIVolumeSource, _impl_.readonly_)
      + sizeof(CSIVolumeSource::_impl_.readonly_)
      - PROTOBUF_FIELD_OFFSET(CSIVolumeSource, _impl_.nodepublishsecretref_)>(
          reinterpret_cast<char*>(&_impl_.nodepublishsecretref_),
          reinterpret_cast<char*>(&other->_impl_.nodepublishsecretref_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CSIVolumeSource::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[12]);
}

// ===================================================================

class Capabilities::_Internal {
 public:
};

Capabilities::Capabilities(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.Capabilities)
}
Capabilities::Capabilities(const Capabilities& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Capabilities* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.add_){from._impl_.add_}
    , decltype(_impl_.drop_){from._impl_.drop_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.Capabilities)
}

inline void Capabilities::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.add_){arena}
    , decltype(_impl_.drop_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Capabilities::~Capabilities() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.Capabilities)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Capabilities::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.add_.~RepeatedPtrField();
  _impl_.drop_.~RepeatedPtrField();
}

void Capabilities::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Capabilities::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.Capabilities)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.add_.Clear();
  _impl_.drop_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Capabilities::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string add = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_add();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "k8s.io.api.core.v1.Capabilities.add");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string drop = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_drop();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "k8s.io.api.core.v1.Capabilities.drop");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Capabilities::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.Capabilities)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string add = 1;
  for (int i = 0, n = this->_internal_add_size(); i < n; i++) {
    const auto& s = this->_internal_add(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "k8s.io.api.core.v1.Capabilities.add");
    target = stream->WriteString(1, s, target);
  }

  // repeated string drop = 2;
  for (int i = 0, n = this->_internal_drop_size(); i < n; i++) {
    const auto& s = this->_internal_drop(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "k8s.io.api.core.v1.Capabilities.drop");
    target = stream->WriteString(2, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.Capabilities)
  return target;
}

size_t Capabilities::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.Capabilities)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string add = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.add_.size());
  for (int i = 0, n = _impl_.add_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.add_.Get(i));
  }

  // repeated string drop = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.drop_.size());
  for (int i = 0, n = _impl_.drop_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.drop_.Get(i));
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Capabilities::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Capabilities::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Capabilities::GetClassData() const { return &_class_data_; }


void Capabilities::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Capabilities*>(&to_msg);
  auto& from = static_cast<const Capabilities&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.Capabilities)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.add_.MergeFrom(from._impl_.add_);
  _this->_impl_.drop_.MergeFrom(from._impl_.drop_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Capabilities::CopyFrom(const Capabilities& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.Capabilities)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Capabilities::IsInitialized() const {
  return true;
}

void Capabilities::InternalSwap(Capabilities* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.add_.InternalSwap(&other->_impl_.add_);
  _impl_.drop_.InternalSwap(&other->_impl_.drop_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Capabilities::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[13]);
}

// ===================================================================

class CephFSPersistentVolumeSource::_Internal {
 public:
  using HasBits = decltype(std::declval<CephFSPersistentVolumeSource>()._impl_._has_bits_);
  static void set_has_path(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_user(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_secretfile(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::k8s::io::api::core::v1::SecretReference& secretref(const CephFSPersistentVolumeSource* msg);
  static void set_has_secretref(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_readonly(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::k8s::io::api::core::v1::SecretReference&
CephFSPersistentVolumeSource::_Internal::secretref(const CephFSPersistentVolumeSource* msg) {
  return *msg->_impl_.secretref_;
}
CephFSPersistentVolumeSource::CephFSPersistentVolumeSource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.CephFSPersistentVolumeSource)
}
CephFSPersistentVolumeSource::CephFSPersistentVolumeSource(const CephFSPersistentVolumeSource& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CephFSPersistentVolumeSource* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.monitors_){from._impl_.monitors_}
    , decltype(_impl_.path_){}
    , decltype(_impl_.user_){}
    , decltype(_impl_.secretfile_){}
    , decltype(_impl_.secretref_){nullptr}
    , decltype(_impl_.readonly_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_path()) {
    _this->_impl_.path_.Set(from._internal_path(), 
      _this->GetArenaForAllocation());
  }
  _impl_.user_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_user()) {
    _this->_impl_.user_.Set(from._internal_user(), 
      _this->GetArenaForAllocation());
  }
  _impl_.secretfile_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.secretfile_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_secretfile()) {
    _this->_impl_.secretfile_.Set(from._internal_secretfile(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_secretref()) {
    _this->_impl_.secretref_ = new ::k8s::io::api::core::v1::SecretReference(*from._impl_.secretref_);
  }
  _this->_impl_.readonly_ = from._impl_.readonly_;
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.CephFSPersistentVolumeSource)
}

inline void CephFSPersistentVolumeSource::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.monitors_){arena}
    , decltype(_impl_.path_){}
    , decltype(_impl_.user_){}
    , decltype(_impl_.secretfile_){}
    , decltype(_impl_.secretref_){nullptr}
    , decltype(_impl_.readonly_){false}
  };
  _impl_.path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.user_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.secretfile_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.secretfile_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CephFSPersistentVolumeSource::~CephFSPersistentVolumeSource() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.CephFSPersistentVolumeSource)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CephFSPersistentVolumeSource::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.monitors_.~RepeatedPtrField();
  _impl_.path_.Destroy();
  _impl_.user_.Destroy();
  _impl_.secretfile_.Destroy();
  if (this != internal_default_instance()) delete _impl_.secretref_;
}

void CephFSPersistentVolumeSource::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CephFSPersistentVolumeSource::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.CephFSPersistentVolumeSource)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.monitors_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.path_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.user_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.secretfile_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.secretref_ != nullptr);
      _impl_.secretref_->Clear();
    }
  }
  _impl_.readonly_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CephFSPersistentVolumeSource::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string monitors = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_monitors();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "k8s.io.api.core.v1.CephFSPersistentVolumeSource.monitors");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bytes path = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_path();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes user = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_user();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes secretFile = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_secretfile();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.SecretReference secretRef = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_secretref(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool readOnly = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_readonly(&has_bits);
          _impl_.readonly_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CephFSPersistentVolumeSource::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.CephFSPersistentVolumeSource)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string monitors = 1;
  for (int i = 0, n = this->_internal_monitors_size(); i < n; i++) {
    const auto& s = this->_internal_monitors(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "k8s.io.api.core.v1.CephFSPersistentVolumeSource.monitors");
    target = stream->WriteString(1, s, target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes path = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_path(), target);
  }

  // optional bytes user = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_user(), target);
  }

  // optional bytes secretFile = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_secretfile(), target);
  }

  // optional .k8s.io.api.core.v1.SecretReference secretRef = 5;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::secretref(this),
        _Internal::secretref(this).GetCachedSize(), target, stream);
  }

  // optional bool readOnly = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_readonly(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.CephFSPersistentVolumeSource)
  return target;
}

size_t CephFSPersistentVolumeSource::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.CephFSPersistentVolumeSource)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string monitors = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.monitors_.size());
  for (int i = 0, n = _impl_.monitors_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.monitors_.Get(i));
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional bytes path = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_path());
    }

    // optional bytes user = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_user());
    }

    // optional bytes secretFile = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_secretfile());
    }

    // optional .k8s.io.api.core.v1.SecretReference secretRef = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.secretref_);
    }

    // optional bool readOnly = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CephFSPersistentVolumeSource::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CephFSPersistentVolumeSource::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CephFSPersistentVolumeSource::GetClassData() const { return &_class_data_; }


void CephFSPersistentVolumeSource::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CephFSPersistentVolumeSource*>(&to_msg);
  auto& from = static_cast<const CephFSPersistentVolumeSource&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.CephFSPersistentVolumeSource)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.monitors_.MergeFrom(from._impl_.monitors_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_path(from._internal_path());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_user(from._internal_user());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_secretfile(from._internal_secretfile());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_secretref()->::k8s::io::api::core::v1::SecretReference::MergeFrom(
          from._internal_secretref());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.readonly_ = from._impl_.readonly_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CephFSPersistentVolumeSource::CopyFrom(const CephFSPersistentVolumeSource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.CephFSPersistentVolumeSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CephFSPersistentVolumeSource::IsInitialized() const {
  return true;
}

void CephFSPersistentVolumeSource::InternalSwap(CephFSPersistentVolumeSource* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.monitors_.InternalSwap(&other->_impl_.monitors_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.path_, lhs_arena,
      &other->_impl_.path_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.user_, lhs_arena,
      &other->_impl_.user_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.secretfile_, lhs_arena,
      &other->_impl_.secretfile_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CephFSPersistentVolumeSource, _impl_.readonly_)
      + sizeof(CephFSPersistentVolumeSource::_impl_.readonly_)
      - PROTOBUF_FIELD_OFFSET(CephFSPersistentVolumeSource, _impl_.secretref_)>(
          reinterpret_cast<char*>(&_impl_.secretref_),
          reinterpret_cast<char*>(&other->_impl_.secretref_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CephFSPersistentVolumeSource::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[14]);
}

// ===================================================================

class CephFSVolumeSource::_Internal {
 public:
  using HasBits = decltype(std::declval<CephFSVolumeSource>()._impl_._has_bits_);
  static void set_has_path(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_user(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_secretfile(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::k8s::io::api::core::v1::LocalObjectReference& secretref(const CephFSVolumeSource* msg);
  static void set_has_secretref(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_readonly(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::k8s::io::api::core::v1::LocalObjectReference&
CephFSVolumeSource::_Internal::secretref(const CephFSVolumeSource* msg) {
  return *msg->_impl_.secretref_;
}
CephFSVolumeSource::CephFSVolumeSource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.CephFSVolumeSource)
}
CephFSVolumeSource::CephFSVolumeSource(const CephFSVolumeSource& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CephFSVolumeSource* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.monitors_){from._impl_.monitors_}
    , decltype(_impl_.path_){}
    , decltype(_impl_.user_){}
    , decltype(_impl_.secretfile_){}
    , decltype(_impl_.secretref_){nullptr}
    , decltype(_impl_.readonly_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_path()) {
    _this->_impl_.path_.Set(from._internal_path(), 
      _this->GetArenaForAllocation());
  }
  _impl_.user_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_user()) {
    _this->_impl_.user_.Set(from._internal_user(), 
      _this->GetArenaForAllocation());
  }
  _impl_.secretfile_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.secretfile_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_secretfile()) {
    _this->_impl_.secretfile_.Set(from._internal_secretfile(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_secretref()) {
    _this->_impl_.secretref_ = new ::k8s::io::api::core::v1::LocalObjectReference(*from._impl_.secretref_);
  }
  _this->_impl_.readonly_ = from._impl_.readonly_;
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.CephFSVolumeSource)
}

inline void CephFSVolumeSource::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.monitors_){arena}
    , decltype(_impl_.path_){}
    , decltype(_impl_.user_){}
    , decltype(_impl_.secretfile_){}
    , decltype(_impl_.secretref_){nullptr}
    , decltype(_impl_.readonly_){false}
  };
  _impl_.path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.user_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.secretfile_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.secretfile_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CephFSVolumeSource::~CephFSVolumeSource() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.CephFSVolumeSource)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CephFSVolumeSource::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.monitors_.~RepeatedPtrField();
  _impl_.path_.Destroy();
  _impl_.user_.Destroy();
  _impl_.secretfile_.Destroy();
  if (this != internal_default_instance()) delete _impl_.secretref_;
}

void CephFSVolumeSource::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CephFSVolumeSource::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.CephFSVolumeSource)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.monitors_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.path_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.user_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.secretfile_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.secretref_ != nullptr);
      _impl_.secretref_->Clear();
    }
  }
  _impl_.readonly_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CephFSVolumeSource::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string monitors = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_monitors();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "k8s.io.api.core.v1.CephFSVolumeSource.monitors");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bytes path = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_path();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes user = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_user();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes secretFile = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_secretfile();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.LocalObjectReference secretRef = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_secretref(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool readOnly = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_readonly(&has_bits);
          _impl_.readonly_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CephFSVolumeSource::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.CephFSVolumeSource)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string monitors = 1;
  for (int i = 0, n = this->_internal_monitors_size(); i < n; i++) {
    const auto& s = this->_internal_monitors(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "k8s.io.api.core.v1.CephFSVolumeSource.monitors");
    target = stream->WriteString(1, s, target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes path = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_path(), target);
  }

  // optional bytes user = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_user(), target);
  }

  // optional bytes secretFile = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_secretfile(), target);
  }

  // optional .k8s.io.api.core.v1.LocalObjectReference secretRef = 5;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::secretref(this),
        _Internal::secretref(this).GetCachedSize(), target, stream);
  }

  // optional bool readOnly = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_readonly(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.CephFSVolumeSource)
  return target;
}

size_t CephFSVolumeSource::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.CephFSVolumeSource)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string monitors = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.monitors_.size());
  for (int i = 0, n = _impl_.monitors_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.monitors_.Get(i));
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional bytes path = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_path());
    }

    // optional bytes user = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_user());
    }

    // optional bytes secretFile = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_secretfile());
    }

    // optional .k8s.io.api.core.v1.LocalObjectReference secretRef = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.secretref_);
    }

    // optional bool readOnly = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CephFSVolumeSource::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CephFSVolumeSource::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CephFSVolumeSource::GetClassData() const { return &_class_data_; }


void CephFSVolumeSource::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CephFSVolumeSource*>(&to_msg);
  auto& from = static_cast<const CephFSVolumeSource&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.CephFSVolumeSource)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.monitors_.MergeFrom(from._impl_.monitors_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_path(from._internal_path());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_user(from._internal_user());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_secretfile(from._internal_secretfile());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_secretref()->::k8s::io::api::core::v1::LocalObjectReference::MergeFrom(
          from._internal_secretref());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.readonly_ = from._impl_.readonly_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CephFSVolumeSource::CopyFrom(const CephFSVolumeSource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.CephFSVolumeSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CephFSVolumeSource::IsInitialized() const {
  return true;
}

void CephFSVolumeSource::InternalSwap(CephFSVolumeSource* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.monitors_.InternalSwap(&other->_impl_.monitors_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.path_, lhs_arena,
      &other->_impl_.path_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.user_, lhs_arena,
      &other->_impl_.user_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.secretfile_, lhs_arena,
      &other->_impl_.secretfile_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CephFSVolumeSource, _impl_.readonly_)
      + sizeof(CephFSVolumeSource::_impl_.readonly_)
      - PROTOBUF_FIELD_OFFSET(CephFSVolumeSource, _impl_.secretref_)>(
          reinterpret_cast<char*>(&_impl_.secretref_),
          reinterpret_cast<char*>(&other->_impl_.secretref_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CephFSVolumeSource::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[15]);
}

// ===================================================================

class CinderPersistentVolumeSource::_Internal {
 public:
  using HasBits = decltype(std::declval<CinderPersistentVolumeSource>()._impl_._has_bits_);
  static void set_has_volumeid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_fstype(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_readonly(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::k8s::io::api::core::v1::SecretReference& secretref(const CinderPersistentVolumeSource* msg);
  static void set_has_secretref(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::k8s::io::api::core::v1::SecretReference&
CinderPersistentVolumeSource::_Internal::secretref(const CinderPersistentVolumeSource* msg) {
  return *msg->_impl_.secretref_;
}
CinderPersistentVolumeSource::CinderPersistentVolumeSource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.CinderPersistentVolumeSource)
}
CinderPersistentVolumeSource::CinderPersistentVolumeSource(const CinderPersistentVolumeSource& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CinderPersistentVolumeSource* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.volumeid_){}
    , decltype(_impl_.fstype_){}
    , decltype(_impl_.secretref_){nullptr}
    , decltype(_impl_.readonly_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.volumeid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.volumeid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_volumeid()) {
    _this->_impl_.volumeid_.Set(from._internal_volumeid(), 
      _this->GetArenaForAllocation());
  }
  _impl_.fstype_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fstype_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_fstype()) {
    _this->_impl_.fstype_.Set(from._internal_fstype(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_secretref()) {
    _this->_impl_.secretref_ = new ::k8s::io::api::core::v1::SecretReference(*from._impl_.secretref_);
  }
  _this->_impl_.readonly_ = from._impl_.readonly_;
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.CinderPersistentVolumeSource)
}

inline void CinderPersistentVolumeSource::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.volumeid_){}
    , decltype(_impl_.fstype_){}
    , decltype(_impl_.secretref_){nullptr}
    , decltype(_impl_.readonly_){false}
  };
  _impl_.volumeid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.volumeid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.fstype_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fstype_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CinderPersistentVolumeSource::~CinderPersistentVolumeSource() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.CinderPersistentVolumeSource)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CinderPersistentVolumeSource::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.volumeid_.Destroy();
  _impl_.fstype_.Destroy();
  if (this != internal_default_instance()) delete _impl_.secretref_;
}

void CinderPersistentVolumeSource::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CinderPersistentVolumeSource::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.CinderPersistentVolumeSource)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.volumeid_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.fstype_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.secretref_ != nullptr);
      _impl_.secretref_->Clear();
    }
  }
  _impl_.readonly_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CinderPersistentVolumeSource::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes volumeID = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_volumeid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes fsType = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_fstype();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool readOnly = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_readonly(&has_bits);
          _impl_.readonly_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.SecretReference secretRef = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_secretref(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CinderPersistentVolumeSource::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.CinderPersistentVolumeSource)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes volumeID = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_volumeid(), target);
  }

  // optional bytes fsType = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_fstype(), target);
  }

  // optional bool readOnly = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_readonly(), target);
  }

  // optional .k8s.io.api.core.v1.SecretReference secretRef = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::secretref(this),
        _Internal::secretref(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.CinderPersistentVolumeSource)
  return target;
}

size_t CinderPersistentVolumeSource::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.CinderPersistentVolumeSource)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional bytes volumeID = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_volumeid());
    }

    // optional bytes fsType = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_fstype());
    }

    // optional .k8s.io.api.core.v1.SecretReference secretRef = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.secretref_);
    }

    // optional bool readOnly = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CinderPersistentVolumeSource::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CinderPersistentVolumeSource::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CinderPersistentVolumeSource::GetClassData() const { return &_class_data_; }


void CinderPersistentVolumeSource::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CinderPersistentVolumeSource*>(&to_msg);
  auto& from = static_cast<const CinderPersistentVolumeSource&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.CinderPersistentVolumeSource)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_volumeid(from._internal_volumeid());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_fstype(from._internal_fstype());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_secretref()->::k8s::io::api::core::v1::SecretReference::MergeFrom(
          from._internal_secretref());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.readonly_ = from._impl_.readonly_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CinderPersistentVolumeSource::CopyFrom(const CinderPersistentVolumeSource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.CinderPersistentVolumeSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CinderPersistentVolumeSource::IsInitialized() const {
  return true;
}

void CinderPersistentVolumeSource::InternalSwap(CinderPersistentVolumeSource* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.volumeid_, lhs_arena,
      &other->_impl_.volumeid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.fstype_, lhs_arena,
      &other->_impl_.fstype_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CinderPersistentVolumeSource, _impl_.readonly_)
      + sizeof(CinderPersistentVolumeSource::_impl_.readonly_)
      - PROTOBUF_FIELD_OFFSET(CinderPersistentVolumeSource, _impl_.secretref_)>(
          reinterpret_cast<char*>(&_impl_.secretref_),
          reinterpret_cast<char*>(&other->_impl_.secretref_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CinderPersistentVolumeSource::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[16]);
}

// ===================================================================

class CinderVolumeSource::_Internal {
 public:
  using HasBits = decltype(std::declval<CinderVolumeSource>()._impl_._has_bits_);
  static void set_has_volumeid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_fstype(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_readonly(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::k8s::io::api::core::v1::LocalObjectReference& secretref(const CinderVolumeSource* msg);
  static void set_has_secretref(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::k8s::io::api::core::v1::LocalObjectReference&
CinderVolumeSource::_Internal::secretref(const CinderVolumeSource* msg) {
  return *msg->_impl_.secretref_;
}
CinderVolumeSource::CinderVolumeSource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.CinderVolumeSource)
}
CinderVolumeSource::CinderVolumeSource(const CinderVolumeSource& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CinderVolumeSource* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.volumeid_){}
    , decltype(_impl_.fstype_){}
    , decltype(_impl_.secretref_){nullptr}
    , decltype(_impl_.readonly_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.volumeid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.volumeid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_volumeid()) {
    _this->_impl_.volumeid_.Set(from._internal_volumeid(), 
      _this->GetArenaForAllocation());
  }
  _impl_.fstype_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fstype_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_fstype()) {
    _this->_impl_.fstype_.Set(from._internal_fstype(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_secretref()) {
    _this->_impl_.secretref_ = new ::k8s::io::api::core::v1::LocalObjectReference(*from._impl_.secretref_);
  }
  _this->_impl_.readonly_ = from._impl_.readonly_;
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.CinderVolumeSource)
}

inline void CinderVolumeSource::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.volumeid_){}
    , decltype(_impl_.fstype_){}
    , decltype(_impl_.secretref_){nullptr}
    , decltype(_impl_.readonly_){false}
  };
  _impl_.volumeid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.volumeid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.fstype_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fstype_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CinderVolumeSource::~CinderVolumeSource() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.CinderVolumeSource)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CinderVolumeSource::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.volumeid_.Destroy();
  _impl_.fstype_.Destroy();
  if (this != internal_default_instance()) delete _impl_.secretref_;
}

void CinderVolumeSource::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CinderVolumeSource::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.CinderVolumeSource)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.volumeid_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.fstype_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.secretref_ != nullptr);
      _impl_.secretref_->Clear();
    }
  }
  _impl_.readonly_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CinderVolumeSource::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes volumeID = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_volumeid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes fsType = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_fstype();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool readOnly = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_readonly(&has_bits);
          _impl_.readonly_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.LocalObjectReference secretRef = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_secretref(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CinderVolumeSource::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.CinderVolumeSource)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes volumeID = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_volumeid(), target);
  }

  // optional bytes fsType = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_fstype(), target);
  }

  // optional bool readOnly = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_readonly(), target);
  }

  // optional .k8s.io.api.core.v1.LocalObjectReference secretRef = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::secretref(this),
        _Internal::secretref(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.CinderVolumeSource)
  return target;
}

size_t CinderVolumeSource::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.CinderVolumeSource)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional bytes volumeID = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_volumeid());
    }

    // optional bytes fsType = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_fstype());
    }

    // optional .k8s.io.api.core.v1.LocalObjectReference secretRef = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.secretref_);
    }

    // optional bool readOnly = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CinderVolumeSource::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CinderVolumeSource::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CinderVolumeSource::GetClassData() const { return &_class_data_; }


void CinderVolumeSource::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CinderVolumeSource*>(&to_msg);
  auto& from = static_cast<const CinderVolumeSource&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.CinderVolumeSource)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_volumeid(from._internal_volumeid());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_fstype(from._internal_fstype());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_secretref()->::k8s::io::api::core::v1::LocalObjectReference::MergeFrom(
          from._internal_secretref());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.readonly_ = from._impl_.readonly_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CinderVolumeSource::CopyFrom(const CinderVolumeSource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.CinderVolumeSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CinderVolumeSource::IsInitialized() const {
  return true;
}

void CinderVolumeSource::InternalSwap(CinderVolumeSource* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.volumeid_, lhs_arena,
      &other->_impl_.volumeid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.fstype_, lhs_arena,
      &other->_impl_.fstype_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CinderVolumeSource, _impl_.readonly_)
      + sizeof(CinderVolumeSource::_impl_.readonly_)
      - PROTOBUF_FIELD_OFFSET(CinderVolumeSource, _impl_.secretref_)>(
          reinterpret_cast<char*>(&_impl_.secretref_),
          reinterpret_cast<char*>(&other->_impl_.secretref_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CinderVolumeSource::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[17]);
}

// ===================================================================

class ClaimSource::_Internal {
 public:
  using HasBits = decltype(std::declval<ClaimSource>()._impl_._has_bits_);
  static void set_has_resourceclaimname(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_resourceclaimtemplatename(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ClaimSource::ClaimSource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.ClaimSource)
}
ClaimSource::ClaimSource(const ClaimSource& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ClaimSource* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.resourceclaimname_){}
    , decltype(_impl_.resourceclaimtemplatename_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.resourceclaimname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.resourceclaimname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_resourceclaimname()) {
    _this->_impl_.resourceclaimname_.Set(from._internal_resourceclaimname(), 
      _this->GetArenaForAllocation());
  }
  _impl_.resourceclaimtemplatename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.resourceclaimtemplatename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_resourceclaimtemplatename()) {
    _this->_impl_.resourceclaimtemplatename_.Set(from._internal_resourceclaimtemplatename(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.ClaimSource)
}

inline void ClaimSource::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.resourceclaimname_){}
    , decltype(_impl_.resourceclaimtemplatename_){}
  };
  _impl_.resourceclaimname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.resourceclaimname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.resourceclaimtemplatename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.resourceclaimtemplatename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClaimSource::~ClaimSource() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.ClaimSource)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClaimSource::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.resourceclaimname_.Destroy();
  _impl_.resourceclaimtemplatename_.Destroy();
}

void ClaimSource::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ClaimSource::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.ClaimSource)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.resourceclaimname_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.resourceclaimtemplatename_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ClaimSource::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes resourceClaimName = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_resourceclaimname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes resourceClaimTemplateName = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_resourceclaimtemplatename();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClaimSource::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.ClaimSource)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes resourceClaimName = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_resourceclaimname(), target);
  }

  // optional bytes resourceClaimTemplateName = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_resourceclaimtemplatename(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.ClaimSource)
  return target;
}

size_t ClaimSource::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.ClaimSource)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes resourceClaimName = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_resourceclaimname());
    }

    // optional bytes resourceClaimTemplateName = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_resourceclaimtemplatename());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ClaimSource::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ClaimSource::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ClaimSource::GetClassData() const { return &_class_data_; }


void ClaimSource::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ClaimSource*>(&to_msg);
  auto& from = static_cast<const ClaimSource&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.ClaimSource)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_resourceclaimname(from._internal_resourceclaimname());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_resourceclaimtemplatename(from._internal_resourceclaimtemplatename());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ClaimSource::CopyFrom(const ClaimSource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.ClaimSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClaimSource::IsInitialized() const {
  return true;
}

void ClaimSource::InternalSwap(ClaimSource* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.resourceclaimname_, lhs_arena,
      &other->_impl_.resourceclaimname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.resourceclaimtemplatename_, lhs_arena,
      &other->_impl_.resourceclaimtemplatename_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ClaimSource::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[18]);
}

// ===================================================================

class ClientIPConfig::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientIPConfig>()._impl_._has_bits_);
  static void set_has_timeoutseconds(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ClientIPConfig::ClientIPConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.ClientIPConfig)
}
ClientIPConfig::ClientIPConfig(const ClientIPConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ClientIPConfig* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.timeoutseconds_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.timeoutseconds_ = from._impl_.timeoutseconds_;
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.ClientIPConfig)
}

inline void ClientIPConfig::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.timeoutseconds_){0}
  };
}

ClientIPConfig::~ClientIPConfig() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.ClientIPConfig)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientIPConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ClientIPConfig::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ClientIPConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.ClientIPConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.timeoutseconds_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ClientIPConfig::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 timeoutSeconds = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_timeoutseconds(&has_bits);
          _impl_.timeoutseconds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientIPConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.ClientIPConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 timeoutSeconds = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_timeoutseconds(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.ClientIPConfig)
  return target;
}

size_t ClientIPConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.ClientIPConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 timeoutSeconds = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_timeoutseconds());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ClientIPConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ClientIPConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ClientIPConfig::GetClassData() const { return &_class_data_; }


void ClientIPConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ClientIPConfig*>(&to_msg);
  auto& from = static_cast<const ClientIPConfig&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.ClientIPConfig)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_timeoutseconds()) {
    _this->_internal_set_timeoutseconds(from._internal_timeoutseconds());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ClientIPConfig::CopyFrom(const ClientIPConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.ClientIPConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientIPConfig::IsInitialized() const {
  return true;
}

void ClientIPConfig::InternalSwap(ClientIPConfig* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.timeoutseconds_, other->_impl_.timeoutseconds_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ClientIPConfig::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[19]);
}

// ===================================================================

class ClusterTrustBundleProjection::_Internal {
 public:
  using HasBits = decltype(std::declval<ClusterTrustBundleProjection>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_signername(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector& labelselector(const ClusterTrustBundleProjection* msg);
  static void set_has_labelselector(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_optional(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_path(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector&
ClusterTrustBundleProjection::_Internal::labelselector(const ClusterTrustBundleProjection* msg) {
  return *msg->_impl_.labelselector_;
}
void ClusterTrustBundleProjection::clear_labelselector() {
  if (_impl_.labelselector_ != nullptr) _impl_.labelselector_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
ClusterTrustBundleProjection::ClusterTrustBundleProjection(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.ClusterTrustBundleProjection)
}
ClusterTrustBundleProjection::ClusterTrustBundleProjection(const ClusterTrustBundleProjection& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ClusterTrustBundleProjection* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.signername_){}
    , decltype(_impl_.path_){}
    , decltype(_impl_.labelselector_){nullptr}
    , decltype(_impl_.optional_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.signername_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.signername_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_signername()) {
    _this->_impl_.signername_.Set(from._internal_signername(), 
      _this->GetArenaForAllocation());
  }
  _impl_.path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_path()) {
    _this->_impl_.path_.Set(from._internal_path(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_labelselector()) {
    _this->_impl_.labelselector_ = new ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector(*from._impl_.labelselector_);
  }
  _this->_impl_.optional_ = from._impl_.optional_;
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.ClusterTrustBundleProjection)
}

inline void ClusterTrustBundleProjection::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.signername_){}
    , decltype(_impl_.path_){}
    , decltype(_impl_.labelselector_){nullptr}
    , decltype(_impl_.optional_){false}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.signername_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.signername_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClusterTrustBundleProjection::~ClusterTrustBundleProjection() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.ClusterTrustBundleProjection)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClusterTrustBundleProjection::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.signername_.Destroy();
  _impl_.path_.Destroy();
  if (this != internal_default_instance()) delete _impl_.labelselector_;
}

void ClusterTrustBundleProjection::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ClusterTrustBundleProjection::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.ClusterTrustBundleProjection)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.signername_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.path_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.labelselector_ != nullptr);
      _impl_.labelselector_->Clear();
    }
  }
  _impl_.optional_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ClusterTrustBundleProjection::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes signerName = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_signername();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector labelSelector = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_labelselector(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes path = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_path();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool optional = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_optional(&has_bits);
          _impl_.optional_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClusterTrustBundleProjection::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.ClusterTrustBundleProjection)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional bytes signerName = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_signername(), target);
  }

  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector labelSelector = 3;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::labelselector(this),
        _Internal::labelselector(this).GetCachedSize(), target, stream);
  }

  // optional bytes path = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_path(), target);
  }

  // optional bool optional = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_optional(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.ClusterTrustBundleProjection)
  return target;
}

size_t ClusterTrustBundleProjection::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.ClusterTrustBundleProjection)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional bytes name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_name());
    }

    // optional bytes signerName = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_signername());
    }

    // optional bytes path = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_path());
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector labelSelector = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.labelselector_);
    }

    // optional bool optional = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ClusterTrustBundleProjection::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ClusterTrustBundleProjection::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ClusterTrustBundleProjection::GetClassData() const { return &_class_data_; }


void ClusterTrustBundleProjection::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ClusterTrustBundleProjection*>(&to_msg);
  auto& from = static_cast<const ClusterTrustBundleProjection&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.ClusterTrustBundleProjection)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_signername(from._internal_signername());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_path(from._internal_path());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_labelselector()->::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector::MergeFrom(
          from._internal_labelselector());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.optional_ = from._impl_.optional_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ClusterTrustBundleProjection::CopyFrom(const ClusterTrustBundleProjection& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.ClusterTrustBundleProjection)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClusterTrustBundleProjection::IsInitialized() const {
  return true;
}

void ClusterTrustBundleProjection::InternalSwap(ClusterTrustBundleProjection* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.signername_, lhs_arena,
      &other->_impl_.signername_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.path_, lhs_arena,
      &other->_impl_.path_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ClusterTrustBundleProjection, _impl_.optional_)
      + sizeof(ClusterTrustBundleProjection::_impl_.optional_)
      - PROTOBUF_FIELD_OFFSET(ClusterTrustBundleProjection, _impl_.labelselector_)>(
          reinterpret_cast<char*>(&_impl_.labelselector_),
          reinterpret_cast<char*>(&other->_impl_.labelselector_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ClusterTrustBundleProjection::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[20]);
}

// ===================================================================

class ComponentCondition::_Internal {
 public:
  using HasBits = decltype(std::declval<ComponentCondition>()._impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_message(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

ComponentCondition::ComponentCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.ComponentCondition)
}
ComponentCondition::ComponentCondition(const ComponentCondition& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ComponentCondition* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.type_){}
    , decltype(_impl_.status_){}
    , decltype(_impl_.message_){}
    , decltype(_impl_.error_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_type()) {
    _this->_impl_.type_.Set(from._internal_type(), 
      _this->GetArenaForAllocation());
  }
  _impl_.status_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.status_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_status()) {
    _this->_impl_.status_.Set(from._internal_status(), 
      _this->GetArenaForAllocation());
  }
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_message()) {
    _this->_impl_.message_.Set(from._internal_message(), 
      _this->GetArenaForAllocation());
  }
  _impl_.error_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.error_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_error()) {
    _this->_impl_.error_.Set(from._internal_error(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.ComponentCondition)
}

inline void ComponentCondition::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.type_){}
    , decltype(_impl_.status_){}
    , decltype(_impl_.message_){}
    , decltype(_impl_.error_){}
  };
  _impl_.type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.status_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.status_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.error_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.error_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ComponentCondition::~ComponentCondition() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.ComponentCondition)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ComponentCondition::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.type_.Destroy();
  _impl_.status_.Destroy();
  _impl_.message_.Destroy();
  _impl_.error_.Destroy();
}

void ComponentCondition::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ComponentCondition::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.ComponentCondition)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.type_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.status_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.message_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.error_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ComponentCondition::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes status = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_status();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes message = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes error = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_error();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ComponentCondition::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.ComponentCondition)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_type(), target);
  }

  // optional bytes status = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_status(), target);
  }

  // optional bytes message = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_message(), target);
  }

  // optional bytes error = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_error(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.ComponentCondition)
  return target;
}

size_t ComponentCondition::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.ComponentCondition)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional bytes type = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_type());
    }

    // optional bytes status = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_status());
    }

    // optional bytes message = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_message());
    }

    // optional bytes error = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_error());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ComponentCondition::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ComponentCondition::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ComponentCondition::GetClassData() const { return &_class_data_; }


void ComponentCondition::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ComponentCondition*>(&to_msg);
  auto& from = static_cast<const ComponentCondition&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.ComponentCondition)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_type(from._internal_type());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_status(from._internal_status());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_message(from._internal_message());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_error(from._internal_error());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ComponentCondition::CopyFrom(const ComponentCondition& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.ComponentCondition)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ComponentCondition::IsInitialized() const {
  return true;
}

void ComponentCondition::InternalSwap(ComponentCondition* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.type_, lhs_arena,
      &other->_impl_.type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.status_, lhs_arena,
      &other->_impl_.status_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.message_, lhs_arena,
      &other->_impl_.message_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.error_, lhs_arena,
      &other->_impl_.error_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ComponentCondition::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[21]);
}

// ===================================================================

class ComponentStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<ComponentStatus>()._impl_._has_bits_);
  static const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& metadata(const ComponentStatus* msg);
  static void set_has_metadata(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta&
ComponentStatus::_Internal::metadata(const ComponentStatus* msg) {
  return *msg->_impl_.metadata_;
}
void ComponentStatus::clear_metadata() {
  if (_impl_.metadata_ != nullptr) _impl_.metadata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
ComponentStatus::ComponentStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.ComponentStatus)
}
ComponentStatus::ComponentStatus(const ComponentStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ComponentStatus* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.conditions_){from._impl_.conditions_}
    , decltype(_impl_.metadata_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_metadata()) {
    _this->_impl_.metadata_ = new ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta(*from._impl_.metadata_);
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.ComponentStatus)
}

inline void ComponentStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.conditions_){arena}
    , decltype(_impl_.metadata_){nullptr}
  };
}

ComponentStatus::~ComponentStatus() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.ComponentStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ComponentStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.conditions_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.metadata_;
}

void ComponentStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ComponentStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.ComponentStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.conditions_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.metadata_ != nullptr);
    _impl_.metadata_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ComponentStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_metadata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .k8s.io.api.core.v1.ComponentCondition conditions = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_conditions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ComponentStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.ComponentStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::metadata(this),
        _Internal::metadata(this).GetCachedSize(), target, stream);
  }

  // repeated .k8s.io.api.core.v1.ComponentCondition conditions = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_conditions_size()); i < n; i++) {
    const auto& repfield = this->_internal_conditions(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.ComponentStatus)
  return target;
}

size_t ComponentStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.ComponentStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .k8s.io.api.core.v1.ComponentCondition conditions = 2;
  total_size += 1UL * this->_internal_conditions_size();
  for (const auto& msg : this->_impl_.conditions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.metadata_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ComponentStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ComponentStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ComponentStatus::GetClassData() const { return &_class_data_; }


void ComponentStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ComponentStatus*>(&to_msg);
  auto& from = static_cast<const ComponentStatus&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.ComponentStatus)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.conditions_.MergeFrom(from._impl_.conditions_);
  if (from._internal_has_metadata()) {
    _this->_internal_mutable_metadata()->::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta::MergeFrom(
        from._internal_metadata());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ComponentStatus::CopyFrom(const ComponentStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.ComponentStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ComponentStatus::IsInitialized() const {
  return true;
}

void ComponentStatus::InternalSwap(ComponentStatus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.conditions_.InternalSwap(&other->_impl_.conditions_);
  swap(_impl_.metadata_, other->_impl_.metadata_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ComponentStatus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[22]);
}

// ===================================================================

class ComponentStatusList::_Internal {
 public:
  using HasBits = decltype(std::declval<ComponentStatusList>()._impl_._has_bits_);
  static const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& metadata(const ComponentStatusList* msg);
  static void set_has_metadata(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta&
ComponentStatusList::_Internal::metadata(const ComponentStatusList* msg) {
  return *msg->_impl_.metadata_;
}
void ComponentStatusList::clear_metadata() {
  if (_impl_.metadata_ != nullptr) _impl_.metadata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
ComponentStatusList::ComponentStatusList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.ComponentStatusList)
}
ComponentStatusList::ComponentStatusList(const ComponentStatusList& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ComponentStatusList* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.items_){from._impl_.items_}
    , decltype(_impl_.metadata_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_metadata()) {
    _this->_impl_.metadata_ = new ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta(*from._impl_.metadata_);
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.ComponentStatusList)
}

inline void ComponentStatusList::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.items_){arena}
    , decltype(_impl_.metadata_){nullptr}
  };
}

ComponentStatusList::~ComponentStatusList() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.ComponentStatusList)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ComponentStatusList::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.items_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.metadata_;
}

void ComponentStatusList::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ComponentStatusList::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.ComponentStatusList)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.items_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.metadata_ != nullptr);
    _impl_.metadata_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ComponentStatusList::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_metadata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .k8s.io.api.core.v1.ComponentStatus items = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_items(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ComponentStatusList::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.ComponentStatusList)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::metadata(this),
        _Internal::metadata(this).GetCachedSize(), target, stream);
  }

  // repeated .k8s.io.api.core.v1.ComponentStatus items = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_items_size()); i < n; i++) {
    const auto& repfield = this->_internal_items(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.ComponentStatusList)
  return target;
}

size_t ComponentStatusList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.ComponentStatusList)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .k8s.io.api.core.v1.ComponentStatus items = 2;
  total_size += 1UL * this->_internal_items_size();
  for (const auto& msg : this->_impl_.items_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.metadata_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ComponentStatusList::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ComponentStatusList::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ComponentStatusList::GetClassData() const { return &_class_data_; }


void ComponentStatusList::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ComponentStatusList*>(&to_msg);
  auto& from = static_cast<const ComponentStatusList&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.ComponentStatusList)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.items_.MergeFrom(from._impl_.items_);
  if (from._internal_has_metadata()) {
    _this->_internal_mutable_metadata()->::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta::MergeFrom(
        from._internal_metadata());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ComponentStatusList::CopyFrom(const ComponentStatusList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.ComponentStatusList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ComponentStatusList::IsInitialized() const {
  return true;
}

void ComponentStatusList::InternalSwap(ComponentStatusList* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.items_.InternalSwap(&other->_impl_.items_);
  swap(_impl_.metadata_, other->_impl_.metadata_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ComponentStatusList::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[23]);
}

// ===================================================================

ConfigMap_DataEntry_DoNotUse::ConfigMap_DataEntry_DoNotUse() {}
ConfigMap_DataEntry_DoNotUse::ConfigMap_DataEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void ConfigMap_DataEntry_DoNotUse::MergeFrom(const ConfigMap_DataEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata ConfigMap_DataEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[24]);
}

// ===================================================================

ConfigMap_BinaryDataEntry_DoNotUse::ConfigMap_BinaryDataEntry_DoNotUse() {}
ConfigMap_BinaryDataEntry_DoNotUse::ConfigMap_BinaryDataEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void ConfigMap_BinaryDataEntry_DoNotUse::MergeFrom(const ConfigMap_BinaryDataEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata ConfigMap_BinaryDataEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[25]);
}

// ===================================================================

class ConfigMap::_Internal {
 public:
  using HasBits = decltype(std::declval<ConfigMap>()._impl_._has_bits_);
  static const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& metadata(const ConfigMap* msg);
  static void set_has_metadata(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_immutable(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta&
ConfigMap::_Internal::metadata(const ConfigMap* msg) {
  return *msg->_impl_.metadata_;
}
void ConfigMap::clear_metadata() {
  if (_impl_.metadata_ != nullptr) _impl_.metadata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
ConfigMap::ConfigMap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &ConfigMap::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.ConfigMap)
}
ConfigMap::ConfigMap(const ConfigMap& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ConfigMap* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_.data_)*/{}
    , /*decltype(_impl_.binarydata_)*/{}
    , decltype(_impl_.metadata_){nullptr}
    , decltype(_impl_.immutable_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.data_.MergeFrom(from._impl_.data_);
  _this->_impl_.binarydata_.MergeFrom(from._impl_.binarydata_);
  if (from._internal_has_metadata()) {
    _this->_impl_.metadata_ = new ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta(*from._impl_.metadata_);
  }
  _this->_impl_.immutable_ = from._impl_.immutable_;
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.ConfigMap)
}

inline void ConfigMap::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_.data_)*/{::_pbi::ArenaInitialized(), arena}
    , /*decltype(_impl_.binarydata_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.metadata_){nullptr}
    , decltype(_impl_.immutable_){false}
  };
}

ConfigMap::~ConfigMap() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.ConfigMap)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void ConfigMap::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.data_.Destruct();
  _impl_.data_.~MapField();
  _impl_.binarydata_.Destruct();
  _impl_.binarydata_.~MapField();
  if (this != internal_default_instance()) delete _impl_.metadata_;
}

void ConfigMap::ArenaDtor(void* object) {
  ConfigMap* _this = reinterpret_cast< ConfigMap* >(object);
  _this->_impl_.data_.Destruct();
  _this->_impl_.binarydata_.Destruct();
}
void ConfigMap::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ConfigMap::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.ConfigMap)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.data_.Clear();
  _impl_.binarydata_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.metadata_ != nullptr);
    _impl_.metadata_->Clear();
  }
  _impl_.immutable_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ConfigMap::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_metadata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // map<string, string> data = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.data_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // map<string, bytes> binaryData = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.binarydata_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool immutable = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_immutable(&has_bits);
          _impl_.immutable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ConfigMap::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.ConfigMap)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::metadata(this),
        _Internal::metadata(this).GetCachedSize(), target, stream);
  }

  // map<string, string> data = 2;
  if (!this->_internal_data().empty()) {
    using MapType = ::_pb::Map<std::string, std::string>;
    using WireHelper = ConfigMap_DataEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_data();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "k8s.io.api.core.v1.ConfigMap.DataEntry.key");
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        entry.second.data(), static_cast<int>(entry.second.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "k8s.io.api.core.v1.ConfigMap.DataEntry.value");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(2, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(2, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  // map<string, bytes> binaryData = 3;
  if (!this->_internal_binarydata().empty()) {
    using MapType = ::_pb::Map<std::string, std::string>;
    using WireHelper = ConfigMap_BinaryDataEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_binarydata();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "k8s.io.api.core.v1.ConfigMap.BinaryDataEntry.key");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(3, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(3, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  // optional bool immutable = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_immutable(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.ConfigMap)
  return target;
}

size_t ConfigMap::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.ConfigMap)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, string> data = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_data_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
      it = this->_internal_data().begin();
      it != this->_internal_data().end(); ++it) {
    total_size += ConfigMap_DataEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // map<string, bytes> binaryData = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_binarydata_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
      it = this->_internal_binarydata().begin();
      it != this->_internal_binarydata().end(); ++it) {
    total_size += ConfigMap_BinaryDataEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.metadata_);
    }

    // optional bool immutable = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ConfigMap::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ConfigMap::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ConfigMap::GetClassData() const { return &_class_data_; }


void ConfigMap::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ConfigMap*>(&to_msg);
  auto& from = static_cast<const ConfigMap&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.ConfigMap)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.data_.MergeFrom(from._impl_.data_);
  _this->_impl_.binarydata_.MergeFrom(from._impl_.binarydata_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_metadata()->::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta::MergeFrom(
          from._internal_metadata());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.immutable_ = from._impl_.immutable_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ConfigMap::CopyFrom(const ConfigMap& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.ConfigMap)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConfigMap::IsInitialized() const {
  return true;
}

void ConfigMap::InternalSwap(ConfigMap* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.data_.InternalSwap(&other->_impl_.data_);
  _impl_.binarydata_.InternalSwap(&other->_impl_.binarydata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ConfigMap, _impl_.immutable_)
      + sizeof(ConfigMap::_impl_.immutable_)
      - PROTOBUF_FIELD_OFFSET(ConfigMap, _impl_.metadata_)>(
          reinterpret_cast<char*>(&_impl_.metadata_),
          reinterpret_cast<char*>(&other->_impl_.metadata_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ConfigMap::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[26]);
}

// ===================================================================

class ConfigMapEnvSource::_Internal {
 public:
  using HasBits = decltype(std::declval<ConfigMapEnvSource>()._impl_._has_bits_);
  static const ::k8s::io::api::core::v1::LocalObjectReference& localobjectreference(const ConfigMapEnvSource* msg);
  static void set_has_localobjectreference(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_optional(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::k8s::io::api::core::v1::LocalObjectReference&
ConfigMapEnvSource::_Internal::localobjectreference(const ConfigMapEnvSource* msg) {
  return *msg->_impl_.localobjectreference_;
}
ConfigMapEnvSource::ConfigMapEnvSource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.ConfigMapEnvSource)
}
ConfigMapEnvSource::ConfigMapEnvSource(const ConfigMapEnvSource& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ConfigMapEnvSource* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.localobjectreference_){nullptr}
    , decltype(_impl_.optional_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_localobjectreference()) {
    _this->_impl_.localobjectreference_ = new ::k8s::io::api::core::v1::LocalObjectReference(*from._impl_.localobjectreference_);
  }
  _this->_impl_.optional_ = from._impl_.optional_;
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.ConfigMapEnvSource)
}

inline void ConfigMapEnvSource::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.localobjectreference_){nullptr}
    , decltype(_impl_.optional_){false}
  };
}

ConfigMapEnvSource::~ConfigMapEnvSource() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.ConfigMapEnvSource)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ConfigMapEnvSource::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.localobjectreference_;
}

void ConfigMapEnvSource::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ConfigMapEnvSource::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.ConfigMapEnvSource)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.localobjectreference_ != nullptr);
    _impl_.localobjectreference_->Clear();
  }
  _impl_.optional_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ConfigMapEnvSource::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .k8s.io.api.core.v1.LocalObjectReference localObjectReference = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_localobjectreference(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool optional = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_optional(&has_bits);
          _impl_.optional_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ConfigMapEnvSource::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.ConfigMapEnvSource)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .k8s.io.api.core.v1.LocalObjectReference localObjectReference = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::localobjectreference(this),
        _Internal::localobjectreference(this).GetCachedSize(), target, stream);
  }

  // optional bool optional = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_optional(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.ConfigMapEnvSource)
  return target;
}

size_t ConfigMapEnvSource::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.ConfigMapEnvSource)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .k8s.io.api.core.v1.LocalObjectReference localObjectReference = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.localobjectreference_);
    }

    // optional bool optional = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ConfigMapEnvSource::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ConfigMapEnvSource::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ConfigMapEnvSource::GetClassData() const { return &_class_data_; }


void ConfigMapEnvSource::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ConfigMapEnvSource*>(&to_msg);
  auto& from = static_cast<const ConfigMapEnvSource&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.ConfigMapEnvSource)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_localobjectreference()->::k8s::io::api::core::v1::LocalObjectReference::MergeFrom(
          from._internal_localobjectreference());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.optional_ = from._impl_.optional_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ConfigMapEnvSource::CopyFrom(const ConfigMapEnvSource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.ConfigMapEnvSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConfigMapEnvSource::IsInitialized() const {
  return true;
}

void ConfigMapEnvSource::InternalSwap(ConfigMapEnvSource* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ConfigMapEnvSource, _impl_.optional_)
      + sizeof(ConfigMapEnvSource::_impl_.optional_)
      - PROTOBUF_FIELD_OFFSET(ConfigMapEnvSource, _impl_.localobjectreference_)>(
          reinterpret_cast<char*>(&_impl_.localobjectreference_),
          reinterpret_cast<char*>(&other->_impl_.localobjectreference_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ConfigMapEnvSource::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[27]);
}

// ===================================================================

class ConfigMapKeySelector::_Internal {
 public:
  using HasBits = decltype(std::declval<ConfigMapKeySelector>()._impl_._has_bits_);
  static const ::k8s::io::api::core::v1::LocalObjectReference& localobjectreference(const ConfigMapKeySelector* msg);
  static void set_has_localobjectreference(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_optional(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::k8s::io::api::core::v1::LocalObjectReference&
ConfigMapKeySelector::_Internal::localobjectreference(const ConfigMapKeySelector* msg) {
  return *msg->_impl_.localobjectreference_;
}
ConfigMapKeySelector::ConfigMapKeySelector(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.ConfigMapKeySelector)
}
ConfigMapKeySelector::ConfigMapKeySelector(const ConfigMapKeySelector& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ConfigMapKeySelector* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.key_){}
    , decltype(_impl_.localobjectreference_){nullptr}
    , decltype(_impl_.optional_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_key()) {
    _this->_impl_.key_.Set(from._internal_key(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_localobjectreference()) {
    _this->_impl_.localobjectreference_ = new ::k8s::io::api::core::v1::LocalObjectReference(*from._impl_.localobjectreference_);
  }
  _this->_impl_.optional_ = from._impl_.optional_;
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.ConfigMapKeySelector)
}

inline void ConfigMapKeySelector::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.key_){}
    , decltype(_impl_.localobjectreference_){nullptr}
    , decltype(_impl_.optional_){false}
  };
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ConfigMapKeySelector::~ConfigMapKeySelector() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.ConfigMapKeySelector)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ConfigMapKeySelector::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.key_.Destroy();
  if (this != internal_default_instance()) delete _impl_.localobjectreference_;
}

void ConfigMapKeySelector::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ConfigMapKeySelector::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.ConfigMapKeySelector)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.key_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.localobjectreference_ != nullptr);
      _impl_.localobjectreference_->Clear();
    }
  }
  _impl_.optional_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ConfigMapKeySelector::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .k8s.io.api.core.v1.LocalObjectReference localObjectReference = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_localobjectreference(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes key = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool optional = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_optional(&has_bits);
          _impl_.optional_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ConfigMapKeySelector::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.ConfigMapKeySelector)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .k8s.io.api.core.v1.LocalObjectReference localObjectReference = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::localobjectreference(this),
        _Internal::localobjectreference(this).GetCachedSize(), target, stream);
  }

  // optional bytes key = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_key(), target);
  }

  // optional bool optional = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_optional(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.ConfigMapKeySelector)
  return target;
}

size_t ConfigMapKeySelector::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.ConfigMapKeySelector)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bytes key = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_key());
    }

    // optional .k8s.io.api.core.v1.LocalObjectReference localObjectReference = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.localobjectreference_);
    }

    // optional bool optional = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ConfigMapKeySelector::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ConfigMapKeySelector::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ConfigMapKeySelector::GetClassData() const { return &_class_data_; }


void ConfigMapKeySelector::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ConfigMapKeySelector*>(&to_msg);
  auto& from = static_cast<const ConfigMapKeySelector&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.ConfigMapKeySelector)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_key(from._internal_key());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_localobjectreference()->::k8s::io::api::core::v1::LocalObjectReference::MergeFrom(
          from._internal_localobjectreference());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.optional_ = from._impl_.optional_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ConfigMapKeySelector::CopyFrom(const ConfigMapKeySelector& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.ConfigMapKeySelector)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConfigMapKeySelector::IsInitialized() const {
  return true;
}

void ConfigMapKeySelector::InternalSwap(ConfigMapKeySelector* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.key_, lhs_arena,
      &other->_impl_.key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ConfigMapKeySelector, _impl_.optional_)
      + sizeof(ConfigMapKeySelector::_impl_.optional_)
      - PROTOBUF_FIELD_OFFSET(ConfigMapKeySelector, _impl_.localobjectreference_)>(
          reinterpret_cast<char*>(&_impl_.localobjectreference_),
          reinterpret_cast<char*>(&other->_impl_.localobjectreference_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ConfigMapKeySelector::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[28]);
}

// ===================================================================

class ConfigMapList::_Internal {
 public:
  using HasBits = decltype(std::declval<ConfigMapList>()._impl_._has_bits_);
  static const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& metadata(const ConfigMapList* msg);
  static void set_has_metadata(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta&
ConfigMapList::_Internal::metadata(const ConfigMapList* msg) {
  return *msg->_impl_.metadata_;
}
void ConfigMapList::clear_metadata() {
  if (_impl_.metadata_ != nullptr) _impl_.metadata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
ConfigMapList::ConfigMapList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.ConfigMapList)
}
ConfigMapList::ConfigMapList(const ConfigMapList& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ConfigMapList* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.items_){from._impl_.items_}
    , decltype(_impl_.metadata_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_metadata()) {
    _this->_impl_.metadata_ = new ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta(*from._impl_.metadata_);
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.ConfigMapList)
}

inline void ConfigMapList::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.items_){arena}
    , decltype(_impl_.metadata_){nullptr}
  };
}

ConfigMapList::~ConfigMapList() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.ConfigMapList)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ConfigMapList::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.items_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.metadata_;
}

void ConfigMapList::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ConfigMapList::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.ConfigMapList)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.items_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.metadata_ != nullptr);
    _impl_.metadata_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ConfigMapList::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_metadata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .k8s.io.api.core.v1.ConfigMap items = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_items(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ConfigMapList::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.ConfigMapList)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::metadata(this),
        _Internal::metadata(this).GetCachedSize(), target, stream);
  }

  // repeated .k8s.io.api.core.v1.ConfigMap items = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_items_size()); i < n; i++) {
    const auto& repfield = this->_internal_items(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.ConfigMapList)
  return target;
}

size_t ConfigMapList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.ConfigMapList)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .k8s.io.api.core.v1.ConfigMap items = 2;
  total_size += 1UL * this->_internal_items_size();
  for (const auto& msg : this->_impl_.items_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.metadata_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ConfigMapList::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ConfigMapList::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ConfigMapList::GetClassData() const { return &_class_data_; }


void ConfigMapList::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ConfigMapList*>(&to_msg);
  auto& from = static_cast<const ConfigMapList&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.ConfigMapList)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.items_.MergeFrom(from._impl_.items_);
  if (from._internal_has_metadata()) {
    _this->_internal_mutable_metadata()->::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta::MergeFrom(
        from._internal_metadata());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ConfigMapList::CopyFrom(const ConfigMapList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.ConfigMapList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConfigMapList::IsInitialized() const {
  return true;
}

void ConfigMapList::InternalSwap(ConfigMapList* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.items_.InternalSwap(&other->_impl_.items_);
  swap(_impl_.metadata_, other->_impl_.metadata_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ConfigMapList::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[29]);
}

// ===================================================================

class ConfigMapNodeConfigSource::_Internal {
 public:
  using HasBits = decltype(std::declval<ConfigMapNodeConfigSource>()._impl_._has_bits_);
  static void set_has_namespace_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_uid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_resourceversion(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_kubeletconfigkey(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

ConfigMapNodeConfigSource::ConfigMapNodeConfigSource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.ConfigMapNodeConfigSource)
}
ConfigMapNodeConfigSource::ConfigMapNodeConfigSource(const ConfigMapNodeConfigSource& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ConfigMapNodeConfigSource* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.namespace__){}
    , decltype(_impl_.name_){}
    , decltype(_impl_.uid_){}
    , decltype(_impl_.resourceversion_){}
    , decltype(_impl_.kubeletconfigkey_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.namespace__.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.namespace__.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_namespace_()) {
    _this->_impl_.namespace__.Set(from._internal_namespace_(), 
      _this->GetArenaForAllocation());
  }
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.uid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.uid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_uid()) {
    _this->_impl_.uid_.Set(from._internal_uid(), 
      _this->GetArenaForAllocation());
  }
  _impl_.resourceversion_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.resourceversion_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_resourceversion()) {
    _this->_impl_.resourceversion_.Set(from._internal_resourceversion(), 
      _this->GetArenaForAllocation());
  }
  _impl_.kubeletconfigkey_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.kubeletconfigkey_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_kubeletconfigkey()) {
    _this->_impl_.kubeletconfigkey_.Set(from._internal_kubeletconfigkey(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.ConfigMapNodeConfigSource)
}

inline void ConfigMapNodeConfigSource::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.namespace__){}
    , decltype(_impl_.name_){}
    , decltype(_impl_.uid_){}
    , decltype(_impl_.resourceversion_){}
    , decltype(_impl_.kubeletconfigkey_){}
  };
  _impl_.namespace__.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.namespace__.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.uid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.uid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.resourceversion_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.resourceversion_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.kubeletconfigkey_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.kubeletconfigkey_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ConfigMapNodeConfigSource::~ConfigMapNodeConfigSource() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.ConfigMapNodeConfigSource)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ConfigMapNodeConfigSource::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.namespace__.Destroy();
  _impl_.name_.Destroy();
  _impl_.uid_.Destroy();
  _impl_.resourceversion_.Destroy();
  _impl_.kubeletconfigkey_.Destroy();
}

void ConfigMapNodeConfigSource::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ConfigMapNodeConfigSource::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.ConfigMapNodeConfigSource)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.namespace__.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.uid_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.resourceversion_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.kubeletconfigkey_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ConfigMapNodeConfigSource::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes namespace = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_namespace_();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes uid = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_uid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes resourceVersion = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_resourceversion();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes kubeletConfigKey = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_kubeletconfigkey();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ConfigMapNodeConfigSource::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.ConfigMapNodeConfigSource)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes namespace = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_namespace_(), target);
  }

  // optional bytes name = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_name(), target);
  }

  // optional bytes uid = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_uid(), target);
  }

  // optional bytes resourceVersion = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_resourceversion(), target);
  }

  // optional bytes kubeletConfigKey = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_kubeletconfigkey(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.ConfigMapNodeConfigSource)
  return target;
}

size_t ConfigMapNodeConfigSource::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.ConfigMapNodeConfigSource)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional bytes namespace = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_namespace_());
    }

    // optional bytes name = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_name());
    }

    // optional bytes uid = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_uid());
    }

    // optional bytes resourceVersion = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_resourceversion());
    }

    // optional bytes kubeletConfigKey = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_kubeletconfigkey());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ConfigMapNodeConfigSource::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ConfigMapNodeConfigSource::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ConfigMapNodeConfigSource::GetClassData() const { return &_class_data_; }


void ConfigMapNodeConfigSource::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ConfigMapNodeConfigSource*>(&to_msg);
  auto& from = static_cast<const ConfigMapNodeConfigSource&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.ConfigMapNodeConfigSource)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_namespace_(from._internal_namespace_());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_uid(from._internal_uid());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_resourceversion(from._internal_resourceversion());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_kubeletconfigkey(from._internal_kubeletconfigkey());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ConfigMapNodeConfigSource::CopyFrom(const ConfigMapNodeConfigSource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.ConfigMapNodeConfigSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConfigMapNodeConfigSource::IsInitialized() const {
  return true;
}

void ConfigMapNodeConfigSource::InternalSwap(ConfigMapNodeConfigSource* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.namespace__, lhs_arena,
      &other->_impl_.namespace__, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.uid_, lhs_arena,
      &other->_impl_.uid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.resourceversion_, lhs_arena,
      &other->_impl_.resourceversion_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.kubeletconfigkey_, lhs_arena,
      &other->_impl_.kubeletconfigkey_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ConfigMapNodeConfigSource::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[30]);
}

// ===================================================================

class ConfigMapProjection::_Internal {
 public:
  using HasBits = decltype(std::declval<ConfigMapProjection>()._impl_._has_bits_);
  static const ::k8s::io::api::core::v1::LocalObjectReference& localobjectreference(const ConfigMapProjection* msg);
  static void set_has_localobjectreference(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_optional(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::k8s::io::api::core::v1::LocalObjectReference&
ConfigMapProjection::_Internal::localobjectreference(const ConfigMapProjection* msg) {
  return *msg->_impl_.localobjectreference_;
}
ConfigMapProjection::ConfigMapProjection(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.ConfigMapProjection)
}
ConfigMapProjection::ConfigMapProjection(const ConfigMapProjection& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ConfigMapProjection* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.items_){from._impl_.items_}
    , decltype(_impl_.localobjectreference_){nullptr}
    , decltype(_impl_.optional_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_localobjectreference()) {
    _this->_impl_.localobjectreference_ = new ::k8s::io::api::core::v1::LocalObjectReference(*from._impl_.localobjectreference_);
  }
  _this->_impl_.optional_ = from._impl_.optional_;
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.ConfigMapProjection)
}

inline void ConfigMapProjection::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.items_){arena}
    , decltype(_impl_.localobjectreference_){nullptr}
    , decltype(_impl_.optional_){false}
  };
}

ConfigMapProjection::~ConfigMapProjection() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.ConfigMapProjection)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ConfigMapProjection::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.items_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.localobjectreference_;
}

void ConfigMapProjection::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ConfigMapProjection::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.ConfigMapProjection)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.items_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.localobjectreference_ != nullptr);
    _impl_.localobjectreference_->Clear();
  }
  _impl_.optional_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ConfigMapProjection::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .k8s.io.api.core.v1.LocalObjectReference localObjectReference = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_localobjectreference(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .k8s.io.api.core.v1.KeyToPath items = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_items(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool optional = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_optional(&has_bits);
          _impl_.optional_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ConfigMapProjection::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.ConfigMapProjection)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .k8s.io.api.core.v1.LocalObjectReference localObjectReference = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::localobjectreference(this),
        _Internal::localobjectreference(this).GetCachedSize(), target, stream);
  }

  // repeated .k8s.io.api.core.v1.KeyToPath items = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_items_size()); i < n; i++) {
    const auto& repfield = this->_internal_items(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bool optional = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_optional(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.ConfigMapProjection)
  return target;
}

size_t ConfigMapProjection::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.ConfigMapProjection)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .k8s.io.api.core.v1.KeyToPath items = 2;
  total_size += 1UL * this->_internal_items_size();
  for (const auto& msg : this->_impl_.items_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .k8s.io.api.core.v1.LocalObjectReference localObjectReference = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.localobjectreference_);
    }

    // optional bool optional = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ConfigMapProjection::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ConfigMapProjection::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ConfigMapProjection::GetClassData() const { return &_class_data_; }


void ConfigMapProjection::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ConfigMapProjection*>(&to_msg);
  auto& from = static_cast<const ConfigMapProjection&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.ConfigMapProjection)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.items_.MergeFrom(from._impl_.items_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_localobjectreference()->::k8s::io::api::core::v1::LocalObjectReference::MergeFrom(
          from._internal_localobjectreference());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.optional_ = from._impl_.optional_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ConfigMapProjection::CopyFrom(const ConfigMapProjection& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.ConfigMapProjection)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConfigMapProjection::IsInitialized() const {
  return true;
}

void ConfigMapProjection::InternalSwap(ConfigMapProjection* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.items_.InternalSwap(&other->_impl_.items_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ConfigMapProjection, _impl_.optional_)
      + sizeof(ConfigMapProjection::_impl_.optional_)
      - PROTOBUF_FIELD_OFFSET(ConfigMapProjection, _impl_.localobjectreference_)>(
          reinterpret_cast<char*>(&_impl_.localobjectreference_),
          reinterpret_cast<char*>(&other->_impl_.localobjectreference_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ConfigMapProjection::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[31]);
}

// ===================================================================

class ConfigMapVolumeSource::_Internal {
 public:
  using HasBits = decltype(std::declval<ConfigMapVolumeSource>()._impl_._has_bits_);
  static const ::k8s::io::api::core::v1::LocalObjectReference& localobjectreference(const ConfigMapVolumeSource* msg);
  static void set_has_localobjectreference(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_defaultmode(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_optional(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::k8s::io::api::core::v1::LocalObjectReference&
ConfigMapVolumeSource::_Internal::localobjectreference(const ConfigMapVolumeSource* msg) {
  return *msg->_impl_.localobjectreference_;
}
ConfigMapVolumeSource::ConfigMapVolumeSource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.ConfigMapVolumeSource)
}
ConfigMapVolumeSource::ConfigMapVolumeSource(const ConfigMapVolumeSource& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ConfigMapVolumeSource* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.items_){from._impl_.items_}
    , decltype(_impl_.localobjectreference_){nullptr}
    , decltype(_impl_.defaultmode_){}
    , decltype(_impl_.optional_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_localobjectreference()) {
    _this->_impl_.localobjectreference_ = new ::k8s::io::api::core::v1::LocalObjectReference(*from._impl_.localobjectreference_);
  }
  ::memcpy(&_impl_.defaultmode_, &from._impl_.defaultmode_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.optional_) -
    reinterpret_cast<char*>(&_impl_.defaultmode_)) + sizeof(_impl_.optional_));
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.ConfigMapVolumeSource)
}

inline void ConfigMapVolumeSource::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.items_){arena}
    , decltype(_impl_.localobjectreference_){nullptr}
    , decltype(_impl_.defaultmode_){0}
    , decltype(_impl_.optional_){false}
  };
}

ConfigMapVolumeSource::~ConfigMapVolumeSource() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.ConfigMapVolumeSource)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ConfigMapVolumeSource::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.items_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.localobjectreference_;
}

void ConfigMapVolumeSource::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ConfigMapVolumeSource::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.ConfigMapVolumeSource)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.items_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.localobjectreference_ != nullptr);
    _impl_.localobjectreference_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.defaultmode_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.optional_) -
        reinterpret_cast<char*>(&_impl_.defaultmode_)) + sizeof(_impl_.optional_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ConfigMapVolumeSource::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .k8s.io.api.core.v1.LocalObjectReference localObjectReference = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_localobjectreference(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .k8s.io.api.core.v1.KeyToPath items = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_items(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional int32 defaultMode = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_defaultmode(&has_bits);
          _impl_.defaultmode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool optional = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_optional(&has_bits);
          _impl_.optional_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ConfigMapVolumeSource::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.ConfigMapVolumeSource)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .k8s.io.api.core.v1.LocalObjectReference localObjectReference = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::localobjectreference(this),
        _Internal::localobjectreference(this).GetCachedSize(), target, stream);
  }

  // repeated .k8s.io.api.core.v1.KeyToPath items = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_items_size()); i < n; i++) {
    const auto& repfield = this->_internal_items(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional int32 defaultMode = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_defaultmode(), target);
  }

  // optional bool optional = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_optional(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.ConfigMapVolumeSource)
  return target;
}

size_t ConfigMapVolumeSource::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.ConfigMapVolumeSource)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .k8s.io.api.core.v1.KeyToPath items = 2;
  total_size += 1UL * this->_internal_items_size();
  for (const auto& msg : this->_impl_.items_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .k8s.io.api.core.v1.LocalObjectReference localObjectReference = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.localobjectreference_);
    }

    // optional int32 defaultMode = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_defaultmode());
    }

    // optional bool optional = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ConfigMapVolumeSource::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ConfigMapVolumeSource::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ConfigMapVolumeSource::GetClassData() const { return &_class_data_; }


void ConfigMapVolumeSource::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ConfigMapVolumeSource*>(&to_msg);
  auto& from = static_cast<const ConfigMapVolumeSource&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.ConfigMapVolumeSource)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.items_.MergeFrom(from._impl_.items_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_localobjectreference()->::k8s::io::api::core::v1::LocalObjectReference::MergeFrom(
          from._internal_localobjectreference());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.defaultmode_ = from._impl_.defaultmode_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.optional_ = from._impl_.optional_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ConfigMapVolumeSource::CopyFrom(const ConfigMapVolumeSource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.ConfigMapVolumeSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConfigMapVolumeSource::IsInitialized() const {
  return true;
}

void ConfigMapVolumeSource::InternalSwap(ConfigMapVolumeSource* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.items_.InternalSwap(&other->_impl_.items_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ConfigMapVolumeSource, _impl_.optional_)
      + sizeof(ConfigMapVolumeSource::_impl_.optional_)
      - PROTOBUF_FIELD_OFFSET(ConfigMapVolumeSource, _impl_.localobjectreference_)>(
          reinterpret_cast<char*>(&_impl_.localobjectreference_),
          reinterpret_cast<char*>(&other->_impl_.localobjectreference_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ConfigMapVolumeSource::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[32]);
}

// ===================================================================

class Container::_Internal {
 public:
  using HasBits = decltype(std::declval<Container>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_image(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_workingdir(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::k8s::io::api::core::v1::ResourceRequirements& resources(const Container* msg);
  static void set_has_resources(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_restartpolicy(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::k8s::io::api::core::v1::Probe& livenessprobe(const Container* msg);
  static void set_has_livenessprobe(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static const ::k8s::io::api::core::v1::Probe& readinessprobe(const Container* msg);
  static void set_has_readinessprobe(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static const ::k8s::io::api::core::v1::Probe& startupprobe(const Container* msg);
  static void set_has_startupprobe(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static const ::k8s::io::api::core::v1::Lifecycle& lifecycle(const Container* msg);
  static void set_has_lifecycle(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_terminationmessagepath(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_terminationmessagepolicy(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_imagepullpolicy(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::k8s::io::api::core::v1::SecurityContext& securitycontext(const Container* msg);
  static void set_has_securitycontext(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_stdin(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_stdinonce(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_tty(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
};

const ::k8s::io::api::core::v1::ResourceRequirements&
Container::_Internal::resources(const Container* msg) {
  return *msg->_impl_.resources_;
}
const ::k8s::io::api::core::v1::Probe&
Container::_Internal::livenessprobe(const Container* msg) {
  return *msg->_impl_.livenessprobe_;
}
const ::k8s::io::api::core::v1::Probe&
Container::_Internal::readinessprobe(const Container* msg) {
  return *msg->_impl_.readinessprobe_;
}
const ::k8s::io::api::core::v1::Probe&
Container::_Internal::startupprobe(const Container* msg) {
  return *msg->_impl_.startupprobe_;
}
const ::k8s::io::api::core::v1::Lifecycle&
Container::_Internal::lifecycle(const Container* msg) {
  return *msg->_impl_.lifecycle_;
}
const ::k8s::io::api::core::v1::SecurityContext&
Container::_Internal::securitycontext(const Container* msg) {
  return *msg->_impl_.securitycontext_;
}
Container::Container(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.Container)
}
Container::Container(const Container& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Container* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.command_){from._impl_.command_}
    , decltype(_impl_.args_){from._impl_.args_}
    , decltype(_impl_.ports_){from._impl_.ports_}
    , decltype(_impl_.env_){from._impl_.env_}
    , decltype(_impl_.volumemounts_){from._impl_.volumemounts_}
    , decltype(_impl_.envfrom_){from._impl_.envfrom_}
    , decltype(_impl_.volumedevices_){from._impl_.volumedevices_}
    , decltype(_impl_.resizepolicy_){from._impl_.resizepolicy_}
    , decltype(_impl_.name_){}
    , decltype(_impl_.image_){}
    , decltype(_impl_.workingdir_){}
    , decltype(_impl_.terminationmessagepath_){}
    , decltype(_impl_.imagepullpolicy_){}
    , decltype(_impl_.terminationmessagepolicy_){}
    , decltype(_impl_.restartpolicy_){}
    , decltype(_impl_.resources_){nullptr}
    , decltype(_impl_.livenessprobe_){nullptr}
    , decltype(_impl_.readinessprobe_){nullptr}
    , decltype(_impl_.lifecycle_){nullptr}
    , decltype(_impl_.securitycontext_){nullptr}
    , decltype(_impl_.startupprobe_){nullptr}
    , decltype(_impl_.stdin_){}
    , decltype(_impl_.stdinonce_){}
    , decltype(_impl_.tty_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.image_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.image_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_image()) {
    _this->_impl_.image_.Set(from._internal_image(), 
      _this->GetArenaForAllocation());
  }
  _impl_.workingdir_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.workingdir_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_workingdir()) {
    _this->_impl_.workingdir_.Set(from._internal_workingdir(), 
      _this->GetArenaForAllocation());
  }
  _impl_.terminationmessagepath_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.terminationmessagepath_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_terminationmessagepath()) {
    _this->_impl_.terminationmessagepath_.Set(from._internal_terminationmessagepath(), 
      _this->GetArenaForAllocation());
  }
  _impl_.imagepullpolicy_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.imagepullpolicy_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_imagepullpolicy()) {
    _this->_impl_.imagepullpolicy_.Set(from._internal_imagepullpolicy(), 
      _this->GetArenaForAllocation());
  }
  _impl_.terminationmessagepolicy_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.terminationmessagepolicy_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_terminationmessagepolicy()) {
    _this->_impl_.terminationmessagepolicy_.Set(from._internal_terminationmessagepolicy(), 
      _this->GetArenaForAllocation());
  }
  _impl_.restartpolicy_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.restartpolicy_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_restartpolicy()) {
    _this->_impl_.restartpolicy_.Set(from._internal_restartpolicy(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_resources()) {
    _this->_impl_.resources_ = new ::k8s::io::api::core::v1::ResourceRequirements(*from._impl_.resources_);
  }
  if (from._internal_has_livenessprobe()) {
    _this->_impl_.livenessprobe_ = new ::k8s::io::api::core::v1::Probe(*from._impl_.livenessprobe_);
  }
  if (from._internal_has_readinessprobe()) {
    _this->_impl_.readinessprobe_ = new ::k8s::io::api::core::v1::Probe(*from._impl_.readinessprobe_);
  }
  if (from._internal_has_lifecycle()) {
    _this->_impl_.lifecycle_ = new ::k8s::io::api::core::v1::Lifecycle(*from._impl_.lifecycle_);
  }
  if (from._internal_has_securitycontext()) {
    _this->_impl_.securitycontext_ = new ::k8s::io::api::core::v1::SecurityContext(*from._impl_.securitycontext_);
  }
  if (from._internal_has_startupprobe()) {
    _this->_impl_.startupprobe_ = new ::k8s::io::api::core::v1::Probe(*from._impl_.startupprobe_);
  }
  ::memcpy(&_impl_.stdin_, &from._impl_.stdin_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.tty_) -
    reinterpret_cast<char*>(&_impl_.stdin_)) + sizeof(_impl_.tty_));
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.Container)
}

inline void Container::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.command_){arena}
    , decltype(_impl_.args_){arena}
    , decltype(_impl_.ports_){arena}
    , decltype(_impl_.env_){arena}
    , decltype(_impl_.volumemounts_){arena}
    , decltype(_impl_.envfrom_){arena}
    , decltype(_impl_.volumedevices_){arena}
    , decltype(_impl_.resizepolicy_){arena}
    , decltype(_impl_.name_){}
    , decltype(_impl_.image_){}
    , decltype(_impl_.workingdir_){}
    , decltype(_impl_.terminationmessagepath_){}
    , decltype(_impl_.imagepullpolicy_){}
    , decltype(_impl_.terminationmessagepolicy_){}
    , decltype(_impl_.restartpolicy_){}
    , decltype(_impl_.resources_){nullptr}
    , decltype(_impl_.livenessprobe_){nullptr}
    , decltype(_impl_.readinessprobe_){nullptr}
    , decltype(_impl_.lifecycle_){nullptr}
    , decltype(_impl_.securitycontext_){nullptr}
    , decltype(_impl_.startupprobe_){nullptr}
    , decltype(_impl_.stdin_){false}
    , decltype(_impl_.stdinonce_){false}
    , decltype(_impl_.tty_){false}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.image_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.image_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.workingdir_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.workingdir_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.terminationmessagepath_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.terminationmessagepath_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.imagepullpolicy_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.imagepullpolicy_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.terminationmessagepolicy_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.terminationmessagepolicy_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.restartpolicy_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.restartpolicy_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Container::~Container() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.Container)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Container::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.command_.~RepeatedPtrField();
  _impl_.args_.~RepeatedPtrField();
  _impl_.ports_.~RepeatedPtrField();
  _impl_.env_.~RepeatedPtrField();
  _impl_.volumemounts_.~RepeatedPtrField();
  _impl_.envfrom_.~RepeatedPtrField();
  _impl_.volumedevices_.~RepeatedPtrField();
  _impl_.resizepolicy_.~RepeatedPtrField();
  _impl_.name_.Destroy();
  _impl_.image_.Destroy();
  _impl_.workingdir_.Destroy();
  _impl_.terminationmessagepath_.Destroy();
  _impl_.imagepullpolicy_.Destroy();
  _impl_.terminationmessagepolicy_.Destroy();
  _impl_.restartpolicy_.Destroy();
  if (this != internal_default_instance()) delete _impl_.resources_;
  if (this != internal_default_instance()) delete _impl_.livenessprobe_;
  if (this != internal_default_instance()) delete _impl_.readinessprobe_;
  if (this != internal_default_instance()) delete _impl_.lifecycle_;
  if (this != internal_default_instance()) delete _impl_.securitycontext_;
  if (this != internal_default_instance()) delete _impl_.startupprobe_;
}

void Container::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Container::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.Container)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.command_.Clear();
  _impl_.args_.Clear();
  _impl_.ports_.Clear();
  _impl_.env_.Clear();
  _impl_.volumemounts_.Clear();
  _impl_.envfrom_.Clear();
  _impl_.volumedevices_.Clear();
  _impl_.resizepolicy_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.image_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.workingdir_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.terminationmessagepath_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.imagepullpolicy_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      _impl_.terminationmessagepolicy_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000040u) {
      _impl_.restartpolicy_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(_impl_.resources_ != nullptr);
      _impl_.resources_->Clear();
    }
  }
  if (cached_has_bits & 0x00001f00u) {
    if (cached_has_bits & 0x00000100u) {
      GOOGLE_DCHECK(_impl_.livenessprobe_ != nullptr);
      _impl_.livenessprobe_->Clear();
    }
    if (cached_has_bits & 0x00000200u) {
      GOOGLE_DCHECK(_impl_.readinessprobe_ != nullptr);
      _impl_.readinessprobe_->Clear();
    }
    if (cached_has_bits & 0x00000400u) {
      GOOGLE_DCHECK(_impl_.lifecycle_ != nullptr);
      _impl_.lifecycle_->Clear();
    }
    if (cached_has_bits & 0x00000800u) {
      GOOGLE_DCHECK(_impl_.securitycontext_ != nullptr);
      _impl_.securitycontext_->Clear();
    }
    if (cached_has_bits & 0x00001000u) {
      GOOGLE_DCHECK(_impl_.startupprobe_ != nullptr);
      _impl_.startupprobe_->Clear();
    }
  }
  ::memset(&_impl_.stdin_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.tty_) -
      reinterpret_cast<char*>(&_impl_.stdin_)) + sizeof(_impl_.tty_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Container::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes image = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_image();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string command = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_command();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "k8s.io.api.core.v1.Container.command");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string args = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_args();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "k8s.io.api.core.v1.Container.args");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bytes workingDir = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_workingdir();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .k8s.io.api.core.v1.ContainerPort ports = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_ports(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .k8s.io.api.core.v1.EnvVar env = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_env(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.ResourceRequirements resources = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_resources(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .k8s.io.api.core.v1.VolumeMount volumeMounts = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_volumemounts(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.Probe livenessProbe = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_livenessprobe(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.Probe readinessProbe = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_readinessprobe(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.Lifecycle lifecycle = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_lifecycle(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes terminationMessagePath = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          auto str = _internal_mutable_terminationmessagepath();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes imagePullPolicy = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          auto str = _internal_mutable_imagepullpolicy();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.SecurityContext securityContext = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_securitycontext(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool stdin = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_stdin(&has_bits);
          _impl_.stdin_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool stdinOnce = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_stdinonce(&has_bits);
          _impl_.stdinonce_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool tty = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _Internal::set_has_tty(&has_bits);
          _impl_.tty_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .k8s.io.api.core.v1.EnvFromSource envFrom = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_envfrom(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<154>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bytes terminationMessagePolicy = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          auto str = _internal_mutable_terminationmessagepolicy();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .k8s.io.api.core.v1.VolumeDevice volumeDevices = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_volumedevices(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<170>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.Probe startupProbe = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 178)) {
          ptr = ctx->ParseMessage(_internal_mutable_startupprobe(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .k8s.io.api.core.v1.ContainerResizePolicy resizePolicy = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 186)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_resizepolicy(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<186>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bytes restartPolicy = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 194)) {
          auto str = _internal_mutable_restartpolicy();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Container::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.Container)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional bytes image = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_image(), target);
  }

  // repeated string command = 3;
  for (int i = 0, n = this->_internal_command_size(); i < n; i++) {
    const auto& s = this->_internal_command(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "k8s.io.api.core.v1.Container.command");
    target = stream->WriteString(3, s, target);
  }

  // repeated string args = 4;
  for (int i = 0, n = this->_internal_args_size(); i < n; i++) {
    const auto& s = this->_internal_args(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "k8s.io.api.core.v1.Container.args");
    target = stream->WriteString(4, s, target);
  }

  // optional bytes workingDir = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_workingdir(), target);
  }

  // repeated .k8s.io.api.core.v1.ContainerPort ports = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_ports_size()); i < n; i++) {
    const auto& repfield = this->_internal_ports(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .k8s.io.api.core.v1.EnvVar env = 7;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_env_size()); i < n; i++) {
    const auto& repfield = this->_internal_env(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.ResourceRequirements resources = 8;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::resources(this),
        _Internal::resources(this).GetCachedSize(), target, stream);
  }

  // repeated .k8s.io.api.core.v1.VolumeMount volumeMounts = 9;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_volumemounts_size()); i < n; i++) {
    const auto& repfield = this->_internal_volumemounts(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(9, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.Probe livenessProbe = 10;
  if (cached_has_bits & 0x00000100u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::livenessprobe(this),
        _Internal::livenessprobe(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.Probe readinessProbe = 11;
  if (cached_has_bits & 0x00000200u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::readinessprobe(this),
        _Internal::readinessprobe(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.Lifecycle lifecycle = 12;
  if (cached_has_bits & 0x00000400u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, _Internal::lifecycle(this),
        _Internal::lifecycle(this).GetCachedSize(), target, stream);
  }

  // optional bytes terminationMessagePath = 13;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        13, this->_internal_terminationmessagepath(), target);
  }

  // optional bytes imagePullPolicy = 14;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteBytesMaybeAliased(
        14, this->_internal_imagepullpolicy(), target);
  }

  // optional .k8s.io.api.core.v1.SecurityContext securityContext = 15;
  if (cached_has_bits & 0x00000800u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(15, _Internal::securitycontext(this),
        _Internal::securitycontext(this).GetCachedSize(), target, stream);
  }

  // optional bool stdin = 16;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(16, this->_internal_stdin(), target);
  }

  // optional bool stdinOnce = 17;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(17, this->_internal_stdinonce(), target);
  }

  // optional bool tty = 18;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(18, this->_internal_tty(), target);
  }

  // repeated .k8s.io.api.core.v1.EnvFromSource envFrom = 19;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_envfrom_size()); i < n; i++) {
    const auto& repfield = this->_internal_envfrom(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(19, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bytes terminationMessagePolicy = 20;
  if (cached_has_bits & 0x00000020u) {
    target = stream->WriteBytesMaybeAliased(
        20, this->_internal_terminationmessagepolicy(), target);
  }

  // repeated .k8s.io.api.core.v1.VolumeDevice volumeDevices = 21;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_volumedevices_size()); i < n; i++) {
    const auto& repfield = this->_internal_volumedevices(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(21, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.Probe startupProbe = 22;
  if (cached_has_bits & 0x00001000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(22, _Internal::startupprobe(this),
        _Internal::startupprobe(this).GetCachedSize(), target, stream);
  }

  // repeated .k8s.io.api.core.v1.ContainerResizePolicy resizePolicy = 23;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_resizepolicy_size()); i < n; i++) {
    const auto& repfield = this->_internal_resizepolicy(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(23, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bytes restartPolicy = 24;
  if (cached_has_bits & 0x00000040u) {
    target = stream->WriteBytesMaybeAliased(
        24, this->_internal_restartpolicy(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.Container)
  return target;
}

size_t Container::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.Container)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string command = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.command_.size());
  for (int i = 0, n = _impl_.command_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.command_.Get(i));
  }

  // repeated string args = 4;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.args_.size());
  for (int i = 0, n = _impl_.args_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.args_.Get(i));
  }

  // repeated .k8s.io.api.core.v1.ContainerPort ports = 6;
  total_size += 1UL * this->_internal_ports_size();
  for (const auto& msg : this->_impl_.ports_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .k8s.io.api.core.v1.EnvVar env = 7;
  total_size += 1UL * this->_internal_env_size();
  for (const auto& msg : this->_impl_.env_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .k8s.io.api.core.v1.VolumeMount volumeMounts = 9;
  total_size += 1UL * this->_internal_volumemounts_size();
  for (const auto& msg : this->_impl_.volumemounts_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .k8s.io.api.core.v1.EnvFromSource envFrom = 19;
  total_size += 2UL * this->_internal_envfrom_size();
  for (const auto& msg : this->_impl_.envfrom_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .k8s.io.api.core.v1.VolumeDevice volumeDevices = 21;
  total_size += 2UL * this->_internal_volumedevices_size();
  for (const auto& msg : this->_impl_.volumedevices_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .k8s.io.api.core.v1.ContainerResizePolicy resizePolicy = 23;
  total_size += 2UL * this->_internal_resizepolicy_size();
  for (const auto& msg : this->_impl_.resizepolicy_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bytes name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_name());
    }

    // optional bytes image = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_image());
    }

    // optional bytes workingDir = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_workingdir());
    }

    // optional bytes terminationMessagePath = 13;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_terminationmessagepath());
    }

    // optional bytes imagePullPolicy = 14;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_imagepullpolicy());
    }

    // optional bytes terminationMessagePolicy = 20;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_terminationmessagepolicy());
    }

    // optional bytes restartPolicy = 24;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_restartpolicy());
    }

    // optional .k8s.io.api.core.v1.ResourceRequirements resources = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.resources_);
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional .k8s.io.api.core.v1.Probe livenessProbe = 10;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.livenessprobe_);
    }

    // optional .k8s.io.api.core.v1.Probe readinessProbe = 11;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.readinessprobe_);
    }

    // optional .k8s.io.api.core.v1.Lifecycle lifecycle = 12;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.lifecycle_);
    }

    // optional .k8s.io.api.core.v1.SecurityContext securityContext = 15;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.securitycontext_);
    }

    // optional .k8s.io.api.core.v1.Probe startupProbe = 22;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.startupprobe_);
    }

    // optional bool stdin = 16;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 + 1;
    }

    // optional bool stdinOnce = 17;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 + 1;
    }

    // optional bool tty = 18;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Container::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Container::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Container::GetClassData() const { return &_class_data_; }


void Container::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Container*>(&to_msg);
  auto& from = static_cast<const Container&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.Container)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.command_.MergeFrom(from._impl_.command_);
  _this->_impl_.args_.MergeFrom(from._impl_.args_);
  _this->_impl_.ports_.MergeFrom(from._impl_.ports_);
  _this->_impl_.env_.MergeFrom(from._impl_.env_);
  _this->_impl_.volumemounts_.MergeFrom(from._impl_.volumemounts_);
  _this->_impl_.envfrom_.MergeFrom(from._impl_.envfrom_);
  _this->_impl_.volumedevices_.MergeFrom(from._impl_.volumedevices_);
  _this->_impl_.resizepolicy_.MergeFrom(from._impl_.resizepolicy_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_image(from._internal_image());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_workingdir(from._internal_workingdir());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_terminationmessagepath(from._internal_terminationmessagepath());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_imagepullpolicy(from._internal_imagepullpolicy());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_set_terminationmessagepolicy(from._internal_terminationmessagepolicy());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_set_restartpolicy(from._internal_restartpolicy());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_mutable_resources()->::k8s::io::api::core::v1::ResourceRequirements::MergeFrom(
          from._internal_resources());
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_internal_mutable_livenessprobe()->::k8s::io::api::core::v1::Probe::MergeFrom(
          from._internal_livenessprobe());
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_internal_mutable_readinessprobe()->::k8s::io::api::core::v1::Probe::MergeFrom(
          from._internal_readinessprobe());
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_internal_mutable_lifecycle()->::k8s::io::api::core::v1::Lifecycle::MergeFrom(
          from._internal_lifecycle());
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_internal_mutable_securitycontext()->::k8s::io::api::core::v1::SecurityContext::MergeFrom(
          from._internal_securitycontext());
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_internal_mutable_startupprobe()->::k8s::io::api::core::v1::Probe::MergeFrom(
          from._internal_startupprobe());
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.stdin_ = from._impl_.stdin_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.stdinonce_ = from._impl_.stdinonce_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.tty_ = from._impl_.tty_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Container::CopyFrom(const Container& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.Container)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Container::IsInitialized() const {
  return true;
}

void Container::InternalSwap(Container* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.command_.InternalSwap(&other->_impl_.command_);
  _impl_.args_.InternalSwap(&other->_impl_.args_);
  _impl_.ports_.InternalSwap(&other->_impl_.ports_);
  _impl_.env_.InternalSwap(&other->_impl_.env_);
  _impl_.volumemounts_.InternalSwap(&other->_impl_.volumemounts_);
  _impl_.envfrom_.InternalSwap(&other->_impl_.envfrom_);
  _impl_.volumedevices_.InternalSwap(&other->_impl_.volumedevices_);
  _impl_.resizepolicy_.InternalSwap(&other->_impl_.resizepolicy_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.image_, lhs_arena,
      &other->_impl_.image_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.workingdir_, lhs_arena,
      &other->_impl_.workingdir_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.terminationmessagepath_, lhs_arena,
      &other->_impl_.terminationmessagepath_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.imagepullpolicy_, lhs_arena,
      &other->_impl_.imagepullpolicy_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.terminationmessagepolicy_, lhs_arena,
      &other->_impl_.terminationmessagepolicy_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.restartpolicy_, lhs_arena,
      &other->_impl_.restartpolicy_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Container, _impl_.tty_)
      + sizeof(Container::_impl_.tty_)
      - PROTOBUF_FIELD_OFFSET(Container, _impl_.resources_)>(
          reinterpret_cast<char*>(&_impl_.resources_),
          reinterpret_cast<char*>(&other->_impl_.resources_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Container::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[33]);
}

// ===================================================================

class ContainerImage::_Internal {
 public:
  using HasBits = decltype(std::declval<ContainerImage>()._impl_._has_bits_);
  static void set_has_sizebytes(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ContainerImage::ContainerImage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.ContainerImage)
}
ContainerImage::ContainerImage(const ContainerImage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ContainerImage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.names_){from._impl_.names_}
    , decltype(_impl_.sizebytes_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.sizebytes_ = from._impl_.sizebytes_;
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.ContainerImage)
}

inline void ContainerImage::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.names_){arena}
    , decltype(_impl_.sizebytes_){int64_t{0}}
  };
}

ContainerImage::~ContainerImage() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.ContainerImage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ContainerImage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.names_.~RepeatedPtrField();
}

void ContainerImage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ContainerImage::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.ContainerImage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.names_.Clear();
  _impl_.sizebytes_ = int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ContainerImage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string names = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_names();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "k8s.io.api.core.v1.ContainerImage.names");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional int64 sizeBytes = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_sizebytes(&has_bits);
          _impl_.sizebytes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ContainerImage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.ContainerImage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string names = 1;
  for (int i = 0, n = this->_internal_names_size(); i < n; i++) {
    const auto& s = this->_internal_names(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "k8s.io.api.core.v1.ContainerImage.names");
    target = stream->WriteString(1, s, target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 sizeBytes = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_sizebytes(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.ContainerImage)
  return target;
}

size_t ContainerImage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.ContainerImage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string names = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.names_.size());
  for (int i = 0, n = _impl_.names_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.names_.Get(i));
  }

  // optional int64 sizeBytes = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_sizebytes());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ContainerImage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ContainerImage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ContainerImage::GetClassData() const { return &_class_data_; }


void ContainerImage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ContainerImage*>(&to_msg);
  auto& from = static_cast<const ContainerImage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.ContainerImage)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.names_.MergeFrom(from._impl_.names_);
  if (from._internal_has_sizebytes()) {
    _this->_internal_set_sizebytes(from._internal_sizebytes());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ContainerImage::CopyFrom(const ContainerImage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.ContainerImage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContainerImage::IsInitialized() const {
  return true;
}

void ContainerImage::InternalSwap(ContainerImage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.names_.InternalSwap(&other->_impl_.names_);
  swap(_impl_.sizebytes_, other->_impl_.sizebytes_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ContainerImage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[34]);
}

// ===================================================================

class ContainerPort::_Internal {
 public:
  using HasBits = decltype(std::declval<ContainerPort>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_hostport(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_containerport(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_protocol(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_hostip(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

ContainerPort::ContainerPort(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.ContainerPort)
}
ContainerPort::ContainerPort(const ContainerPort& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ContainerPort* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.protocol_){}
    , decltype(_impl_.hostip_){}
    , decltype(_impl_.hostport_){}
    , decltype(_impl_.containerport_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.protocol_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.protocol_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_protocol()) {
    _this->_impl_.protocol_.Set(from._internal_protocol(), 
      _this->GetArenaForAllocation());
  }
  _impl_.hostip_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hostip_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_hostip()) {
    _this->_impl_.hostip_.Set(from._internal_hostip(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.hostport_, &from._impl_.hostport_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.containerport_) -
    reinterpret_cast<char*>(&_impl_.hostport_)) + sizeof(_impl_.containerport_));
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.ContainerPort)
}

inline void ContainerPort::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.protocol_){}
    , decltype(_impl_.hostip_){}
    , decltype(_impl_.hostport_){0}
    , decltype(_impl_.containerport_){0}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.protocol_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.protocol_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.hostip_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hostip_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ContainerPort::~ContainerPort() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.ContainerPort)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ContainerPort::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.protocol_.Destroy();
  _impl_.hostip_.Destroy();
}

void ContainerPort::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ContainerPort::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.ContainerPort)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.protocol_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.hostip_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000018u) {
    ::memset(&_impl_.hostport_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.containerport_) -
        reinterpret_cast<char*>(&_impl_.hostport_)) + sizeof(_impl_.containerport_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ContainerPort::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 hostPort = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_hostport(&has_bits);
          _impl_.hostport_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 containerPort = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_containerport(&has_bits);
          _impl_.containerport_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes protocol = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_protocol();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes hostIP = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_hostip();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ContainerPort::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.ContainerPort)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional int32 hostPort = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_hostport(), target);
  }

  // optional int32 containerPort = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_containerport(), target);
  }

  // optional bytes protocol = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_protocol(), target);
  }

  // optional bytes hostIP = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_hostip(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.ContainerPort)
  return target;
}

size_t ContainerPort::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.ContainerPort)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional bytes name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_name());
    }

    // optional bytes protocol = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_protocol());
    }

    // optional bytes hostIP = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_hostip());
    }

    // optional int32 hostPort = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_hostport());
    }

    // optional int32 containerPort = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_containerport());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ContainerPort::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ContainerPort::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ContainerPort::GetClassData() const { return &_class_data_; }


void ContainerPort::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ContainerPort*>(&to_msg);
  auto& from = static_cast<const ContainerPort&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.ContainerPort)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_protocol(from._internal_protocol());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_hostip(from._internal_hostip());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.hostport_ = from._impl_.hostport_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.containerport_ = from._impl_.containerport_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ContainerPort::CopyFrom(const ContainerPort& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.ContainerPort)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContainerPort::IsInitialized() const {
  return true;
}

void ContainerPort::InternalSwap(ContainerPort* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.protocol_, lhs_arena,
      &other->_impl_.protocol_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.hostip_, lhs_arena,
      &other->_impl_.hostip_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ContainerPort, _impl_.containerport_)
      + sizeof(ContainerPort::_impl_.containerport_)
      - PROTOBUF_FIELD_OFFSET(ContainerPort, _impl_.hostport_)>(
          reinterpret_cast<char*>(&_impl_.hostport_),
          reinterpret_cast<char*>(&other->_impl_.hostport_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ContainerPort::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[35]);
}

// ===================================================================

class ContainerResizePolicy::_Internal {
 public:
  using HasBits = decltype(std::declval<ContainerResizePolicy>()._impl_._has_bits_);
  static void set_has_resourcename(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_restartpolicy(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ContainerResizePolicy::ContainerResizePolicy(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.ContainerResizePolicy)
}
ContainerResizePolicy::ContainerResizePolicy(const ContainerResizePolicy& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ContainerResizePolicy* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.resourcename_){}
    , decltype(_impl_.restartpolicy_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.resourcename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.resourcename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_resourcename()) {
    _this->_impl_.resourcename_.Set(from._internal_resourcename(), 
      _this->GetArenaForAllocation());
  }
  _impl_.restartpolicy_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.restartpolicy_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_restartpolicy()) {
    _this->_impl_.restartpolicy_.Set(from._internal_restartpolicy(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.ContainerResizePolicy)
}

inline void ContainerResizePolicy::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.resourcename_){}
    , decltype(_impl_.restartpolicy_){}
  };
  _impl_.resourcename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.resourcename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.restartpolicy_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.restartpolicy_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ContainerResizePolicy::~ContainerResizePolicy() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.ContainerResizePolicy)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ContainerResizePolicy::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.resourcename_.Destroy();
  _impl_.restartpolicy_.Destroy();
}

void ContainerResizePolicy::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ContainerResizePolicy::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.ContainerResizePolicy)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.resourcename_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.restartpolicy_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ContainerResizePolicy::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes resourceName = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_resourcename();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes restartPolicy = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_restartpolicy();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ContainerResizePolicy::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.ContainerResizePolicy)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes resourceName = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_resourcename(), target);
  }

  // optional bytes restartPolicy = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_restartpolicy(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.ContainerResizePolicy)
  return target;
}

size_t ContainerResizePolicy::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.ContainerResizePolicy)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes resourceName = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_resourcename());
    }

    // optional bytes restartPolicy = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_restartpolicy());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ContainerResizePolicy::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ContainerResizePolicy::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ContainerResizePolicy::GetClassData() const { return &_class_data_; }


void ContainerResizePolicy::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ContainerResizePolicy*>(&to_msg);
  auto& from = static_cast<const ContainerResizePolicy&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.ContainerResizePolicy)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_resourcename(from._internal_resourcename());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_restartpolicy(from._internal_restartpolicy());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ContainerResizePolicy::CopyFrom(const ContainerResizePolicy& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.ContainerResizePolicy)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContainerResizePolicy::IsInitialized() const {
  return true;
}

void ContainerResizePolicy::InternalSwap(ContainerResizePolicy* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.resourcename_, lhs_arena,
      &other->_impl_.resourcename_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.restartpolicy_, lhs_arena,
      &other->_impl_.restartpolicy_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ContainerResizePolicy::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[36]);
}

// ===================================================================

class ContainerState::_Internal {
 public:
  using HasBits = decltype(std::declval<ContainerState>()._impl_._has_bits_);
  static const ::k8s::io::api::core::v1::ContainerStateWaiting& waiting(const ContainerState* msg);
  static void set_has_waiting(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::k8s::io::api::core::v1::ContainerStateRunning& running(const ContainerState* msg);
  static void set_has_running(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::k8s::io::api::core::v1::ContainerStateTerminated& terminated(const ContainerState* msg);
  static void set_has_terminated(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::k8s::io::api::core::v1::ContainerStateWaiting&
ContainerState::_Internal::waiting(const ContainerState* msg) {
  return *msg->_impl_.waiting_;
}
const ::k8s::io::api::core::v1::ContainerStateRunning&
ContainerState::_Internal::running(const ContainerState* msg) {
  return *msg->_impl_.running_;
}
const ::k8s::io::api::core::v1::ContainerStateTerminated&
ContainerState::_Internal::terminated(const ContainerState* msg) {
  return *msg->_impl_.terminated_;
}
ContainerState::ContainerState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.ContainerState)
}
ContainerState::ContainerState(const ContainerState& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ContainerState* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.waiting_){nullptr}
    , decltype(_impl_.running_){nullptr}
    , decltype(_impl_.terminated_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_waiting()) {
    _this->_impl_.waiting_ = new ::k8s::io::api::core::v1::ContainerStateWaiting(*from._impl_.waiting_);
  }
  if (from._internal_has_running()) {
    _this->_impl_.running_ = new ::k8s::io::api::core::v1::ContainerStateRunning(*from._impl_.running_);
  }
  if (from._internal_has_terminated()) {
    _this->_impl_.terminated_ = new ::k8s::io::api::core::v1::ContainerStateTerminated(*from._impl_.terminated_);
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.ContainerState)
}

inline void ContainerState::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.waiting_){nullptr}
    , decltype(_impl_.running_){nullptr}
    , decltype(_impl_.terminated_){nullptr}
  };
}

ContainerState::~ContainerState() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.ContainerState)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ContainerState::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.waiting_;
  if (this != internal_default_instance()) delete _impl_.running_;
  if (this != internal_default_instance()) delete _impl_.terminated_;
}

void ContainerState::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ContainerState::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.ContainerState)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.waiting_ != nullptr);
      _impl_.waiting_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.running_ != nullptr);
      _impl_.running_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.terminated_ != nullptr);
      _impl_.terminated_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ContainerState::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .k8s.io.api.core.v1.ContainerStateWaiting waiting = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_waiting(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.ContainerStateRunning running = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_running(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.ContainerStateTerminated terminated = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_terminated(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ContainerState::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.ContainerState)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .k8s.io.api.core.v1.ContainerStateWaiting waiting = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::waiting(this),
        _Internal::waiting(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.ContainerStateRunning running = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::running(this),
        _Internal::running(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.ContainerStateTerminated terminated = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::terminated(this),
        _Internal::terminated(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.ContainerState)
  return target;
}

size_t ContainerState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.ContainerState)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .k8s.io.api.core.v1.ContainerStateWaiting waiting = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.waiting_);
    }

    // optional .k8s.io.api.core.v1.ContainerStateRunning running = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.running_);
    }

    // optional .k8s.io.api.core.v1.ContainerStateTerminated terminated = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.terminated_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ContainerState::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ContainerState::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ContainerState::GetClassData() const { return &_class_data_; }


void ContainerState::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ContainerState*>(&to_msg);
  auto& from = static_cast<const ContainerState&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.ContainerState)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_waiting()->::k8s::io::api::core::v1::ContainerStateWaiting::MergeFrom(
          from._internal_waiting());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_running()->::k8s::io::api::core::v1::ContainerStateRunning::MergeFrom(
          from._internal_running());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_terminated()->::k8s::io::api::core::v1::ContainerStateTerminated::MergeFrom(
          from._internal_terminated());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ContainerState::CopyFrom(const ContainerState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.ContainerState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContainerState::IsInitialized() const {
  return true;
}

void ContainerState::InternalSwap(ContainerState* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ContainerState, _impl_.terminated_)
      + sizeof(ContainerState::_impl_.terminated_)
      - PROTOBUF_FIELD_OFFSET(ContainerState, _impl_.waiting_)>(
          reinterpret_cast<char*>(&_impl_.waiting_),
          reinterpret_cast<char*>(&other->_impl_.waiting_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ContainerState::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[37]);
}

// ===================================================================

class ContainerStateRunning::_Internal {
 public:
  using HasBits = decltype(std::declval<ContainerStateRunning>()._impl_._has_bits_);
  static const ::k8s::io::apimachinery::pkg::apis::meta::v1::Time& startedat(const ContainerStateRunning* msg);
  static void set_has_startedat(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::k8s::io::apimachinery::pkg::apis::meta::v1::Time&
ContainerStateRunning::_Internal::startedat(const ContainerStateRunning* msg) {
  return *msg->_impl_.startedat_;
}
void ContainerStateRunning::clear_startedat() {
  if (_impl_.startedat_ != nullptr) _impl_.startedat_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
ContainerStateRunning::ContainerStateRunning(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.ContainerStateRunning)
}
ContainerStateRunning::ContainerStateRunning(const ContainerStateRunning& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ContainerStateRunning* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.startedat_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_startedat()) {
    _this->_impl_.startedat_ = new ::k8s::io::apimachinery::pkg::apis::meta::v1::Time(*from._impl_.startedat_);
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.ContainerStateRunning)
}

inline void ContainerStateRunning::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.startedat_){nullptr}
  };
}

ContainerStateRunning::~ContainerStateRunning() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.ContainerStateRunning)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ContainerStateRunning::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.startedat_;
}

void ContainerStateRunning::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ContainerStateRunning::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.ContainerStateRunning)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.startedat_ != nullptr);
    _impl_.startedat_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ContainerStateRunning::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time startedAt = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_startedat(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ContainerStateRunning::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.ContainerStateRunning)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time startedAt = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::startedat(this),
        _Internal::startedat(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.ContainerStateRunning)
  return target;
}

size_t ContainerStateRunning::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.ContainerStateRunning)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time startedAt = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.startedat_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ContainerStateRunning::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ContainerStateRunning::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ContainerStateRunning::GetClassData() const { return &_class_data_; }


void ContainerStateRunning::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ContainerStateRunning*>(&to_msg);
  auto& from = static_cast<const ContainerStateRunning&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.ContainerStateRunning)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_startedat()) {
    _this->_internal_mutable_startedat()->::k8s::io::apimachinery::pkg::apis::meta::v1::Time::MergeFrom(
        from._internal_startedat());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ContainerStateRunning::CopyFrom(const ContainerStateRunning& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.ContainerStateRunning)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContainerStateRunning::IsInitialized() const {
  return true;
}

void ContainerStateRunning::InternalSwap(ContainerStateRunning* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.startedat_, other->_impl_.startedat_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ContainerStateRunning::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[38]);
}

// ===================================================================

class ContainerStateTerminated::_Internal {
 public:
  using HasBits = decltype(std::declval<ContainerStateTerminated>()._impl_._has_bits_);
  static void set_has_exitcode(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_signal(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_reason(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_message(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::k8s::io::apimachinery::pkg::apis::meta::v1::Time& startedat(const ContainerStateTerminated* msg);
  static void set_has_startedat(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::k8s::io::apimachinery::pkg::apis::meta::v1::Time& finishedat(const ContainerStateTerminated* msg);
  static void set_has_finishedat(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_containerid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::k8s::io::apimachinery::pkg::apis::meta::v1::Time&
ContainerStateTerminated::_Internal::startedat(const ContainerStateTerminated* msg) {
  return *msg->_impl_.startedat_;
}
const ::k8s::io::apimachinery::pkg::apis::meta::v1::Time&
ContainerStateTerminated::_Internal::finishedat(const ContainerStateTerminated* msg) {
  return *msg->_impl_.finishedat_;
}
void ContainerStateTerminated::clear_startedat() {
  if (_impl_.startedat_ != nullptr) _impl_.startedat_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
void ContainerStateTerminated::clear_finishedat() {
  if (_impl_.finishedat_ != nullptr) _impl_.finishedat_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
ContainerStateTerminated::ContainerStateTerminated(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.ContainerStateTerminated)
}
ContainerStateTerminated::ContainerStateTerminated(const ContainerStateTerminated& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ContainerStateTerminated* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.reason_){}
    , decltype(_impl_.message_){}
    , decltype(_impl_.containerid_){}
    , decltype(_impl_.startedat_){nullptr}
    , decltype(_impl_.finishedat_){nullptr}
    , decltype(_impl_.exitcode_){}
    , decltype(_impl_.signal_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.reason_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.reason_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_reason()) {
    _this->_impl_.reason_.Set(from._internal_reason(), 
      _this->GetArenaForAllocation());
  }
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_message()) {
    _this->_impl_.message_.Set(from._internal_message(), 
      _this->GetArenaForAllocation());
  }
  _impl_.containerid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.containerid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_containerid()) {
    _this->_impl_.containerid_.Set(from._internal_containerid(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_startedat()) {
    _this->_impl_.startedat_ = new ::k8s::io::apimachinery::pkg::apis::meta::v1::Time(*from._impl_.startedat_);
  }
  if (from._internal_has_finishedat()) {
    _this->_impl_.finishedat_ = new ::k8s::io::apimachinery::pkg::apis::meta::v1::Time(*from._impl_.finishedat_);
  }
  ::memcpy(&_impl_.exitcode_, &from._impl_.exitcode_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.signal_) -
    reinterpret_cast<char*>(&_impl_.exitcode_)) + sizeof(_impl_.signal_));
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.ContainerStateTerminated)
}

inline void ContainerStateTerminated::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.reason_){}
    , decltype(_impl_.message_){}
    , decltype(_impl_.containerid_){}
    , decltype(_impl_.startedat_){nullptr}
    , decltype(_impl_.finishedat_){nullptr}
    , decltype(_impl_.exitcode_){0}
    , decltype(_impl_.signal_){0}
  };
  _impl_.reason_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.reason_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.containerid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.containerid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ContainerStateTerminated::~ContainerStateTerminated() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.ContainerStateTerminated)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ContainerStateTerminated::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.reason_.Destroy();
  _impl_.message_.Destroy();
  _impl_.containerid_.Destroy();
  if (this != internal_default_instance()) delete _impl_.startedat_;
  if (this != internal_default_instance()) delete _impl_.finishedat_;
}

void ContainerStateTerminated::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ContainerStateTerminated::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.ContainerStateTerminated)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.reason_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.message_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.containerid_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.startedat_ != nullptr);
      _impl_.startedat_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.finishedat_ != nullptr);
      _impl_.finishedat_->Clear();
    }
  }
  if (cached_has_bits & 0x00000060u) {
    ::memset(&_impl_.exitcode_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.signal_) -
        reinterpret_cast<char*>(&_impl_.exitcode_)) + sizeof(_impl_.signal_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ContainerStateTerminated::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 exitCode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_exitcode(&has_bits);
          _impl_.exitcode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 signal = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_signal(&has_bits);
          _impl_.signal_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes reason = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_reason();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes message = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time startedAt = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_startedat(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time finishedAt = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_finishedat(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes containerID = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_containerid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ContainerStateTerminated::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.ContainerStateTerminated)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 exitCode = 1;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_exitcode(), target);
  }

  // optional int32 signal = 2;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_signal(), target);
  }

  // optional bytes reason = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_reason(), target);
  }

  // optional bytes message = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_message(), target);
  }

  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time startedAt = 5;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::startedat(this),
        _Internal::startedat(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time finishedAt = 6;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::finishedat(this),
        _Internal::finishedat(this).GetCachedSize(), target, stream);
  }

  // optional bytes containerID = 7;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        7, this->_internal_containerid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.ContainerStateTerminated)
  return target;
}

size_t ContainerStateTerminated::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.ContainerStateTerminated)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional bytes reason = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_reason());
    }

    // optional bytes message = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_message());
    }

    // optional bytes containerID = 7;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_containerid());
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time startedAt = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.startedat_);
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time finishedAt = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.finishedat_);
    }

    // optional int32 exitCode = 1;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_exitcode());
    }

    // optional int32 signal = 2;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_signal());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ContainerStateTerminated::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ContainerStateTerminated::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ContainerStateTerminated::GetClassData() const { return &_class_data_; }


void ContainerStateTerminated::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ContainerStateTerminated*>(&to_msg);
  auto& from = static_cast<const ContainerStateTerminated&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.ContainerStateTerminated)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_reason(from._internal_reason());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_message(from._internal_message());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_containerid(from._internal_containerid());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_startedat()->::k8s::io::apimachinery::pkg::apis::meta::v1::Time::MergeFrom(
          from._internal_startedat());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_finishedat()->::k8s::io::apimachinery::pkg::apis::meta::v1::Time::MergeFrom(
          from._internal_finishedat());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.exitcode_ = from._impl_.exitcode_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.signal_ = from._impl_.signal_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ContainerStateTerminated::CopyFrom(const ContainerStateTerminated& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.ContainerStateTerminated)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContainerStateTerminated::IsInitialized() const {
  return true;
}

void ContainerStateTerminated::InternalSwap(ContainerStateTerminated* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.reason_, lhs_arena,
      &other->_impl_.reason_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.message_, lhs_arena,
      &other->_impl_.message_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.containerid_, lhs_arena,
      &other->_impl_.containerid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ContainerStateTerminated, _impl_.signal_)
      + sizeof(ContainerStateTerminated::_impl_.signal_)
      - PROTOBUF_FIELD_OFFSET(ContainerStateTerminated, _impl_.startedat_)>(
          reinterpret_cast<char*>(&_impl_.startedat_),
          reinterpret_cast<char*>(&other->_impl_.startedat_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ContainerStateTerminated::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[39]);
}

// ===================================================================

class ContainerStateWaiting::_Internal {
 public:
  using HasBits = decltype(std::declval<ContainerStateWaiting>()._impl_._has_bits_);
  static void set_has_reason(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_message(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ContainerStateWaiting::ContainerStateWaiting(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.ContainerStateWaiting)
}
ContainerStateWaiting::ContainerStateWaiting(const ContainerStateWaiting& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ContainerStateWaiting* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.reason_){}
    , decltype(_impl_.message_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.reason_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.reason_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_reason()) {
    _this->_impl_.reason_.Set(from._internal_reason(), 
      _this->GetArenaForAllocation());
  }
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_message()) {
    _this->_impl_.message_.Set(from._internal_message(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.ContainerStateWaiting)
}

inline void ContainerStateWaiting::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.reason_){}
    , decltype(_impl_.message_){}
  };
  _impl_.reason_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.reason_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ContainerStateWaiting::~ContainerStateWaiting() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.ContainerStateWaiting)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ContainerStateWaiting::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.reason_.Destroy();
  _impl_.message_.Destroy();
}

void ContainerStateWaiting::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ContainerStateWaiting::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.ContainerStateWaiting)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.reason_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.message_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ContainerStateWaiting::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes reason = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_reason();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes message = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ContainerStateWaiting::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.ContainerStateWaiting)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes reason = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_reason(), target);
  }

  // optional bytes message = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_message(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.ContainerStateWaiting)
  return target;
}

size_t ContainerStateWaiting::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.ContainerStateWaiting)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes reason = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_reason());
    }

    // optional bytes message = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_message());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ContainerStateWaiting::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ContainerStateWaiting::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ContainerStateWaiting::GetClassData() const { return &_class_data_; }


void ContainerStateWaiting::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ContainerStateWaiting*>(&to_msg);
  auto& from = static_cast<const ContainerStateWaiting&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.ContainerStateWaiting)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_reason(from._internal_reason());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_message(from._internal_message());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ContainerStateWaiting::CopyFrom(const ContainerStateWaiting& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.ContainerStateWaiting)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContainerStateWaiting::IsInitialized() const {
  return true;
}

void ContainerStateWaiting::InternalSwap(ContainerStateWaiting* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.reason_, lhs_arena,
      &other->_impl_.reason_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.message_, lhs_arena,
      &other->_impl_.message_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ContainerStateWaiting::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[40]);
}

// ===================================================================

ContainerStatus_AllocatedResourcesEntry_DoNotUse::ContainerStatus_AllocatedResourcesEntry_DoNotUse() {}
ContainerStatus_AllocatedResourcesEntry_DoNotUse::ContainerStatus_AllocatedResourcesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void ContainerStatus_AllocatedResourcesEntry_DoNotUse::MergeFrom(const ContainerStatus_AllocatedResourcesEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata ContainerStatus_AllocatedResourcesEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[41]);
}

// ===================================================================

class ContainerStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<ContainerStatus>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::k8s::io::api::core::v1::ContainerState& state(const ContainerStatus* msg);
  static void set_has_state(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::k8s::io::api::core::v1::ContainerState& laststate(const ContainerStatus* msg);
  static void set_has_laststate(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_ready(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_restartcount(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_image(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_imageid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_containerid(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_started(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static const ::k8s::io::api::core::v1::ResourceRequirements& resources(const ContainerStatus* msg);
  static void set_has_resources(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

const ::k8s::io::api::core::v1::ContainerState&
ContainerStatus::_Internal::state(const ContainerStatus* msg) {
  return *msg->_impl_.state_;
}
const ::k8s::io::api::core::v1::ContainerState&
ContainerStatus::_Internal::laststate(const ContainerStatus* msg) {
  return *msg->_impl_.laststate_;
}
const ::k8s::io::api::core::v1::ResourceRequirements&
ContainerStatus::_Internal::resources(const ContainerStatus* msg) {
  return *msg->_impl_.resources_;
}
void ContainerStatus::clear_allocatedresources() {
  _impl_.allocatedresources_.Clear();
}
ContainerStatus::ContainerStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &ContainerStatus::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.ContainerStatus)
}
ContainerStatus::ContainerStatus(const ContainerStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ContainerStatus* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_.allocatedresources_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.image_){}
    , decltype(_impl_.imageid_){}
    , decltype(_impl_.containerid_){}
    , decltype(_impl_.state_){nullptr}
    , decltype(_impl_.laststate_){nullptr}
    , decltype(_impl_.resources_){nullptr}
    , decltype(_impl_.restartcount_){}
    , decltype(_impl_.ready_){}
    , decltype(_impl_.started_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.allocatedresources_.MergeFrom(from._impl_.allocatedresources_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.image_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.image_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_image()) {
    _this->_impl_.image_.Set(from._internal_image(), 
      _this->GetArenaForAllocation());
  }
  _impl_.imageid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.imageid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_imageid()) {
    _this->_impl_.imageid_.Set(from._internal_imageid(), 
      _this->GetArenaForAllocation());
  }
  _impl_.containerid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.containerid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_containerid()) {
    _this->_impl_.containerid_.Set(from._internal_containerid(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_state()) {
    _this->_impl_.state_ = new ::k8s::io::api::core::v1::ContainerState(*from._impl_.state_);
  }
  if (from._internal_has_laststate()) {
    _this->_impl_.laststate_ = new ::k8s::io::api::core::v1::ContainerState(*from._impl_.laststate_);
  }
  if (from._internal_has_resources()) {
    _this->_impl_.resources_ = new ::k8s::io::api::core::v1::ResourceRequirements(*from._impl_.resources_);
  }
  ::memcpy(&_impl_.restartcount_, &from._impl_.restartcount_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.started_) -
    reinterpret_cast<char*>(&_impl_.restartcount_)) + sizeof(_impl_.started_));
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.ContainerStatus)
}

inline void ContainerStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_.allocatedresources_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.name_){}
    , decltype(_impl_.image_){}
    , decltype(_impl_.imageid_){}
    , decltype(_impl_.containerid_){}
    , decltype(_impl_.state_){nullptr}
    , decltype(_impl_.laststate_){nullptr}
    , decltype(_impl_.resources_){nullptr}
    , decltype(_impl_.restartcount_){0}
    , decltype(_impl_.ready_){false}
    , decltype(_impl_.started_){false}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.image_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.image_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.imageid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.imageid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.containerid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.containerid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ContainerStatus::~ContainerStatus() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.ContainerStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void ContainerStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.allocatedresources_.Destruct();
  _impl_.allocatedresources_.~MapField();
  _impl_.name_.Destroy();
  _impl_.image_.Destroy();
  _impl_.imageid_.Destroy();
  _impl_.containerid_.Destroy();
  if (this != internal_default_instance()) delete _impl_.state_;
  if (this != internal_default_instance()) delete _impl_.laststate_;
  if (this != internal_default_instance()) delete _impl_.resources_;
}

void ContainerStatus::ArenaDtor(void* object) {
  ContainerStatus* _this = reinterpret_cast< ContainerStatus* >(object);
  _this->_impl_.allocatedresources_.Destruct();
}
void ContainerStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ContainerStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.ContainerStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.allocatedresources_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.image_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.imageid_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.containerid_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.state_ != nullptr);
      _impl_.state_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.laststate_ != nullptr);
      _impl_.laststate_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(_impl_.resources_ != nullptr);
      _impl_.resources_->Clear();
    }
  }
  _impl_.restartcount_ = 0;
  if (cached_has_bits & 0x00000300u) {
    ::memset(&_impl_.ready_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.started_) -
        reinterpret_cast<char*>(&_impl_.ready_)) + sizeof(_impl_.started_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ContainerStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.ContainerState state = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_state(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.ContainerState lastState = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_laststate(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool ready = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_ready(&has_bits);
          _impl_.ready_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 restartCount = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_restartcount(&has_bits);
          _impl_.restartcount_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes image = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_image();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes imageID = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_imageid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes containerID = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_containerid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool started = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_started(&has_bits);
          _impl_.started_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // map<string, .k8s.io.apimachinery.pkg.api.resource.Quantity> allocatedResources = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.allocatedresources_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.ResourceRequirements resources = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_resources(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ContainerStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.ContainerStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional .k8s.io.api.core.v1.ContainerState state = 2;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::state(this),
        _Internal::state(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.ContainerState lastState = 3;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::laststate(this),
        _Internal::laststate(this).GetCachedSize(), target, stream);
  }

  // optional bool ready = 4;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_ready(), target);
  }

  // optional int32 restartCount = 5;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_restartcount(), target);
  }

  // optional bytes image = 6;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        6, this->_internal_image(), target);
  }

  // optional bytes imageID = 7;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        7, this->_internal_imageid(), target);
  }

  // optional bytes containerID = 8;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        8, this->_internal_containerid(), target);
  }

  // optional bool started = 9;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(9, this->_internal_started(), target);
  }

  // map<string, .k8s.io.apimachinery.pkg.api.resource.Quantity> allocatedResources = 10;
  if (!this->_internal_allocatedresources().empty()) {
    using MapType = ::_pb::Map<std::string, ::k8s::io::apimachinery::pkg::api::resource::Quantity>;
    using WireHelper = ContainerStatus_AllocatedResourcesEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_allocatedresources();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "k8s.io.api.core.v1.ContainerStatus.AllocatedResourcesEntry.key");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(10, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(10, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  // optional .k8s.io.api.core.v1.ResourceRequirements resources = 11;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::resources(this),
        _Internal::resources(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.ContainerStatus)
  return target;
}

size_t ContainerStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.ContainerStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, .k8s.io.apimachinery.pkg.api.resource.Quantity> allocatedResources = 10;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_allocatedresources_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::k8s::io::apimachinery::pkg::api::resource::Quantity >::const_iterator
      it = this->_internal_allocatedresources().begin();
      it != this->_internal_allocatedresources().end(); ++it) {
    total_size += ContainerStatus_AllocatedResourcesEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bytes name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_name());
    }

    // optional bytes image = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_image());
    }

    // optional bytes imageID = 7;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_imageid());
    }

    // optional bytes containerID = 8;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_containerid());
    }

    // optional .k8s.io.api.core.v1.ContainerState state = 2;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.state_);
    }

    // optional .k8s.io.api.core.v1.ContainerState lastState = 3;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.laststate_);
    }

    // optional .k8s.io.api.core.v1.ResourceRequirements resources = 11;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.resources_);
    }

    // optional int32 restartCount = 5;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_restartcount());
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional bool ready = 4;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional bool started = 9;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ContainerStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ContainerStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ContainerStatus::GetClassData() const { return &_class_data_; }


void ContainerStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ContainerStatus*>(&to_msg);
  auto& from = static_cast<const ContainerStatus&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.ContainerStatus)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.allocatedresources_.MergeFrom(from._impl_.allocatedresources_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_image(from._internal_image());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_imageid(from._internal_imageid());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_containerid(from._internal_containerid());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_state()->::k8s::io::api::core::v1::ContainerState::MergeFrom(
          from._internal_state());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_laststate()->::k8s::io::api::core::v1::ContainerState::MergeFrom(
          from._internal_laststate());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_resources()->::k8s::io::api::core::v1::ResourceRequirements::MergeFrom(
          from._internal_resources());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.restartcount_ = from._impl_.restartcount_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.ready_ = from._impl_.ready_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.started_ = from._impl_.started_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ContainerStatus::CopyFrom(const ContainerStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.ContainerStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContainerStatus::IsInitialized() const {
  return true;
}

void ContainerStatus::InternalSwap(ContainerStatus* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.allocatedresources_.InternalSwap(&other->_impl_.allocatedresources_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.image_, lhs_arena,
      &other->_impl_.image_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.imageid_, lhs_arena,
      &other->_impl_.imageid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.containerid_, lhs_arena,
      &other->_impl_.containerid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ContainerStatus, _impl_.started_)
      + sizeof(ContainerStatus::_impl_.started_)
      - PROTOBUF_FIELD_OFFSET(ContainerStatus, _impl_.state_)>(
          reinterpret_cast<char*>(&_impl_.state_),
          reinterpret_cast<char*>(&other->_impl_.state_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ContainerStatus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[42]);
}

// ===================================================================

class DaemonEndpoint::_Internal {
 public:
  using HasBits = decltype(std::declval<DaemonEndpoint>()._impl_._has_bits_);
  static void set_has_port(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DaemonEndpoint::DaemonEndpoint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.DaemonEndpoint)
}
DaemonEndpoint::DaemonEndpoint(const DaemonEndpoint& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DaemonEndpoint* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.port_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.port_ = from._impl_.port_;
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.DaemonEndpoint)
}

inline void DaemonEndpoint::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.port_){0}
  };
}

DaemonEndpoint::~DaemonEndpoint() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.DaemonEndpoint)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DaemonEndpoint::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DaemonEndpoint::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DaemonEndpoint::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.DaemonEndpoint)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.port_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DaemonEndpoint::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 Port = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_port(&has_bits);
          _impl_.port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DaemonEndpoint::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.DaemonEndpoint)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 Port = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_port(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.DaemonEndpoint)
  return target;
}

size_t DaemonEndpoint::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.DaemonEndpoint)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 Port = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_port());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DaemonEndpoint::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DaemonEndpoint::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DaemonEndpoint::GetClassData() const { return &_class_data_; }


void DaemonEndpoint::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DaemonEndpoint*>(&to_msg);
  auto& from = static_cast<const DaemonEndpoint&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.DaemonEndpoint)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_port()) {
    _this->_internal_set_port(from._internal_port());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DaemonEndpoint::CopyFrom(const DaemonEndpoint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.DaemonEndpoint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DaemonEndpoint::IsInitialized() const {
  return true;
}

void DaemonEndpoint::InternalSwap(DaemonEndpoint* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.port_, other->_impl_.port_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DaemonEndpoint::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[43]);
}

// ===================================================================

class DownwardAPIProjection::_Internal {
 public:
};

DownwardAPIProjection::DownwardAPIProjection(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.DownwardAPIProjection)
}
DownwardAPIProjection::DownwardAPIProjection(const DownwardAPIProjection& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DownwardAPIProjection* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.items_){from._impl_.items_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.DownwardAPIProjection)
}

inline void DownwardAPIProjection::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.items_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

DownwardAPIProjection::~DownwardAPIProjection() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.DownwardAPIProjection)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DownwardAPIProjection::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.items_.~RepeatedPtrField();
}

void DownwardAPIProjection::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DownwardAPIProjection::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.DownwardAPIProjection)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.items_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DownwardAPIProjection::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .k8s.io.api.core.v1.DownwardAPIVolumeFile items = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_items(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DownwardAPIProjection::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.DownwardAPIProjection)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .k8s.io.api.core.v1.DownwardAPIVolumeFile items = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_items_size()); i < n; i++) {
    const auto& repfield = this->_internal_items(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.DownwardAPIProjection)
  return target;
}

size_t DownwardAPIProjection::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.DownwardAPIProjection)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .k8s.io.api.core.v1.DownwardAPIVolumeFile items = 1;
  total_size += 1UL * this->_internal_items_size();
  for (const auto& msg : this->_impl_.items_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DownwardAPIProjection::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DownwardAPIProjection::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DownwardAPIProjection::GetClassData() const { return &_class_data_; }


void DownwardAPIProjection::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DownwardAPIProjection*>(&to_msg);
  auto& from = static_cast<const DownwardAPIProjection&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.DownwardAPIProjection)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.items_.MergeFrom(from._impl_.items_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DownwardAPIProjection::CopyFrom(const DownwardAPIProjection& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.DownwardAPIProjection)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DownwardAPIProjection::IsInitialized() const {
  return true;
}

void DownwardAPIProjection::InternalSwap(DownwardAPIProjection* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.items_.InternalSwap(&other->_impl_.items_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DownwardAPIProjection::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[44]);
}

// ===================================================================

class DownwardAPIVolumeFile::_Internal {
 public:
  using HasBits = decltype(std::declval<DownwardAPIVolumeFile>()._impl_._has_bits_);
  static void set_has_path(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::k8s::io::api::core::v1::ObjectFieldSelector& fieldref(const DownwardAPIVolumeFile* msg);
  static void set_has_fieldref(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::k8s::io::api::core::v1::ResourceFieldSelector& resourcefieldref(const DownwardAPIVolumeFile* msg);
  static void set_has_resourcefieldref(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::k8s::io::api::core::v1::ObjectFieldSelector&
DownwardAPIVolumeFile::_Internal::fieldref(const DownwardAPIVolumeFile* msg) {
  return *msg->_impl_.fieldref_;
}
const ::k8s::io::api::core::v1::ResourceFieldSelector&
DownwardAPIVolumeFile::_Internal::resourcefieldref(const DownwardAPIVolumeFile* msg) {
  return *msg->_impl_.resourcefieldref_;
}
DownwardAPIVolumeFile::DownwardAPIVolumeFile(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.DownwardAPIVolumeFile)
}
DownwardAPIVolumeFile::DownwardAPIVolumeFile(const DownwardAPIVolumeFile& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DownwardAPIVolumeFile* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.path_){}
    , decltype(_impl_.fieldref_){nullptr}
    , decltype(_impl_.resourcefieldref_){nullptr}
    , decltype(_impl_.mode_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_path()) {
    _this->_impl_.path_.Set(from._internal_path(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_fieldref()) {
    _this->_impl_.fieldref_ = new ::k8s::io::api::core::v1::ObjectFieldSelector(*from._impl_.fieldref_);
  }
  if (from._internal_has_resourcefieldref()) {
    _this->_impl_.resourcefieldref_ = new ::k8s::io::api::core::v1::ResourceFieldSelector(*from._impl_.resourcefieldref_);
  }
  _this->_impl_.mode_ = from._impl_.mode_;
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.DownwardAPIVolumeFile)
}

inline void DownwardAPIVolumeFile::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.path_){}
    , decltype(_impl_.fieldref_){nullptr}
    , decltype(_impl_.resourcefieldref_){nullptr}
    , decltype(_impl_.mode_){0}
  };
  _impl_.path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DownwardAPIVolumeFile::~DownwardAPIVolumeFile() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.DownwardAPIVolumeFile)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DownwardAPIVolumeFile::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.path_.Destroy();
  if (this != internal_default_instance()) delete _impl_.fieldref_;
  if (this != internal_default_instance()) delete _impl_.resourcefieldref_;
}

void DownwardAPIVolumeFile::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DownwardAPIVolumeFile::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.DownwardAPIVolumeFile)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.path_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.fieldref_ != nullptr);
      _impl_.fieldref_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.resourcefieldref_ != nullptr);
      _impl_.resourcefieldref_->Clear();
    }
  }
  _impl_.mode_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DownwardAPIVolumeFile::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes path = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_path();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.ObjectFieldSelector fieldRef = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_fieldref(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.ResourceFieldSelector resourceFieldRef = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_resourcefieldref(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 mode = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_mode(&has_bits);
          _impl_.mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DownwardAPIVolumeFile::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.DownwardAPIVolumeFile)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes path = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_path(), target);
  }

  // optional .k8s.io.api.core.v1.ObjectFieldSelector fieldRef = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::fieldref(this),
        _Internal::fieldref(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.ResourceFieldSelector resourceFieldRef = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::resourcefieldref(this),
        _Internal::resourcefieldref(this).GetCachedSize(), target, stream);
  }

  // optional int32 mode = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_mode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.DownwardAPIVolumeFile)
  return target;
}

size_t DownwardAPIVolumeFile::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.DownwardAPIVolumeFile)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional bytes path = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_path());
    }

    // optional .k8s.io.api.core.v1.ObjectFieldSelector fieldRef = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.fieldref_);
    }

    // optional .k8s.io.api.core.v1.ResourceFieldSelector resourceFieldRef = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.resourcefieldref_);
    }

    // optional int32 mode = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_mode());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DownwardAPIVolumeFile::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DownwardAPIVolumeFile::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DownwardAPIVolumeFile::GetClassData() const { return &_class_data_; }


void DownwardAPIVolumeFile::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DownwardAPIVolumeFile*>(&to_msg);
  auto& from = static_cast<const DownwardAPIVolumeFile&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.DownwardAPIVolumeFile)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_path(from._internal_path());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_fieldref()->::k8s::io::api::core::v1::ObjectFieldSelector::MergeFrom(
          from._internal_fieldref());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_resourcefieldref()->::k8s::io::api::core::v1::ResourceFieldSelector::MergeFrom(
          from._internal_resourcefieldref());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.mode_ = from._impl_.mode_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DownwardAPIVolumeFile::CopyFrom(const DownwardAPIVolumeFile& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.DownwardAPIVolumeFile)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DownwardAPIVolumeFile::IsInitialized() const {
  return true;
}

void DownwardAPIVolumeFile::InternalSwap(DownwardAPIVolumeFile* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.path_, lhs_arena,
      &other->_impl_.path_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DownwardAPIVolumeFile, _impl_.mode_)
      + sizeof(DownwardAPIVolumeFile::_impl_.mode_)
      - PROTOBUF_FIELD_OFFSET(DownwardAPIVolumeFile, _impl_.fieldref_)>(
          reinterpret_cast<char*>(&_impl_.fieldref_),
          reinterpret_cast<char*>(&other->_impl_.fieldref_));
}

::PROTOBUF_NAMESPACE_ID::Metadata DownwardAPIVolumeFile::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[45]);
}

// ===================================================================

class DownwardAPIVolumeSource::_Internal {
 public:
  using HasBits = decltype(std::declval<DownwardAPIVolumeSource>()._impl_._has_bits_);
  static void set_has_defaultmode(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DownwardAPIVolumeSource::DownwardAPIVolumeSource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.DownwardAPIVolumeSource)
}
DownwardAPIVolumeSource::DownwardAPIVolumeSource(const DownwardAPIVolumeSource& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DownwardAPIVolumeSource* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.items_){from._impl_.items_}
    , decltype(_impl_.defaultmode_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.defaultmode_ = from._impl_.defaultmode_;
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.DownwardAPIVolumeSource)
}

inline void DownwardAPIVolumeSource::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.items_){arena}
    , decltype(_impl_.defaultmode_){0}
  };
}

DownwardAPIVolumeSource::~DownwardAPIVolumeSource() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.DownwardAPIVolumeSource)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DownwardAPIVolumeSource::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.items_.~RepeatedPtrField();
}

void DownwardAPIVolumeSource::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DownwardAPIVolumeSource::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.DownwardAPIVolumeSource)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.items_.Clear();
  _impl_.defaultmode_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DownwardAPIVolumeSource::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .k8s.io.api.core.v1.DownwardAPIVolumeFile items = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_items(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional int32 defaultMode = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_defaultmode(&has_bits);
          _impl_.defaultmode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DownwardAPIVolumeSource::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.DownwardAPIVolumeSource)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .k8s.io.api.core.v1.DownwardAPIVolumeFile items = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_items_size()); i < n; i++) {
    const auto& repfield = this->_internal_items(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 defaultMode = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_defaultmode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.DownwardAPIVolumeSource)
  return target;
}

size_t DownwardAPIVolumeSource::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.DownwardAPIVolumeSource)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .k8s.io.api.core.v1.DownwardAPIVolumeFile items = 1;
  total_size += 1UL * this->_internal_items_size();
  for (const auto& msg : this->_impl_.items_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional int32 defaultMode = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_defaultmode());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DownwardAPIVolumeSource::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DownwardAPIVolumeSource::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DownwardAPIVolumeSource::GetClassData() const { return &_class_data_; }


void DownwardAPIVolumeSource::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DownwardAPIVolumeSource*>(&to_msg);
  auto& from = static_cast<const DownwardAPIVolumeSource&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.DownwardAPIVolumeSource)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.items_.MergeFrom(from._impl_.items_);
  if (from._internal_has_defaultmode()) {
    _this->_internal_set_defaultmode(from._internal_defaultmode());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DownwardAPIVolumeSource::CopyFrom(const DownwardAPIVolumeSource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.DownwardAPIVolumeSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DownwardAPIVolumeSource::IsInitialized() const {
  return true;
}

void DownwardAPIVolumeSource::InternalSwap(DownwardAPIVolumeSource* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.items_.InternalSwap(&other->_impl_.items_);
  swap(_impl_.defaultmode_, other->_impl_.defaultmode_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DownwardAPIVolumeSource::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[46]);
}

// ===================================================================

class EmptyDirVolumeSource::_Internal {
 public:
  using HasBits = decltype(std::declval<EmptyDirVolumeSource>()._impl_._has_bits_);
  static void set_has_medium(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::k8s::io::apimachinery::pkg::api::resource::Quantity& sizelimit(const EmptyDirVolumeSource* msg);
  static void set_has_sizelimit(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::k8s::io::apimachinery::pkg::api::resource::Quantity&
EmptyDirVolumeSource::_Internal::sizelimit(const EmptyDirVolumeSource* msg) {
  return *msg->_impl_.sizelimit_;
}
void EmptyDirVolumeSource::clear_sizelimit() {
  if (_impl_.sizelimit_ != nullptr) _impl_.sizelimit_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
EmptyDirVolumeSource::EmptyDirVolumeSource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.EmptyDirVolumeSource)
}
EmptyDirVolumeSource::EmptyDirVolumeSource(const EmptyDirVolumeSource& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EmptyDirVolumeSource* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.medium_){}
    , decltype(_impl_.sizelimit_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.medium_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.medium_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_medium()) {
    _this->_impl_.medium_.Set(from._internal_medium(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_sizelimit()) {
    _this->_impl_.sizelimit_ = new ::k8s::io::apimachinery::pkg::api::resource::Quantity(*from._impl_.sizelimit_);
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.EmptyDirVolumeSource)
}

inline void EmptyDirVolumeSource::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.medium_){}
    , decltype(_impl_.sizelimit_){nullptr}
  };
  _impl_.medium_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.medium_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

EmptyDirVolumeSource::~EmptyDirVolumeSource() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.EmptyDirVolumeSource)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EmptyDirVolumeSource::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.medium_.Destroy();
  if (this != internal_default_instance()) delete _impl_.sizelimit_;
}

void EmptyDirVolumeSource::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EmptyDirVolumeSource::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.EmptyDirVolumeSource)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.medium_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.sizelimit_ != nullptr);
      _impl_.sizelimit_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EmptyDirVolumeSource::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes medium = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_medium();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.apimachinery.pkg.api.resource.Quantity sizeLimit = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_sizelimit(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EmptyDirVolumeSource::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.EmptyDirVolumeSource)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes medium = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_medium(), target);
  }

  // optional .k8s.io.apimachinery.pkg.api.resource.Quantity sizeLimit = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::sizelimit(this),
        _Internal::sizelimit(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.EmptyDirVolumeSource)
  return target;
}

size_t EmptyDirVolumeSource::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.EmptyDirVolumeSource)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes medium = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_medium());
    }

    // optional .k8s.io.apimachinery.pkg.api.resource.Quantity sizeLimit = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.sizelimit_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EmptyDirVolumeSource::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EmptyDirVolumeSource::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EmptyDirVolumeSource::GetClassData() const { return &_class_data_; }


void EmptyDirVolumeSource::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EmptyDirVolumeSource*>(&to_msg);
  auto& from = static_cast<const EmptyDirVolumeSource&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.EmptyDirVolumeSource)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_medium(from._internal_medium());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_sizelimit()->::k8s::io::apimachinery::pkg::api::resource::Quantity::MergeFrom(
          from._internal_sizelimit());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EmptyDirVolumeSource::CopyFrom(const EmptyDirVolumeSource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.EmptyDirVolumeSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EmptyDirVolumeSource::IsInitialized() const {
  return true;
}

void EmptyDirVolumeSource::InternalSwap(EmptyDirVolumeSource* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.medium_, lhs_arena,
      &other->_impl_.medium_, rhs_arena
  );
  swap(_impl_.sizelimit_, other->_impl_.sizelimit_);
}

::PROTOBUF_NAMESPACE_ID::Metadata EmptyDirVolumeSource::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[47]);
}

// ===================================================================

class EndpointAddress::_Internal {
 public:
  using HasBits = decltype(std::declval<EndpointAddress>()._impl_._has_bits_);
  static void set_has_ip(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_hostname(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_nodename(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::k8s::io::api::core::v1::ObjectReference& targetref(const EndpointAddress* msg);
  static void set_has_targetref(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::k8s::io::api::core::v1::ObjectReference&
EndpointAddress::_Internal::targetref(const EndpointAddress* msg) {
  return *msg->_impl_.targetref_;
}
EndpointAddress::EndpointAddress(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.EndpointAddress)
}
EndpointAddress::EndpointAddress(const EndpointAddress& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EndpointAddress* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ip_){}
    , decltype(_impl_.hostname_){}
    , decltype(_impl_.nodename_){}
    , decltype(_impl_.targetref_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.ip_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ip_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ip()) {
    _this->_impl_.ip_.Set(from._internal_ip(), 
      _this->GetArenaForAllocation());
  }
  _impl_.hostname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hostname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_hostname()) {
    _this->_impl_.hostname_.Set(from._internal_hostname(), 
      _this->GetArenaForAllocation());
  }
  _impl_.nodename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nodename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_nodename()) {
    _this->_impl_.nodename_.Set(from._internal_nodename(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_targetref()) {
    _this->_impl_.targetref_ = new ::k8s::io::api::core::v1::ObjectReference(*from._impl_.targetref_);
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.EndpointAddress)
}

inline void EndpointAddress::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ip_){}
    , decltype(_impl_.hostname_){}
    , decltype(_impl_.nodename_){}
    , decltype(_impl_.targetref_){nullptr}
  };
  _impl_.ip_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ip_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.hostname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hostname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.nodename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nodename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

EndpointAddress::~EndpointAddress() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.EndpointAddress)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EndpointAddress::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.ip_.Destroy();
  _impl_.hostname_.Destroy();
  _impl_.nodename_.Destroy();
  if (this != internal_default_instance()) delete _impl_.targetref_;
}

void EndpointAddress::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EndpointAddress::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.EndpointAddress)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.ip_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.hostname_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.nodename_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.targetref_ != nullptr);
      _impl_.targetref_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EndpointAddress::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes ip = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_ip();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.ObjectReference targetRef = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_targetref(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes hostname = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_hostname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes nodeName = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_nodename();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EndpointAddress::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.EndpointAddress)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes ip = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_ip(), target);
  }

  // optional .k8s.io.api.core.v1.ObjectReference targetRef = 2;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::targetref(this),
        _Internal::targetref(this).GetCachedSize(), target, stream);
  }

  // optional bytes hostname = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_hostname(), target);
  }

  // optional bytes nodeName = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_nodename(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.EndpointAddress)
  return target;
}

size_t EndpointAddress::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.EndpointAddress)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional bytes ip = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_ip());
    }

    // optional bytes hostname = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_hostname());
    }

    // optional bytes nodeName = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_nodename());
    }

    // optional .k8s.io.api.core.v1.ObjectReference targetRef = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.targetref_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EndpointAddress::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EndpointAddress::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EndpointAddress::GetClassData() const { return &_class_data_; }


void EndpointAddress::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EndpointAddress*>(&to_msg);
  auto& from = static_cast<const EndpointAddress&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.EndpointAddress)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_ip(from._internal_ip());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_hostname(from._internal_hostname());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_nodename(from._internal_nodename());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_targetref()->::k8s::io::api::core::v1::ObjectReference::MergeFrom(
          from._internal_targetref());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EndpointAddress::CopyFrom(const EndpointAddress& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.EndpointAddress)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EndpointAddress::IsInitialized() const {
  return true;
}

void EndpointAddress::InternalSwap(EndpointAddress* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.ip_, lhs_arena,
      &other->_impl_.ip_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.hostname_, lhs_arena,
      &other->_impl_.hostname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.nodename_, lhs_arena,
      &other->_impl_.nodename_, rhs_arena
  );
  swap(_impl_.targetref_, other->_impl_.targetref_);
}

::PROTOBUF_NAMESPACE_ID::Metadata EndpointAddress::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[48]);
}

// ===================================================================

class EndpointPort::_Internal {
 public:
  using HasBits = decltype(std::declval<EndpointPort>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_port(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_protocol(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_appprotocol(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

EndpointPort::EndpointPort(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.EndpointPort)
}
EndpointPort::EndpointPort(const EndpointPort& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EndpointPort* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.protocol_){}
    , decltype(_impl_.appprotocol_){}
    , decltype(_impl_.port_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.protocol_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.protocol_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_protocol()) {
    _this->_impl_.protocol_.Set(from._internal_protocol(), 
      _this->GetArenaForAllocation());
  }
  _impl_.appprotocol_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.appprotocol_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_appprotocol()) {
    _this->_impl_.appprotocol_.Set(from._internal_appprotocol(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.port_ = from._impl_.port_;
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.EndpointPort)
}

inline void EndpointPort::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.protocol_){}
    , decltype(_impl_.appprotocol_){}
    , decltype(_impl_.port_){0}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.protocol_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.protocol_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.appprotocol_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.appprotocol_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

EndpointPort::~EndpointPort() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.EndpointPort)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EndpointPort::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.protocol_.Destroy();
  _impl_.appprotocol_.Destroy();
}

void EndpointPort::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EndpointPort::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.EndpointPort)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.protocol_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.appprotocol_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.port_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EndpointPort::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 port = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_port(&has_bits);
          _impl_.port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes protocol = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_protocol();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes appProtocol = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_appprotocol();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EndpointPort::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.EndpointPort)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional int32 port = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_port(), target);
  }

  // optional bytes protocol = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_protocol(), target);
  }

  // optional bytes appProtocol = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_appprotocol(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.EndpointPort)
  return target;
}

size_t EndpointPort::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.EndpointPort)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional bytes name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_name());
    }

    // optional bytes protocol = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_protocol());
    }

    // optional bytes appProtocol = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_appprotocol());
    }

    // optional int32 port = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_port());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EndpointPort::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EndpointPort::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EndpointPort::GetClassData() const { return &_class_data_; }


void EndpointPort::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EndpointPort*>(&to_msg);
  auto& from = static_cast<const EndpointPort&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.EndpointPort)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_protocol(from._internal_protocol());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_appprotocol(from._internal_appprotocol());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.port_ = from._impl_.port_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EndpointPort::CopyFrom(const EndpointPort& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.EndpointPort)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EndpointPort::IsInitialized() const {
  return true;
}

void EndpointPort::InternalSwap(EndpointPort* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.protocol_, lhs_arena,
      &other->_impl_.protocol_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.appprotocol_, lhs_arena,
      &other->_impl_.appprotocol_, rhs_arena
  );
  swap(_impl_.port_, other->_impl_.port_);
}

::PROTOBUF_NAMESPACE_ID::Metadata EndpointPort::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[49]);
}

// ===================================================================

class EndpointSubset::_Internal {
 public:
};

EndpointSubset::EndpointSubset(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.EndpointSubset)
}
EndpointSubset::EndpointSubset(const EndpointSubset& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EndpointSubset* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.addresses_){from._impl_.addresses_}
    , decltype(_impl_.notreadyaddresses_){from._impl_.notreadyaddresses_}
    , decltype(_impl_.ports_){from._impl_.ports_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.EndpointSubset)
}

inline void EndpointSubset::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.addresses_){arena}
    , decltype(_impl_.notreadyaddresses_){arena}
    , decltype(_impl_.ports_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

EndpointSubset::~EndpointSubset() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.EndpointSubset)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EndpointSubset::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.addresses_.~RepeatedPtrField();
  _impl_.notreadyaddresses_.~RepeatedPtrField();
  _impl_.ports_.~RepeatedPtrField();
}

void EndpointSubset::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EndpointSubset::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.EndpointSubset)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.addresses_.Clear();
  _impl_.notreadyaddresses_.Clear();
  _impl_.ports_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EndpointSubset::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .k8s.io.api.core.v1.EndpointAddress addresses = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_addresses(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .k8s.io.api.core.v1.EndpointAddress notReadyAddresses = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_notreadyaddresses(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .k8s.io.api.core.v1.EndpointPort ports = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_ports(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EndpointSubset::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.EndpointSubset)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .k8s.io.api.core.v1.EndpointAddress addresses = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_addresses_size()); i < n; i++) {
    const auto& repfield = this->_internal_addresses(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .k8s.io.api.core.v1.EndpointAddress notReadyAddresses = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_notreadyaddresses_size()); i < n; i++) {
    const auto& repfield = this->_internal_notreadyaddresses(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .k8s.io.api.core.v1.EndpointPort ports = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_ports_size()); i < n; i++) {
    const auto& repfield = this->_internal_ports(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.EndpointSubset)
  return target;
}

size_t EndpointSubset::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.EndpointSubset)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .k8s.io.api.core.v1.EndpointAddress addresses = 1;
  total_size += 1UL * this->_internal_addresses_size();
  for (const auto& msg : this->_impl_.addresses_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .k8s.io.api.core.v1.EndpointAddress notReadyAddresses = 2;
  total_size += 1UL * this->_internal_notreadyaddresses_size();
  for (const auto& msg : this->_impl_.notreadyaddresses_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .k8s.io.api.core.v1.EndpointPort ports = 3;
  total_size += 1UL * this->_internal_ports_size();
  for (const auto& msg : this->_impl_.ports_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EndpointSubset::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EndpointSubset::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EndpointSubset::GetClassData() const { return &_class_data_; }


void EndpointSubset::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EndpointSubset*>(&to_msg);
  auto& from = static_cast<const EndpointSubset&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.EndpointSubset)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.addresses_.MergeFrom(from._impl_.addresses_);
  _this->_impl_.notreadyaddresses_.MergeFrom(from._impl_.notreadyaddresses_);
  _this->_impl_.ports_.MergeFrom(from._impl_.ports_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EndpointSubset::CopyFrom(const EndpointSubset& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.EndpointSubset)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EndpointSubset::IsInitialized() const {
  return true;
}

void EndpointSubset::InternalSwap(EndpointSubset* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.addresses_.InternalSwap(&other->_impl_.addresses_);
  _impl_.notreadyaddresses_.InternalSwap(&other->_impl_.notreadyaddresses_);
  _impl_.ports_.InternalSwap(&other->_impl_.ports_);
}

::PROTOBUF_NAMESPACE_ID::Metadata EndpointSubset::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[50]);
}

// ===================================================================

class Endpoints::_Internal {
 public:
  using HasBits = decltype(std::declval<Endpoints>()._impl_._has_bits_);
  static const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& metadata(const Endpoints* msg);
  static void set_has_metadata(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta&
Endpoints::_Internal::metadata(const Endpoints* msg) {
  return *msg->_impl_.metadata_;
}
void Endpoints::clear_metadata() {
  if (_impl_.metadata_ != nullptr) _impl_.metadata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
Endpoints::Endpoints(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.Endpoints)
}
Endpoints::Endpoints(const Endpoints& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Endpoints* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.subsets_){from._impl_.subsets_}
    , decltype(_impl_.metadata_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_metadata()) {
    _this->_impl_.metadata_ = new ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta(*from._impl_.metadata_);
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.Endpoints)
}

inline void Endpoints::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.subsets_){arena}
    , decltype(_impl_.metadata_){nullptr}
  };
}

Endpoints::~Endpoints() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.Endpoints)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Endpoints::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.subsets_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.metadata_;
}

void Endpoints::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Endpoints::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.Endpoints)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.subsets_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.metadata_ != nullptr);
    _impl_.metadata_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Endpoints::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_metadata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .k8s.io.api.core.v1.EndpointSubset subsets = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_subsets(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Endpoints::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.Endpoints)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::metadata(this),
        _Internal::metadata(this).GetCachedSize(), target, stream);
  }

  // repeated .k8s.io.api.core.v1.EndpointSubset subsets = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_subsets_size()); i < n; i++) {
    const auto& repfield = this->_internal_subsets(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.Endpoints)
  return target;
}

size_t Endpoints::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.Endpoints)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .k8s.io.api.core.v1.EndpointSubset subsets = 2;
  total_size += 1UL * this->_internal_subsets_size();
  for (const auto& msg : this->_impl_.subsets_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.metadata_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Endpoints::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Endpoints::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Endpoints::GetClassData() const { return &_class_data_; }


void Endpoints::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Endpoints*>(&to_msg);
  auto& from = static_cast<const Endpoints&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.Endpoints)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.subsets_.MergeFrom(from._impl_.subsets_);
  if (from._internal_has_metadata()) {
    _this->_internal_mutable_metadata()->::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta::MergeFrom(
        from._internal_metadata());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Endpoints::CopyFrom(const Endpoints& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.Endpoints)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Endpoints::IsInitialized() const {
  return true;
}

void Endpoints::InternalSwap(Endpoints* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.subsets_.InternalSwap(&other->_impl_.subsets_);
  swap(_impl_.metadata_, other->_impl_.metadata_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Endpoints::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[51]);
}

// ===================================================================

class EndpointsList::_Internal {
 public:
  using HasBits = decltype(std::declval<EndpointsList>()._impl_._has_bits_);
  static const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& metadata(const EndpointsList* msg);
  static void set_has_metadata(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta&
EndpointsList::_Internal::metadata(const EndpointsList* msg) {
  return *msg->_impl_.metadata_;
}
void EndpointsList::clear_metadata() {
  if (_impl_.metadata_ != nullptr) _impl_.metadata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
EndpointsList::EndpointsList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.EndpointsList)
}
EndpointsList::EndpointsList(const EndpointsList& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EndpointsList* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.items_){from._impl_.items_}
    , decltype(_impl_.metadata_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_metadata()) {
    _this->_impl_.metadata_ = new ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta(*from._impl_.metadata_);
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.EndpointsList)
}

inline void EndpointsList::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.items_){arena}
    , decltype(_impl_.metadata_){nullptr}
  };
}

EndpointsList::~EndpointsList() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.EndpointsList)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EndpointsList::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.items_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.metadata_;
}

void EndpointsList::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EndpointsList::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.EndpointsList)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.items_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.metadata_ != nullptr);
    _impl_.metadata_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EndpointsList::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_metadata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .k8s.io.api.core.v1.Endpoints items = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_items(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EndpointsList::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.EndpointsList)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::metadata(this),
        _Internal::metadata(this).GetCachedSize(), target, stream);
  }

  // repeated .k8s.io.api.core.v1.Endpoints items = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_items_size()); i < n; i++) {
    const auto& repfield = this->_internal_items(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.EndpointsList)
  return target;
}

size_t EndpointsList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.EndpointsList)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .k8s.io.api.core.v1.Endpoints items = 2;
  total_size += 1UL * this->_internal_items_size();
  for (const auto& msg : this->_impl_.items_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.metadata_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EndpointsList::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EndpointsList::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EndpointsList::GetClassData() const { return &_class_data_; }


void EndpointsList::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EndpointsList*>(&to_msg);
  auto& from = static_cast<const EndpointsList&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.EndpointsList)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.items_.MergeFrom(from._impl_.items_);
  if (from._internal_has_metadata()) {
    _this->_internal_mutable_metadata()->::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta::MergeFrom(
        from._internal_metadata());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EndpointsList::CopyFrom(const EndpointsList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.EndpointsList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EndpointsList::IsInitialized() const {
  return true;
}

void EndpointsList::InternalSwap(EndpointsList* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.items_.InternalSwap(&other->_impl_.items_);
  swap(_impl_.metadata_, other->_impl_.metadata_);
}

::PROTOBUF_NAMESPACE_ID::Metadata EndpointsList::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[52]);
}

// ===================================================================

class EnvFromSource::_Internal {
 public:
  using HasBits = decltype(std::declval<EnvFromSource>()._impl_._has_bits_);
  static void set_has_prefix(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::k8s::io::api::core::v1::ConfigMapEnvSource& configmapref(const EnvFromSource* msg);
  static void set_has_configmapref(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::k8s::io::api::core::v1::SecretEnvSource& secretref(const EnvFromSource* msg);
  static void set_has_secretref(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::k8s::io::api::core::v1::ConfigMapEnvSource&
EnvFromSource::_Internal::configmapref(const EnvFromSource* msg) {
  return *msg->_impl_.configmapref_;
}
const ::k8s::io::api::core::v1::SecretEnvSource&
EnvFromSource::_Internal::secretref(const EnvFromSource* msg) {
  return *msg->_impl_.secretref_;
}
EnvFromSource::EnvFromSource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.EnvFromSource)
}
EnvFromSource::EnvFromSource(const EnvFromSource& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EnvFromSource* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.prefix_){}
    , decltype(_impl_.configmapref_){nullptr}
    , decltype(_impl_.secretref_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.prefix_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.prefix_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_prefix()) {
    _this->_impl_.prefix_.Set(from._internal_prefix(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_configmapref()) {
    _this->_impl_.configmapref_ = new ::k8s::io::api::core::v1::ConfigMapEnvSource(*from._impl_.configmapref_);
  }
  if (from._internal_has_secretref()) {
    _this->_impl_.secretref_ = new ::k8s::io::api::core::v1::SecretEnvSource(*from._impl_.secretref_);
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.EnvFromSource)
}

inline void EnvFromSource::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.prefix_){}
    , decltype(_impl_.configmapref_){nullptr}
    , decltype(_impl_.secretref_){nullptr}
  };
  _impl_.prefix_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.prefix_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

EnvFromSource::~EnvFromSource() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.EnvFromSource)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EnvFromSource::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.prefix_.Destroy();
  if (this != internal_default_instance()) delete _impl_.configmapref_;
  if (this != internal_default_instance()) delete _impl_.secretref_;
}

void EnvFromSource::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EnvFromSource::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.EnvFromSource)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.prefix_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.configmapref_ != nullptr);
      _impl_.configmapref_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.secretref_ != nullptr);
      _impl_.secretref_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EnvFromSource::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes prefix = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_prefix();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.ConfigMapEnvSource configMapRef = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_configmapref(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.SecretEnvSource secretRef = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_secretref(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EnvFromSource::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.EnvFromSource)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes prefix = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_prefix(), target);
  }

  // optional .k8s.io.api.core.v1.ConfigMapEnvSource configMapRef = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::configmapref(this),
        _Internal::configmapref(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.SecretEnvSource secretRef = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::secretref(this),
        _Internal::secretref(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.EnvFromSource)
  return target;
}

size_t EnvFromSource::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.EnvFromSource)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bytes prefix = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_prefix());
    }

    // optional .k8s.io.api.core.v1.ConfigMapEnvSource configMapRef = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.configmapref_);
    }

    // optional .k8s.io.api.core.v1.SecretEnvSource secretRef = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.secretref_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EnvFromSource::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EnvFromSource::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EnvFromSource::GetClassData() const { return &_class_data_; }


void EnvFromSource::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EnvFromSource*>(&to_msg);
  auto& from = static_cast<const EnvFromSource&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.EnvFromSource)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_prefix(from._internal_prefix());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_configmapref()->::k8s::io::api::core::v1::ConfigMapEnvSource::MergeFrom(
          from._internal_configmapref());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_secretref()->::k8s::io::api::core::v1::SecretEnvSource::MergeFrom(
          from._internal_secretref());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EnvFromSource::CopyFrom(const EnvFromSource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.EnvFromSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EnvFromSource::IsInitialized() const {
  return true;
}

void EnvFromSource::InternalSwap(EnvFromSource* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.prefix_, lhs_arena,
      &other->_impl_.prefix_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EnvFromSource, _impl_.secretref_)
      + sizeof(EnvFromSource::_impl_.secretref_)
      - PROTOBUF_FIELD_OFFSET(EnvFromSource, _impl_.configmapref_)>(
          reinterpret_cast<char*>(&_impl_.configmapref_),
          reinterpret_cast<char*>(&other->_impl_.configmapref_));
}

::PROTOBUF_NAMESPACE_ID::Metadata EnvFromSource::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[53]);
}

// ===================================================================

class EnvVar::_Internal {
 public:
  using HasBits = decltype(std::declval<EnvVar>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::k8s::io::api::core::v1::EnvVarSource& valuefrom(const EnvVar* msg);
  static void set_has_valuefrom(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::k8s::io::api::core::v1::EnvVarSource&
EnvVar::_Internal::valuefrom(const EnvVar* msg) {
  return *msg->_impl_.valuefrom_;
}
EnvVar::EnvVar(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.EnvVar)
}
EnvVar::EnvVar(const EnvVar& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EnvVar* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.value_){}
    , decltype(_impl_.valuefrom_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_value()) {
    _this->_impl_.value_.Set(from._internal_value(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_valuefrom()) {
    _this->_impl_.valuefrom_ = new ::k8s::io::api::core::v1::EnvVarSource(*from._impl_.valuefrom_);
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.EnvVar)
}

inline void EnvVar::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.value_){}
    , decltype(_impl_.valuefrom_){nullptr}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

EnvVar::~EnvVar() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.EnvVar)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EnvVar::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.value_.Destroy();
  if (this != internal_default_instance()) delete _impl_.valuefrom_;
}

void EnvVar::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EnvVar::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.EnvVar)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.value_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.valuefrom_ != nullptr);
      _impl_.valuefrom_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EnvVar::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.EnvVarSource valueFrom = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_valuefrom(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EnvVar::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.EnvVar)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional bytes value = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_value(), target);
  }

  // optional .k8s.io.api.core.v1.EnvVarSource valueFrom = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::valuefrom(this),
        _Internal::valuefrom(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.EnvVar)
  return target;
}

size_t EnvVar::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.EnvVar)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bytes name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_name());
    }

    // optional bytes value = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_value());
    }

    // optional .k8s.io.api.core.v1.EnvVarSource valueFrom = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.valuefrom_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EnvVar::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EnvVar::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EnvVar::GetClassData() const { return &_class_data_; }


void EnvVar::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EnvVar*>(&to_msg);
  auto& from = static_cast<const EnvVar&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.EnvVar)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_value(from._internal_value());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_valuefrom()->::k8s::io::api::core::v1::EnvVarSource::MergeFrom(
          from._internal_valuefrom());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EnvVar::CopyFrom(const EnvVar& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.EnvVar)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EnvVar::IsInitialized() const {
  return true;
}

void EnvVar::InternalSwap(EnvVar* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.value_, lhs_arena,
      &other->_impl_.value_, rhs_arena
  );
  swap(_impl_.valuefrom_, other->_impl_.valuefrom_);
}

::PROTOBUF_NAMESPACE_ID::Metadata EnvVar::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[54]);
}

// ===================================================================

class EnvVarSource::_Internal {
 public:
  using HasBits = decltype(std::declval<EnvVarSource>()._impl_._has_bits_);
  static const ::k8s::io::api::core::v1::ObjectFieldSelector& fieldref(const EnvVarSource* msg);
  static void set_has_fieldref(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::k8s::io::api::core::v1::ResourceFieldSelector& resourcefieldref(const EnvVarSource* msg);
  static void set_has_resourcefieldref(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::k8s::io::api::core::v1::ConfigMapKeySelector& configmapkeyref(const EnvVarSource* msg);
  static void set_has_configmapkeyref(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::k8s::io::api::core::v1::SecretKeySelector& secretkeyref(const EnvVarSource* msg);
  static void set_has_secretkeyref(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::k8s::io::api::core::v1::ObjectFieldSelector&
EnvVarSource::_Internal::fieldref(const EnvVarSource* msg) {
  return *msg->_impl_.fieldref_;
}
const ::k8s::io::api::core::v1::ResourceFieldSelector&
EnvVarSource::_Internal::resourcefieldref(const EnvVarSource* msg) {
  return *msg->_impl_.resourcefieldref_;
}
const ::k8s::io::api::core::v1::ConfigMapKeySelector&
EnvVarSource::_Internal::configmapkeyref(const EnvVarSource* msg) {
  return *msg->_impl_.configmapkeyref_;
}
const ::k8s::io::api::core::v1::SecretKeySelector&
EnvVarSource::_Internal::secretkeyref(const EnvVarSource* msg) {
  return *msg->_impl_.secretkeyref_;
}
EnvVarSource::EnvVarSource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.EnvVarSource)
}
EnvVarSource::EnvVarSource(const EnvVarSource& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EnvVarSource* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.fieldref_){nullptr}
    , decltype(_impl_.resourcefieldref_){nullptr}
    , decltype(_impl_.configmapkeyref_){nullptr}
    , decltype(_impl_.secretkeyref_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_fieldref()) {
    _this->_impl_.fieldref_ = new ::k8s::io::api::core::v1::ObjectFieldSelector(*from._impl_.fieldref_);
  }
  if (from._internal_has_resourcefieldref()) {
    _this->_impl_.resourcefieldref_ = new ::k8s::io::api::core::v1::ResourceFieldSelector(*from._impl_.resourcefieldref_);
  }
  if (from._internal_has_configmapkeyref()) {
    _this->_impl_.configmapkeyref_ = new ::k8s::io::api::core::v1::ConfigMapKeySelector(*from._impl_.configmapkeyref_);
  }
  if (from._internal_has_secretkeyref()) {
    _this->_impl_.secretkeyref_ = new ::k8s::io::api::core::v1::SecretKeySelector(*from._impl_.secretkeyref_);
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.EnvVarSource)
}

inline void EnvVarSource::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.fieldref_){nullptr}
    , decltype(_impl_.resourcefieldref_){nullptr}
    , decltype(_impl_.configmapkeyref_){nullptr}
    , decltype(_impl_.secretkeyref_){nullptr}
  };
}

EnvVarSource::~EnvVarSource() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.EnvVarSource)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EnvVarSource::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.fieldref_;
  if (this != internal_default_instance()) delete _impl_.resourcefieldref_;
  if (this != internal_default_instance()) delete _impl_.configmapkeyref_;
  if (this != internal_default_instance()) delete _impl_.secretkeyref_;
}

void EnvVarSource::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EnvVarSource::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.EnvVarSource)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.fieldref_ != nullptr);
      _impl_.fieldref_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.resourcefieldref_ != nullptr);
      _impl_.resourcefieldref_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.configmapkeyref_ != nullptr);
      _impl_.configmapkeyref_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.secretkeyref_ != nullptr);
      _impl_.secretkeyref_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EnvVarSource::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .k8s.io.api.core.v1.ObjectFieldSelector fieldRef = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_fieldref(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.ResourceFieldSelector resourceFieldRef = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_resourcefieldref(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.ConfigMapKeySelector configMapKeyRef = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_configmapkeyref(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.SecretKeySelector secretKeyRef = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_secretkeyref(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EnvVarSource::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.EnvVarSource)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .k8s.io.api.core.v1.ObjectFieldSelector fieldRef = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::fieldref(this),
        _Internal::fieldref(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.ResourceFieldSelector resourceFieldRef = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::resourcefieldref(this),
        _Internal::resourcefieldref(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.ConfigMapKeySelector configMapKeyRef = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::configmapkeyref(this),
        _Internal::configmapkeyref(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.SecretKeySelector secretKeyRef = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::secretkeyref(this),
        _Internal::secretkeyref(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.EnvVarSource)
  return target;
}

size_t EnvVarSource::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.EnvVarSource)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .k8s.io.api.core.v1.ObjectFieldSelector fieldRef = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.fieldref_);
    }

    // optional .k8s.io.api.core.v1.ResourceFieldSelector resourceFieldRef = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.resourcefieldref_);
    }

    // optional .k8s.io.api.core.v1.ConfigMapKeySelector configMapKeyRef = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.configmapkeyref_);
    }

    // optional .k8s.io.api.core.v1.SecretKeySelector secretKeyRef = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.secretkeyref_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EnvVarSource::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EnvVarSource::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EnvVarSource::GetClassData() const { return &_class_data_; }


void EnvVarSource::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EnvVarSource*>(&to_msg);
  auto& from = static_cast<const EnvVarSource&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.EnvVarSource)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_fieldref()->::k8s::io::api::core::v1::ObjectFieldSelector::MergeFrom(
          from._internal_fieldref());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_resourcefieldref()->::k8s::io::api::core::v1::ResourceFieldSelector::MergeFrom(
          from._internal_resourcefieldref());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_configmapkeyref()->::k8s::io::api::core::v1::ConfigMapKeySelector::MergeFrom(
          from._internal_configmapkeyref());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_secretkeyref()->::k8s::io::api::core::v1::SecretKeySelector::MergeFrom(
          from._internal_secretkeyref());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EnvVarSource::CopyFrom(const EnvVarSource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.EnvVarSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EnvVarSource::IsInitialized() const {
  return true;
}

void EnvVarSource::InternalSwap(EnvVarSource* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EnvVarSource, _impl_.secretkeyref_)
      + sizeof(EnvVarSource::_impl_.secretkeyref_)
      - PROTOBUF_FIELD_OFFSET(EnvVarSource, _impl_.fieldref_)>(
          reinterpret_cast<char*>(&_impl_.fieldref_),
          reinterpret_cast<char*>(&other->_impl_.fieldref_));
}

::PROTOBUF_NAMESPACE_ID::Metadata EnvVarSource::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[55]);
}

// ===================================================================

class EphemeralContainer::_Internal {
 public:
  using HasBits = decltype(std::declval<EphemeralContainer>()._impl_._has_bits_);
  static const ::k8s::io::api::core::v1::EphemeralContainerCommon& ephemeralcontainercommon(const EphemeralContainer* msg);
  static void set_has_ephemeralcontainercommon(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_targetcontainername(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::k8s::io::api::core::v1::EphemeralContainerCommon&
EphemeralContainer::_Internal::ephemeralcontainercommon(const EphemeralContainer* msg) {
  return *msg->_impl_.ephemeralcontainercommon_;
}
EphemeralContainer::EphemeralContainer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.EphemeralContainer)
}
EphemeralContainer::EphemeralContainer(const EphemeralContainer& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EphemeralContainer* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.targetcontainername_){}
    , decltype(_impl_.ephemeralcontainercommon_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.targetcontainername_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.targetcontainername_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_targetcontainername()) {
    _this->_impl_.targetcontainername_.Set(from._internal_targetcontainername(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_ephemeralcontainercommon()) {
    _this->_impl_.ephemeralcontainercommon_ = new ::k8s::io::api::core::v1::EphemeralContainerCommon(*from._impl_.ephemeralcontainercommon_);
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.EphemeralContainer)
}

inline void EphemeralContainer::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.targetcontainername_){}
    , decltype(_impl_.ephemeralcontainercommon_){nullptr}
  };
  _impl_.targetcontainername_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.targetcontainername_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

EphemeralContainer::~EphemeralContainer() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.EphemeralContainer)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EphemeralContainer::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.targetcontainername_.Destroy();
  if (this != internal_default_instance()) delete _impl_.ephemeralcontainercommon_;
}

void EphemeralContainer::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EphemeralContainer::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.EphemeralContainer)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.targetcontainername_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.ephemeralcontainercommon_ != nullptr);
      _impl_.ephemeralcontainercommon_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EphemeralContainer::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .k8s.io.api.core.v1.EphemeralContainerCommon ephemeralContainerCommon = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_ephemeralcontainercommon(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes targetContainerName = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_targetcontainername();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EphemeralContainer::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.EphemeralContainer)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .k8s.io.api.core.v1.EphemeralContainerCommon ephemeralContainerCommon = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::ephemeralcontainercommon(this),
        _Internal::ephemeralcontainercommon(this).GetCachedSize(), target, stream);
  }

  // optional bytes targetContainerName = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_targetcontainername(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.EphemeralContainer)
  return target;
}

size_t EphemeralContainer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.EphemeralContainer)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes targetContainerName = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_targetcontainername());
    }

    // optional .k8s.io.api.core.v1.EphemeralContainerCommon ephemeralContainerCommon = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.ephemeralcontainercommon_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EphemeralContainer::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EphemeralContainer::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EphemeralContainer::GetClassData() const { return &_class_data_; }


void EphemeralContainer::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EphemeralContainer*>(&to_msg);
  auto& from = static_cast<const EphemeralContainer&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.EphemeralContainer)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_targetcontainername(from._internal_targetcontainername());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_ephemeralcontainercommon()->::k8s::io::api::core::v1::EphemeralContainerCommon::MergeFrom(
          from._internal_ephemeralcontainercommon());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EphemeralContainer::CopyFrom(const EphemeralContainer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.EphemeralContainer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EphemeralContainer::IsInitialized() const {
  return true;
}

void EphemeralContainer::InternalSwap(EphemeralContainer* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.targetcontainername_, lhs_arena,
      &other->_impl_.targetcontainername_, rhs_arena
  );
  swap(_impl_.ephemeralcontainercommon_, other->_impl_.ephemeralcontainercommon_);
}

::PROTOBUF_NAMESPACE_ID::Metadata EphemeralContainer::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[56]);
}

// ===================================================================

class EphemeralContainerCommon::_Internal {
 public:
  using HasBits = decltype(std::declval<EphemeralContainerCommon>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_image(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_workingdir(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::k8s::io::api::core::v1::ResourceRequirements& resources(const EphemeralContainerCommon* msg);
  static void set_has_resources(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_restartpolicy(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::k8s::io::api::core::v1::Probe& livenessprobe(const EphemeralContainerCommon* msg);
  static void set_has_livenessprobe(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static const ::k8s::io::api::core::v1::Probe& readinessprobe(const EphemeralContainerCommon* msg);
  static void set_has_readinessprobe(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static const ::k8s::io::api::core::v1::Probe& startupprobe(const EphemeralContainerCommon* msg);
  static void set_has_startupprobe(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static const ::k8s::io::api::core::v1::Lifecycle& lifecycle(const EphemeralContainerCommon* msg);
  static void set_has_lifecycle(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_terminationmessagepath(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_terminationmessagepolicy(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_imagepullpolicy(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::k8s::io::api::core::v1::SecurityContext& securitycontext(const EphemeralContainerCommon* msg);
  static void set_has_securitycontext(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_stdin(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_stdinonce(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_tty(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
};

const ::k8s::io::api::core::v1::ResourceRequirements&
EphemeralContainerCommon::_Internal::resources(const EphemeralContainerCommon* msg) {
  return *msg->_impl_.resources_;
}
const ::k8s::io::api::core::v1::Probe&
EphemeralContainerCommon::_Internal::livenessprobe(const EphemeralContainerCommon* msg) {
  return *msg->_impl_.livenessprobe_;
}
const ::k8s::io::api::core::v1::Probe&
EphemeralContainerCommon::_Internal::readinessprobe(const EphemeralContainerCommon* msg) {
  return *msg->_impl_.readinessprobe_;
}
const ::k8s::io::api::core::v1::Probe&
EphemeralContainerCommon::_Internal::startupprobe(const EphemeralContainerCommon* msg) {
  return *msg->_impl_.startupprobe_;
}
const ::k8s::io::api::core::v1::Lifecycle&
EphemeralContainerCommon::_Internal::lifecycle(const EphemeralContainerCommon* msg) {
  return *msg->_impl_.lifecycle_;
}
const ::k8s::io::api::core::v1::SecurityContext&
EphemeralContainerCommon::_Internal::securitycontext(const EphemeralContainerCommon* msg) {
  return *msg->_impl_.securitycontext_;
}
EphemeralContainerCommon::EphemeralContainerCommon(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.EphemeralContainerCommon)
}
EphemeralContainerCommon::EphemeralContainerCommon(const EphemeralContainerCommon& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EphemeralContainerCommon* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.command_){from._impl_.command_}
    , decltype(_impl_.args_){from._impl_.args_}
    , decltype(_impl_.ports_){from._impl_.ports_}
    , decltype(_impl_.env_){from._impl_.env_}
    , decltype(_impl_.volumemounts_){from._impl_.volumemounts_}
    , decltype(_impl_.envfrom_){from._impl_.envfrom_}
    , decltype(_impl_.volumedevices_){from._impl_.volumedevices_}
    , decltype(_impl_.resizepolicy_){from._impl_.resizepolicy_}
    , decltype(_impl_.name_){}
    , decltype(_impl_.image_){}
    , decltype(_impl_.workingdir_){}
    , decltype(_impl_.terminationmessagepath_){}
    , decltype(_impl_.imagepullpolicy_){}
    , decltype(_impl_.terminationmessagepolicy_){}
    , decltype(_impl_.restartpolicy_){}
    , decltype(_impl_.resources_){nullptr}
    , decltype(_impl_.livenessprobe_){nullptr}
    , decltype(_impl_.readinessprobe_){nullptr}
    , decltype(_impl_.lifecycle_){nullptr}
    , decltype(_impl_.securitycontext_){nullptr}
    , decltype(_impl_.startupprobe_){nullptr}
    , decltype(_impl_.stdin_){}
    , decltype(_impl_.stdinonce_){}
    , decltype(_impl_.tty_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.image_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.image_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_image()) {
    _this->_impl_.image_.Set(from._internal_image(), 
      _this->GetArenaForAllocation());
  }
  _impl_.workingdir_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.workingdir_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_workingdir()) {
    _this->_impl_.workingdir_.Set(from._internal_workingdir(), 
      _this->GetArenaForAllocation());
  }
  _impl_.terminationmessagepath_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.terminationmessagepath_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_terminationmessagepath()) {
    _this->_impl_.terminationmessagepath_.Set(from._internal_terminationmessagepath(), 
      _this->GetArenaForAllocation());
  }
  _impl_.imagepullpolicy_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.imagepullpolicy_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_imagepullpolicy()) {
    _this->_impl_.imagepullpolicy_.Set(from._internal_imagepullpolicy(), 
      _this->GetArenaForAllocation());
  }
  _impl_.terminationmessagepolicy_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.terminationmessagepolicy_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_terminationmessagepolicy()) {
    _this->_impl_.terminationmessagepolicy_.Set(from._internal_terminationmessagepolicy(), 
      _this->GetArenaForAllocation());
  }
  _impl_.restartpolicy_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.restartpolicy_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_restartpolicy()) {
    _this->_impl_.restartpolicy_.Set(from._internal_restartpolicy(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_resources()) {
    _this->_impl_.resources_ = new ::k8s::io::api::core::v1::ResourceRequirements(*from._impl_.resources_);
  }
  if (from._internal_has_livenessprobe()) {
    _this->_impl_.livenessprobe_ = new ::k8s::io::api::core::v1::Probe(*from._impl_.livenessprobe_);
  }
  if (from._internal_has_readinessprobe()) {
    _this->_impl_.readinessprobe_ = new ::k8s::io::api::core::v1::Probe(*from._impl_.readinessprobe_);
  }
  if (from._internal_has_lifecycle()) {
    _this->_impl_.lifecycle_ = new ::k8s::io::api::core::v1::Lifecycle(*from._impl_.lifecycle_);
  }
  if (from._internal_has_securitycontext()) {
    _this->_impl_.securitycontext_ = new ::k8s::io::api::core::v1::SecurityContext(*from._impl_.securitycontext_);
  }
  if (from._internal_has_startupprobe()) {
    _this->_impl_.startupprobe_ = new ::k8s::io::api::core::v1::Probe(*from._impl_.startupprobe_);
  }
  ::memcpy(&_impl_.stdin_, &from._impl_.stdin_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.tty_) -
    reinterpret_cast<char*>(&_impl_.stdin_)) + sizeof(_impl_.tty_));
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.EphemeralContainerCommon)
}

inline void EphemeralContainerCommon::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.command_){arena}
    , decltype(_impl_.args_){arena}
    , decltype(_impl_.ports_){arena}
    , decltype(_impl_.env_){arena}
    , decltype(_impl_.volumemounts_){arena}
    , decltype(_impl_.envfrom_){arena}
    , decltype(_impl_.volumedevices_){arena}
    , decltype(_impl_.resizepolicy_){arena}
    , decltype(_impl_.name_){}
    , decltype(_impl_.image_){}
    , decltype(_impl_.workingdir_){}
    , decltype(_impl_.terminationmessagepath_){}
    , decltype(_impl_.imagepullpolicy_){}
    , decltype(_impl_.terminationmessagepolicy_){}
    , decltype(_impl_.restartpolicy_){}
    , decltype(_impl_.resources_){nullptr}
    , decltype(_impl_.livenessprobe_){nullptr}
    , decltype(_impl_.readinessprobe_){nullptr}
    , decltype(_impl_.lifecycle_){nullptr}
    , decltype(_impl_.securitycontext_){nullptr}
    , decltype(_impl_.startupprobe_){nullptr}
    , decltype(_impl_.stdin_){false}
    , decltype(_impl_.stdinonce_){false}
    , decltype(_impl_.tty_){false}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.image_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.image_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.workingdir_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.workingdir_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.terminationmessagepath_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.terminationmessagepath_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.imagepullpolicy_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.imagepullpolicy_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.terminationmessagepolicy_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.terminationmessagepolicy_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.restartpolicy_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.restartpolicy_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

EphemeralContainerCommon::~EphemeralContainerCommon() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.EphemeralContainerCommon)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EphemeralContainerCommon::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.command_.~RepeatedPtrField();
  _impl_.args_.~RepeatedPtrField();
  _impl_.ports_.~RepeatedPtrField();
  _impl_.env_.~RepeatedPtrField();
  _impl_.volumemounts_.~RepeatedPtrField();
  _impl_.envfrom_.~RepeatedPtrField();
  _impl_.volumedevices_.~RepeatedPtrField();
  _impl_.resizepolicy_.~RepeatedPtrField();
  _impl_.name_.Destroy();
  _impl_.image_.Destroy();
  _impl_.workingdir_.Destroy();
  _impl_.terminationmessagepath_.Destroy();
  _impl_.imagepullpolicy_.Destroy();
  _impl_.terminationmessagepolicy_.Destroy();
  _impl_.restartpolicy_.Destroy();
  if (this != internal_default_instance()) delete _impl_.resources_;
  if (this != internal_default_instance()) delete _impl_.livenessprobe_;
  if (this != internal_default_instance()) delete _impl_.readinessprobe_;
  if (this != internal_default_instance()) delete _impl_.lifecycle_;
  if (this != internal_default_instance()) delete _impl_.securitycontext_;
  if (this != internal_default_instance()) delete _impl_.startupprobe_;
}

void EphemeralContainerCommon::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EphemeralContainerCommon::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.EphemeralContainerCommon)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.command_.Clear();
  _impl_.args_.Clear();
  _impl_.ports_.Clear();
  _impl_.env_.Clear();
  _impl_.volumemounts_.Clear();
  _impl_.envfrom_.Clear();
  _impl_.volumedevices_.Clear();
  _impl_.resizepolicy_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.image_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.workingdir_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.terminationmessagepath_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.imagepullpolicy_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      _impl_.terminationmessagepolicy_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000040u) {
      _impl_.restartpolicy_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(_impl_.resources_ != nullptr);
      _impl_.resources_->Clear();
    }
  }
  if (cached_has_bits & 0x00001f00u) {
    if (cached_has_bits & 0x00000100u) {
      GOOGLE_DCHECK(_impl_.livenessprobe_ != nullptr);
      _impl_.livenessprobe_->Clear();
    }
    if (cached_has_bits & 0x00000200u) {
      GOOGLE_DCHECK(_impl_.readinessprobe_ != nullptr);
      _impl_.readinessprobe_->Clear();
    }
    if (cached_has_bits & 0x00000400u) {
      GOOGLE_DCHECK(_impl_.lifecycle_ != nullptr);
      _impl_.lifecycle_->Clear();
    }
    if (cached_has_bits & 0x00000800u) {
      GOOGLE_DCHECK(_impl_.securitycontext_ != nullptr);
      _impl_.securitycontext_->Clear();
    }
    if (cached_has_bits & 0x00001000u) {
      GOOGLE_DCHECK(_impl_.startupprobe_ != nullptr);
      _impl_.startupprobe_->Clear();
    }
  }
  ::memset(&_impl_.stdin_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.tty_) -
      reinterpret_cast<char*>(&_impl_.stdin_)) + sizeof(_impl_.tty_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EphemeralContainerCommon::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes image = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_image();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string command = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_command();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "k8s.io.api.core.v1.EphemeralContainerCommon.command");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string args = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_args();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "k8s.io.api.core.v1.EphemeralContainerCommon.args");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bytes workingDir = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_workingdir();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .k8s.io.api.core.v1.ContainerPort ports = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_ports(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .k8s.io.api.core.v1.EnvVar env = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_env(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.ResourceRequirements resources = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_resources(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .k8s.io.api.core.v1.VolumeMount volumeMounts = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_volumemounts(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.Probe livenessProbe = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_livenessprobe(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.Probe readinessProbe = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_readinessprobe(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.Lifecycle lifecycle = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_lifecycle(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes terminationMessagePath = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          auto str = _internal_mutable_terminationmessagepath();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes imagePullPolicy = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          auto str = _internal_mutable_imagepullpolicy();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.SecurityContext securityContext = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_securitycontext(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool stdin = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_stdin(&has_bits);
          _impl_.stdin_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool stdinOnce = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_stdinonce(&has_bits);
          _impl_.stdinonce_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool tty = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _Internal::set_has_tty(&has_bits);
          _impl_.tty_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .k8s.io.api.core.v1.EnvFromSource envFrom = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_envfrom(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<154>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bytes terminationMessagePolicy = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          auto str = _internal_mutable_terminationmessagepolicy();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .k8s.io.api.core.v1.VolumeDevice volumeDevices = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_volumedevices(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<170>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.Probe startupProbe = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 178)) {
          ptr = ctx->ParseMessage(_internal_mutable_startupprobe(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .k8s.io.api.core.v1.ContainerResizePolicy resizePolicy = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 186)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_resizepolicy(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<186>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bytes restartPolicy = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 194)) {
          auto str = _internal_mutable_restartpolicy();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EphemeralContainerCommon::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.EphemeralContainerCommon)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional bytes image = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_image(), target);
  }

  // repeated string command = 3;
  for (int i = 0, n = this->_internal_command_size(); i < n; i++) {
    const auto& s = this->_internal_command(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "k8s.io.api.core.v1.EphemeralContainerCommon.command");
    target = stream->WriteString(3, s, target);
  }

  // repeated string args = 4;
  for (int i = 0, n = this->_internal_args_size(); i < n; i++) {
    const auto& s = this->_internal_args(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "k8s.io.api.core.v1.EphemeralContainerCommon.args");
    target = stream->WriteString(4, s, target);
  }

  // optional bytes workingDir = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_workingdir(), target);
  }

  // repeated .k8s.io.api.core.v1.ContainerPort ports = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_ports_size()); i < n; i++) {
    const auto& repfield = this->_internal_ports(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .k8s.io.api.core.v1.EnvVar env = 7;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_env_size()); i < n; i++) {
    const auto& repfield = this->_internal_env(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.ResourceRequirements resources = 8;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::resources(this),
        _Internal::resources(this).GetCachedSize(), target, stream);
  }

  // repeated .k8s.io.api.core.v1.VolumeMount volumeMounts = 9;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_volumemounts_size()); i < n; i++) {
    const auto& repfield = this->_internal_volumemounts(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(9, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.Probe livenessProbe = 10;
  if (cached_has_bits & 0x00000100u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::livenessprobe(this),
        _Internal::livenessprobe(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.Probe readinessProbe = 11;
  if (cached_has_bits & 0x00000200u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::readinessprobe(this),
        _Internal::readinessprobe(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.Lifecycle lifecycle = 12;
  if (cached_has_bits & 0x00000400u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, _Internal::lifecycle(this),
        _Internal::lifecycle(this).GetCachedSize(), target, stream);
  }

  // optional bytes terminationMessagePath = 13;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        13, this->_internal_terminationmessagepath(), target);
  }

  // optional bytes imagePullPolicy = 14;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteBytesMaybeAliased(
        14, this->_internal_imagepullpolicy(), target);
  }

  // optional .k8s.io.api.core.v1.SecurityContext securityContext = 15;
  if (cached_has_bits & 0x00000800u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(15, _Internal::securitycontext(this),
        _Internal::securitycontext(this).GetCachedSize(), target, stream);
  }

  // optional bool stdin = 16;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(16, this->_internal_stdin(), target);
  }

  // optional bool stdinOnce = 17;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(17, this->_internal_stdinonce(), target);
  }

  // optional bool tty = 18;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(18, this->_internal_tty(), target);
  }

  // repeated .k8s.io.api.core.v1.EnvFromSource envFrom = 19;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_envfrom_size()); i < n; i++) {
    const auto& repfield = this->_internal_envfrom(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(19, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bytes terminationMessagePolicy = 20;
  if (cached_has_bits & 0x00000020u) {
    target = stream->WriteBytesMaybeAliased(
        20, this->_internal_terminationmessagepolicy(), target);
  }

  // repeated .k8s.io.api.core.v1.VolumeDevice volumeDevices = 21;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_volumedevices_size()); i < n; i++) {
    const auto& repfield = this->_internal_volumedevices(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(21, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.Probe startupProbe = 22;
  if (cached_has_bits & 0x00001000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(22, _Internal::startupprobe(this),
        _Internal::startupprobe(this).GetCachedSize(), target, stream);
  }

  // repeated .k8s.io.api.core.v1.ContainerResizePolicy resizePolicy = 23;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_resizepolicy_size()); i < n; i++) {
    const auto& repfield = this->_internal_resizepolicy(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(23, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bytes restartPolicy = 24;
  if (cached_has_bits & 0x00000040u) {
    target = stream->WriteBytesMaybeAliased(
        24, this->_internal_restartpolicy(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.EphemeralContainerCommon)
  return target;
}

size_t EphemeralContainerCommon::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.EphemeralContainerCommon)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string command = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.command_.size());
  for (int i = 0, n = _impl_.command_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.command_.Get(i));
  }

  // repeated string args = 4;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.args_.size());
  for (int i = 0, n = _impl_.args_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.args_.Get(i));
  }

  // repeated .k8s.io.api.core.v1.ContainerPort ports = 6;
  total_size += 1UL * this->_internal_ports_size();
  for (const auto& msg : this->_impl_.ports_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .k8s.io.api.core.v1.EnvVar env = 7;
  total_size += 1UL * this->_internal_env_size();
  for (const auto& msg : this->_impl_.env_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .k8s.io.api.core.v1.VolumeMount volumeMounts = 9;
  total_size += 1UL * this->_internal_volumemounts_size();
  for (const auto& msg : this->_impl_.volumemounts_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .k8s.io.api.core.v1.EnvFromSource envFrom = 19;
  total_size += 2UL * this->_internal_envfrom_size();
  for (const auto& msg : this->_impl_.envfrom_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .k8s.io.api.core.v1.VolumeDevice volumeDevices = 21;
  total_size += 2UL * this->_internal_volumedevices_size();
  for (const auto& msg : this->_impl_.volumedevices_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .k8s.io.api.core.v1.ContainerResizePolicy resizePolicy = 23;
  total_size += 2UL * this->_internal_resizepolicy_size();
  for (const auto& msg : this->_impl_.resizepolicy_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bytes name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_name());
    }

    // optional bytes image = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_image());
    }

    // optional bytes workingDir = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_workingdir());
    }

    // optional bytes terminationMessagePath = 13;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_terminationmessagepath());
    }

    // optional bytes imagePullPolicy = 14;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_imagepullpolicy());
    }

    // optional bytes terminationMessagePolicy = 20;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_terminationmessagepolicy());
    }

    // optional bytes restartPolicy = 24;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_restartpolicy());
    }

    // optional .k8s.io.api.core.v1.ResourceRequirements resources = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.resources_);
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional .k8s.io.api.core.v1.Probe livenessProbe = 10;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.livenessprobe_);
    }

    // optional .k8s.io.api.core.v1.Probe readinessProbe = 11;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.readinessprobe_);
    }

    // optional .k8s.io.api.core.v1.Lifecycle lifecycle = 12;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.lifecycle_);
    }

    // optional .k8s.io.api.core.v1.SecurityContext securityContext = 15;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.securitycontext_);
    }

    // optional .k8s.io.api.core.v1.Probe startupProbe = 22;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.startupprobe_);
    }

    // optional bool stdin = 16;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 + 1;
    }

    // optional bool stdinOnce = 17;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 + 1;
    }

    // optional bool tty = 18;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EphemeralContainerCommon::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EphemeralContainerCommon::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EphemeralContainerCommon::GetClassData() const { return &_class_data_; }


void EphemeralContainerCommon::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EphemeralContainerCommon*>(&to_msg);
  auto& from = static_cast<const EphemeralContainerCommon&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.EphemeralContainerCommon)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.command_.MergeFrom(from._impl_.command_);
  _this->_impl_.args_.MergeFrom(from._impl_.args_);
  _this->_impl_.ports_.MergeFrom(from._impl_.ports_);
  _this->_impl_.env_.MergeFrom(from._impl_.env_);
  _this->_impl_.volumemounts_.MergeFrom(from._impl_.volumemounts_);
  _this->_impl_.envfrom_.MergeFrom(from._impl_.envfrom_);
  _this->_impl_.volumedevices_.MergeFrom(from._impl_.volumedevices_);
  _this->_impl_.resizepolicy_.MergeFrom(from._impl_.resizepolicy_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_image(from._internal_image());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_workingdir(from._internal_workingdir());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_terminationmessagepath(from._internal_terminationmessagepath());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_imagepullpolicy(from._internal_imagepullpolicy());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_set_terminationmessagepolicy(from._internal_terminationmessagepolicy());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_set_restartpolicy(from._internal_restartpolicy());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_mutable_resources()->::k8s::io::api::core::v1::ResourceRequirements::MergeFrom(
          from._internal_resources());
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_internal_mutable_livenessprobe()->::k8s::io::api::core::v1::Probe::MergeFrom(
          from._internal_livenessprobe());
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_internal_mutable_readinessprobe()->::k8s::io::api::core::v1::Probe::MergeFrom(
          from._internal_readinessprobe());
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_internal_mutable_lifecycle()->::k8s::io::api::core::v1::Lifecycle::MergeFrom(
          from._internal_lifecycle());
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_internal_mutable_securitycontext()->::k8s::io::api::core::v1::SecurityContext::MergeFrom(
          from._internal_securitycontext());
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_internal_mutable_startupprobe()->::k8s::io::api::core::v1::Probe::MergeFrom(
          from._internal_startupprobe());
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.stdin_ = from._impl_.stdin_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.stdinonce_ = from._impl_.stdinonce_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.tty_ = from._impl_.tty_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EphemeralContainerCommon::CopyFrom(const EphemeralContainerCommon& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.EphemeralContainerCommon)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EphemeralContainerCommon::IsInitialized() const {
  return true;
}

void EphemeralContainerCommon::InternalSwap(EphemeralContainerCommon* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.command_.InternalSwap(&other->_impl_.command_);
  _impl_.args_.InternalSwap(&other->_impl_.args_);
  _impl_.ports_.InternalSwap(&other->_impl_.ports_);
  _impl_.env_.InternalSwap(&other->_impl_.env_);
  _impl_.volumemounts_.InternalSwap(&other->_impl_.volumemounts_);
  _impl_.envfrom_.InternalSwap(&other->_impl_.envfrom_);
  _impl_.volumedevices_.InternalSwap(&other->_impl_.volumedevices_);
  _impl_.resizepolicy_.InternalSwap(&other->_impl_.resizepolicy_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.image_, lhs_arena,
      &other->_impl_.image_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.workingdir_, lhs_arena,
      &other->_impl_.workingdir_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.terminationmessagepath_, lhs_arena,
      &other->_impl_.terminationmessagepath_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.imagepullpolicy_, lhs_arena,
      &other->_impl_.imagepullpolicy_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.terminationmessagepolicy_, lhs_arena,
      &other->_impl_.terminationmessagepolicy_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.restartpolicy_, lhs_arena,
      &other->_impl_.restartpolicy_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EphemeralContainerCommon, _impl_.tty_)
      + sizeof(EphemeralContainerCommon::_impl_.tty_)
      - PROTOBUF_FIELD_OFFSET(EphemeralContainerCommon, _impl_.resources_)>(
          reinterpret_cast<char*>(&_impl_.resources_),
          reinterpret_cast<char*>(&other->_impl_.resources_));
}

::PROTOBUF_NAMESPACE_ID::Metadata EphemeralContainerCommon::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[57]);
}

// ===================================================================

class EphemeralVolumeSource::_Internal {
 public:
  using HasBits = decltype(std::declval<EphemeralVolumeSource>()._impl_._has_bits_);
  static const ::k8s::io::api::core::v1::PersistentVolumeClaimTemplate& volumeclaimtemplate(const EphemeralVolumeSource* msg);
  static void set_has_volumeclaimtemplate(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::k8s::io::api::core::v1::PersistentVolumeClaimTemplate&
EphemeralVolumeSource::_Internal::volumeclaimtemplate(const EphemeralVolumeSource* msg) {
  return *msg->_impl_.volumeclaimtemplate_;
}
EphemeralVolumeSource::EphemeralVolumeSource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.EphemeralVolumeSource)
}
EphemeralVolumeSource::EphemeralVolumeSource(const EphemeralVolumeSource& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EphemeralVolumeSource* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.volumeclaimtemplate_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_volumeclaimtemplate()) {
    _this->_impl_.volumeclaimtemplate_ = new ::k8s::io::api::core::v1::PersistentVolumeClaimTemplate(*from._impl_.volumeclaimtemplate_);
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.EphemeralVolumeSource)
}

inline void EphemeralVolumeSource::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.volumeclaimtemplate_){nullptr}
  };
}

EphemeralVolumeSource::~EphemeralVolumeSource() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.EphemeralVolumeSource)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EphemeralVolumeSource::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.volumeclaimtemplate_;
}

void EphemeralVolumeSource::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EphemeralVolumeSource::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.EphemeralVolumeSource)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.volumeclaimtemplate_ != nullptr);
    _impl_.volumeclaimtemplate_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EphemeralVolumeSource::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .k8s.io.api.core.v1.PersistentVolumeClaimTemplate volumeClaimTemplate = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_volumeclaimtemplate(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EphemeralVolumeSource::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.EphemeralVolumeSource)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .k8s.io.api.core.v1.PersistentVolumeClaimTemplate volumeClaimTemplate = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::volumeclaimtemplate(this),
        _Internal::volumeclaimtemplate(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.EphemeralVolumeSource)
  return target;
}

size_t EphemeralVolumeSource::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.EphemeralVolumeSource)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .k8s.io.api.core.v1.PersistentVolumeClaimTemplate volumeClaimTemplate = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.volumeclaimtemplate_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EphemeralVolumeSource::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EphemeralVolumeSource::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EphemeralVolumeSource::GetClassData() const { return &_class_data_; }


void EphemeralVolumeSource::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EphemeralVolumeSource*>(&to_msg);
  auto& from = static_cast<const EphemeralVolumeSource&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.EphemeralVolumeSource)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_volumeclaimtemplate()) {
    _this->_internal_mutable_volumeclaimtemplate()->::k8s::io::api::core::v1::PersistentVolumeClaimTemplate::MergeFrom(
        from._internal_volumeclaimtemplate());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EphemeralVolumeSource::CopyFrom(const EphemeralVolumeSource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.EphemeralVolumeSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EphemeralVolumeSource::IsInitialized() const {
  return true;
}

void EphemeralVolumeSource::InternalSwap(EphemeralVolumeSource* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.volumeclaimtemplate_, other->_impl_.volumeclaimtemplate_);
}

::PROTOBUF_NAMESPACE_ID::Metadata EphemeralVolumeSource::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[58]);
}

// ===================================================================

class Event::_Internal {
 public:
  using HasBits = decltype(std::declval<Event>()._impl_._has_bits_);
  static const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& metadata(const Event* msg);
  static void set_has_metadata(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::k8s::io::api::core::v1::ObjectReference& involvedobject(const Event* msg);
  static void set_has_involvedobject(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_reason(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_message(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::k8s::io::api::core::v1::EventSource& source(const Event* msg);
  static void set_has_source(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static const ::k8s::io::apimachinery::pkg::apis::meta::v1::Time& firsttimestamp(const Event* msg);
  static void set_has_firsttimestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static const ::k8s::io::apimachinery::pkg::apis::meta::v1::Time& lasttimestamp(const Event* msg);
  static void set_has_lasttimestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_count(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::k8s::io::apimachinery::pkg::apis::meta::v1::MicroTime& eventtime(const Event* msg);
  static void set_has_eventtime(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static const ::k8s::io::api::core::v1::EventSeries& series(const Event* msg);
  static void set_has_series(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_action(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::k8s::io::api::core::v1::ObjectReference& related(const Event* msg);
  static void set_has_related(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_reportingcomponent(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_reportinginstance(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta&
Event::_Internal::metadata(const Event* msg) {
  return *msg->_impl_.metadata_;
}
const ::k8s::io::api::core::v1::ObjectReference&
Event::_Internal::involvedobject(const Event* msg) {
  return *msg->_impl_.involvedobject_;
}
const ::k8s::io::api::core::v1::EventSource&
Event::_Internal::source(const Event* msg) {
  return *msg->_impl_.source_;
}
const ::k8s::io::apimachinery::pkg::apis::meta::v1::Time&
Event::_Internal::firsttimestamp(const Event* msg) {
  return *msg->_impl_.firsttimestamp_;
}
const ::k8s::io::apimachinery::pkg::apis::meta::v1::Time&
Event::_Internal::lasttimestamp(const Event* msg) {
  return *msg->_impl_.lasttimestamp_;
}
const ::k8s::io::apimachinery::pkg::apis::meta::v1::MicroTime&
Event::_Internal::eventtime(const Event* msg) {
  return *msg->_impl_.eventtime_;
}
const ::k8s::io::api::core::v1::EventSeries&
Event::_Internal::series(const Event* msg) {
  return *msg->_impl_.series_;
}
const ::k8s::io::api::core::v1::ObjectReference&
Event::_Internal::related(const Event* msg) {
  return *msg->_impl_.related_;
}
void Event::clear_metadata() {
  if (_impl_.metadata_ != nullptr) _impl_.metadata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
void Event::clear_firsttimestamp() {
  if (_impl_.firsttimestamp_ != nullptr) _impl_.firsttimestamp_->Clear();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
void Event::clear_lasttimestamp() {
  if (_impl_.lasttimestamp_ != nullptr) _impl_.lasttimestamp_->Clear();
  _impl_._has_bits_[0] &= ~0x00000400u;
}
void Event::clear_eventtime() {
  if (_impl_.eventtime_ != nullptr) _impl_.eventtime_->Clear();
  _impl_._has_bits_[0] &= ~0x00000800u;
}
Event::Event(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.Event)
}
Event::Event(const Event& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Event* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.reason_){}
    , decltype(_impl_.message_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.action_){}
    , decltype(_impl_.reportingcomponent_){}
    , decltype(_impl_.reportinginstance_){}
    , decltype(_impl_.metadata_){nullptr}
    , decltype(_impl_.involvedobject_){nullptr}
    , decltype(_impl_.source_){nullptr}
    , decltype(_impl_.firsttimestamp_){nullptr}
    , decltype(_impl_.lasttimestamp_){nullptr}
    , decltype(_impl_.eventtime_){nullptr}
    , decltype(_impl_.series_){nullptr}
    , decltype(_impl_.related_){nullptr}
    , decltype(_impl_.count_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.reason_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.reason_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_reason()) {
    _this->_impl_.reason_.Set(from._internal_reason(), 
      _this->GetArenaForAllocation());
  }
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_message()) {
    _this->_impl_.message_.Set(from._internal_message(), 
      _this->GetArenaForAllocation());
  }
  _impl_.type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_type()) {
    _this->_impl_.type_.Set(from._internal_type(), 
      _this->GetArenaForAllocation());
  }
  _impl_.action_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.action_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_action()) {
    _this->_impl_.action_.Set(from._internal_action(), 
      _this->GetArenaForAllocation());
  }
  _impl_.reportingcomponent_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.reportingcomponent_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_reportingcomponent()) {
    _this->_impl_.reportingcomponent_.Set(from._internal_reportingcomponent(), 
      _this->GetArenaForAllocation());
  }
  _impl_.reportinginstance_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.reportinginstance_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_reportinginstance()) {
    _this->_impl_.reportinginstance_.Set(from._internal_reportinginstance(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_metadata()) {
    _this->_impl_.metadata_ = new ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta(*from._impl_.metadata_);
  }
  if (from._internal_has_involvedobject()) {
    _this->_impl_.involvedobject_ = new ::k8s::io::api::core::v1::ObjectReference(*from._impl_.involvedobject_);
  }
  if (from._internal_has_source()) {
    _this->_impl_.source_ = new ::k8s::io::api::core::v1::EventSource(*from._impl_.source_);
  }
  if (from._internal_has_firsttimestamp()) {
    _this->_impl_.firsttimestamp_ = new ::k8s::io::apimachinery::pkg::apis::meta::v1::Time(*from._impl_.firsttimestamp_);
  }
  if (from._internal_has_lasttimestamp()) {
    _this->_impl_.lasttimestamp_ = new ::k8s::io::apimachinery::pkg::apis::meta::v1::Time(*from._impl_.lasttimestamp_);
  }
  if (from._internal_has_eventtime()) {
    _this->_impl_.eventtime_ = new ::k8s::io::apimachinery::pkg::apis::meta::v1::MicroTime(*from._impl_.eventtime_);
  }
  if (from._internal_has_series()) {
    _this->_impl_.series_ = new ::k8s::io::api::core::v1::EventSeries(*from._impl_.series_);
  }
  if (from._internal_has_related()) {
    _this->_impl_.related_ = new ::k8s::io::api::core::v1::ObjectReference(*from._impl_.related_);
  }
  _this->_impl_.count_ = from._impl_.count_;
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.Event)
}

inline void Event::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.reason_){}
    , decltype(_impl_.message_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.action_){}
    , decltype(_impl_.reportingcomponent_){}
    , decltype(_impl_.reportinginstance_){}
    , decltype(_impl_.metadata_){nullptr}
    , decltype(_impl_.involvedobject_){nullptr}
    , decltype(_impl_.source_){nullptr}
    , decltype(_impl_.firsttimestamp_){nullptr}
    , decltype(_impl_.lasttimestamp_){nullptr}
    , decltype(_impl_.eventtime_){nullptr}
    , decltype(_impl_.series_){nullptr}
    , decltype(_impl_.related_){nullptr}
    , decltype(_impl_.count_){0}
  };
  _impl_.reason_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.reason_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.action_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.action_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.reportingcomponent_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.reportingcomponent_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.reportinginstance_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.reportinginstance_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Event::~Event() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.Event)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Event::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.reason_.Destroy();
  _impl_.message_.Destroy();
  _impl_.type_.Destroy();
  _impl_.action_.Destroy();
  _impl_.reportingcomponent_.Destroy();
  _impl_.reportinginstance_.Destroy();
  if (this != internal_default_instance()) delete _impl_.metadata_;
  if (this != internal_default_instance()) delete _impl_.involvedobject_;
  if (this != internal_default_instance()) delete _impl_.source_;
  if (this != internal_default_instance()) delete _impl_.firsttimestamp_;
  if (this != internal_default_instance()) delete _impl_.lasttimestamp_;
  if (this != internal_default_instance()) delete _impl_.eventtime_;
  if (this != internal_default_instance()) delete _impl_.series_;
  if (this != internal_default_instance()) delete _impl_.related_;
}

void Event::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Event::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.Event)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.reason_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.message_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.type_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.action_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.reportingcomponent_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      _impl_.reportinginstance_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(_impl_.metadata_ != nullptr);
      _impl_.metadata_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(_impl_.involvedobject_ != nullptr);
      _impl_.involvedobject_->Clear();
    }
  }
  if (cached_has_bits & 0x00003f00u) {
    if (cached_has_bits & 0x00000100u) {
      GOOGLE_DCHECK(_impl_.source_ != nullptr);
      _impl_.source_->Clear();
    }
    if (cached_has_bits & 0x00000200u) {
      GOOGLE_DCHECK(_impl_.firsttimestamp_ != nullptr);
      _impl_.firsttimestamp_->Clear();
    }
    if (cached_has_bits & 0x00000400u) {
      GOOGLE_DCHECK(_impl_.lasttimestamp_ != nullptr);
      _impl_.lasttimestamp_->Clear();
    }
    if (cached_has_bits & 0x00000800u) {
      GOOGLE_DCHECK(_impl_.eventtime_ != nullptr);
      _impl_.eventtime_->Clear();
    }
    if (cached_has_bits & 0x00001000u) {
      GOOGLE_DCHECK(_impl_.series_ != nullptr);
      _impl_.series_->Clear();
    }
    if (cached_has_bits & 0x00002000u) {
      GOOGLE_DCHECK(_impl_.related_ != nullptr);
      _impl_.related_->Clear();
    }
  }
  _impl_.count_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Event::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_metadata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.ObjectReference involvedObject = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_involvedobject(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes reason = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_reason();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes message = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.EventSource source = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_source(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time firstTimestamp = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_firsttimestamp(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTimestamp = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_lasttimestamp(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 count = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_count(&has_bits);
          _impl_.count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes type = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime eventTime = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_eventtime(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.EventSeries series = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_series(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes action = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          auto str = _internal_mutable_action();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.ObjectReference related = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_related(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes reportingComponent = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          auto str = _internal_mutable_reportingcomponent();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes reportingInstance = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          auto str = _internal_mutable_reportinginstance();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Event::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.Event)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::metadata(this),
        _Internal::metadata(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.ObjectReference involvedObject = 2;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::involvedobject(this),
        _Internal::involvedobject(this).GetCachedSize(), target, stream);
  }

  // optional bytes reason = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_reason(), target);
  }

  // optional bytes message = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_message(), target);
  }

  // optional .k8s.io.api.core.v1.EventSource source = 5;
  if (cached_has_bits & 0x00000100u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::source(this),
        _Internal::source(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time firstTimestamp = 6;
  if (cached_has_bits & 0x00000200u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::firsttimestamp(this),
        _Internal::firsttimestamp(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTimestamp = 7;
  if (cached_has_bits & 0x00000400u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::lasttimestamp(this),
        _Internal::lasttimestamp(this).GetCachedSize(), target, stream);
  }

  // optional int32 count = 8;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(8, this->_internal_count(), target);
  }

  // optional bytes type = 9;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        9, this->_internal_type(), target);
  }

  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime eventTime = 10;
  if (cached_has_bits & 0x00000800u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::eventtime(this),
        _Internal::eventtime(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.EventSeries series = 11;
  if (cached_has_bits & 0x00001000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::series(this),
        _Internal::series(this).GetCachedSize(), target, stream);
  }

  // optional bytes action = 12;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        12, this->_internal_action(), target);
  }

  // optional .k8s.io.api.core.v1.ObjectReference related = 13;
  if (cached_has_bits & 0x00002000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(13, _Internal::related(this),
        _Internal::related(this).GetCachedSize(), target, stream);
  }

  // optional bytes reportingComponent = 14;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteBytesMaybeAliased(
        14, this->_internal_reportingcomponent(), target);
  }

  // optional bytes reportingInstance = 15;
  if (cached_has_bits & 0x00000020u) {
    target = stream->WriteBytesMaybeAliased(
        15, this->_internal_reportinginstance(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.Event)
  return target;
}

size_t Event::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.Event)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bytes reason = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_reason());
    }

    // optional bytes message = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_message());
    }

    // optional bytes type = 9;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_type());
    }

    // optional bytes action = 12;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_action());
    }

    // optional bytes reportingComponent = 14;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_reportingcomponent());
    }

    // optional bytes reportingInstance = 15;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_reportinginstance());
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.metadata_);
    }

    // optional .k8s.io.api.core.v1.ObjectReference involvedObject = 2;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.involvedobject_);
    }

  }
  if (cached_has_bits & 0x00007f00u) {
    // optional .k8s.io.api.core.v1.EventSource source = 5;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.source_);
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time firstTimestamp = 6;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.firsttimestamp_);
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTimestamp = 7;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.lasttimestamp_);
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime eventTime = 10;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.eventtime_);
    }

    // optional .k8s.io.api.core.v1.EventSeries series = 11;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.series_);
    }

    // optional .k8s.io.api.core.v1.ObjectReference related = 13;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.related_);
    }

    // optional int32 count = 8;
    if (cached_has_bits & 0x00004000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_count());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Event::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Event::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Event::GetClassData() const { return &_class_data_; }


void Event::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Event*>(&to_msg);
  auto& from = static_cast<const Event&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.Event)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_reason(from._internal_reason());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_message(from._internal_message());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_type(from._internal_type());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_action(from._internal_action());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_reportingcomponent(from._internal_reportingcomponent());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_set_reportinginstance(from._internal_reportinginstance());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_metadata()->::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta::MergeFrom(
          from._internal_metadata());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_mutable_involvedobject()->::k8s::io::api::core::v1::ObjectReference::MergeFrom(
          from._internal_involvedobject());
    }
  }
  if (cached_has_bits & 0x00007f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_internal_mutable_source()->::k8s::io::api::core::v1::EventSource::MergeFrom(
          from._internal_source());
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_internal_mutable_firsttimestamp()->::k8s::io::apimachinery::pkg::apis::meta::v1::Time::MergeFrom(
          from._internal_firsttimestamp());
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_internal_mutable_lasttimestamp()->::k8s::io::apimachinery::pkg::apis::meta::v1::Time::MergeFrom(
          from._internal_lasttimestamp());
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_internal_mutable_eventtime()->::k8s::io::apimachinery::pkg::apis::meta::v1::MicroTime::MergeFrom(
          from._internal_eventtime());
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_internal_mutable_series()->::k8s::io::api::core::v1::EventSeries::MergeFrom(
          from._internal_series());
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_internal_mutable_related()->::k8s::io::api::core::v1::ObjectReference::MergeFrom(
          from._internal_related());
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.count_ = from._impl_.count_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Event::CopyFrom(const Event& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.Event)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Event::IsInitialized() const {
  return true;
}

void Event::InternalSwap(Event* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.reason_, lhs_arena,
      &other->_impl_.reason_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.message_, lhs_arena,
      &other->_impl_.message_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.type_, lhs_arena,
      &other->_impl_.type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.action_, lhs_arena,
      &other->_impl_.action_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.reportingcomponent_, lhs_arena,
      &other->_impl_.reportingcomponent_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.reportinginstance_, lhs_arena,
      &other->_impl_.reportinginstance_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Event, _impl_.count_)
      + sizeof(Event::_impl_.count_)
      - PROTOBUF_FIELD_OFFSET(Event, _impl_.metadata_)>(
          reinterpret_cast<char*>(&_impl_.metadata_),
          reinterpret_cast<char*>(&other->_impl_.metadata_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Event::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[59]);
}

// ===================================================================

class EventList::_Internal {
 public:
  using HasBits = decltype(std::declval<EventList>()._impl_._has_bits_);
  static const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& metadata(const EventList* msg);
  static void set_has_metadata(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta&
EventList::_Internal::metadata(const EventList* msg) {
  return *msg->_impl_.metadata_;
}
void EventList::clear_metadata() {
  if (_impl_.metadata_ != nullptr) _impl_.metadata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
EventList::EventList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.EventList)
}
EventList::EventList(const EventList& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EventList* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.items_){from._impl_.items_}
    , decltype(_impl_.metadata_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_metadata()) {
    _this->_impl_.metadata_ = new ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta(*from._impl_.metadata_);
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.EventList)
}

inline void EventList::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.items_){arena}
    , decltype(_impl_.metadata_){nullptr}
  };
}

EventList::~EventList() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.EventList)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EventList::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.items_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.metadata_;
}

void EventList::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EventList::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.EventList)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.items_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.metadata_ != nullptr);
    _impl_.metadata_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EventList::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_metadata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .k8s.io.api.core.v1.Event items = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_items(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EventList::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.EventList)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::metadata(this),
        _Internal::metadata(this).GetCachedSize(), target, stream);
  }

  // repeated .k8s.io.api.core.v1.Event items = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_items_size()); i < n; i++) {
    const auto& repfield = this->_internal_items(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.EventList)
  return target;
}

size_t EventList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.EventList)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .k8s.io.api.core.v1.Event items = 2;
  total_size += 1UL * this->_internal_items_size();
  for (const auto& msg : this->_impl_.items_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.metadata_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EventList::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EventList::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EventList::GetClassData() const { return &_class_data_; }


void EventList::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EventList*>(&to_msg);
  auto& from = static_cast<const EventList&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.EventList)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.items_.MergeFrom(from._impl_.items_);
  if (from._internal_has_metadata()) {
    _this->_internal_mutable_metadata()->::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta::MergeFrom(
        from._internal_metadata());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EventList::CopyFrom(const EventList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.EventList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EventList::IsInitialized() const {
  return true;
}

void EventList::InternalSwap(EventList* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.items_.InternalSwap(&other->_impl_.items_);
  swap(_impl_.metadata_, other->_impl_.metadata_);
}

::PROTOBUF_NAMESPACE_ID::Metadata EventList::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[60]);
}

// ===================================================================

class EventSeries::_Internal {
 public:
  using HasBits = decltype(std::declval<EventSeries>()._impl_._has_bits_);
  static void set_has_count(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::k8s::io::apimachinery::pkg::apis::meta::v1::MicroTime& lastobservedtime(const EventSeries* msg);
  static void set_has_lastobservedtime(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::k8s::io::apimachinery::pkg::apis::meta::v1::MicroTime&
EventSeries::_Internal::lastobservedtime(const EventSeries* msg) {
  return *msg->_impl_.lastobservedtime_;
}
void EventSeries::clear_lastobservedtime() {
  if (_impl_.lastobservedtime_ != nullptr) _impl_.lastobservedtime_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
EventSeries::EventSeries(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.EventSeries)
}
EventSeries::EventSeries(const EventSeries& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EventSeries* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.lastobservedtime_){nullptr}
    , decltype(_impl_.count_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_lastobservedtime()) {
    _this->_impl_.lastobservedtime_ = new ::k8s::io::apimachinery::pkg::apis::meta::v1::MicroTime(*from._impl_.lastobservedtime_);
  }
  _this->_impl_.count_ = from._impl_.count_;
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.EventSeries)
}

inline void EventSeries::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.lastobservedtime_){nullptr}
    , decltype(_impl_.count_){0}
  };
}

EventSeries::~EventSeries() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.EventSeries)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EventSeries::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.lastobservedtime_;
}

void EventSeries::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EventSeries::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.EventSeries)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.lastobservedtime_ != nullptr);
    _impl_.lastobservedtime_->Clear();
  }
  _impl_.count_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EventSeries::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 count = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_count(&has_bits);
          _impl_.count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime lastObservedTime = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_lastobservedtime(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EventSeries::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.EventSeries)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 count = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_count(), target);
  }

  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime lastObservedTime = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::lastobservedtime(this),
        _Internal::lastobservedtime(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.EventSeries)
  return target;
}

size_t EventSeries::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.EventSeries)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime lastObservedTime = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.lastobservedtime_);
    }

    // optional int32 count = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_count());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EventSeries::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EventSeries::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EventSeries::GetClassData() const { return &_class_data_; }


void EventSeries::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EventSeries*>(&to_msg);
  auto& from = static_cast<const EventSeries&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.EventSeries)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_lastobservedtime()->::k8s::io::apimachinery::pkg::apis::meta::v1::MicroTime::MergeFrom(
          from._internal_lastobservedtime());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.count_ = from._impl_.count_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EventSeries::CopyFrom(const EventSeries& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.EventSeries)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EventSeries::IsInitialized() const {
  return true;
}

void EventSeries::InternalSwap(EventSeries* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EventSeries, _impl_.count_)
      + sizeof(EventSeries::_impl_.count_)
      - PROTOBUF_FIELD_OFFSET(EventSeries, _impl_.lastobservedtime_)>(
          reinterpret_cast<char*>(&_impl_.lastobservedtime_),
          reinterpret_cast<char*>(&other->_impl_.lastobservedtime_));
}

::PROTOBUF_NAMESPACE_ID::Metadata EventSeries::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[61]);
}

// ===================================================================

class EventSource::_Internal {
 public:
  using HasBits = decltype(std::declval<EventSource>()._impl_._has_bits_);
  static void set_has_component(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_host(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

EventSource::EventSource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.EventSource)
}
EventSource::EventSource(const EventSource& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EventSource* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.component_){}
    , decltype(_impl_.host_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.component_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.component_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_component()) {
    _this->_impl_.component_.Set(from._internal_component(), 
      _this->GetArenaForAllocation());
  }
  _impl_.host_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.host_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_host()) {
    _this->_impl_.host_.Set(from._internal_host(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.EventSource)
}

inline void EventSource::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.component_){}
    , decltype(_impl_.host_){}
  };
  _impl_.component_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.component_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.host_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.host_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

EventSource::~EventSource() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.EventSource)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EventSource::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.component_.Destroy();
  _impl_.host_.Destroy();
}

void EventSource::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EventSource::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.EventSource)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.component_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.host_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EventSource::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes component = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_component();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes host = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_host();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EventSource::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.EventSource)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes component = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_component(), target);
  }

  // optional bytes host = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_host(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.EventSource)
  return target;
}

size_t EventSource::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.EventSource)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes component = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_component());
    }

    // optional bytes host = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_host());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EventSource::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EventSource::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EventSource::GetClassData() const { return &_class_data_; }


void EventSource::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EventSource*>(&to_msg);
  auto& from = static_cast<const EventSource&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.EventSource)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_component(from._internal_component());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_host(from._internal_host());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EventSource::CopyFrom(const EventSource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.EventSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EventSource::IsInitialized() const {
  return true;
}

void EventSource::InternalSwap(EventSource* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.component_, lhs_arena,
      &other->_impl_.component_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.host_, lhs_arena,
      &other->_impl_.host_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata EventSource::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[62]);
}

// ===================================================================

class ExecAction::_Internal {
 public:
};

ExecAction::ExecAction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.ExecAction)
}
ExecAction::ExecAction(const ExecAction& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ExecAction* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.command_){from._impl_.command_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.ExecAction)
}

inline void ExecAction::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.command_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ExecAction::~ExecAction() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.ExecAction)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ExecAction::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.command_.~RepeatedPtrField();
}

void ExecAction::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ExecAction::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.ExecAction)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.command_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ExecAction::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string command = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_command();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "k8s.io.api.core.v1.ExecAction.command");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ExecAction::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.ExecAction)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string command = 1;
  for (int i = 0, n = this->_internal_command_size(); i < n; i++) {
    const auto& s = this->_internal_command(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "k8s.io.api.core.v1.ExecAction.command");
    target = stream->WriteString(1, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.ExecAction)
  return target;
}

size_t ExecAction::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.ExecAction)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string command = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.command_.size());
  for (int i = 0, n = _impl_.command_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.command_.Get(i));
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ExecAction::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ExecAction::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ExecAction::GetClassData() const { return &_class_data_; }


void ExecAction::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ExecAction*>(&to_msg);
  auto& from = static_cast<const ExecAction&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.ExecAction)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.command_.MergeFrom(from._impl_.command_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ExecAction::CopyFrom(const ExecAction& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.ExecAction)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExecAction::IsInitialized() const {
  return true;
}

void ExecAction::InternalSwap(ExecAction* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.command_.InternalSwap(&other->_impl_.command_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ExecAction::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[63]);
}

// ===================================================================

class FCVolumeSource::_Internal {
 public:
  using HasBits = decltype(std::declval<FCVolumeSource>()._impl_._has_bits_);
  static void set_has_lun(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_fstype(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_readonly(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

FCVolumeSource::FCVolumeSource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.FCVolumeSource)
}
FCVolumeSource::FCVolumeSource(const FCVolumeSource& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FCVolumeSource* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.targetwwns_){from._impl_.targetwwns_}
    , decltype(_impl_.wwids_){from._impl_.wwids_}
    , decltype(_impl_.fstype_){}
    , decltype(_impl_.lun_){}
    , decltype(_impl_.readonly_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.fstype_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fstype_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_fstype()) {
    _this->_impl_.fstype_.Set(from._internal_fstype(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.lun_, &from._impl_.lun_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.readonly_) -
    reinterpret_cast<char*>(&_impl_.lun_)) + sizeof(_impl_.readonly_));
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.FCVolumeSource)
}

inline void FCVolumeSource::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.targetwwns_){arena}
    , decltype(_impl_.wwids_){arena}
    , decltype(_impl_.fstype_){}
    , decltype(_impl_.lun_){0}
    , decltype(_impl_.readonly_){false}
  };
  _impl_.fstype_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fstype_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

FCVolumeSource::~FCVolumeSource() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.FCVolumeSource)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FCVolumeSource::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.targetwwns_.~RepeatedPtrField();
  _impl_.wwids_.~RepeatedPtrField();
  _impl_.fstype_.Destroy();
}

void FCVolumeSource::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FCVolumeSource::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.FCVolumeSource)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.targetwwns_.Clear();
  _impl_.wwids_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.fstype_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.lun_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.readonly_) -
        reinterpret_cast<char*>(&_impl_.lun_)) + sizeof(_impl_.readonly_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FCVolumeSource::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string targetWWNs = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_targetwwns();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "k8s.io.api.core.v1.FCVolumeSource.targetWWNs");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional int32 lun = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_lun(&has_bits);
          _impl_.lun_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes fsType = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_fstype();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool readOnly = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_readonly(&has_bits);
          _impl_.readonly_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string wwids = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_wwids();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "k8s.io.api.core.v1.FCVolumeSource.wwids");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FCVolumeSource::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.FCVolumeSource)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string targetWWNs = 1;
  for (int i = 0, n = this->_internal_targetwwns_size(); i < n; i++) {
    const auto& s = this->_internal_targetwwns(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "k8s.io.api.core.v1.FCVolumeSource.targetWWNs");
    target = stream->WriteString(1, s, target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 lun = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_lun(), target);
  }

  // optional bytes fsType = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_fstype(), target);
  }

  // optional bool readOnly = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_readonly(), target);
  }

  // repeated string wwids = 5;
  for (int i = 0, n = this->_internal_wwids_size(); i < n; i++) {
    const auto& s = this->_internal_wwids(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "k8s.io.api.core.v1.FCVolumeSource.wwids");
    target = stream->WriteString(5, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.FCVolumeSource)
  return target;
}

size_t FCVolumeSource::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.FCVolumeSource)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string targetWWNs = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.targetwwns_.size());
  for (int i = 0, n = _impl_.targetwwns_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.targetwwns_.Get(i));
  }

  // repeated string wwids = 5;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.wwids_.size());
  for (int i = 0, n = _impl_.wwids_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.wwids_.Get(i));
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bytes fsType = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_fstype());
    }

    // optional int32 lun = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_lun());
    }

    // optional bool readOnly = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FCVolumeSource::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FCVolumeSource::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FCVolumeSource::GetClassData() const { return &_class_data_; }


void FCVolumeSource::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FCVolumeSource*>(&to_msg);
  auto& from = static_cast<const FCVolumeSource&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.FCVolumeSource)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.targetwwns_.MergeFrom(from._impl_.targetwwns_);
  _this->_impl_.wwids_.MergeFrom(from._impl_.wwids_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_fstype(from._internal_fstype());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.lun_ = from._impl_.lun_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.readonly_ = from._impl_.readonly_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FCVolumeSource::CopyFrom(const FCVolumeSource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.FCVolumeSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FCVolumeSource::IsInitialized() const {
  return true;
}

void FCVolumeSource::InternalSwap(FCVolumeSource* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.targetwwns_.InternalSwap(&other->_impl_.targetwwns_);
  _impl_.wwids_.InternalSwap(&other->_impl_.wwids_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.fstype_, lhs_arena,
      &other->_impl_.fstype_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FCVolumeSource, _impl_.readonly_)
      + sizeof(FCVolumeSource::_impl_.readonly_)
      - PROTOBUF_FIELD_OFFSET(FCVolumeSource, _impl_.lun_)>(
          reinterpret_cast<char*>(&_impl_.lun_),
          reinterpret_cast<char*>(&other->_impl_.lun_));
}

::PROTOBUF_NAMESPACE_ID::Metadata FCVolumeSource::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[64]);
}

// ===================================================================

FlexPersistentVolumeSource_OptionsEntry_DoNotUse::FlexPersistentVolumeSource_OptionsEntry_DoNotUse() {}
FlexPersistentVolumeSource_OptionsEntry_DoNotUse::FlexPersistentVolumeSource_OptionsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void FlexPersistentVolumeSource_OptionsEntry_DoNotUse::MergeFrom(const FlexPersistentVolumeSource_OptionsEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata FlexPersistentVolumeSource_OptionsEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[65]);
}

// ===================================================================

class FlexPersistentVolumeSource::_Internal {
 public:
  using HasBits = decltype(std::declval<FlexPersistentVolumeSource>()._impl_._has_bits_);
  static void set_has_driver(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_fstype(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::k8s::io::api::core::v1::SecretReference& secretref(const FlexPersistentVolumeSource* msg);
  static void set_has_secretref(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_readonly(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::k8s::io::api::core::v1::SecretReference&
FlexPersistentVolumeSource::_Internal::secretref(const FlexPersistentVolumeSource* msg) {
  return *msg->_impl_.secretref_;
}
FlexPersistentVolumeSource::FlexPersistentVolumeSource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &FlexPersistentVolumeSource::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.FlexPersistentVolumeSource)
}
FlexPersistentVolumeSource::FlexPersistentVolumeSource(const FlexPersistentVolumeSource& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FlexPersistentVolumeSource* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_.options_)*/{}
    , decltype(_impl_.driver_){}
    , decltype(_impl_.fstype_){}
    , decltype(_impl_.secretref_){nullptr}
    , decltype(_impl_.readonly_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.options_.MergeFrom(from._impl_.options_);
  _impl_.driver_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.driver_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_driver()) {
    _this->_impl_.driver_.Set(from._internal_driver(), 
      _this->GetArenaForAllocation());
  }
  _impl_.fstype_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fstype_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_fstype()) {
    _this->_impl_.fstype_.Set(from._internal_fstype(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_secretref()) {
    _this->_impl_.secretref_ = new ::k8s::io::api::core::v1::SecretReference(*from._impl_.secretref_);
  }
  _this->_impl_.readonly_ = from._impl_.readonly_;
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.FlexPersistentVolumeSource)
}

inline void FlexPersistentVolumeSource::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_.options_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.driver_){}
    , decltype(_impl_.fstype_){}
    , decltype(_impl_.secretref_){nullptr}
    , decltype(_impl_.readonly_){false}
  };
  _impl_.driver_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.driver_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.fstype_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fstype_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

FlexPersistentVolumeSource::~FlexPersistentVolumeSource() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.FlexPersistentVolumeSource)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void FlexPersistentVolumeSource::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.options_.Destruct();
  _impl_.options_.~MapField();
  _impl_.driver_.Destroy();
  _impl_.fstype_.Destroy();
  if (this != internal_default_instance()) delete _impl_.secretref_;
}

void FlexPersistentVolumeSource::ArenaDtor(void* object) {
  FlexPersistentVolumeSource* _this = reinterpret_cast< FlexPersistentVolumeSource* >(object);
  _this->_impl_.options_.Destruct();
}
void FlexPersistentVolumeSource::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FlexPersistentVolumeSource::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.FlexPersistentVolumeSource)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.options_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.driver_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.fstype_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.secretref_ != nullptr);
      _impl_.secretref_->Clear();
    }
  }
  _impl_.readonly_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FlexPersistentVolumeSource::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes driver = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_driver();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes fsType = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_fstype();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.SecretReference secretRef = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_secretref(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool readOnly = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_readonly(&has_bits);
          _impl_.readonly_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // map<string, string> options = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.options_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FlexPersistentVolumeSource::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.FlexPersistentVolumeSource)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes driver = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_driver(), target);
  }

  // optional bytes fsType = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_fstype(), target);
  }

  // optional .k8s.io.api.core.v1.SecretReference secretRef = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::secretref(this),
        _Internal::secretref(this).GetCachedSize(), target, stream);
  }

  // optional bool readOnly = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_readonly(), target);
  }

  // map<string, string> options = 5;
  if (!this->_internal_options().empty()) {
    using MapType = ::_pb::Map<std::string, std::string>;
    using WireHelper = FlexPersistentVolumeSource_OptionsEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_options();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "k8s.io.api.core.v1.FlexPersistentVolumeSource.OptionsEntry.key");
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        entry.second.data(), static_cast<int>(entry.second.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "k8s.io.api.core.v1.FlexPersistentVolumeSource.OptionsEntry.value");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(5, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(5, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.FlexPersistentVolumeSource)
  return target;
}

size_t FlexPersistentVolumeSource::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.FlexPersistentVolumeSource)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, string> options = 5;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_options_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
      it = this->_internal_options().begin();
      it != this->_internal_options().end(); ++it) {
    total_size += FlexPersistentVolumeSource_OptionsEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional bytes driver = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_driver());
    }

    // optional bytes fsType = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_fstype());
    }

    // optional .k8s.io.api.core.v1.SecretReference secretRef = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.secretref_);
    }

    // optional bool readOnly = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FlexPersistentVolumeSource::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FlexPersistentVolumeSource::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FlexPersistentVolumeSource::GetClassData() const { return &_class_data_; }


void FlexPersistentVolumeSource::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FlexPersistentVolumeSource*>(&to_msg);
  auto& from = static_cast<const FlexPersistentVolumeSource&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.FlexPersistentVolumeSource)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.options_.MergeFrom(from._impl_.options_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_driver(from._internal_driver());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_fstype(from._internal_fstype());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_secretref()->::k8s::io::api::core::v1::SecretReference::MergeFrom(
          from._internal_secretref());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.readonly_ = from._impl_.readonly_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FlexPersistentVolumeSource::CopyFrom(const FlexPersistentVolumeSource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.FlexPersistentVolumeSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FlexPersistentVolumeSource::IsInitialized() const {
  return true;
}

void FlexPersistentVolumeSource::InternalSwap(FlexPersistentVolumeSource* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.options_.InternalSwap(&other->_impl_.options_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.driver_, lhs_arena,
      &other->_impl_.driver_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.fstype_, lhs_arena,
      &other->_impl_.fstype_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FlexPersistentVolumeSource, _impl_.readonly_)
      + sizeof(FlexPersistentVolumeSource::_impl_.readonly_)
      - PROTOBUF_FIELD_OFFSET(FlexPersistentVolumeSource, _impl_.secretref_)>(
          reinterpret_cast<char*>(&_impl_.secretref_),
          reinterpret_cast<char*>(&other->_impl_.secretref_));
}

::PROTOBUF_NAMESPACE_ID::Metadata FlexPersistentVolumeSource::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[66]);
}

// ===================================================================

FlexVolumeSource_OptionsEntry_DoNotUse::FlexVolumeSource_OptionsEntry_DoNotUse() {}
FlexVolumeSource_OptionsEntry_DoNotUse::FlexVolumeSource_OptionsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void FlexVolumeSource_OptionsEntry_DoNotUse::MergeFrom(const FlexVolumeSource_OptionsEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata FlexVolumeSource_OptionsEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[67]);
}

// ===================================================================

class FlexVolumeSource::_Internal {
 public:
  using HasBits = decltype(std::declval<FlexVolumeSource>()._impl_._has_bits_);
  static void set_has_driver(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_fstype(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::k8s::io::api::core::v1::LocalObjectReference& secretref(const FlexVolumeSource* msg);
  static void set_has_secretref(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_readonly(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::k8s::io::api::core::v1::LocalObjectReference&
FlexVolumeSource::_Internal::secretref(const FlexVolumeSource* msg) {
  return *msg->_impl_.secretref_;
}
FlexVolumeSource::FlexVolumeSource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &FlexVolumeSource::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.FlexVolumeSource)
}
FlexVolumeSource::FlexVolumeSource(const FlexVolumeSource& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FlexVolumeSource* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_.options_)*/{}
    , decltype(_impl_.driver_){}
    , decltype(_impl_.fstype_){}
    , decltype(_impl_.secretref_){nullptr}
    , decltype(_impl_.readonly_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.options_.MergeFrom(from._impl_.options_);
  _impl_.driver_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.driver_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_driver()) {
    _this->_impl_.driver_.Set(from._internal_driver(), 
      _this->GetArenaForAllocation());
  }
  _impl_.fstype_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fstype_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_fstype()) {
    _this->_impl_.fstype_.Set(from._internal_fstype(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_secretref()) {
    _this->_impl_.secretref_ = new ::k8s::io::api::core::v1::LocalObjectReference(*from._impl_.secretref_);
  }
  _this->_impl_.readonly_ = from._impl_.readonly_;
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.FlexVolumeSource)
}

inline void FlexVolumeSource::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_.options_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.driver_){}
    , decltype(_impl_.fstype_){}
    , decltype(_impl_.secretref_){nullptr}
    , decltype(_impl_.readonly_){false}
  };
  _impl_.driver_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.driver_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.fstype_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fstype_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

FlexVolumeSource::~FlexVolumeSource() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.FlexVolumeSource)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void FlexVolumeSource::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.options_.Destruct();
  _impl_.options_.~MapField();
  _impl_.driver_.Destroy();
  _impl_.fstype_.Destroy();
  if (this != internal_default_instance()) delete _impl_.secretref_;
}

void FlexVolumeSource::ArenaDtor(void* object) {
  FlexVolumeSource* _this = reinterpret_cast< FlexVolumeSource* >(object);
  _this->_impl_.options_.Destruct();
}
void FlexVolumeSource::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FlexVolumeSource::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.FlexVolumeSource)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.options_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.driver_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.fstype_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.secretref_ != nullptr);
      _impl_.secretref_->Clear();
    }
  }
  _impl_.readonly_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FlexVolumeSource::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes driver = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_driver();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes fsType = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_fstype();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.LocalObjectReference secretRef = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_secretref(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool readOnly = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_readonly(&has_bits);
          _impl_.readonly_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // map<string, string> options = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.options_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FlexVolumeSource::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.FlexVolumeSource)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes driver = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_driver(), target);
  }

  // optional bytes fsType = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_fstype(), target);
  }

  // optional .k8s.io.api.core.v1.LocalObjectReference secretRef = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::secretref(this),
        _Internal::secretref(this).GetCachedSize(), target, stream);
  }

  // optional bool readOnly = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_readonly(), target);
  }

  // map<string, string> options = 5;
  if (!this->_internal_options().empty()) {
    using MapType = ::_pb::Map<std::string, std::string>;
    using WireHelper = FlexVolumeSource_OptionsEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_options();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "k8s.io.api.core.v1.FlexVolumeSource.OptionsEntry.key");
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        entry.second.data(), static_cast<int>(entry.second.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "k8s.io.api.core.v1.FlexVolumeSource.OptionsEntry.value");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(5, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(5, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.FlexVolumeSource)
  return target;
}

size_t FlexVolumeSource::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.FlexVolumeSource)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, string> options = 5;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_options_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
      it = this->_internal_options().begin();
      it != this->_internal_options().end(); ++it) {
    total_size += FlexVolumeSource_OptionsEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional bytes driver = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_driver());
    }

    // optional bytes fsType = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_fstype());
    }

    // optional .k8s.io.api.core.v1.LocalObjectReference secretRef = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.secretref_);
    }

    // optional bool readOnly = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FlexVolumeSource::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FlexVolumeSource::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FlexVolumeSource::GetClassData() const { return &_class_data_; }


void FlexVolumeSource::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FlexVolumeSource*>(&to_msg);
  auto& from = static_cast<const FlexVolumeSource&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.FlexVolumeSource)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.options_.MergeFrom(from._impl_.options_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_driver(from._internal_driver());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_fstype(from._internal_fstype());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_secretref()->::k8s::io::api::core::v1::LocalObjectReference::MergeFrom(
          from._internal_secretref());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.readonly_ = from._impl_.readonly_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FlexVolumeSource::CopyFrom(const FlexVolumeSource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.FlexVolumeSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FlexVolumeSource::IsInitialized() const {
  return true;
}

void FlexVolumeSource::InternalSwap(FlexVolumeSource* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.options_.InternalSwap(&other->_impl_.options_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.driver_, lhs_arena,
      &other->_impl_.driver_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.fstype_, lhs_arena,
      &other->_impl_.fstype_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FlexVolumeSource, _impl_.readonly_)
      + sizeof(FlexVolumeSource::_impl_.readonly_)
      - PROTOBUF_FIELD_OFFSET(FlexVolumeSource, _impl_.secretref_)>(
          reinterpret_cast<char*>(&_impl_.secretref_),
          reinterpret_cast<char*>(&other->_impl_.secretref_));
}

::PROTOBUF_NAMESPACE_ID::Metadata FlexVolumeSource::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[68]);
}

// ===================================================================

class FlockerVolumeSource::_Internal {
 public:
  using HasBits = decltype(std::declval<FlockerVolumeSource>()._impl_._has_bits_);
  static void set_has_datasetname(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_datasetuuid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

FlockerVolumeSource::FlockerVolumeSource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.FlockerVolumeSource)
}
FlockerVolumeSource::FlockerVolumeSource(const FlockerVolumeSource& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FlockerVolumeSource* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.datasetname_){}
    , decltype(_impl_.datasetuuid_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.datasetname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.datasetname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_datasetname()) {
    _this->_impl_.datasetname_.Set(from._internal_datasetname(), 
      _this->GetArenaForAllocation());
  }
  _impl_.datasetuuid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.datasetuuid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_datasetuuid()) {
    _this->_impl_.datasetuuid_.Set(from._internal_datasetuuid(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.FlockerVolumeSource)
}

inline void FlockerVolumeSource::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.datasetname_){}
    , decltype(_impl_.datasetuuid_){}
  };
  _impl_.datasetname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.datasetname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.datasetuuid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.datasetuuid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

FlockerVolumeSource::~FlockerVolumeSource() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.FlockerVolumeSource)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FlockerVolumeSource::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.datasetname_.Destroy();
  _impl_.datasetuuid_.Destroy();
}

void FlockerVolumeSource::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FlockerVolumeSource::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.FlockerVolumeSource)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.datasetname_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.datasetuuid_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FlockerVolumeSource::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes datasetName = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_datasetname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes datasetUUID = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_datasetuuid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FlockerVolumeSource::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.FlockerVolumeSource)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes datasetName = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_datasetname(), target);
  }

  // optional bytes datasetUUID = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_datasetuuid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.FlockerVolumeSource)
  return target;
}

size_t FlockerVolumeSource::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.FlockerVolumeSource)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes datasetName = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_datasetname());
    }

    // optional bytes datasetUUID = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_datasetuuid());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FlockerVolumeSource::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FlockerVolumeSource::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FlockerVolumeSource::GetClassData() const { return &_class_data_; }


void FlockerVolumeSource::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FlockerVolumeSource*>(&to_msg);
  auto& from = static_cast<const FlockerVolumeSource&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.FlockerVolumeSource)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_datasetname(from._internal_datasetname());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_datasetuuid(from._internal_datasetuuid());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FlockerVolumeSource::CopyFrom(const FlockerVolumeSource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.FlockerVolumeSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FlockerVolumeSource::IsInitialized() const {
  return true;
}

void FlockerVolumeSource::InternalSwap(FlockerVolumeSource* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.datasetname_, lhs_arena,
      &other->_impl_.datasetname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.datasetuuid_, lhs_arena,
      &other->_impl_.datasetuuid_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata FlockerVolumeSource::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[69]);
}

// ===================================================================

class GCEPersistentDiskVolumeSource::_Internal {
 public:
  using HasBits = decltype(std::declval<GCEPersistentDiskVolumeSource>()._impl_._has_bits_);
  static void set_has_pdname(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_fstype(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_partition(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_readonly(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

GCEPersistentDiskVolumeSource::GCEPersistentDiskVolumeSource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.GCEPersistentDiskVolumeSource)
}
GCEPersistentDiskVolumeSource::GCEPersistentDiskVolumeSource(const GCEPersistentDiskVolumeSource& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GCEPersistentDiskVolumeSource* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pdname_){}
    , decltype(_impl_.fstype_){}
    , decltype(_impl_.partition_){}
    , decltype(_impl_.readonly_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.pdname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pdname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_pdname()) {
    _this->_impl_.pdname_.Set(from._internal_pdname(), 
      _this->GetArenaForAllocation());
  }
  _impl_.fstype_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fstype_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_fstype()) {
    _this->_impl_.fstype_.Set(from._internal_fstype(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.partition_, &from._impl_.partition_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.readonly_) -
    reinterpret_cast<char*>(&_impl_.partition_)) + sizeof(_impl_.readonly_));
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.GCEPersistentDiskVolumeSource)
}

inline void GCEPersistentDiskVolumeSource::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pdname_){}
    , decltype(_impl_.fstype_){}
    , decltype(_impl_.partition_){0}
    , decltype(_impl_.readonly_){false}
  };
  _impl_.pdname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pdname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.fstype_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fstype_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GCEPersistentDiskVolumeSource::~GCEPersistentDiskVolumeSource() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.GCEPersistentDiskVolumeSource)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GCEPersistentDiskVolumeSource::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.pdname_.Destroy();
  _impl_.fstype_.Destroy();
}

void GCEPersistentDiskVolumeSource::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GCEPersistentDiskVolumeSource::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.GCEPersistentDiskVolumeSource)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.pdname_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.fstype_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&_impl_.partition_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.readonly_) -
        reinterpret_cast<char*>(&_impl_.partition_)) + sizeof(_impl_.readonly_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GCEPersistentDiskVolumeSource::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes pdName = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_pdname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes fsType = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_fstype();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 partition = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_partition(&has_bits);
          _impl_.partition_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool readOnly = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_readonly(&has_bits);
          _impl_.readonly_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GCEPersistentDiskVolumeSource::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.GCEPersistentDiskVolumeSource)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes pdName = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_pdname(), target);
  }

  // optional bytes fsType = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_fstype(), target);
  }

  // optional int32 partition = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_partition(), target);
  }

  // optional bool readOnly = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_readonly(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.GCEPersistentDiskVolumeSource)
  return target;
}

size_t GCEPersistentDiskVolumeSource::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.GCEPersistentDiskVolumeSource)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional bytes pdName = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_pdname());
    }

    // optional bytes fsType = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_fstype());
    }

    // optional int32 partition = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_partition());
    }

    // optional bool readOnly = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GCEPersistentDiskVolumeSource::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GCEPersistentDiskVolumeSource::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GCEPersistentDiskVolumeSource::GetClassData() const { return &_class_data_; }


void GCEPersistentDiskVolumeSource::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GCEPersistentDiskVolumeSource*>(&to_msg);
  auto& from = static_cast<const GCEPersistentDiskVolumeSource&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.GCEPersistentDiskVolumeSource)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_pdname(from._internal_pdname());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_fstype(from._internal_fstype());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.partition_ = from._impl_.partition_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.readonly_ = from._impl_.readonly_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GCEPersistentDiskVolumeSource::CopyFrom(const GCEPersistentDiskVolumeSource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.GCEPersistentDiskVolumeSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GCEPersistentDiskVolumeSource::IsInitialized() const {
  return true;
}

void GCEPersistentDiskVolumeSource::InternalSwap(GCEPersistentDiskVolumeSource* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.pdname_, lhs_arena,
      &other->_impl_.pdname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.fstype_, lhs_arena,
      &other->_impl_.fstype_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GCEPersistentDiskVolumeSource, _impl_.readonly_)
      + sizeof(GCEPersistentDiskVolumeSource::_impl_.readonly_)
      - PROTOBUF_FIELD_OFFSET(GCEPersistentDiskVolumeSource, _impl_.partition_)>(
          reinterpret_cast<char*>(&_impl_.partition_),
          reinterpret_cast<char*>(&other->_impl_.partition_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GCEPersistentDiskVolumeSource::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[70]);
}

// ===================================================================

class GRPCAction::_Internal {
 public:
  using HasBits = decltype(std::declval<GRPCAction>()._impl_._has_bits_);
  static void set_has_port(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_service(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

GRPCAction::GRPCAction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.GRPCAction)
}
GRPCAction::GRPCAction(const GRPCAction& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GRPCAction* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.service_){}
    , decltype(_impl_.port_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.service_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.service_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_service()) {
    _this->_impl_.service_.Set(from._internal_service(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.port_ = from._impl_.port_;
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.GRPCAction)
}

inline void GRPCAction::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.service_){}
    , decltype(_impl_.port_){0}
  };
  _impl_.service_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.service_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GRPCAction::~GRPCAction() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.GRPCAction)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GRPCAction::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.service_.Destroy();
}

void GRPCAction::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GRPCAction::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.GRPCAction)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.service_.ClearNonDefaultToEmpty();
  }
  _impl_.port_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GRPCAction::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 port = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_port(&has_bits);
          _impl_.port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes service = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_service();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GRPCAction::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.GRPCAction)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 port = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_port(), target);
  }

  // optional bytes service = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_service(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.GRPCAction)
  return target;
}

size_t GRPCAction::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.GRPCAction)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes service = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_service());
    }

    // optional int32 port = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_port());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GRPCAction::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GRPCAction::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GRPCAction::GetClassData() const { return &_class_data_; }


void GRPCAction::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GRPCAction*>(&to_msg);
  auto& from = static_cast<const GRPCAction&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.GRPCAction)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_service(from._internal_service());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.port_ = from._impl_.port_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GRPCAction::CopyFrom(const GRPCAction& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.GRPCAction)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GRPCAction::IsInitialized() const {
  return true;
}

void GRPCAction::InternalSwap(GRPCAction* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.service_, lhs_arena,
      &other->_impl_.service_, rhs_arena
  );
  swap(_impl_.port_, other->_impl_.port_);
}

::PROTOBUF_NAMESPACE_ID::Metadata GRPCAction::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[71]);
}

// ===================================================================

class GitRepoVolumeSource::_Internal {
 public:
  using HasBits = decltype(std::declval<GitRepoVolumeSource>()._impl_._has_bits_);
  static void set_has_repository(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_revision(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_directory(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

GitRepoVolumeSource::GitRepoVolumeSource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.GitRepoVolumeSource)
}
GitRepoVolumeSource::GitRepoVolumeSource(const GitRepoVolumeSource& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GitRepoVolumeSource* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.repository_){}
    , decltype(_impl_.revision_){}
    , decltype(_impl_.directory_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.repository_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.repository_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_repository()) {
    _this->_impl_.repository_.Set(from._internal_repository(), 
      _this->GetArenaForAllocation());
  }
  _impl_.revision_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.revision_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_revision()) {
    _this->_impl_.revision_.Set(from._internal_revision(), 
      _this->GetArenaForAllocation());
  }
  _impl_.directory_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.directory_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_directory()) {
    _this->_impl_.directory_.Set(from._internal_directory(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.GitRepoVolumeSource)
}

inline void GitRepoVolumeSource::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.repository_){}
    , decltype(_impl_.revision_){}
    , decltype(_impl_.directory_){}
  };
  _impl_.repository_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.repository_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.revision_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.revision_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.directory_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.directory_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GitRepoVolumeSource::~GitRepoVolumeSource() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.GitRepoVolumeSource)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GitRepoVolumeSource::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.repository_.Destroy();
  _impl_.revision_.Destroy();
  _impl_.directory_.Destroy();
}

void GitRepoVolumeSource::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GitRepoVolumeSource::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.GitRepoVolumeSource)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.repository_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.revision_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.directory_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GitRepoVolumeSource::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes repository = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_repository();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes revision = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_revision();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes directory = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_directory();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GitRepoVolumeSource::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.GitRepoVolumeSource)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes repository = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_repository(), target);
  }

  // optional bytes revision = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_revision(), target);
  }

  // optional bytes directory = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_directory(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.GitRepoVolumeSource)
  return target;
}

size_t GitRepoVolumeSource::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.GitRepoVolumeSource)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bytes repository = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_repository());
    }

    // optional bytes revision = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_revision());
    }

    // optional bytes directory = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_directory());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GitRepoVolumeSource::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GitRepoVolumeSource::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GitRepoVolumeSource::GetClassData() const { return &_class_data_; }


void GitRepoVolumeSource::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GitRepoVolumeSource*>(&to_msg);
  auto& from = static_cast<const GitRepoVolumeSource&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.GitRepoVolumeSource)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_repository(from._internal_repository());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_revision(from._internal_revision());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_directory(from._internal_directory());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GitRepoVolumeSource::CopyFrom(const GitRepoVolumeSource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.GitRepoVolumeSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GitRepoVolumeSource::IsInitialized() const {
  return true;
}

void GitRepoVolumeSource::InternalSwap(GitRepoVolumeSource* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.repository_, lhs_arena,
      &other->_impl_.repository_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.revision_, lhs_arena,
      &other->_impl_.revision_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.directory_, lhs_arena,
      &other->_impl_.directory_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata GitRepoVolumeSource::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[72]);
}

// ===================================================================

class GlusterfsPersistentVolumeSource::_Internal {
 public:
  using HasBits = decltype(std::declval<GlusterfsPersistentVolumeSource>()._impl_._has_bits_);
  static void set_has_endpoints(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_path(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_readonly(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_endpointsnamespace(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

GlusterfsPersistentVolumeSource::GlusterfsPersistentVolumeSource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.GlusterfsPersistentVolumeSource)
}
GlusterfsPersistentVolumeSource::GlusterfsPersistentVolumeSource(const GlusterfsPersistentVolumeSource& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GlusterfsPersistentVolumeSource* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.endpoints_){}
    , decltype(_impl_.path_){}
    , decltype(_impl_.endpointsnamespace_){}
    , decltype(_impl_.readonly_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.endpoints_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.endpoints_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_endpoints()) {
    _this->_impl_.endpoints_.Set(from._internal_endpoints(), 
      _this->GetArenaForAllocation());
  }
  _impl_.path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_path()) {
    _this->_impl_.path_.Set(from._internal_path(), 
      _this->GetArenaForAllocation());
  }
  _impl_.endpointsnamespace_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.endpointsnamespace_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_endpointsnamespace()) {
    _this->_impl_.endpointsnamespace_.Set(from._internal_endpointsnamespace(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.readonly_ = from._impl_.readonly_;
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.GlusterfsPersistentVolumeSource)
}

inline void GlusterfsPersistentVolumeSource::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.endpoints_){}
    , decltype(_impl_.path_){}
    , decltype(_impl_.endpointsnamespace_){}
    , decltype(_impl_.readonly_){false}
  };
  _impl_.endpoints_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.endpoints_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.endpointsnamespace_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.endpointsnamespace_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GlusterfsPersistentVolumeSource::~GlusterfsPersistentVolumeSource() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.GlusterfsPersistentVolumeSource)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GlusterfsPersistentVolumeSource::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.endpoints_.Destroy();
  _impl_.path_.Destroy();
  _impl_.endpointsnamespace_.Destroy();
}

void GlusterfsPersistentVolumeSource::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GlusterfsPersistentVolumeSource::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.GlusterfsPersistentVolumeSource)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.endpoints_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.path_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.endpointsnamespace_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.readonly_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GlusterfsPersistentVolumeSource::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes endpoints = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_endpoints();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes path = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_path();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool readOnly = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_readonly(&has_bits);
          _impl_.readonly_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes endpointsNamespace = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_endpointsnamespace();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GlusterfsPersistentVolumeSource::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.GlusterfsPersistentVolumeSource)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes endpoints = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_endpoints(), target);
  }

  // optional bytes path = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_path(), target);
  }

  // optional bool readOnly = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_readonly(), target);
  }

  // optional bytes endpointsNamespace = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_endpointsnamespace(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.GlusterfsPersistentVolumeSource)
  return target;
}

size_t GlusterfsPersistentVolumeSource::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.GlusterfsPersistentVolumeSource)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional bytes endpoints = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_endpoints());
    }

    // optional bytes path = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_path());
    }

    // optional bytes endpointsNamespace = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_endpointsnamespace());
    }

    // optional bool readOnly = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GlusterfsPersistentVolumeSource::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GlusterfsPersistentVolumeSource::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GlusterfsPersistentVolumeSource::GetClassData() const { return &_class_data_; }


void GlusterfsPersistentVolumeSource::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GlusterfsPersistentVolumeSource*>(&to_msg);
  auto& from = static_cast<const GlusterfsPersistentVolumeSource&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.GlusterfsPersistentVolumeSource)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_endpoints(from._internal_endpoints());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_path(from._internal_path());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_endpointsnamespace(from._internal_endpointsnamespace());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.readonly_ = from._impl_.readonly_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GlusterfsPersistentVolumeSource::CopyFrom(const GlusterfsPersistentVolumeSource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.GlusterfsPersistentVolumeSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GlusterfsPersistentVolumeSource::IsInitialized() const {
  return true;
}

void GlusterfsPersistentVolumeSource::InternalSwap(GlusterfsPersistentVolumeSource* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.endpoints_, lhs_arena,
      &other->_impl_.endpoints_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.path_, lhs_arena,
      &other->_impl_.path_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.endpointsnamespace_, lhs_arena,
      &other->_impl_.endpointsnamespace_, rhs_arena
  );
  swap(_impl_.readonly_, other->_impl_.readonly_);
}

::PROTOBUF_NAMESPACE_ID::Metadata GlusterfsPersistentVolumeSource::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[73]);
}

// ===================================================================

class GlusterfsVolumeSource::_Internal {
 public:
  using HasBits = decltype(std::declval<GlusterfsVolumeSource>()._impl_._has_bits_);
  static void set_has_endpoints(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_path(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_readonly(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

GlusterfsVolumeSource::GlusterfsVolumeSource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.GlusterfsVolumeSource)
}
GlusterfsVolumeSource::GlusterfsVolumeSource(const GlusterfsVolumeSource& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GlusterfsVolumeSource* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.endpoints_){}
    , decltype(_impl_.path_){}
    , decltype(_impl_.readonly_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.endpoints_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.endpoints_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_endpoints()) {
    _this->_impl_.endpoints_.Set(from._internal_endpoints(), 
      _this->GetArenaForAllocation());
  }
  _impl_.path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_path()) {
    _this->_impl_.path_.Set(from._internal_path(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.readonly_ = from._impl_.readonly_;
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.GlusterfsVolumeSource)
}

inline void GlusterfsVolumeSource::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.endpoints_){}
    , decltype(_impl_.path_){}
    , decltype(_impl_.readonly_){false}
  };
  _impl_.endpoints_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.endpoints_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GlusterfsVolumeSource::~GlusterfsVolumeSource() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.GlusterfsVolumeSource)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GlusterfsVolumeSource::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.endpoints_.Destroy();
  _impl_.path_.Destroy();
}

void GlusterfsVolumeSource::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GlusterfsVolumeSource::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.GlusterfsVolumeSource)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.endpoints_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.path_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.readonly_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GlusterfsVolumeSource::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes endpoints = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_endpoints();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes path = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_path();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool readOnly = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_readonly(&has_bits);
          _impl_.readonly_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GlusterfsVolumeSource::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.GlusterfsVolumeSource)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes endpoints = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_endpoints(), target);
  }

  // optional bytes path = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_path(), target);
  }

  // optional bool readOnly = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_readonly(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.GlusterfsVolumeSource)
  return target;
}

size_t GlusterfsVolumeSource::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.GlusterfsVolumeSource)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bytes endpoints = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_endpoints());
    }

    // optional bytes path = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_path());
    }

    // optional bool readOnly = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GlusterfsVolumeSource::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GlusterfsVolumeSource::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GlusterfsVolumeSource::GetClassData() const { return &_class_data_; }


void GlusterfsVolumeSource::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GlusterfsVolumeSource*>(&to_msg);
  auto& from = static_cast<const GlusterfsVolumeSource&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.GlusterfsVolumeSource)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_endpoints(from._internal_endpoints());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_path(from._internal_path());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.readonly_ = from._impl_.readonly_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GlusterfsVolumeSource::CopyFrom(const GlusterfsVolumeSource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.GlusterfsVolumeSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GlusterfsVolumeSource::IsInitialized() const {
  return true;
}

void GlusterfsVolumeSource::InternalSwap(GlusterfsVolumeSource* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.endpoints_, lhs_arena,
      &other->_impl_.endpoints_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.path_, lhs_arena,
      &other->_impl_.path_, rhs_arena
  );
  swap(_impl_.readonly_, other->_impl_.readonly_);
}

::PROTOBUF_NAMESPACE_ID::Metadata GlusterfsVolumeSource::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[74]);
}

// ===================================================================

class HTTPGetAction::_Internal {
 public:
  using HasBits = decltype(std::declval<HTTPGetAction>()._impl_._has_bits_);
  static void set_has_path(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::k8s::io::apimachinery::pkg::util::intstr::IntOrString& port(const HTTPGetAction* msg);
  static void set_has_port(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_host(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_scheme(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::k8s::io::apimachinery::pkg::util::intstr::IntOrString&
HTTPGetAction::_Internal::port(const HTTPGetAction* msg) {
  return *msg->_impl_.port_;
}
void HTTPGetAction::clear_port() {
  if (_impl_.port_ != nullptr) _impl_.port_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
HTTPGetAction::HTTPGetAction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.HTTPGetAction)
}
HTTPGetAction::HTTPGetAction(const HTTPGetAction& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  HTTPGetAction* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.httpheaders_){from._impl_.httpheaders_}
    , decltype(_impl_.path_){}
    , decltype(_impl_.host_){}
    , decltype(_impl_.scheme_){}
    , decltype(_impl_.port_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_path()) {
    _this->_impl_.path_.Set(from._internal_path(), 
      _this->GetArenaForAllocation());
  }
  _impl_.host_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.host_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_host()) {
    _this->_impl_.host_.Set(from._internal_host(), 
      _this->GetArenaForAllocation());
  }
  _impl_.scheme_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.scheme_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_scheme()) {
    _this->_impl_.scheme_.Set(from._internal_scheme(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_port()) {
    _this->_impl_.port_ = new ::k8s::io::apimachinery::pkg::util::intstr::IntOrString(*from._impl_.port_);
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.HTTPGetAction)
}

inline void HTTPGetAction::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.httpheaders_){arena}
    , decltype(_impl_.path_){}
    , decltype(_impl_.host_){}
    , decltype(_impl_.scheme_){}
    , decltype(_impl_.port_){nullptr}
  };
  _impl_.path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.host_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.host_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.scheme_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.scheme_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

HTTPGetAction::~HTTPGetAction() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.HTTPGetAction)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void HTTPGetAction::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.httpheaders_.~RepeatedPtrField();
  _impl_.path_.Destroy();
  _impl_.host_.Destroy();
  _impl_.scheme_.Destroy();
  if (this != internal_default_instance()) delete _impl_.port_;
}

void HTTPGetAction::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void HTTPGetAction::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.HTTPGetAction)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.httpheaders_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.path_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.host_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.scheme_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.port_ != nullptr);
      _impl_.port_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* HTTPGetAction::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes path = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_path();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString port = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_port(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes host = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_host();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes scheme = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_scheme();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .k8s.io.api.core.v1.HTTPHeader httpHeaders = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_httpheaders(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* HTTPGetAction::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.HTTPGetAction)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes path = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_path(), target);
  }

  // optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString port = 2;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::port(this),
        _Internal::port(this).GetCachedSize(), target, stream);
  }

  // optional bytes host = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_host(), target);
  }

  // optional bytes scheme = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_scheme(), target);
  }

  // repeated .k8s.io.api.core.v1.HTTPHeader httpHeaders = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_httpheaders_size()); i < n; i++) {
    const auto& repfield = this->_internal_httpheaders(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.HTTPGetAction)
  return target;
}

size_t HTTPGetAction::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.HTTPGetAction)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .k8s.io.api.core.v1.HTTPHeader httpHeaders = 5;
  total_size += 1UL * this->_internal_httpheaders_size();
  for (const auto& msg : this->_impl_.httpheaders_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional bytes path = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_path());
    }

    // optional bytes host = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_host());
    }

    // optional bytes scheme = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_scheme());
    }

    // optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString port = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.port_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData HTTPGetAction::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    HTTPGetAction::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*HTTPGetAction::GetClassData() const { return &_class_data_; }


void HTTPGetAction::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<HTTPGetAction*>(&to_msg);
  auto& from = static_cast<const HTTPGetAction&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.HTTPGetAction)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.httpheaders_.MergeFrom(from._impl_.httpheaders_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_path(from._internal_path());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_host(from._internal_host());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_scheme(from._internal_scheme());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_port()->::k8s::io::apimachinery::pkg::util::intstr::IntOrString::MergeFrom(
          from._internal_port());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void HTTPGetAction::CopyFrom(const HTTPGetAction& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.HTTPGetAction)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HTTPGetAction::IsInitialized() const {
  return true;
}

void HTTPGetAction::InternalSwap(HTTPGetAction* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.httpheaders_.InternalSwap(&other->_impl_.httpheaders_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.path_, lhs_arena,
      &other->_impl_.path_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.host_, lhs_arena,
      &other->_impl_.host_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.scheme_, lhs_arena,
      &other->_impl_.scheme_, rhs_arena
  );
  swap(_impl_.port_, other->_impl_.port_);
}

::PROTOBUF_NAMESPACE_ID::Metadata HTTPGetAction::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[75]);
}

// ===================================================================

class HTTPHeader::_Internal {
 public:
  using HasBits = decltype(std::declval<HTTPHeader>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

HTTPHeader::HTTPHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.HTTPHeader)
}
HTTPHeader::HTTPHeader(const HTTPHeader& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  HTTPHeader* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.value_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_value()) {
    _this->_impl_.value_.Set(from._internal_value(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.HTTPHeader)
}

inline void HTTPHeader::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.value_){}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

HTTPHeader::~HTTPHeader() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.HTTPHeader)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void HTTPHeader::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.value_.Destroy();
}

void HTTPHeader::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void HTTPHeader::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.HTTPHeader)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.value_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* HTTPHeader::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* HTTPHeader::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.HTTPHeader)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional bytes value = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.HTTPHeader)
  return target;
}

size_t HTTPHeader::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.HTTPHeader)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_name());
    }

    // optional bytes value = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_value());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData HTTPHeader::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    HTTPHeader::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*HTTPHeader::GetClassData() const { return &_class_data_; }


void HTTPHeader::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<HTTPHeader*>(&to_msg);
  auto& from = static_cast<const HTTPHeader&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.HTTPHeader)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_value(from._internal_value());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void HTTPHeader::CopyFrom(const HTTPHeader& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.HTTPHeader)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HTTPHeader::IsInitialized() const {
  return true;
}

void HTTPHeader::InternalSwap(HTTPHeader* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.value_, lhs_arena,
      &other->_impl_.value_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata HTTPHeader::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[76]);
}

// ===================================================================

class HostAlias::_Internal {
 public:
  using HasBits = decltype(std::declval<HostAlias>()._impl_._has_bits_);
  static void set_has_ip(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

HostAlias::HostAlias(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.HostAlias)
}
HostAlias::HostAlias(const HostAlias& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  HostAlias* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.hostnames_){from._impl_.hostnames_}
    , decltype(_impl_.ip_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.ip_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ip_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ip()) {
    _this->_impl_.ip_.Set(from._internal_ip(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.HostAlias)
}

inline void HostAlias::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.hostnames_){arena}
    , decltype(_impl_.ip_){}
  };
  _impl_.ip_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ip_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

HostAlias::~HostAlias() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.HostAlias)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void HostAlias::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.hostnames_.~RepeatedPtrField();
  _impl_.ip_.Destroy();
}

void HostAlias::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void HostAlias::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.HostAlias)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.hostnames_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.ip_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* HostAlias::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes ip = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_ip();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string hostnames = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_hostnames();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "k8s.io.api.core.v1.HostAlias.hostnames");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* HostAlias::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.HostAlias)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes ip = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_ip(), target);
  }

  // repeated string hostnames = 2;
  for (int i = 0, n = this->_internal_hostnames_size(); i < n; i++) {
    const auto& s = this->_internal_hostnames(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "k8s.io.api.core.v1.HostAlias.hostnames");
    target = stream->WriteString(2, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.HostAlias)
  return target;
}

size_t HostAlias::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.HostAlias)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string hostnames = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.hostnames_.size());
  for (int i = 0, n = _impl_.hostnames_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.hostnames_.Get(i));
  }

  // optional bytes ip = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_ip());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData HostAlias::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    HostAlias::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*HostAlias::GetClassData() const { return &_class_data_; }


void HostAlias::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<HostAlias*>(&to_msg);
  auto& from = static_cast<const HostAlias&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.HostAlias)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.hostnames_.MergeFrom(from._impl_.hostnames_);
  if (from._internal_has_ip()) {
    _this->_internal_set_ip(from._internal_ip());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void HostAlias::CopyFrom(const HostAlias& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.HostAlias)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HostAlias::IsInitialized() const {
  return true;
}

void HostAlias::InternalSwap(HostAlias* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.hostnames_.InternalSwap(&other->_impl_.hostnames_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.ip_, lhs_arena,
      &other->_impl_.ip_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata HostAlias::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[77]);
}

// ===================================================================

class HostIP::_Internal {
 public:
  using HasBits = decltype(std::declval<HostIP>()._impl_._has_bits_);
  static void set_has_ip(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

HostIP::HostIP(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.HostIP)
}
HostIP::HostIP(const HostIP& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  HostIP* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ip_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.ip_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ip_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ip()) {
    _this->_impl_.ip_.Set(from._internal_ip(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.HostIP)
}

inline void HostIP::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ip_){}
  };
  _impl_.ip_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ip_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

HostIP::~HostIP() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.HostIP)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void HostIP::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.ip_.Destroy();
}

void HostIP::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void HostIP::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.HostIP)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.ip_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* HostIP::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes ip = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_ip();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* HostIP::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.HostIP)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes ip = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_ip(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.HostIP)
  return target;
}

size_t HostIP::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.HostIP)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes ip = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_ip());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData HostIP::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    HostIP::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*HostIP::GetClassData() const { return &_class_data_; }


void HostIP::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<HostIP*>(&to_msg);
  auto& from = static_cast<const HostIP&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.HostIP)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_ip()) {
    _this->_internal_set_ip(from._internal_ip());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void HostIP::CopyFrom(const HostIP& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.HostIP)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HostIP::IsInitialized() const {
  return true;
}

void HostIP::InternalSwap(HostIP* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.ip_, lhs_arena,
      &other->_impl_.ip_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata HostIP::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[78]);
}

// ===================================================================

class HostPathVolumeSource::_Internal {
 public:
  using HasBits = decltype(std::declval<HostPathVolumeSource>()._impl_._has_bits_);
  static void set_has_path(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

HostPathVolumeSource::HostPathVolumeSource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.HostPathVolumeSource)
}
HostPathVolumeSource::HostPathVolumeSource(const HostPathVolumeSource& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  HostPathVolumeSource* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.path_){}
    , decltype(_impl_.type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_path()) {
    _this->_impl_.path_.Set(from._internal_path(), 
      _this->GetArenaForAllocation());
  }
  _impl_.type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_type()) {
    _this->_impl_.type_.Set(from._internal_type(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.HostPathVolumeSource)
}

inline void HostPathVolumeSource::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.path_){}
    , decltype(_impl_.type_){}
  };
  _impl_.path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

HostPathVolumeSource::~HostPathVolumeSource() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.HostPathVolumeSource)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void HostPathVolumeSource::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.path_.Destroy();
  _impl_.type_.Destroy();
}

void HostPathVolumeSource::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void HostPathVolumeSource::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.HostPathVolumeSource)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.path_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.type_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* HostPathVolumeSource::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes path = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_path();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* HostPathVolumeSource::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.HostPathVolumeSource)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes path = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_path(), target);
  }

  // optional bytes type = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.HostPathVolumeSource)
  return target;
}

size_t HostPathVolumeSource::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.HostPathVolumeSource)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes path = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_path());
    }

    // optional bytes type = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData HostPathVolumeSource::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    HostPathVolumeSource::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*HostPathVolumeSource::GetClassData() const { return &_class_data_; }


void HostPathVolumeSource::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<HostPathVolumeSource*>(&to_msg);
  auto& from = static_cast<const HostPathVolumeSource&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.HostPathVolumeSource)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_path(from._internal_path());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_type(from._internal_type());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void HostPathVolumeSource::CopyFrom(const HostPathVolumeSource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.HostPathVolumeSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HostPathVolumeSource::IsInitialized() const {
  return true;
}

void HostPathVolumeSource::InternalSwap(HostPathVolumeSource* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.path_, lhs_arena,
      &other->_impl_.path_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.type_, lhs_arena,
      &other->_impl_.type_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata HostPathVolumeSource::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[79]);
}

// ===================================================================

class ISCSIPersistentVolumeSource::_Internal {
 public:
  using HasBits = decltype(std::declval<ISCSIPersistentVolumeSource>()._impl_._has_bits_);
  static void set_has_targetportal(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_iqn(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lun(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_iscsiinterface(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_fstype(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_readonly(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_chapauthdiscovery(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_chapauthsession(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static const ::k8s::io::api::core::v1::SecretReference& secretref(const ISCSIPersistentVolumeSource* msg);
  static void set_has_secretref(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_initiatorname(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::k8s::io::api::core::v1::SecretReference&
ISCSIPersistentVolumeSource::_Internal::secretref(const ISCSIPersistentVolumeSource* msg) {
  return *msg->_impl_.secretref_;
}
ISCSIPersistentVolumeSource::ISCSIPersistentVolumeSource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.ISCSIPersistentVolumeSource)
}
ISCSIPersistentVolumeSource::ISCSIPersistentVolumeSource(const ISCSIPersistentVolumeSource& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ISCSIPersistentVolumeSource* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.portals_){from._impl_.portals_}
    , decltype(_impl_.targetportal_){}
    , decltype(_impl_.iqn_){}
    , decltype(_impl_.iscsiinterface_){}
    , decltype(_impl_.fstype_){}
    , decltype(_impl_.initiatorname_){}
    , decltype(_impl_.secretref_){nullptr}
    , decltype(_impl_.lun_){}
    , decltype(_impl_.readonly_){}
    , decltype(_impl_.chapauthdiscovery_){}
    , decltype(_impl_.chapauthsession_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.targetportal_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.targetportal_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_targetportal()) {
    _this->_impl_.targetportal_.Set(from._internal_targetportal(), 
      _this->GetArenaForAllocation());
  }
  _impl_.iqn_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.iqn_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_iqn()) {
    _this->_impl_.iqn_.Set(from._internal_iqn(), 
      _this->GetArenaForAllocation());
  }
  _impl_.iscsiinterface_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.iscsiinterface_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_iscsiinterface()) {
    _this->_impl_.iscsiinterface_.Set(from._internal_iscsiinterface(), 
      _this->GetArenaForAllocation());
  }
  _impl_.fstype_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fstype_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_fstype()) {
    _this->_impl_.fstype_.Set(from._internal_fstype(), 
      _this->GetArenaForAllocation());
  }
  _impl_.initiatorname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.initiatorname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_initiatorname()) {
    _this->_impl_.initiatorname_.Set(from._internal_initiatorname(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_secretref()) {
    _this->_impl_.secretref_ = new ::k8s::io::api::core::v1::SecretReference(*from._impl_.secretref_);
  }
  ::memcpy(&_impl_.lun_, &from._impl_.lun_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.chapauthsession_) -
    reinterpret_cast<char*>(&_impl_.lun_)) + sizeof(_impl_.chapauthsession_));
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.ISCSIPersistentVolumeSource)
}

inline void ISCSIPersistentVolumeSource::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.portals_){arena}
    , decltype(_impl_.targetportal_){}
    , decltype(_impl_.iqn_){}
    , decltype(_impl_.iscsiinterface_){}
    , decltype(_impl_.fstype_){}
    , decltype(_impl_.initiatorname_){}
    , decltype(_impl_.secretref_){nullptr}
    , decltype(_impl_.lun_){0}
    , decltype(_impl_.readonly_){false}
    , decltype(_impl_.chapauthdiscovery_){false}
    , decltype(_impl_.chapauthsession_){false}
  };
  _impl_.targetportal_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.targetportal_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.iqn_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.iqn_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.iscsiinterface_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.iscsiinterface_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.fstype_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fstype_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.initiatorname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.initiatorname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ISCSIPersistentVolumeSource::~ISCSIPersistentVolumeSource() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.ISCSIPersistentVolumeSource)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ISCSIPersistentVolumeSource::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.portals_.~RepeatedPtrField();
  _impl_.targetportal_.Destroy();
  _impl_.iqn_.Destroy();
  _impl_.iscsiinterface_.Destroy();
  _impl_.fstype_.Destroy();
  _impl_.initiatorname_.Destroy();
  if (this != internal_default_instance()) delete _impl_.secretref_;
}

void ISCSIPersistentVolumeSource::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ISCSIPersistentVolumeSource::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.ISCSIPersistentVolumeSource)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.portals_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.targetportal_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.iqn_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.iscsiinterface_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.fstype_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.initiatorname_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.secretref_ != nullptr);
      _impl_.secretref_->Clear();
    }
  }
  if (cached_has_bits & 0x000000c0u) {
    ::memset(&_impl_.lun_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.readonly_) -
        reinterpret_cast<char*>(&_impl_.lun_)) + sizeof(_impl_.readonly_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&_impl_.chapauthdiscovery_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.chapauthsession_) -
        reinterpret_cast<char*>(&_impl_.chapauthdiscovery_)) + sizeof(_impl_.chapauthsession_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ISCSIPersistentVolumeSource::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes targetPortal = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_targetportal();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes iqn = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_iqn();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 lun = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_lun(&has_bits);
          _impl_.lun_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes iscsiInterface = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_iscsiinterface();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes fsType = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_fstype();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool readOnly = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_readonly(&has_bits);
          _impl_.readonly_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string portals = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_portals();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "k8s.io.api.core.v1.ISCSIPersistentVolumeSource.portals");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool chapAuthDiscovery = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_chapauthdiscovery(&has_bits);
          _impl_.chapauthdiscovery_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.SecretReference secretRef = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_secretref(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool chapAuthSession = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_chapauthsession(&has_bits);
          _impl_.chapauthsession_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes initiatorName = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          auto str = _internal_mutable_initiatorname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ISCSIPersistentVolumeSource::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.ISCSIPersistentVolumeSource)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes targetPortal = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_targetportal(), target);
  }

  // optional bytes iqn = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_iqn(), target);
  }

  // optional int32 lun = 3;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_lun(), target);
  }

  // optional bytes iscsiInterface = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_iscsiinterface(), target);
  }

  // optional bytes fsType = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_fstype(), target);
  }

  // optional bool readOnly = 6;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_readonly(), target);
  }

  // repeated string portals = 7;
  for (int i = 0, n = this->_internal_portals_size(); i < n; i++) {
    const auto& s = this->_internal_portals(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "k8s.io.api.core.v1.ISCSIPersistentVolumeSource.portals");
    target = stream->WriteString(7, s, target);
  }

  // optional bool chapAuthDiscovery = 8;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_chapauthdiscovery(), target);
  }

  // optional .k8s.io.api.core.v1.SecretReference secretRef = 10;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::secretref(this),
        _Internal::secretref(this).GetCachedSize(), target, stream);
  }

  // optional bool chapAuthSession = 11;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(11, this->_internal_chapauthsession(), target);
  }

  // optional bytes initiatorName = 12;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteBytesMaybeAliased(
        12, this->_internal_initiatorname(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.ISCSIPersistentVolumeSource)
  return target;
}

size_t ISCSIPersistentVolumeSource::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.ISCSIPersistentVolumeSource)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string portals = 7;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.portals_.size());
  for (int i = 0, n = _impl_.portals_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.portals_.Get(i));
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bytes targetPortal = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_targetportal());
    }

    // optional bytes iqn = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_iqn());
    }

    // optional bytes iscsiInterface = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_iscsiinterface());
    }

    // optional bytes fsType = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_fstype());
    }

    // optional bytes initiatorName = 12;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_initiatorname());
    }

    // optional .k8s.io.api.core.v1.SecretReference secretRef = 10;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.secretref_);
    }

    // optional int32 lun = 3;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_lun());
    }

    // optional bool readOnly = 6;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional bool chapAuthDiscovery = 8;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional bool chapAuthSession = 11;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ISCSIPersistentVolumeSource::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ISCSIPersistentVolumeSource::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ISCSIPersistentVolumeSource::GetClassData() const { return &_class_data_; }


void ISCSIPersistentVolumeSource::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ISCSIPersistentVolumeSource*>(&to_msg);
  auto& from = static_cast<const ISCSIPersistentVolumeSource&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.ISCSIPersistentVolumeSource)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.portals_.MergeFrom(from._impl_.portals_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_targetportal(from._internal_targetportal());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_iqn(from._internal_iqn());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_iscsiinterface(from._internal_iscsiinterface());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_fstype(from._internal_fstype());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_initiatorname(from._internal_initiatorname());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_secretref()->::k8s::io::api::core::v1::SecretReference::MergeFrom(
          from._internal_secretref());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.lun_ = from._impl_.lun_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.readonly_ = from._impl_.readonly_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.chapauthdiscovery_ = from._impl_.chapauthdiscovery_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.chapauthsession_ = from._impl_.chapauthsession_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ISCSIPersistentVolumeSource::CopyFrom(const ISCSIPersistentVolumeSource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.ISCSIPersistentVolumeSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ISCSIPersistentVolumeSource::IsInitialized() const {
  return true;
}

void ISCSIPersistentVolumeSource::InternalSwap(ISCSIPersistentVolumeSource* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.portals_.InternalSwap(&other->_impl_.portals_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.targetportal_, lhs_arena,
      &other->_impl_.targetportal_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.iqn_, lhs_arena,
      &other->_impl_.iqn_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.iscsiinterface_, lhs_arena,
      &other->_impl_.iscsiinterface_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.fstype_, lhs_arena,
      &other->_impl_.fstype_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.initiatorname_, lhs_arena,
      &other->_impl_.initiatorname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ISCSIPersistentVolumeSource, _impl_.chapauthsession_)
      + sizeof(ISCSIPersistentVolumeSource::_impl_.chapauthsession_)
      - PROTOBUF_FIELD_OFFSET(ISCSIPersistentVolumeSource, _impl_.secretref_)>(
          reinterpret_cast<char*>(&_impl_.secretref_),
          reinterpret_cast<char*>(&other->_impl_.secretref_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ISCSIPersistentVolumeSource::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[80]);
}

// ===================================================================

class ISCSIVolumeSource::_Internal {
 public:
  using HasBits = decltype(std::declval<ISCSIVolumeSource>()._impl_._has_bits_);
  static void set_has_targetportal(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_iqn(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lun(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_iscsiinterface(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_fstype(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_readonly(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_chapauthdiscovery(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_chapauthsession(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static const ::k8s::io::api::core::v1::LocalObjectReference& secretref(const ISCSIVolumeSource* msg);
  static void set_has_secretref(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_initiatorname(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::k8s::io::api::core::v1::LocalObjectReference&
ISCSIVolumeSource::_Internal::secretref(const ISCSIVolumeSource* msg) {
  return *msg->_impl_.secretref_;
}
ISCSIVolumeSource::ISCSIVolumeSource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.ISCSIVolumeSource)
}
ISCSIVolumeSource::ISCSIVolumeSource(const ISCSIVolumeSource& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ISCSIVolumeSource* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.portals_){from._impl_.portals_}
    , decltype(_impl_.targetportal_){}
    , decltype(_impl_.iqn_){}
    , decltype(_impl_.iscsiinterface_){}
    , decltype(_impl_.fstype_){}
    , decltype(_impl_.initiatorname_){}
    , decltype(_impl_.secretref_){nullptr}
    , decltype(_impl_.lun_){}
    , decltype(_impl_.readonly_){}
    , decltype(_impl_.chapauthdiscovery_){}
    , decltype(_impl_.chapauthsession_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.targetportal_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.targetportal_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_targetportal()) {
    _this->_impl_.targetportal_.Set(from._internal_targetportal(), 
      _this->GetArenaForAllocation());
  }
  _impl_.iqn_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.iqn_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_iqn()) {
    _this->_impl_.iqn_.Set(from._internal_iqn(), 
      _this->GetArenaForAllocation());
  }
  _impl_.iscsiinterface_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.iscsiinterface_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_iscsiinterface()) {
    _this->_impl_.iscsiinterface_.Set(from._internal_iscsiinterface(), 
      _this->GetArenaForAllocation());
  }
  _impl_.fstype_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fstype_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_fstype()) {
    _this->_impl_.fstype_.Set(from._internal_fstype(), 
      _this->GetArenaForAllocation());
  }
  _impl_.initiatorname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.initiatorname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_initiatorname()) {
    _this->_impl_.initiatorname_.Set(from._internal_initiatorname(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_secretref()) {
    _this->_impl_.secretref_ = new ::k8s::io::api::core::v1::LocalObjectReference(*from._impl_.secretref_);
  }
  ::memcpy(&_impl_.lun_, &from._impl_.lun_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.chapauthsession_) -
    reinterpret_cast<char*>(&_impl_.lun_)) + sizeof(_impl_.chapauthsession_));
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.ISCSIVolumeSource)
}

inline void ISCSIVolumeSource::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.portals_){arena}
    , decltype(_impl_.targetportal_){}
    , decltype(_impl_.iqn_){}
    , decltype(_impl_.iscsiinterface_){}
    , decltype(_impl_.fstype_){}
    , decltype(_impl_.initiatorname_){}
    , decltype(_impl_.secretref_){nullptr}
    , decltype(_impl_.lun_){0}
    , decltype(_impl_.readonly_){false}
    , decltype(_impl_.chapauthdiscovery_){false}
    , decltype(_impl_.chapauthsession_){false}
  };
  _impl_.targetportal_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.targetportal_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.iqn_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.iqn_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.iscsiinterface_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.iscsiinterface_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.fstype_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fstype_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.initiatorname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.initiatorname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ISCSIVolumeSource::~ISCSIVolumeSource() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.ISCSIVolumeSource)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ISCSIVolumeSource::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.portals_.~RepeatedPtrField();
  _impl_.targetportal_.Destroy();
  _impl_.iqn_.Destroy();
  _impl_.iscsiinterface_.Destroy();
  _impl_.fstype_.Destroy();
  _impl_.initiatorname_.Destroy();
  if (this != internal_default_instance()) delete _impl_.secretref_;
}

void ISCSIVolumeSource::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ISCSIVolumeSource::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.ISCSIVolumeSource)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.portals_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.targetportal_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.iqn_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.iscsiinterface_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.fstype_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.initiatorname_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.secretref_ != nullptr);
      _impl_.secretref_->Clear();
    }
  }
  if (cached_has_bits & 0x000000c0u) {
    ::memset(&_impl_.lun_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.readonly_) -
        reinterpret_cast<char*>(&_impl_.lun_)) + sizeof(_impl_.readonly_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&_impl_.chapauthdiscovery_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.chapauthsession_) -
        reinterpret_cast<char*>(&_impl_.chapauthdiscovery_)) + sizeof(_impl_.chapauthsession_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ISCSIVolumeSource::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes targetPortal = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_targetportal();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes iqn = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_iqn();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 lun = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_lun(&has_bits);
          _impl_.lun_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes iscsiInterface = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_iscsiinterface();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes fsType = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_fstype();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool readOnly = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_readonly(&has_bits);
          _impl_.readonly_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string portals = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_portals();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "k8s.io.api.core.v1.ISCSIVolumeSource.portals");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool chapAuthDiscovery = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_chapauthdiscovery(&has_bits);
          _impl_.chapauthdiscovery_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.LocalObjectReference secretRef = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_secretref(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool chapAuthSession = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_chapauthsession(&has_bits);
          _impl_.chapauthsession_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes initiatorName = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          auto str = _internal_mutable_initiatorname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ISCSIVolumeSource::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.ISCSIVolumeSource)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes targetPortal = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_targetportal(), target);
  }

  // optional bytes iqn = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_iqn(), target);
  }

  // optional int32 lun = 3;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_lun(), target);
  }

  // optional bytes iscsiInterface = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_iscsiinterface(), target);
  }

  // optional bytes fsType = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_fstype(), target);
  }

  // optional bool readOnly = 6;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_readonly(), target);
  }

  // repeated string portals = 7;
  for (int i = 0, n = this->_internal_portals_size(); i < n; i++) {
    const auto& s = this->_internal_portals(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "k8s.io.api.core.v1.ISCSIVolumeSource.portals");
    target = stream->WriteString(7, s, target);
  }

  // optional bool chapAuthDiscovery = 8;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_chapauthdiscovery(), target);
  }

  // optional .k8s.io.api.core.v1.LocalObjectReference secretRef = 10;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::secretref(this),
        _Internal::secretref(this).GetCachedSize(), target, stream);
  }

  // optional bool chapAuthSession = 11;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(11, this->_internal_chapauthsession(), target);
  }

  // optional bytes initiatorName = 12;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteBytesMaybeAliased(
        12, this->_internal_initiatorname(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.ISCSIVolumeSource)
  return target;
}

size_t ISCSIVolumeSource::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.ISCSIVolumeSource)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string portals = 7;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.portals_.size());
  for (int i = 0, n = _impl_.portals_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.portals_.Get(i));
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bytes targetPortal = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_targetportal());
    }

    // optional bytes iqn = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_iqn());
    }

    // optional bytes iscsiInterface = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_iscsiinterface());
    }

    // optional bytes fsType = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_fstype());
    }

    // optional bytes initiatorName = 12;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_initiatorname());
    }

    // optional .k8s.io.api.core.v1.LocalObjectReference secretRef = 10;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.secretref_);
    }

    // optional int32 lun = 3;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_lun());
    }

    // optional bool readOnly = 6;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional bool chapAuthDiscovery = 8;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional bool chapAuthSession = 11;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ISCSIVolumeSource::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ISCSIVolumeSource::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ISCSIVolumeSource::GetClassData() const { return &_class_data_; }


void ISCSIVolumeSource::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ISCSIVolumeSource*>(&to_msg);
  auto& from = static_cast<const ISCSIVolumeSource&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.ISCSIVolumeSource)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.portals_.MergeFrom(from._impl_.portals_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_targetportal(from._internal_targetportal());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_iqn(from._internal_iqn());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_iscsiinterface(from._internal_iscsiinterface());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_fstype(from._internal_fstype());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_initiatorname(from._internal_initiatorname());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_secretref()->::k8s::io::api::core::v1::LocalObjectReference::MergeFrom(
          from._internal_secretref());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.lun_ = from._impl_.lun_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.readonly_ = from._impl_.readonly_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.chapauthdiscovery_ = from._impl_.chapauthdiscovery_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.chapauthsession_ = from._impl_.chapauthsession_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ISCSIVolumeSource::CopyFrom(const ISCSIVolumeSource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.ISCSIVolumeSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ISCSIVolumeSource::IsInitialized() const {
  return true;
}

void ISCSIVolumeSource::InternalSwap(ISCSIVolumeSource* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.portals_.InternalSwap(&other->_impl_.portals_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.targetportal_, lhs_arena,
      &other->_impl_.targetportal_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.iqn_, lhs_arena,
      &other->_impl_.iqn_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.iscsiinterface_, lhs_arena,
      &other->_impl_.iscsiinterface_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.fstype_, lhs_arena,
      &other->_impl_.fstype_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.initiatorname_, lhs_arena,
      &other->_impl_.initiatorname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ISCSIVolumeSource, _impl_.chapauthsession_)
      + sizeof(ISCSIVolumeSource::_impl_.chapauthsession_)
      - PROTOBUF_FIELD_OFFSET(ISCSIVolumeSource, _impl_.secretref_)>(
          reinterpret_cast<char*>(&_impl_.secretref_),
          reinterpret_cast<char*>(&other->_impl_.secretref_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ISCSIVolumeSource::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[81]);
}

// ===================================================================

class KeyToPath::_Internal {
 public:
  using HasBits = decltype(std::declval<KeyToPath>()._impl_._has_bits_);
  static void set_has_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_path(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

KeyToPath::KeyToPath(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.KeyToPath)
}
KeyToPath::KeyToPath(const KeyToPath& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  KeyToPath* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.key_){}
    , decltype(_impl_.path_){}
    , decltype(_impl_.mode_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_key()) {
    _this->_impl_.key_.Set(from._internal_key(), 
      _this->GetArenaForAllocation());
  }
  _impl_.path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_path()) {
    _this->_impl_.path_.Set(from._internal_path(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.mode_ = from._impl_.mode_;
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.KeyToPath)
}

inline void KeyToPath::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.key_){}
    , decltype(_impl_.path_){}
    , decltype(_impl_.mode_){0}
  };
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

KeyToPath::~KeyToPath() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.KeyToPath)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KeyToPath::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.key_.Destroy();
  _impl_.path_.Destroy();
}

void KeyToPath::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KeyToPath::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.KeyToPath)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.key_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.path_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.mode_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* KeyToPath::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes path = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_path();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 mode = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_mode(&has_bits);
          _impl_.mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KeyToPath::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.KeyToPath)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes key = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_key(), target);
  }

  // optional bytes path = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_path(), target);
  }

  // optional int32 mode = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_mode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.KeyToPath)
  return target;
}

size_t KeyToPath::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.KeyToPath)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bytes key = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_key());
    }

    // optional bytes path = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_path());
    }

    // optional int32 mode = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_mode());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData KeyToPath::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    KeyToPath::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*KeyToPath::GetClassData() const { return &_class_data_; }


void KeyToPath::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<KeyToPath*>(&to_msg);
  auto& from = static_cast<const KeyToPath&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.KeyToPath)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_key(from._internal_key());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_path(from._internal_path());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.mode_ = from._impl_.mode_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void KeyToPath::CopyFrom(const KeyToPath& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.KeyToPath)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KeyToPath::IsInitialized() const {
  return true;
}

void KeyToPath::InternalSwap(KeyToPath* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.key_, lhs_arena,
      &other->_impl_.key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.path_, lhs_arena,
      &other->_impl_.path_, rhs_arena
  );
  swap(_impl_.mode_, other->_impl_.mode_);
}

::PROTOBUF_NAMESPACE_ID::Metadata KeyToPath::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[82]);
}

// ===================================================================

class Lifecycle::_Internal {
 public:
  using HasBits = decltype(std::declval<Lifecycle>()._impl_._has_bits_);
  static const ::k8s::io::api::core::v1::LifecycleHandler& poststart(const Lifecycle* msg);
  static void set_has_poststart(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::k8s::io::api::core::v1::LifecycleHandler& prestop(const Lifecycle* msg);
  static void set_has_prestop(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::k8s::io::api::core::v1::LifecycleHandler&
Lifecycle::_Internal::poststart(const Lifecycle* msg) {
  return *msg->_impl_.poststart_;
}
const ::k8s::io::api::core::v1::LifecycleHandler&
Lifecycle::_Internal::prestop(const Lifecycle* msg) {
  return *msg->_impl_.prestop_;
}
Lifecycle::Lifecycle(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.Lifecycle)
}
Lifecycle::Lifecycle(const Lifecycle& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Lifecycle* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.poststart_){nullptr}
    , decltype(_impl_.prestop_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_poststart()) {
    _this->_impl_.poststart_ = new ::k8s::io::api::core::v1::LifecycleHandler(*from._impl_.poststart_);
  }
  if (from._internal_has_prestop()) {
    _this->_impl_.prestop_ = new ::k8s::io::api::core::v1::LifecycleHandler(*from._impl_.prestop_);
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.Lifecycle)
}

inline void Lifecycle::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.poststart_){nullptr}
    , decltype(_impl_.prestop_){nullptr}
  };
}

Lifecycle::~Lifecycle() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.Lifecycle)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Lifecycle::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.poststart_;
  if (this != internal_default_instance()) delete _impl_.prestop_;
}

void Lifecycle::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Lifecycle::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.Lifecycle)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.poststart_ != nullptr);
      _impl_.poststart_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.prestop_ != nullptr);
      _impl_.prestop_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Lifecycle::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .k8s.io.api.core.v1.LifecycleHandler postStart = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_poststart(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.LifecycleHandler preStop = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_prestop(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Lifecycle::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.Lifecycle)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .k8s.io.api.core.v1.LifecycleHandler postStart = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::poststart(this),
        _Internal::poststart(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.LifecycleHandler preStop = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::prestop(this),
        _Internal::prestop(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.Lifecycle)
  return target;
}

size_t Lifecycle::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.Lifecycle)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .k8s.io.api.core.v1.LifecycleHandler postStart = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.poststart_);
    }

    // optional .k8s.io.api.core.v1.LifecycleHandler preStop = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.prestop_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Lifecycle::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Lifecycle::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Lifecycle::GetClassData() const { return &_class_data_; }


void Lifecycle::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Lifecycle*>(&to_msg);
  auto& from = static_cast<const Lifecycle&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.Lifecycle)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_poststart()->::k8s::io::api::core::v1::LifecycleHandler::MergeFrom(
          from._internal_poststart());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_prestop()->::k8s::io::api::core::v1::LifecycleHandler::MergeFrom(
          from._internal_prestop());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Lifecycle::CopyFrom(const Lifecycle& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.Lifecycle)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Lifecycle::IsInitialized() const {
  return true;
}

void Lifecycle::InternalSwap(Lifecycle* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Lifecycle, _impl_.prestop_)
      + sizeof(Lifecycle::_impl_.prestop_)
      - PROTOBUF_FIELD_OFFSET(Lifecycle, _impl_.poststart_)>(
          reinterpret_cast<char*>(&_impl_.poststart_),
          reinterpret_cast<char*>(&other->_impl_.poststart_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Lifecycle::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[83]);
}

// ===================================================================

class LifecycleHandler::_Internal {
 public:
  using HasBits = decltype(std::declval<LifecycleHandler>()._impl_._has_bits_);
  static const ::k8s::io::api::core::v1::ExecAction& exec(const LifecycleHandler* msg);
  static void set_has_exec(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::k8s::io::api::core::v1::HTTPGetAction& httpget(const LifecycleHandler* msg);
  static void set_has_httpget(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::k8s::io::api::core::v1::TCPSocketAction& tcpsocket(const LifecycleHandler* msg);
  static void set_has_tcpsocket(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::k8s::io::api::core::v1::SleepAction& sleep(const LifecycleHandler* msg);
  static void set_has_sleep(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::k8s::io::api::core::v1::ExecAction&
LifecycleHandler::_Internal::exec(const LifecycleHandler* msg) {
  return *msg->_impl_.exec_;
}
const ::k8s::io::api::core::v1::HTTPGetAction&
LifecycleHandler::_Internal::httpget(const LifecycleHandler* msg) {
  return *msg->_impl_.httpget_;
}
const ::k8s::io::api::core::v1::TCPSocketAction&
LifecycleHandler::_Internal::tcpsocket(const LifecycleHandler* msg) {
  return *msg->_impl_.tcpsocket_;
}
const ::k8s::io::api::core::v1::SleepAction&
LifecycleHandler::_Internal::sleep(const LifecycleHandler* msg) {
  return *msg->_impl_.sleep_;
}
LifecycleHandler::LifecycleHandler(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.LifecycleHandler)
}
LifecycleHandler::LifecycleHandler(const LifecycleHandler& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LifecycleHandler* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.exec_){nullptr}
    , decltype(_impl_.httpget_){nullptr}
    , decltype(_impl_.tcpsocket_){nullptr}
    , decltype(_impl_.sleep_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_exec()) {
    _this->_impl_.exec_ = new ::k8s::io::api::core::v1::ExecAction(*from._impl_.exec_);
  }
  if (from._internal_has_httpget()) {
    _this->_impl_.httpget_ = new ::k8s::io::api::core::v1::HTTPGetAction(*from._impl_.httpget_);
  }
  if (from._internal_has_tcpsocket()) {
    _this->_impl_.tcpsocket_ = new ::k8s::io::api::core::v1::TCPSocketAction(*from._impl_.tcpsocket_);
  }
  if (from._internal_has_sleep()) {
    _this->_impl_.sleep_ = new ::k8s::io::api::core::v1::SleepAction(*from._impl_.sleep_);
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.LifecycleHandler)
}

inline void LifecycleHandler::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.exec_){nullptr}
    , decltype(_impl_.httpget_){nullptr}
    , decltype(_impl_.tcpsocket_){nullptr}
    , decltype(_impl_.sleep_){nullptr}
  };
}

LifecycleHandler::~LifecycleHandler() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.LifecycleHandler)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LifecycleHandler::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.exec_;
  if (this != internal_default_instance()) delete _impl_.httpget_;
  if (this != internal_default_instance()) delete _impl_.tcpsocket_;
  if (this != internal_default_instance()) delete _impl_.sleep_;
}

void LifecycleHandler::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LifecycleHandler::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.LifecycleHandler)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.exec_ != nullptr);
      _impl_.exec_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.httpget_ != nullptr);
      _impl_.httpget_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.tcpsocket_ != nullptr);
      _impl_.tcpsocket_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.sleep_ != nullptr);
      _impl_.sleep_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LifecycleHandler::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .k8s.io.api.core.v1.ExecAction exec = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_exec(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.HTTPGetAction httpGet = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_httpget(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.TCPSocketAction tcpSocket = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_tcpsocket(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.SleepAction sleep = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_sleep(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LifecycleHandler::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.LifecycleHandler)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .k8s.io.api.core.v1.ExecAction exec = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::exec(this),
        _Internal::exec(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.HTTPGetAction httpGet = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::httpget(this),
        _Internal::httpget(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.TCPSocketAction tcpSocket = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::tcpsocket(this),
        _Internal::tcpsocket(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.SleepAction sleep = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::sleep(this),
        _Internal::sleep(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.LifecycleHandler)
  return target;
}

size_t LifecycleHandler::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.LifecycleHandler)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .k8s.io.api.core.v1.ExecAction exec = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.exec_);
    }

    // optional .k8s.io.api.core.v1.HTTPGetAction httpGet = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.httpget_);
    }

    // optional .k8s.io.api.core.v1.TCPSocketAction tcpSocket = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.tcpsocket_);
    }

    // optional .k8s.io.api.core.v1.SleepAction sleep = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.sleep_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LifecycleHandler::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LifecycleHandler::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LifecycleHandler::GetClassData() const { return &_class_data_; }


void LifecycleHandler::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LifecycleHandler*>(&to_msg);
  auto& from = static_cast<const LifecycleHandler&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.LifecycleHandler)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_exec()->::k8s::io::api::core::v1::ExecAction::MergeFrom(
          from._internal_exec());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_httpget()->::k8s::io::api::core::v1::HTTPGetAction::MergeFrom(
          from._internal_httpget());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_tcpsocket()->::k8s::io::api::core::v1::TCPSocketAction::MergeFrom(
          from._internal_tcpsocket());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_sleep()->::k8s::io::api::core::v1::SleepAction::MergeFrom(
          from._internal_sleep());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LifecycleHandler::CopyFrom(const LifecycleHandler& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.LifecycleHandler)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LifecycleHandler::IsInitialized() const {
  return true;
}

void LifecycleHandler::InternalSwap(LifecycleHandler* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LifecycleHandler, _impl_.sleep_)
      + sizeof(LifecycleHandler::_impl_.sleep_)
      - PROTOBUF_FIELD_OFFSET(LifecycleHandler, _impl_.exec_)>(
          reinterpret_cast<char*>(&_impl_.exec_),
          reinterpret_cast<char*>(&other->_impl_.exec_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LifecycleHandler::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[84]);
}

// ===================================================================

class LimitRange::_Internal {
 public:
  using HasBits = decltype(std::declval<LimitRange>()._impl_._has_bits_);
  static const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& metadata(const LimitRange* msg);
  static void set_has_metadata(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::k8s::io::api::core::v1::LimitRangeSpec& spec(const LimitRange* msg);
  static void set_has_spec(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta&
LimitRange::_Internal::metadata(const LimitRange* msg) {
  return *msg->_impl_.metadata_;
}
const ::k8s::io::api::core::v1::LimitRangeSpec&
LimitRange::_Internal::spec(const LimitRange* msg) {
  return *msg->_impl_.spec_;
}
void LimitRange::clear_metadata() {
  if (_impl_.metadata_ != nullptr) _impl_.metadata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
LimitRange::LimitRange(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.LimitRange)
}
LimitRange::LimitRange(const LimitRange& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LimitRange* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.metadata_){nullptr}
    , decltype(_impl_.spec_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_metadata()) {
    _this->_impl_.metadata_ = new ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta(*from._impl_.metadata_);
  }
  if (from._internal_has_spec()) {
    _this->_impl_.spec_ = new ::k8s::io::api::core::v1::LimitRangeSpec(*from._impl_.spec_);
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.LimitRange)
}

inline void LimitRange::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.metadata_){nullptr}
    , decltype(_impl_.spec_){nullptr}
  };
}

LimitRange::~LimitRange() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.LimitRange)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LimitRange::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.metadata_;
  if (this != internal_default_instance()) delete _impl_.spec_;
}

void LimitRange::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LimitRange::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.LimitRange)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.metadata_ != nullptr);
      _impl_.metadata_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.spec_ != nullptr);
      _impl_.spec_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LimitRange::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_metadata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.LimitRangeSpec spec = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_spec(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LimitRange::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.LimitRange)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::metadata(this),
        _Internal::metadata(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.LimitRangeSpec spec = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::spec(this),
        _Internal::spec(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.LimitRange)
  return target;
}

size_t LimitRange::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.LimitRange)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.metadata_);
    }

    // optional .k8s.io.api.core.v1.LimitRangeSpec spec = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.spec_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LimitRange::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LimitRange::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LimitRange::GetClassData() const { return &_class_data_; }


void LimitRange::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LimitRange*>(&to_msg);
  auto& from = static_cast<const LimitRange&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.LimitRange)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_metadata()->::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta::MergeFrom(
          from._internal_metadata());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_spec()->::k8s::io::api::core::v1::LimitRangeSpec::MergeFrom(
          from._internal_spec());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LimitRange::CopyFrom(const LimitRange& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.LimitRange)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LimitRange::IsInitialized() const {
  return true;
}

void LimitRange::InternalSwap(LimitRange* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LimitRange, _impl_.spec_)
      + sizeof(LimitRange::_impl_.spec_)
      - PROTOBUF_FIELD_OFFSET(LimitRange, _impl_.metadata_)>(
          reinterpret_cast<char*>(&_impl_.metadata_),
          reinterpret_cast<char*>(&other->_impl_.metadata_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LimitRange::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[85]);
}

// ===================================================================

LimitRangeItem_MaxEntry_DoNotUse::LimitRangeItem_MaxEntry_DoNotUse() {}
LimitRangeItem_MaxEntry_DoNotUse::LimitRangeItem_MaxEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void LimitRangeItem_MaxEntry_DoNotUse::MergeFrom(const LimitRangeItem_MaxEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata LimitRangeItem_MaxEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[86]);
}

// ===================================================================

LimitRangeItem_MinEntry_DoNotUse::LimitRangeItem_MinEntry_DoNotUse() {}
LimitRangeItem_MinEntry_DoNotUse::LimitRangeItem_MinEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void LimitRangeItem_MinEntry_DoNotUse::MergeFrom(const LimitRangeItem_MinEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata LimitRangeItem_MinEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[87]);
}

// ===================================================================

LimitRangeItem_DefaultEntry_DoNotUse::LimitRangeItem_DefaultEntry_DoNotUse() {}
LimitRangeItem_DefaultEntry_DoNotUse::LimitRangeItem_DefaultEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void LimitRangeItem_DefaultEntry_DoNotUse::MergeFrom(const LimitRangeItem_DefaultEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata LimitRangeItem_DefaultEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[88]);
}

// ===================================================================

LimitRangeItem_DefaultRequestEntry_DoNotUse::LimitRangeItem_DefaultRequestEntry_DoNotUse() {}
LimitRangeItem_DefaultRequestEntry_DoNotUse::LimitRangeItem_DefaultRequestEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void LimitRangeItem_DefaultRequestEntry_DoNotUse::MergeFrom(const LimitRangeItem_DefaultRequestEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata LimitRangeItem_DefaultRequestEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[89]);
}

// ===================================================================

LimitRangeItem_MaxLimitRequestRatioEntry_DoNotUse::LimitRangeItem_MaxLimitRequestRatioEntry_DoNotUse() {}
LimitRangeItem_MaxLimitRequestRatioEntry_DoNotUse::LimitRangeItem_MaxLimitRequestRatioEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void LimitRangeItem_MaxLimitRequestRatioEntry_DoNotUse::MergeFrom(const LimitRangeItem_MaxLimitRequestRatioEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata LimitRangeItem_MaxLimitRequestRatioEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[90]);
}

// ===================================================================

class LimitRangeItem::_Internal {
 public:
  using HasBits = decltype(std::declval<LimitRangeItem>()._impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

void LimitRangeItem::clear_max() {
  _impl_.max_.Clear();
}
void LimitRangeItem::clear_min() {
  _impl_.min_.Clear();
}
void LimitRangeItem::clear_default_() {
  _impl_.default__.Clear();
}
void LimitRangeItem::clear_defaultrequest() {
  _impl_.defaultrequest_.Clear();
}
void LimitRangeItem::clear_maxlimitrequestratio() {
  _impl_.maxlimitrequestratio_.Clear();
}
LimitRangeItem::LimitRangeItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &LimitRangeItem::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.LimitRangeItem)
}
LimitRangeItem::LimitRangeItem(const LimitRangeItem& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LimitRangeItem* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_.max_)*/{}
    , /*decltype(_impl_.min_)*/{}
    , /*decltype(_impl_.default__)*/{}
    , /*decltype(_impl_.defaultrequest_)*/{}
    , /*decltype(_impl_.maxlimitrequestratio_)*/{}
    , decltype(_impl_.type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.max_.MergeFrom(from._impl_.max_);
  _this->_impl_.min_.MergeFrom(from._impl_.min_);
  _this->_impl_.default__.MergeFrom(from._impl_.default__);
  _this->_impl_.defaultrequest_.MergeFrom(from._impl_.defaultrequest_);
  _this->_impl_.maxlimitrequestratio_.MergeFrom(from._impl_.maxlimitrequestratio_);
  _impl_.type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_type()) {
    _this->_impl_.type_.Set(from._internal_type(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.LimitRangeItem)
}

inline void LimitRangeItem::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_.max_)*/{::_pbi::ArenaInitialized(), arena}
    , /*decltype(_impl_.min_)*/{::_pbi::ArenaInitialized(), arena}
    , /*decltype(_impl_.default__)*/{::_pbi::ArenaInitialized(), arena}
    , /*decltype(_impl_.defaultrequest_)*/{::_pbi::ArenaInitialized(), arena}
    , /*decltype(_impl_.maxlimitrequestratio_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.type_){}
  };
  _impl_.type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LimitRangeItem::~LimitRangeItem() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.LimitRangeItem)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void LimitRangeItem::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.max_.Destruct();
  _impl_.max_.~MapField();
  _impl_.min_.Destruct();
  _impl_.min_.~MapField();
  _impl_.default__.Destruct();
  _impl_.default__.~MapField();
  _impl_.defaultrequest_.Destruct();
  _impl_.defaultrequest_.~MapField();
  _impl_.maxlimitrequestratio_.Destruct();
  _impl_.maxlimitrequestratio_.~MapField();
  _impl_.type_.Destroy();
}

void LimitRangeItem::ArenaDtor(void* object) {
  LimitRangeItem* _this = reinterpret_cast< LimitRangeItem* >(object);
  _this->_impl_.max_.Destruct();
  _this->_impl_.min_.Destruct();
  _this->_impl_.default__.Destruct();
  _this->_impl_.defaultrequest_.Destruct();
  _this->_impl_.maxlimitrequestratio_.Destruct();
}
void LimitRangeItem::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LimitRangeItem::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.LimitRangeItem)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.max_.Clear();
  _impl_.min_.Clear();
  _impl_.default__.Clear();
  _impl_.defaultrequest_.Clear();
  _impl_.maxlimitrequestratio_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.type_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LimitRangeItem::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // map<string, .k8s.io.apimachinery.pkg.api.resource.Quantity> max = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.max_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // map<string, .k8s.io.apimachinery.pkg.api.resource.Quantity> min = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.min_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // map<string, .k8s.io.apimachinery.pkg.api.resource.Quantity> default = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.default__, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // map<string, .k8s.io.apimachinery.pkg.api.resource.Quantity> defaultRequest = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.defaultrequest_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // map<string, .k8s.io.apimachinery.pkg.api.resource.Quantity> maxLimitRequestRatio = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.maxlimitrequestratio_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LimitRangeItem::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.LimitRangeItem)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_type(), target);
  }

  // map<string, .k8s.io.apimachinery.pkg.api.resource.Quantity> max = 2;
  if (!this->_internal_max().empty()) {
    using MapType = ::_pb::Map<std::string, ::k8s::io::apimachinery::pkg::api::resource::Quantity>;
    using WireHelper = LimitRangeItem_MaxEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_max();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "k8s.io.api.core.v1.LimitRangeItem.MaxEntry.key");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(2, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(2, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  // map<string, .k8s.io.apimachinery.pkg.api.resource.Quantity> min = 3;
  if (!this->_internal_min().empty()) {
    using MapType = ::_pb::Map<std::string, ::k8s::io::apimachinery::pkg::api::resource::Quantity>;
    using WireHelper = LimitRangeItem_MinEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_min();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "k8s.io.api.core.v1.LimitRangeItem.MinEntry.key");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(3, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(3, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  // map<string, .k8s.io.apimachinery.pkg.api.resource.Quantity> default = 4;
  if (!this->_internal_default_().empty()) {
    using MapType = ::_pb::Map<std::string, ::k8s::io::apimachinery::pkg::api::resource::Quantity>;
    using WireHelper = LimitRangeItem_DefaultEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_default_();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "k8s.io.api.core.v1.LimitRangeItem.DefaultEntry.key");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(4, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(4, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  // map<string, .k8s.io.apimachinery.pkg.api.resource.Quantity> defaultRequest = 5;
  if (!this->_internal_defaultrequest().empty()) {
    using MapType = ::_pb::Map<std::string, ::k8s::io::apimachinery::pkg::api::resource::Quantity>;
    using WireHelper = LimitRangeItem_DefaultRequestEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_defaultrequest();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "k8s.io.api.core.v1.LimitRangeItem.DefaultRequestEntry.key");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(5, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(5, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  // map<string, .k8s.io.apimachinery.pkg.api.resource.Quantity> maxLimitRequestRatio = 6;
  if (!this->_internal_maxlimitrequestratio().empty()) {
    using MapType = ::_pb::Map<std::string, ::k8s::io::apimachinery::pkg::api::resource::Quantity>;
    using WireHelper = LimitRangeItem_MaxLimitRequestRatioEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_maxlimitrequestratio();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "k8s.io.api.core.v1.LimitRangeItem.MaxLimitRequestRatioEntry.key");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(6, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(6, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.LimitRangeItem)
  return target;
}

size_t LimitRangeItem::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.LimitRangeItem)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, .k8s.io.apimachinery.pkg.api.resource.Quantity> max = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_max_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::k8s::io::apimachinery::pkg::api::resource::Quantity >::const_iterator
      it = this->_internal_max().begin();
      it != this->_internal_max().end(); ++it) {
    total_size += LimitRangeItem_MaxEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // map<string, .k8s.io.apimachinery.pkg.api.resource.Quantity> min = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_min_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::k8s::io::apimachinery::pkg::api::resource::Quantity >::const_iterator
      it = this->_internal_min().begin();
      it != this->_internal_min().end(); ++it) {
    total_size += LimitRangeItem_MinEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // map<string, .k8s.io.apimachinery.pkg.api.resource.Quantity> default = 4;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_default__size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::k8s::io::apimachinery::pkg::api::resource::Quantity >::const_iterator
      it = this->_internal_default_().begin();
      it != this->_internal_default_().end(); ++it) {
    total_size += LimitRangeItem_DefaultEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // map<string, .k8s.io.apimachinery.pkg.api.resource.Quantity> defaultRequest = 5;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_defaultrequest_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::k8s::io::apimachinery::pkg::api::resource::Quantity >::const_iterator
      it = this->_internal_defaultrequest().begin();
      it != this->_internal_defaultrequest().end(); ++it) {
    total_size += LimitRangeItem_DefaultRequestEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // map<string, .k8s.io.apimachinery.pkg.api.resource.Quantity> maxLimitRequestRatio = 6;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_maxlimitrequestratio_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::k8s::io::apimachinery::pkg::api::resource::Quantity >::const_iterator
      it = this->_internal_maxlimitrequestratio().begin();
      it != this->_internal_maxlimitrequestratio().end(); ++it) {
    total_size += LimitRangeItem_MaxLimitRequestRatioEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // optional bytes type = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LimitRangeItem::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LimitRangeItem::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LimitRangeItem::GetClassData() const { return &_class_data_; }


void LimitRangeItem::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LimitRangeItem*>(&to_msg);
  auto& from = static_cast<const LimitRangeItem&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.LimitRangeItem)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.max_.MergeFrom(from._impl_.max_);
  _this->_impl_.min_.MergeFrom(from._impl_.min_);
  _this->_impl_.default__.MergeFrom(from._impl_.default__);
  _this->_impl_.defaultrequest_.MergeFrom(from._impl_.defaultrequest_);
  _this->_impl_.maxlimitrequestratio_.MergeFrom(from._impl_.maxlimitrequestratio_);
  if (from._internal_has_type()) {
    _this->_internal_set_type(from._internal_type());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LimitRangeItem::CopyFrom(const LimitRangeItem& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.LimitRangeItem)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LimitRangeItem::IsInitialized() const {
  return true;
}

void LimitRangeItem::InternalSwap(LimitRangeItem* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.max_.InternalSwap(&other->_impl_.max_);
  _impl_.min_.InternalSwap(&other->_impl_.min_);
  _impl_.default__.InternalSwap(&other->_impl_.default__);
  _impl_.defaultrequest_.InternalSwap(&other->_impl_.defaultrequest_);
  _impl_.maxlimitrequestratio_.InternalSwap(&other->_impl_.maxlimitrequestratio_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.type_, lhs_arena,
      &other->_impl_.type_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata LimitRangeItem::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[91]);
}

// ===================================================================

class LimitRangeList::_Internal {
 public:
  using HasBits = decltype(std::declval<LimitRangeList>()._impl_._has_bits_);
  static const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& metadata(const LimitRangeList* msg);
  static void set_has_metadata(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta&
LimitRangeList::_Internal::metadata(const LimitRangeList* msg) {
  return *msg->_impl_.metadata_;
}
void LimitRangeList::clear_metadata() {
  if (_impl_.metadata_ != nullptr) _impl_.metadata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
LimitRangeList::LimitRangeList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.LimitRangeList)
}
LimitRangeList::LimitRangeList(const LimitRangeList& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LimitRangeList* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.items_){from._impl_.items_}
    , decltype(_impl_.metadata_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_metadata()) {
    _this->_impl_.metadata_ = new ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta(*from._impl_.metadata_);
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.LimitRangeList)
}

inline void LimitRangeList::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.items_){arena}
    , decltype(_impl_.metadata_){nullptr}
  };
}

LimitRangeList::~LimitRangeList() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.LimitRangeList)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LimitRangeList::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.items_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.metadata_;
}

void LimitRangeList::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LimitRangeList::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.LimitRangeList)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.items_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.metadata_ != nullptr);
    _impl_.metadata_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LimitRangeList::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_metadata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .k8s.io.api.core.v1.LimitRange items = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_items(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LimitRangeList::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.LimitRangeList)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::metadata(this),
        _Internal::metadata(this).GetCachedSize(), target, stream);
  }

  // repeated .k8s.io.api.core.v1.LimitRange items = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_items_size()); i < n; i++) {
    const auto& repfield = this->_internal_items(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.LimitRangeList)
  return target;
}

size_t LimitRangeList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.LimitRangeList)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .k8s.io.api.core.v1.LimitRange items = 2;
  total_size += 1UL * this->_internal_items_size();
  for (const auto& msg : this->_impl_.items_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.metadata_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LimitRangeList::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LimitRangeList::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LimitRangeList::GetClassData() const { return &_class_data_; }


void LimitRangeList::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LimitRangeList*>(&to_msg);
  auto& from = static_cast<const LimitRangeList&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.LimitRangeList)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.items_.MergeFrom(from._impl_.items_);
  if (from._internal_has_metadata()) {
    _this->_internal_mutable_metadata()->::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta::MergeFrom(
        from._internal_metadata());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LimitRangeList::CopyFrom(const LimitRangeList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.LimitRangeList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LimitRangeList::IsInitialized() const {
  return true;
}

void LimitRangeList::InternalSwap(LimitRangeList* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.items_.InternalSwap(&other->_impl_.items_);
  swap(_impl_.metadata_, other->_impl_.metadata_);
}

::PROTOBUF_NAMESPACE_ID::Metadata LimitRangeList::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[92]);
}

// ===================================================================

class LimitRangeSpec::_Internal {
 public:
};

LimitRangeSpec::LimitRangeSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.LimitRangeSpec)
}
LimitRangeSpec::LimitRangeSpec(const LimitRangeSpec& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LimitRangeSpec* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.limits_){from._impl_.limits_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.LimitRangeSpec)
}

inline void LimitRangeSpec::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.limits_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

LimitRangeSpec::~LimitRangeSpec() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.LimitRangeSpec)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LimitRangeSpec::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.limits_.~RepeatedPtrField();
}

void LimitRangeSpec::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LimitRangeSpec::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.LimitRangeSpec)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.limits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LimitRangeSpec::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .k8s.io.api.core.v1.LimitRangeItem limits = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_limits(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LimitRangeSpec::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.LimitRangeSpec)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .k8s.io.api.core.v1.LimitRangeItem limits = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_limits_size()); i < n; i++) {
    const auto& repfield = this->_internal_limits(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.LimitRangeSpec)
  return target;
}

size_t LimitRangeSpec::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.LimitRangeSpec)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .k8s.io.api.core.v1.LimitRangeItem limits = 1;
  total_size += 1UL * this->_internal_limits_size();
  for (const auto& msg : this->_impl_.limits_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LimitRangeSpec::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LimitRangeSpec::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LimitRangeSpec::GetClassData() const { return &_class_data_; }


void LimitRangeSpec::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LimitRangeSpec*>(&to_msg);
  auto& from = static_cast<const LimitRangeSpec&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.LimitRangeSpec)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.limits_.MergeFrom(from._impl_.limits_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LimitRangeSpec::CopyFrom(const LimitRangeSpec& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.LimitRangeSpec)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LimitRangeSpec::IsInitialized() const {
  return true;
}

void LimitRangeSpec::InternalSwap(LimitRangeSpec* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.limits_.InternalSwap(&other->_impl_.limits_);
}

::PROTOBUF_NAMESPACE_ID::Metadata LimitRangeSpec::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[93]);
}

// ===================================================================

class List::_Internal {
 public:
  using HasBits = decltype(std::declval<List>()._impl_._has_bits_);
  static const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& metadata(const List* msg);
  static void set_has_metadata(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta&
List::_Internal::metadata(const List* msg) {
  return *msg->_impl_.metadata_;
}
void List::clear_metadata() {
  if (_impl_.metadata_ != nullptr) _impl_.metadata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void List::clear_items() {
  _impl_.items_.Clear();
}
List::List(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.List)
}
List::List(const List& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  List* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.items_){from._impl_.items_}
    , decltype(_impl_.metadata_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_metadata()) {
    _this->_impl_.metadata_ = new ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta(*from._impl_.metadata_);
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.List)
}

inline void List::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.items_){arena}
    , decltype(_impl_.metadata_){nullptr}
  };
}

List::~List() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.List)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void List::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.items_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.metadata_;
}

void List::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void List::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.List)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.items_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.metadata_ != nullptr);
    _impl_.metadata_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* List::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_metadata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .k8s.io.apimachinery.pkg.runtime.RawExtension items = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_items(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* List::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.List)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::metadata(this),
        _Internal::metadata(this).GetCachedSize(), target, stream);
  }

  // repeated .k8s.io.apimachinery.pkg.runtime.RawExtension items = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_items_size()); i < n; i++) {
    const auto& repfield = this->_internal_items(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.List)
  return target;
}

size_t List::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.List)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .k8s.io.apimachinery.pkg.runtime.RawExtension items = 2;
  total_size += 1UL * this->_internal_items_size();
  for (const auto& msg : this->_impl_.items_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.metadata_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData List::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    List::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*List::GetClassData() const { return &_class_data_; }


void List::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<List*>(&to_msg);
  auto& from = static_cast<const List&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.List)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.items_.MergeFrom(from._impl_.items_);
  if (from._internal_has_metadata()) {
    _this->_internal_mutable_metadata()->::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta::MergeFrom(
        from._internal_metadata());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void List::CopyFrom(const List& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.List)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool List::IsInitialized() const {
  return true;
}

void List::InternalSwap(List* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.items_.InternalSwap(&other->_impl_.items_);
  swap(_impl_.metadata_, other->_impl_.metadata_);
}

::PROTOBUF_NAMESPACE_ID::Metadata List::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[94]);
}

// ===================================================================

class LoadBalancerIngress::_Internal {
 public:
  using HasBits = decltype(std::declval<LoadBalancerIngress>()._impl_._has_bits_);
  static void set_has_ip(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_hostname(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_ipmode(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

LoadBalancerIngress::LoadBalancerIngress(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.LoadBalancerIngress)
}
LoadBalancerIngress::LoadBalancerIngress(const LoadBalancerIngress& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LoadBalancerIngress* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ports_){from._impl_.ports_}
    , decltype(_impl_.ip_){}
    , decltype(_impl_.hostname_){}
    , decltype(_impl_.ipmode_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.ip_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ip_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ip()) {
    _this->_impl_.ip_.Set(from._internal_ip(), 
      _this->GetArenaForAllocation());
  }
  _impl_.hostname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hostname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_hostname()) {
    _this->_impl_.hostname_.Set(from._internal_hostname(), 
      _this->GetArenaForAllocation());
  }
  _impl_.ipmode_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ipmode_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ipmode()) {
    _this->_impl_.ipmode_.Set(from._internal_ipmode(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.LoadBalancerIngress)
}

inline void LoadBalancerIngress::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ports_){arena}
    , decltype(_impl_.ip_){}
    , decltype(_impl_.hostname_){}
    , decltype(_impl_.ipmode_){}
  };
  _impl_.ip_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ip_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.hostname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hostname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.ipmode_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ipmode_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LoadBalancerIngress::~LoadBalancerIngress() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.LoadBalancerIngress)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LoadBalancerIngress::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.ports_.~RepeatedPtrField();
  _impl_.ip_.Destroy();
  _impl_.hostname_.Destroy();
  _impl_.ipmode_.Destroy();
}

void LoadBalancerIngress::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LoadBalancerIngress::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.LoadBalancerIngress)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.ports_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.ip_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.hostname_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.ipmode_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LoadBalancerIngress::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes ip = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_ip();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes hostname = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_hostname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes ipMode = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_ipmode();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .k8s.io.api.core.v1.PortStatus ports = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_ports(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LoadBalancerIngress::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.LoadBalancerIngress)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes ip = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_ip(), target);
  }

  // optional bytes hostname = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_hostname(), target);
  }

  // optional bytes ipMode = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_ipmode(), target);
  }

  // repeated .k8s.io.api.core.v1.PortStatus ports = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_ports_size()); i < n; i++) {
    const auto& repfield = this->_internal_ports(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.LoadBalancerIngress)
  return target;
}

size_t LoadBalancerIngress::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.LoadBalancerIngress)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .k8s.io.api.core.v1.PortStatus ports = 4;
  total_size += 1UL * this->_internal_ports_size();
  for (const auto& msg : this->_impl_.ports_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bytes ip = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_ip());
    }

    // optional bytes hostname = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_hostname());
    }

    // optional bytes ipMode = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_ipmode());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LoadBalancerIngress::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LoadBalancerIngress::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LoadBalancerIngress::GetClassData() const { return &_class_data_; }


void LoadBalancerIngress::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LoadBalancerIngress*>(&to_msg);
  auto& from = static_cast<const LoadBalancerIngress&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.LoadBalancerIngress)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.ports_.MergeFrom(from._impl_.ports_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_ip(from._internal_ip());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_hostname(from._internal_hostname());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_ipmode(from._internal_ipmode());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LoadBalancerIngress::CopyFrom(const LoadBalancerIngress& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.LoadBalancerIngress)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoadBalancerIngress::IsInitialized() const {
  return true;
}

void LoadBalancerIngress::InternalSwap(LoadBalancerIngress* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.ports_.InternalSwap(&other->_impl_.ports_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.ip_, lhs_arena,
      &other->_impl_.ip_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.hostname_, lhs_arena,
      &other->_impl_.hostname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.ipmode_, lhs_arena,
      &other->_impl_.ipmode_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata LoadBalancerIngress::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[95]);
}

// ===================================================================

class LoadBalancerStatus::_Internal {
 public:
};

LoadBalancerStatus::LoadBalancerStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.LoadBalancerStatus)
}
LoadBalancerStatus::LoadBalancerStatus(const LoadBalancerStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LoadBalancerStatus* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.ingress_){from._impl_.ingress_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.LoadBalancerStatus)
}

inline void LoadBalancerStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.ingress_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

LoadBalancerStatus::~LoadBalancerStatus() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.LoadBalancerStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LoadBalancerStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.ingress_.~RepeatedPtrField();
}

void LoadBalancerStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LoadBalancerStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.LoadBalancerStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.ingress_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LoadBalancerStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .k8s.io.api.core.v1.LoadBalancerIngress ingress = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_ingress(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LoadBalancerStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.LoadBalancerStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .k8s.io.api.core.v1.LoadBalancerIngress ingress = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_ingress_size()); i < n; i++) {
    const auto& repfield = this->_internal_ingress(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.LoadBalancerStatus)
  return target;
}

size_t LoadBalancerStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.LoadBalancerStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .k8s.io.api.core.v1.LoadBalancerIngress ingress = 1;
  total_size += 1UL * this->_internal_ingress_size();
  for (const auto& msg : this->_impl_.ingress_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LoadBalancerStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LoadBalancerStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LoadBalancerStatus::GetClassData() const { return &_class_data_; }


void LoadBalancerStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LoadBalancerStatus*>(&to_msg);
  auto& from = static_cast<const LoadBalancerStatus&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.LoadBalancerStatus)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.ingress_.MergeFrom(from._impl_.ingress_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LoadBalancerStatus::CopyFrom(const LoadBalancerStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.LoadBalancerStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoadBalancerStatus::IsInitialized() const {
  return true;
}

void LoadBalancerStatus::InternalSwap(LoadBalancerStatus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.ingress_.InternalSwap(&other->_impl_.ingress_);
}

::PROTOBUF_NAMESPACE_ID::Metadata LoadBalancerStatus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[96]);
}

// ===================================================================

class LocalObjectReference::_Internal {
 public:
  using HasBits = decltype(std::declval<LocalObjectReference>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

LocalObjectReference::LocalObjectReference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.LocalObjectReference)
}
LocalObjectReference::LocalObjectReference(const LocalObjectReference& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LocalObjectReference* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.LocalObjectReference)
}

inline void LocalObjectReference::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LocalObjectReference::~LocalObjectReference() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.LocalObjectReference)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LocalObjectReference::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void LocalObjectReference::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LocalObjectReference::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.LocalObjectReference)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.name_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LocalObjectReference::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LocalObjectReference::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.LocalObjectReference)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.LocalObjectReference)
  return target;
}

size_t LocalObjectReference::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.LocalObjectReference)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes name = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LocalObjectReference::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LocalObjectReference::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LocalObjectReference::GetClassData() const { return &_class_data_; }


void LocalObjectReference::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LocalObjectReference*>(&to_msg);
  auto& from = static_cast<const LocalObjectReference&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.LocalObjectReference)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_name()) {
    _this->_internal_set_name(from._internal_name());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LocalObjectReference::CopyFrom(const LocalObjectReference& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.LocalObjectReference)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LocalObjectReference::IsInitialized() const {
  return true;
}

void LocalObjectReference::InternalSwap(LocalObjectReference* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata LocalObjectReference::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[97]);
}

// ===================================================================

class LocalVolumeSource::_Internal {
 public:
  using HasBits = decltype(std::declval<LocalVolumeSource>()._impl_._has_bits_);
  static void set_has_path(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_fstype(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

LocalVolumeSource::LocalVolumeSource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.LocalVolumeSource)
}
LocalVolumeSource::LocalVolumeSource(const LocalVolumeSource& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LocalVolumeSource* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.path_){}
    , decltype(_impl_.fstype_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_path()) {
    _this->_impl_.path_.Set(from._internal_path(), 
      _this->GetArenaForAllocation());
  }
  _impl_.fstype_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fstype_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_fstype()) {
    _this->_impl_.fstype_.Set(from._internal_fstype(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.LocalVolumeSource)
}

inline void LocalVolumeSource::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.path_){}
    , decltype(_impl_.fstype_){}
  };
  _impl_.path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.fstype_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fstype_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LocalVolumeSource::~LocalVolumeSource() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.LocalVolumeSource)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LocalVolumeSource::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.path_.Destroy();
  _impl_.fstype_.Destroy();
}

void LocalVolumeSource::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LocalVolumeSource::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.LocalVolumeSource)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.path_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.fstype_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LocalVolumeSource::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes path = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_path();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes fsType = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_fstype();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LocalVolumeSource::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.LocalVolumeSource)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes path = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_path(), target);
  }

  // optional bytes fsType = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_fstype(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.LocalVolumeSource)
  return target;
}

size_t LocalVolumeSource::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.LocalVolumeSource)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes path = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_path());
    }

    // optional bytes fsType = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_fstype());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LocalVolumeSource::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LocalVolumeSource::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LocalVolumeSource::GetClassData() const { return &_class_data_; }


void LocalVolumeSource::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LocalVolumeSource*>(&to_msg);
  auto& from = static_cast<const LocalVolumeSource&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.LocalVolumeSource)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_path(from._internal_path());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_fstype(from._internal_fstype());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LocalVolumeSource::CopyFrom(const LocalVolumeSource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.LocalVolumeSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LocalVolumeSource::IsInitialized() const {
  return true;
}

void LocalVolumeSource::InternalSwap(LocalVolumeSource* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.path_, lhs_arena,
      &other->_impl_.path_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.fstype_, lhs_arena,
      &other->_impl_.fstype_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata LocalVolumeSource::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[98]);
}

// ===================================================================

class ModifyVolumeStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<ModifyVolumeStatus>()._impl_._has_bits_);
  static void set_has_targetvolumeattributesclassname(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ModifyVolumeStatus::ModifyVolumeStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.ModifyVolumeStatus)
}
ModifyVolumeStatus::ModifyVolumeStatus(const ModifyVolumeStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ModifyVolumeStatus* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.targetvolumeattributesclassname_){}
    , decltype(_impl_.status_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.targetvolumeattributesclassname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.targetvolumeattributesclassname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_targetvolumeattributesclassname()) {
    _this->_impl_.targetvolumeattributesclassname_.Set(from._internal_targetvolumeattributesclassname(), 
      _this->GetArenaForAllocation());
  }
  _impl_.status_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.status_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_status()) {
    _this->_impl_.status_.Set(from._internal_status(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.ModifyVolumeStatus)
}

inline void ModifyVolumeStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.targetvolumeattributesclassname_){}
    , decltype(_impl_.status_){}
  };
  _impl_.targetvolumeattributesclassname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.targetvolumeattributesclassname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.status_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.status_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ModifyVolumeStatus::~ModifyVolumeStatus() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.ModifyVolumeStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ModifyVolumeStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.targetvolumeattributesclassname_.Destroy();
  _impl_.status_.Destroy();
}

void ModifyVolumeStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ModifyVolumeStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.ModifyVolumeStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.targetvolumeattributesclassname_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.status_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModifyVolumeStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes targetVolumeAttributesClassName = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_targetvolumeattributesclassname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes status = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_status();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModifyVolumeStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.ModifyVolumeStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes targetVolumeAttributesClassName = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_targetvolumeattributesclassname(), target);
  }

  // optional bytes status = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_status(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.ModifyVolumeStatus)
  return target;
}

size_t ModifyVolumeStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.ModifyVolumeStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes targetVolumeAttributesClassName = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_targetvolumeattributesclassname());
    }

    // optional bytes status = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_status());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModifyVolumeStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ModifyVolumeStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModifyVolumeStatus::GetClassData() const { return &_class_data_; }


void ModifyVolumeStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ModifyVolumeStatus*>(&to_msg);
  auto& from = static_cast<const ModifyVolumeStatus&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.ModifyVolumeStatus)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_targetvolumeattributesclassname(from._internal_targetvolumeattributesclassname());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_status(from._internal_status());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModifyVolumeStatus::CopyFrom(const ModifyVolumeStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.ModifyVolumeStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModifyVolumeStatus::IsInitialized() const {
  return true;
}

void ModifyVolumeStatus::InternalSwap(ModifyVolumeStatus* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.targetvolumeattributesclassname_, lhs_arena,
      &other->_impl_.targetvolumeattributesclassname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.status_, lhs_arena,
      &other->_impl_.status_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ModifyVolumeStatus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[99]);
}

// ===================================================================

class NFSVolumeSource::_Internal {
 public:
  using HasBits = decltype(std::declval<NFSVolumeSource>()._impl_._has_bits_);
  static void set_has_server(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_path(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_readonly(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

NFSVolumeSource::NFSVolumeSource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.NFSVolumeSource)
}
NFSVolumeSource::NFSVolumeSource(const NFSVolumeSource& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NFSVolumeSource* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.server_){}
    , decltype(_impl_.path_){}
    , decltype(_impl_.readonly_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.server_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.server_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_server()) {
    _this->_impl_.server_.Set(from._internal_server(), 
      _this->GetArenaForAllocation());
  }
  _impl_.path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_path()) {
    _this->_impl_.path_.Set(from._internal_path(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.readonly_ = from._impl_.readonly_;
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.NFSVolumeSource)
}

inline void NFSVolumeSource::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.server_){}
    , decltype(_impl_.path_){}
    , decltype(_impl_.readonly_){false}
  };
  _impl_.server_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.server_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NFSVolumeSource::~NFSVolumeSource() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.NFSVolumeSource)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NFSVolumeSource::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.server_.Destroy();
  _impl_.path_.Destroy();
}

void NFSVolumeSource::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NFSVolumeSource::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.NFSVolumeSource)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.server_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.path_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.readonly_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NFSVolumeSource::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes server = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_server();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes path = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_path();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool readOnly = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_readonly(&has_bits);
          _impl_.readonly_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NFSVolumeSource::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.NFSVolumeSource)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes server = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_server(), target);
  }

  // optional bytes path = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_path(), target);
  }

  // optional bool readOnly = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_readonly(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.NFSVolumeSource)
  return target;
}

size_t NFSVolumeSource::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.NFSVolumeSource)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bytes server = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_server());
    }

    // optional bytes path = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_path());
    }

    // optional bool readOnly = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NFSVolumeSource::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NFSVolumeSource::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NFSVolumeSource::GetClassData() const { return &_class_data_; }


void NFSVolumeSource::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NFSVolumeSource*>(&to_msg);
  auto& from = static_cast<const NFSVolumeSource&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.NFSVolumeSource)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_server(from._internal_server());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_path(from._internal_path());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.readonly_ = from._impl_.readonly_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NFSVolumeSource::CopyFrom(const NFSVolumeSource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.NFSVolumeSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NFSVolumeSource::IsInitialized() const {
  return true;
}

void NFSVolumeSource::InternalSwap(NFSVolumeSource* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.server_, lhs_arena,
      &other->_impl_.server_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.path_, lhs_arena,
      &other->_impl_.path_, rhs_arena
  );
  swap(_impl_.readonly_, other->_impl_.readonly_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NFSVolumeSource::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[100]);
}

// ===================================================================

class Namespace::_Internal {
 public:
  using HasBits = decltype(std::declval<Namespace>()._impl_._has_bits_);
  static const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& metadata(const Namespace* msg);
  static void set_has_metadata(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::k8s::io::api::core::v1::NamespaceSpec& spec(const Namespace* msg);
  static void set_has_spec(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::k8s::io::api::core::v1::NamespaceStatus& status(const Namespace* msg);
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta&
Namespace::_Internal::metadata(const Namespace* msg) {
  return *msg->_impl_.metadata_;
}
const ::k8s::io::api::core::v1::NamespaceSpec&
Namespace::_Internal::spec(const Namespace* msg) {
  return *msg->_impl_.spec_;
}
const ::k8s::io::api::core::v1::NamespaceStatus&
Namespace::_Internal::status(const Namespace* msg) {
  return *msg->_impl_.status_;
}
void Namespace::clear_metadata() {
  if (_impl_.metadata_ != nullptr) _impl_.metadata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
Namespace::Namespace(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.Namespace)
}
Namespace::Namespace(const Namespace& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Namespace* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.metadata_){nullptr}
    , decltype(_impl_.spec_){nullptr}
    , decltype(_impl_.status_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_metadata()) {
    _this->_impl_.metadata_ = new ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta(*from._impl_.metadata_);
  }
  if (from._internal_has_spec()) {
    _this->_impl_.spec_ = new ::k8s::io::api::core::v1::NamespaceSpec(*from._impl_.spec_);
  }
  if (from._internal_has_status()) {
    _this->_impl_.status_ = new ::k8s::io::api::core::v1::NamespaceStatus(*from._impl_.status_);
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.Namespace)
}

inline void Namespace::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.metadata_){nullptr}
    , decltype(_impl_.spec_){nullptr}
    , decltype(_impl_.status_){nullptr}
  };
}

Namespace::~Namespace() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.Namespace)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Namespace::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.metadata_;
  if (this != internal_default_instance()) delete _impl_.spec_;
  if (this != internal_default_instance()) delete _impl_.status_;
}

void Namespace::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Namespace::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.Namespace)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.metadata_ != nullptr);
      _impl_.metadata_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.spec_ != nullptr);
      _impl_.spec_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.status_ != nullptr);
      _impl_.status_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Namespace::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_metadata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.NamespaceSpec spec = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_spec(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.NamespaceStatus status = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_status(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Namespace::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.Namespace)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::metadata(this),
        _Internal::metadata(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.NamespaceSpec spec = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::spec(this),
        _Internal::spec(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.NamespaceStatus status = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::status(this),
        _Internal::status(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.Namespace)
  return target;
}

size_t Namespace::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.Namespace)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.metadata_);
    }

    // optional .k8s.io.api.core.v1.NamespaceSpec spec = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.spec_);
    }

    // optional .k8s.io.api.core.v1.NamespaceStatus status = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.status_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Namespace::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Namespace::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Namespace::GetClassData() const { return &_class_data_; }


void Namespace::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Namespace*>(&to_msg);
  auto& from = static_cast<const Namespace&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.Namespace)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_metadata()->::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta::MergeFrom(
          from._internal_metadata());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_spec()->::k8s::io::api::core::v1::NamespaceSpec::MergeFrom(
          from._internal_spec());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_status()->::k8s::io::api::core::v1::NamespaceStatus::MergeFrom(
          from._internal_status());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Namespace::CopyFrom(const Namespace& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.Namespace)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Namespace::IsInitialized() const {
  return true;
}

void Namespace::InternalSwap(Namespace* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Namespace, _impl_.status_)
      + sizeof(Namespace::_impl_.status_)
      - PROTOBUF_FIELD_OFFSET(Namespace, _impl_.metadata_)>(
          reinterpret_cast<char*>(&_impl_.metadata_),
          reinterpret_cast<char*>(&other->_impl_.metadata_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Namespace::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[101]);
}

// ===================================================================

class NamespaceCondition::_Internal {
 public:
  using HasBits = decltype(std::declval<NamespaceCondition>()._impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::k8s::io::apimachinery::pkg::apis::meta::v1::Time& lasttransitiontime(const NamespaceCondition* msg);
  static void set_has_lasttransitiontime(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_reason(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_message(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::k8s::io::apimachinery::pkg::apis::meta::v1::Time&
NamespaceCondition::_Internal::lasttransitiontime(const NamespaceCondition* msg) {
  return *msg->_impl_.lasttransitiontime_;
}
void NamespaceCondition::clear_lasttransitiontime() {
  if (_impl_.lasttransitiontime_ != nullptr) _impl_.lasttransitiontime_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
NamespaceCondition::NamespaceCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.NamespaceCondition)
}
NamespaceCondition::NamespaceCondition(const NamespaceCondition& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NamespaceCondition* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.type_){}
    , decltype(_impl_.status_){}
    , decltype(_impl_.reason_){}
    , decltype(_impl_.message_){}
    , decltype(_impl_.lasttransitiontime_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_type()) {
    _this->_impl_.type_.Set(from._internal_type(), 
      _this->GetArenaForAllocation());
  }
  _impl_.status_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.status_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_status()) {
    _this->_impl_.status_.Set(from._internal_status(), 
      _this->GetArenaForAllocation());
  }
  _impl_.reason_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.reason_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_reason()) {
    _this->_impl_.reason_.Set(from._internal_reason(), 
      _this->GetArenaForAllocation());
  }
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_message()) {
    _this->_impl_.message_.Set(from._internal_message(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_lasttransitiontime()) {
    _this->_impl_.lasttransitiontime_ = new ::k8s::io::apimachinery::pkg::apis::meta::v1::Time(*from._impl_.lasttransitiontime_);
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.NamespaceCondition)
}

inline void NamespaceCondition::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.type_){}
    , decltype(_impl_.status_){}
    , decltype(_impl_.reason_){}
    , decltype(_impl_.message_){}
    , decltype(_impl_.lasttransitiontime_){nullptr}
  };
  _impl_.type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.status_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.status_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.reason_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.reason_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NamespaceCondition::~NamespaceCondition() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.NamespaceCondition)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NamespaceCondition::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.type_.Destroy();
  _impl_.status_.Destroy();
  _impl_.reason_.Destroy();
  _impl_.message_.Destroy();
  if (this != internal_default_instance()) delete _impl_.lasttransitiontime_;
}

void NamespaceCondition::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NamespaceCondition::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.NamespaceCondition)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.type_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.status_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.reason_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.message_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.lasttransitiontime_ != nullptr);
      _impl_.lasttransitiontime_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NamespaceCondition::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes status = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_status();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_lasttransitiontime(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes reason = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_reason();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes message = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NamespaceCondition::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.NamespaceCondition)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_type(), target);
  }

  // optional bytes status = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_status(), target);
  }

  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 4;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::lasttransitiontime(this),
        _Internal::lasttransitiontime(this).GetCachedSize(), target, stream);
  }

  // optional bytes reason = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_reason(), target);
  }

  // optional bytes message = 6;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        6, this->_internal_message(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.NamespaceCondition)
  return target;
}

size_t NamespaceCondition::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.NamespaceCondition)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional bytes type = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_type());
    }

    // optional bytes status = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_status());
    }

    // optional bytes reason = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_reason());
    }

    // optional bytes message = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_message());
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.lasttransitiontime_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NamespaceCondition::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NamespaceCondition::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NamespaceCondition::GetClassData() const { return &_class_data_; }


void NamespaceCondition::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NamespaceCondition*>(&to_msg);
  auto& from = static_cast<const NamespaceCondition&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.NamespaceCondition)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_type(from._internal_type());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_status(from._internal_status());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_reason(from._internal_reason());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_message(from._internal_message());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_lasttransitiontime()->::k8s::io::apimachinery::pkg::apis::meta::v1::Time::MergeFrom(
          from._internal_lasttransitiontime());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NamespaceCondition::CopyFrom(const NamespaceCondition& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.NamespaceCondition)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NamespaceCondition::IsInitialized() const {
  return true;
}

void NamespaceCondition::InternalSwap(NamespaceCondition* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.type_, lhs_arena,
      &other->_impl_.type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.status_, lhs_arena,
      &other->_impl_.status_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.reason_, lhs_arena,
      &other->_impl_.reason_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.message_, lhs_arena,
      &other->_impl_.message_, rhs_arena
  );
  swap(_impl_.lasttransitiontime_, other->_impl_.lasttransitiontime_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NamespaceCondition::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[102]);
}

// ===================================================================

class NamespaceList::_Internal {
 public:
  using HasBits = decltype(std::declval<NamespaceList>()._impl_._has_bits_);
  static const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& metadata(const NamespaceList* msg);
  static void set_has_metadata(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta&
NamespaceList::_Internal::metadata(const NamespaceList* msg) {
  return *msg->_impl_.metadata_;
}
void NamespaceList::clear_metadata() {
  if (_impl_.metadata_ != nullptr) _impl_.metadata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
NamespaceList::NamespaceList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.NamespaceList)
}
NamespaceList::NamespaceList(const NamespaceList& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NamespaceList* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.items_){from._impl_.items_}
    , decltype(_impl_.metadata_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_metadata()) {
    _this->_impl_.metadata_ = new ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta(*from._impl_.metadata_);
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.NamespaceList)
}

inline void NamespaceList::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.items_){arena}
    , decltype(_impl_.metadata_){nullptr}
  };
}

NamespaceList::~NamespaceList() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.NamespaceList)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NamespaceList::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.items_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.metadata_;
}

void NamespaceList::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NamespaceList::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.NamespaceList)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.items_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.metadata_ != nullptr);
    _impl_.metadata_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NamespaceList::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_metadata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .k8s.io.api.core.v1.Namespace items = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_items(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NamespaceList::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.NamespaceList)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::metadata(this),
        _Internal::metadata(this).GetCachedSize(), target, stream);
  }

  // repeated .k8s.io.api.core.v1.Namespace items = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_items_size()); i < n; i++) {
    const auto& repfield = this->_internal_items(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.NamespaceList)
  return target;
}

size_t NamespaceList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.NamespaceList)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .k8s.io.api.core.v1.Namespace items = 2;
  total_size += 1UL * this->_internal_items_size();
  for (const auto& msg : this->_impl_.items_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.metadata_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NamespaceList::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NamespaceList::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NamespaceList::GetClassData() const { return &_class_data_; }


void NamespaceList::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NamespaceList*>(&to_msg);
  auto& from = static_cast<const NamespaceList&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.NamespaceList)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.items_.MergeFrom(from._impl_.items_);
  if (from._internal_has_metadata()) {
    _this->_internal_mutable_metadata()->::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta::MergeFrom(
        from._internal_metadata());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NamespaceList::CopyFrom(const NamespaceList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.NamespaceList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NamespaceList::IsInitialized() const {
  return true;
}

void NamespaceList::InternalSwap(NamespaceList* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.items_.InternalSwap(&other->_impl_.items_);
  swap(_impl_.metadata_, other->_impl_.metadata_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NamespaceList::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[103]);
}

// ===================================================================

class NamespaceSpec::_Internal {
 public:
};

NamespaceSpec::NamespaceSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.NamespaceSpec)
}
NamespaceSpec::NamespaceSpec(const NamespaceSpec& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NamespaceSpec* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.finalizers_){from._impl_.finalizers_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.NamespaceSpec)
}

inline void NamespaceSpec::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.finalizers_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

NamespaceSpec::~NamespaceSpec() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.NamespaceSpec)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NamespaceSpec::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.finalizers_.~RepeatedPtrField();
}

void NamespaceSpec::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NamespaceSpec::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.NamespaceSpec)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.finalizers_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NamespaceSpec::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string finalizers = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_finalizers();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "k8s.io.api.core.v1.NamespaceSpec.finalizers");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NamespaceSpec::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.NamespaceSpec)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string finalizers = 1;
  for (int i = 0, n = this->_internal_finalizers_size(); i < n; i++) {
    const auto& s = this->_internal_finalizers(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "k8s.io.api.core.v1.NamespaceSpec.finalizers");
    target = stream->WriteString(1, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.NamespaceSpec)
  return target;
}

size_t NamespaceSpec::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.NamespaceSpec)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string finalizers = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.finalizers_.size());
  for (int i = 0, n = _impl_.finalizers_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.finalizers_.Get(i));
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NamespaceSpec::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NamespaceSpec::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NamespaceSpec::GetClassData() const { return &_class_data_; }


void NamespaceSpec::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NamespaceSpec*>(&to_msg);
  auto& from = static_cast<const NamespaceSpec&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.NamespaceSpec)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.finalizers_.MergeFrom(from._impl_.finalizers_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NamespaceSpec::CopyFrom(const NamespaceSpec& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.NamespaceSpec)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NamespaceSpec::IsInitialized() const {
  return true;
}

void NamespaceSpec::InternalSwap(NamespaceSpec* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.finalizers_.InternalSwap(&other->_impl_.finalizers_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NamespaceSpec::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[104]);
}

// ===================================================================

class NamespaceStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<NamespaceStatus>()._impl_._has_bits_);
  static void set_has_phase(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

NamespaceStatus::NamespaceStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.NamespaceStatus)
}
NamespaceStatus::NamespaceStatus(const NamespaceStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NamespaceStatus* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.conditions_){from._impl_.conditions_}
    , decltype(_impl_.phase_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.phase_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.phase_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_phase()) {
    _this->_impl_.phase_.Set(from._internal_phase(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.NamespaceStatus)
}

inline void NamespaceStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.conditions_){arena}
    , decltype(_impl_.phase_){}
  };
  _impl_.phase_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.phase_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NamespaceStatus::~NamespaceStatus() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.NamespaceStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NamespaceStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.conditions_.~RepeatedPtrField();
  _impl_.phase_.Destroy();
}

void NamespaceStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NamespaceStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.NamespaceStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.conditions_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.phase_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NamespaceStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes phase = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_phase();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .k8s.io.api.core.v1.NamespaceCondition conditions = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_conditions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NamespaceStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.NamespaceStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes phase = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_phase(), target);
  }

  // repeated .k8s.io.api.core.v1.NamespaceCondition conditions = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_conditions_size()); i < n; i++) {
    const auto& repfield = this->_internal_conditions(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.NamespaceStatus)
  return target;
}

size_t NamespaceStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.NamespaceStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .k8s.io.api.core.v1.NamespaceCondition conditions = 2;
  total_size += 1UL * this->_internal_conditions_size();
  for (const auto& msg : this->_impl_.conditions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional bytes phase = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_phase());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NamespaceStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NamespaceStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NamespaceStatus::GetClassData() const { return &_class_data_; }


void NamespaceStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NamespaceStatus*>(&to_msg);
  auto& from = static_cast<const NamespaceStatus&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.NamespaceStatus)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.conditions_.MergeFrom(from._impl_.conditions_);
  if (from._internal_has_phase()) {
    _this->_internal_set_phase(from._internal_phase());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NamespaceStatus::CopyFrom(const NamespaceStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.NamespaceStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NamespaceStatus::IsInitialized() const {
  return true;
}

void NamespaceStatus::InternalSwap(NamespaceStatus* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.conditions_.InternalSwap(&other->_impl_.conditions_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.phase_, lhs_arena,
      &other->_impl_.phase_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata NamespaceStatus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[105]);
}

// ===================================================================

class Node::_Internal {
 public:
  using HasBits = decltype(std::declval<Node>()._impl_._has_bits_);
  static const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& metadata(const Node* msg);
  static void set_has_metadata(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::k8s::io::api::core::v1::NodeSpec& spec(const Node* msg);
  static void set_has_spec(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::k8s::io::api::core::v1::NodeStatus& status(const Node* msg);
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta&
Node::_Internal::metadata(const Node* msg) {
  return *msg->_impl_.metadata_;
}
const ::k8s::io::api::core::v1::NodeSpec&
Node::_Internal::spec(const Node* msg) {
  return *msg->_impl_.spec_;
}
const ::k8s::io::api::core::v1::NodeStatus&
Node::_Internal::status(const Node* msg) {
  return *msg->_impl_.status_;
}
void Node::clear_metadata() {
  if (_impl_.metadata_ != nullptr) _impl_.metadata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
Node::Node(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.Node)
}
Node::Node(const Node& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Node* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.metadata_){nullptr}
    , decltype(_impl_.spec_){nullptr}
    , decltype(_impl_.status_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_metadata()) {
    _this->_impl_.metadata_ = new ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta(*from._impl_.metadata_);
  }
  if (from._internal_has_spec()) {
    _this->_impl_.spec_ = new ::k8s::io::api::core::v1::NodeSpec(*from._impl_.spec_);
  }
  if (from._internal_has_status()) {
    _this->_impl_.status_ = new ::k8s::io::api::core::v1::NodeStatus(*from._impl_.status_);
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.Node)
}

inline void Node::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.metadata_){nullptr}
    , decltype(_impl_.spec_){nullptr}
    , decltype(_impl_.status_){nullptr}
  };
}

Node::~Node() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.Node)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Node::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.metadata_;
  if (this != internal_default_instance()) delete _impl_.spec_;
  if (this != internal_default_instance()) delete _impl_.status_;
}

void Node::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Node::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.Node)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.metadata_ != nullptr);
      _impl_.metadata_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.spec_ != nullptr);
      _impl_.spec_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.status_ != nullptr);
      _impl_.status_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Node::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_metadata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.NodeSpec spec = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_spec(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.NodeStatus status = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_status(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Node::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.Node)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::metadata(this),
        _Internal::metadata(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.NodeSpec spec = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::spec(this),
        _Internal::spec(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.NodeStatus status = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::status(this),
        _Internal::status(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.Node)
  return target;
}

size_t Node::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.Node)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.metadata_);
    }

    // optional .k8s.io.api.core.v1.NodeSpec spec = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.spec_);
    }

    // optional .k8s.io.api.core.v1.NodeStatus status = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.status_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Node::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Node::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Node::GetClassData() const { return &_class_data_; }


void Node::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Node*>(&to_msg);
  auto& from = static_cast<const Node&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.Node)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_metadata()->::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta::MergeFrom(
          from._internal_metadata());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_spec()->::k8s::io::api::core::v1::NodeSpec::MergeFrom(
          from._internal_spec());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_status()->::k8s::io::api::core::v1::NodeStatus::MergeFrom(
          from._internal_status());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Node::CopyFrom(const Node& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.Node)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Node::IsInitialized() const {
  return true;
}

void Node::InternalSwap(Node* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Node, _impl_.status_)
      + sizeof(Node::_impl_.status_)
      - PROTOBUF_FIELD_OFFSET(Node, _impl_.metadata_)>(
          reinterpret_cast<char*>(&_impl_.metadata_),
          reinterpret_cast<char*>(&other->_impl_.metadata_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Node::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[106]);
}

// ===================================================================

class NodeAddress::_Internal {
 public:
  using HasBits = decltype(std::declval<NodeAddress>()._impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_address(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

NodeAddress::NodeAddress(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.NodeAddress)
}
NodeAddress::NodeAddress(const NodeAddress& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NodeAddress* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.type_){}
    , decltype(_impl_.address_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_type()) {
    _this->_impl_.type_.Set(from._internal_type(), 
      _this->GetArenaForAllocation());
  }
  _impl_.address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_address()) {
    _this->_impl_.address_.Set(from._internal_address(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.NodeAddress)
}

inline void NodeAddress::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.type_){}
    , decltype(_impl_.address_){}
  };
  _impl_.type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NodeAddress::~NodeAddress() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.NodeAddress)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NodeAddress::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.type_.Destroy();
  _impl_.address_.Destroy();
}

void NodeAddress::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NodeAddress::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.NodeAddress)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.type_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.address_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NodeAddress::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes address = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_address();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NodeAddress::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.NodeAddress)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_type(), target);
  }

  // optional bytes address = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_address(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.NodeAddress)
  return target;
}

size_t NodeAddress::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.NodeAddress)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes type = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_type());
    }

    // optional bytes address = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_address());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NodeAddress::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NodeAddress::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NodeAddress::GetClassData() const { return &_class_data_; }


void NodeAddress::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NodeAddress*>(&to_msg);
  auto& from = static_cast<const NodeAddress&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.NodeAddress)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_type(from._internal_type());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_address(from._internal_address());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NodeAddress::CopyFrom(const NodeAddress& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.NodeAddress)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NodeAddress::IsInitialized() const {
  return true;
}

void NodeAddress::InternalSwap(NodeAddress* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.type_, lhs_arena,
      &other->_impl_.type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.address_, lhs_arena,
      &other->_impl_.address_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata NodeAddress::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[107]);
}

// ===================================================================

class NodeAffinity::_Internal {
 public:
  using HasBits = decltype(std::declval<NodeAffinity>()._impl_._has_bits_);
  static const ::k8s::io::api::core::v1::NodeSelector& requiredduringschedulingignoredduringexecution(const NodeAffinity* msg);
  static void set_has_requiredduringschedulingignoredduringexecution(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::k8s::io::api::core::v1::NodeSelector&
NodeAffinity::_Internal::requiredduringschedulingignoredduringexecution(const NodeAffinity* msg) {
  return *msg->_impl_.requiredduringschedulingignoredduringexecution_;
}
NodeAffinity::NodeAffinity(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.NodeAffinity)
}
NodeAffinity::NodeAffinity(const NodeAffinity& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NodeAffinity* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.preferredduringschedulingignoredduringexecution_){from._impl_.preferredduringschedulingignoredduringexecution_}
    , decltype(_impl_.requiredduringschedulingignoredduringexecution_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_requiredduringschedulingignoredduringexecution()) {
    _this->_impl_.requiredduringschedulingignoredduringexecution_ = new ::k8s::io::api::core::v1::NodeSelector(*from._impl_.requiredduringschedulingignoredduringexecution_);
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.NodeAffinity)
}

inline void NodeAffinity::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.preferredduringschedulingignoredduringexecution_){arena}
    , decltype(_impl_.requiredduringschedulingignoredduringexecution_){nullptr}
  };
}

NodeAffinity::~NodeAffinity() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.NodeAffinity)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NodeAffinity::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.preferredduringschedulingignoredduringexecution_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.requiredduringschedulingignoredduringexecution_;
}

void NodeAffinity::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NodeAffinity::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.NodeAffinity)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.preferredduringschedulingignoredduringexecution_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.requiredduringschedulingignoredduringexecution_ != nullptr);
    _impl_.requiredduringschedulingignoredduringexecution_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NodeAffinity::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .k8s.io.api.core.v1.NodeSelector requiredDuringSchedulingIgnoredDuringExecution = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_requiredduringschedulingignoredduringexecution(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .k8s.io.api.core.v1.PreferredSchedulingTerm preferredDuringSchedulingIgnoredDuringExecution = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_preferredduringschedulingignoredduringexecution(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NodeAffinity::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.NodeAffinity)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .k8s.io.api.core.v1.NodeSelector requiredDuringSchedulingIgnoredDuringExecution = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::requiredduringschedulingignoredduringexecution(this),
        _Internal::requiredduringschedulingignoredduringexecution(this).GetCachedSize(), target, stream);
  }

  // repeated .k8s.io.api.core.v1.PreferredSchedulingTerm preferredDuringSchedulingIgnoredDuringExecution = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_preferredduringschedulingignoredduringexecution_size()); i < n; i++) {
    const auto& repfield = this->_internal_preferredduringschedulingignoredduringexecution(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.NodeAffinity)
  return target;
}

size_t NodeAffinity::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.NodeAffinity)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .k8s.io.api.core.v1.PreferredSchedulingTerm preferredDuringSchedulingIgnoredDuringExecution = 2;
  total_size += 1UL * this->_internal_preferredduringschedulingignoredduringexecution_size();
  for (const auto& msg : this->_impl_.preferredduringschedulingignoredduringexecution_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .k8s.io.api.core.v1.NodeSelector requiredDuringSchedulingIgnoredDuringExecution = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.requiredduringschedulingignoredduringexecution_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NodeAffinity::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NodeAffinity::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NodeAffinity::GetClassData() const { return &_class_data_; }


void NodeAffinity::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NodeAffinity*>(&to_msg);
  auto& from = static_cast<const NodeAffinity&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.NodeAffinity)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.preferredduringschedulingignoredduringexecution_.MergeFrom(from._impl_.preferredduringschedulingignoredduringexecution_);
  if (from._internal_has_requiredduringschedulingignoredduringexecution()) {
    _this->_internal_mutable_requiredduringschedulingignoredduringexecution()->::k8s::io::api::core::v1::NodeSelector::MergeFrom(
        from._internal_requiredduringschedulingignoredduringexecution());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NodeAffinity::CopyFrom(const NodeAffinity& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.NodeAffinity)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NodeAffinity::IsInitialized() const {
  return true;
}

void NodeAffinity::InternalSwap(NodeAffinity* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.preferredduringschedulingignoredduringexecution_.InternalSwap(&other->_impl_.preferredduringschedulingignoredduringexecution_);
  swap(_impl_.requiredduringschedulingignoredduringexecution_, other->_impl_.requiredduringschedulingignoredduringexecution_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NodeAffinity::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[108]);
}

// ===================================================================

class NodeCondition::_Internal {
 public:
  using HasBits = decltype(std::declval<NodeCondition>()._impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::k8s::io::apimachinery::pkg::apis::meta::v1::Time& lastheartbeattime(const NodeCondition* msg);
  static void set_has_lastheartbeattime(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::k8s::io::apimachinery::pkg::apis::meta::v1::Time& lasttransitiontime(const NodeCondition* msg);
  static void set_has_lasttransitiontime(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_reason(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_message(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::k8s::io::apimachinery::pkg::apis::meta::v1::Time&
NodeCondition::_Internal::lastheartbeattime(const NodeCondition* msg) {
  return *msg->_impl_.lastheartbeattime_;
}
const ::k8s::io::apimachinery::pkg::apis::meta::v1::Time&
NodeCondition::_Internal::lasttransitiontime(const NodeCondition* msg) {
  return *msg->_impl_.lasttransitiontime_;
}
void NodeCondition::clear_lastheartbeattime() {
  if (_impl_.lastheartbeattime_ != nullptr) _impl_.lastheartbeattime_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
void NodeCondition::clear_lasttransitiontime() {
  if (_impl_.lasttransitiontime_ != nullptr) _impl_.lasttransitiontime_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
NodeCondition::NodeCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.NodeCondition)
}
NodeCondition::NodeCondition(const NodeCondition& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NodeCondition* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.type_){}
    , decltype(_impl_.status_){}
    , decltype(_impl_.reason_){}
    , decltype(_impl_.message_){}
    , decltype(_impl_.lastheartbeattime_){nullptr}
    , decltype(_impl_.lasttransitiontime_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_type()) {
    _this->_impl_.type_.Set(from._internal_type(), 
      _this->GetArenaForAllocation());
  }
  _impl_.status_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.status_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_status()) {
    _this->_impl_.status_.Set(from._internal_status(), 
      _this->GetArenaForAllocation());
  }
  _impl_.reason_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.reason_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_reason()) {
    _this->_impl_.reason_.Set(from._internal_reason(), 
      _this->GetArenaForAllocation());
  }
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_message()) {
    _this->_impl_.message_.Set(from._internal_message(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_lastheartbeattime()) {
    _this->_impl_.lastheartbeattime_ = new ::k8s::io::apimachinery::pkg::apis::meta::v1::Time(*from._impl_.lastheartbeattime_);
  }
  if (from._internal_has_lasttransitiontime()) {
    _this->_impl_.lasttransitiontime_ = new ::k8s::io::apimachinery::pkg::apis::meta::v1::Time(*from._impl_.lasttransitiontime_);
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.NodeCondition)
}

inline void NodeCondition::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.type_){}
    , decltype(_impl_.status_){}
    , decltype(_impl_.reason_){}
    , decltype(_impl_.message_){}
    , decltype(_impl_.lastheartbeattime_){nullptr}
    , decltype(_impl_.lasttransitiontime_){nullptr}
  };
  _impl_.type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.status_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.status_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.reason_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.reason_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NodeCondition::~NodeCondition() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.NodeCondition)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NodeCondition::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.type_.Destroy();
  _impl_.status_.Destroy();
  _impl_.reason_.Destroy();
  _impl_.message_.Destroy();
  if (this != internal_default_instance()) delete _impl_.lastheartbeattime_;
  if (this != internal_default_instance()) delete _impl_.lasttransitiontime_;
}

void NodeCondition::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NodeCondition::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.NodeCondition)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.type_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.status_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.reason_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.message_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.lastheartbeattime_ != nullptr);
      _impl_.lastheartbeattime_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.lasttransitiontime_ != nullptr);
      _impl_.lasttransitiontime_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NodeCondition::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes status = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_status();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastHeartbeatTime = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_lastheartbeattime(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_lasttransitiontime(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes reason = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_reason();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes message = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NodeCondition::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.NodeCondition)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_type(), target);
  }

  // optional bytes status = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_status(), target);
  }

  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastHeartbeatTime = 3;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::lastheartbeattime(this),
        _Internal::lastheartbeattime(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 4;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::lasttransitiontime(this),
        _Internal::lasttransitiontime(this).GetCachedSize(), target, stream);
  }

  // optional bytes reason = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_reason(), target);
  }

  // optional bytes message = 6;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        6, this->_internal_message(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.NodeCondition)
  return target;
}

size_t NodeCondition::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.NodeCondition)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional bytes type = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_type());
    }

    // optional bytes status = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_status());
    }

    // optional bytes reason = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_reason());
    }

    // optional bytes message = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_message());
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastHeartbeatTime = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.lastheartbeattime_);
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.lasttransitiontime_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NodeCondition::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NodeCondition::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NodeCondition::GetClassData() const { return &_class_data_; }


void NodeCondition::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NodeCondition*>(&to_msg);
  auto& from = static_cast<const NodeCondition&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.NodeCondition)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_type(from._internal_type());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_status(from._internal_status());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_reason(from._internal_reason());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_message(from._internal_message());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_lastheartbeattime()->::k8s::io::apimachinery::pkg::apis::meta::v1::Time::MergeFrom(
          from._internal_lastheartbeattime());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_lasttransitiontime()->::k8s::io::apimachinery::pkg::apis::meta::v1::Time::MergeFrom(
          from._internal_lasttransitiontime());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NodeCondition::CopyFrom(const NodeCondition& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.NodeCondition)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NodeCondition::IsInitialized() const {
  return true;
}

void NodeCondition::InternalSwap(NodeCondition* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.type_, lhs_arena,
      &other->_impl_.type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.status_, lhs_arena,
      &other->_impl_.status_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.reason_, lhs_arena,
      &other->_impl_.reason_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.message_, lhs_arena,
      &other->_impl_.message_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NodeCondition, _impl_.lasttransitiontime_)
      + sizeof(NodeCondition::_impl_.lasttransitiontime_)
      - PROTOBUF_FIELD_OFFSET(NodeCondition, _impl_.lastheartbeattime_)>(
          reinterpret_cast<char*>(&_impl_.lastheartbeattime_),
          reinterpret_cast<char*>(&other->_impl_.lastheartbeattime_));
}

::PROTOBUF_NAMESPACE_ID::Metadata NodeCondition::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[109]);
}

// ===================================================================

class NodeConfigSource::_Internal {
 public:
  using HasBits = decltype(std::declval<NodeConfigSource>()._impl_._has_bits_);
  static const ::k8s::io::api::core::v1::ConfigMapNodeConfigSource& configmap(const NodeConfigSource* msg);
  static void set_has_configmap(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::k8s::io::api::core::v1::ConfigMapNodeConfigSource&
NodeConfigSource::_Internal::configmap(const NodeConfigSource* msg) {
  return *msg->_impl_.configmap_;
}
NodeConfigSource::NodeConfigSource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.NodeConfigSource)
}
NodeConfigSource::NodeConfigSource(const NodeConfigSource& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NodeConfigSource* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.configmap_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_configmap()) {
    _this->_impl_.configmap_ = new ::k8s::io::api::core::v1::ConfigMapNodeConfigSource(*from._impl_.configmap_);
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.NodeConfigSource)
}

inline void NodeConfigSource::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.configmap_){nullptr}
  };
}

NodeConfigSource::~NodeConfigSource() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.NodeConfigSource)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NodeConfigSource::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.configmap_;
}

void NodeConfigSource::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NodeConfigSource::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.NodeConfigSource)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.configmap_ != nullptr);
    _impl_.configmap_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NodeConfigSource::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .k8s.io.api.core.v1.ConfigMapNodeConfigSource configMap = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_configmap(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NodeConfigSource::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.NodeConfigSource)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .k8s.io.api.core.v1.ConfigMapNodeConfigSource configMap = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::configmap(this),
        _Internal::configmap(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.NodeConfigSource)
  return target;
}

size_t NodeConfigSource::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.NodeConfigSource)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .k8s.io.api.core.v1.ConfigMapNodeConfigSource configMap = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.configmap_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NodeConfigSource::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NodeConfigSource::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NodeConfigSource::GetClassData() const { return &_class_data_; }


void NodeConfigSource::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NodeConfigSource*>(&to_msg);
  auto& from = static_cast<const NodeConfigSource&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.NodeConfigSource)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_configmap()) {
    _this->_internal_mutable_configmap()->::k8s::io::api::core::v1::ConfigMapNodeConfigSource::MergeFrom(
        from._internal_configmap());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NodeConfigSource::CopyFrom(const NodeConfigSource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.NodeConfigSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NodeConfigSource::IsInitialized() const {
  return true;
}

void NodeConfigSource::InternalSwap(NodeConfigSource* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.configmap_, other->_impl_.configmap_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NodeConfigSource::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[110]);
}

// ===================================================================

class NodeConfigStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<NodeConfigStatus>()._impl_._has_bits_);
  static const ::k8s::io::api::core::v1::NodeConfigSource& assigned(const NodeConfigStatus* msg);
  static void set_has_assigned(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::k8s::io::api::core::v1::NodeConfigSource& active(const NodeConfigStatus* msg);
  static void set_has_active(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::k8s::io::api::core::v1::NodeConfigSource& lastknowngood(const NodeConfigStatus* msg);
  static void set_has_lastknowngood(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::k8s::io::api::core::v1::NodeConfigSource&
NodeConfigStatus::_Internal::assigned(const NodeConfigStatus* msg) {
  return *msg->_impl_.assigned_;
}
const ::k8s::io::api::core::v1::NodeConfigSource&
NodeConfigStatus::_Internal::active(const NodeConfigStatus* msg) {
  return *msg->_impl_.active_;
}
const ::k8s::io::api::core::v1::NodeConfigSource&
NodeConfigStatus::_Internal::lastknowngood(const NodeConfigStatus* msg) {
  return *msg->_impl_.lastknowngood_;
}
NodeConfigStatus::NodeConfigStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.NodeConfigStatus)
}
NodeConfigStatus::NodeConfigStatus(const NodeConfigStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NodeConfigStatus* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.error_){}
    , decltype(_impl_.assigned_){nullptr}
    , decltype(_impl_.active_){nullptr}
    , decltype(_impl_.lastknowngood_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.error_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.error_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_error()) {
    _this->_impl_.error_.Set(from._internal_error(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_assigned()) {
    _this->_impl_.assigned_ = new ::k8s::io::api::core::v1::NodeConfigSource(*from._impl_.assigned_);
  }
  if (from._internal_has_active()) {
    _this->_impl_.active_ = new ::k8s::io::api::core::v1::NodeConfigSource(*from._impl_.active_);
  }
  if (from._internal_has_lastknowngood()) {
    _this->_impl_.lastknowngood_ = new ::k8s::io::api::core::v1::NodeConfigSource(*from._impl_.lastknowngood_);
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.NodeConfigStatus)
}

inline void NodeConfigStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.error_){}
    , decltype(_impl_.assigned_){nullptr}
    , decltype(_impl_.active_){nullptr}
    , decltype(_impl_.lastknowngood_){nullptr}
  };
  _impl_.error_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.error_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NodeConfigStatus::~NodeConfigStatus() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.NodeConfigStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NodeConfigStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.error_.Destroy();
  if (this != internal_default_instance()) delete _impl_.assigned_;
  if (this != internal_default_instance()) delete _impl_.active_;
  if (this != internal_default_instance()) delete _impl_.lastknowngood_;
}

void NodeConfigStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NodeConfigStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.NodeConfigStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.error_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.assigned_ != nullptr);
      _impl_.assigned_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.active_ != nullptr);
      _impl_.active_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.lastknowngood_ != nullptr);
      _impl_.lastknowngood_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NodeConfigStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .k8s.io.api.core.v1.NodeConfigSource assigned = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_assigned(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.NodeConfigSource active = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_active(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.NodeConfigSource lastKnownGood = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_lastknowngood(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes error = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_error();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NodeConfigStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.NodeConfigStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .k8s.io.api.core.v1.NodeConfigSource assigned = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::assigned(this),
        _Internal::assigned(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.NodeConfigSource active = 2;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::active(this),
        _Internal::active(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.NodeConfigSource lastKnownGood = 3;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::lastknowngood(this),
        _Internal::lastknowngood(this).GetCachedSize(), target, stream);
  }

  // optional bytes error = 4;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_error(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.NodeConfigStatus)
  return target;
}

size_t NodeConfigStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.NodeConfigStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional bytes error = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_error());
    }

    // optional .k8s.io.api.core.v1.NodeConfigSource assigned = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.assigned_);
    }

    // optional .k8s.io.api.core.v1.NodeConfigSource active = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.active_);
    }

    // optional .k8s.io.api.core.v1.NodeConfigSource lastKnownGood = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.lastknowngood_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NodeConfigStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NodeConfigStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NodeConfigStatus::GetClassData() const { return &_class_data_; }


void NodeConfigStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NodeConfigStatus*>(&to_msg);
  auto& from = static_cast<const NodeConfigStatus&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.NodeConfigStatus)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_error(from._internal_error());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_assigned()->::k8s::io::api::core::v1::NodeConfigSource::MergeFrom(
          from._internal_assigned());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_active()->::k8s::io::api::core::v1::NodeConfigSource::MergeFrom(
          from._internal_active());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_lastknowngood()->::k8s::io::api::core::v1::NodeConfigSource::MergeFrom(
          from._internal_lastknowngood());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NodeConfigStatus::CopyFrom(const NodeConfigStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.NodeConfigStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NodeConfigStatus::IsInitialized() const {
  return true;
}

void NodeConfigStatus::InternalSwap(NodeConfigStatus* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.error_, lhs_arena,
      &other->_impl_.error_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NodeConfigStatus, _impl_.lastknowngood_)
      + sizeof(NodeConfigStatus::_impl_.lastknowngood_)
      - PROTOBUF_FIELD_OFFSET(NodeConfigStatus, _impl_.assigned_)>(
          reinterpret_cast<char*>(&_impl_.assigned_),
          reinterpret_cast<char*>(&other->_impl_.assigned_));
}

::PROTOBUF_NAMESPACE_ID::Metadata NodeConfigStatus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[111]);
}

// ===================================================================

class NodeDaemonEndpoints::_Internal {
 public:
  using HasBits = decltype(std::declval<NodeDaemonEndpoints>()._impl_._has_bits_);
  static const ::k8s::io::api::core::v1::DaemonEndpoint& kubeletendpoint(const NodeDaemonEndpoints* msg);
  static void set_has_kubeletendpoint(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::k8s::io::api::core::v1::DaemonEndpoint&
NodeDaemonEndpoints::_Internal::kubeletendpoint(const NodeDaemonEndpoints* msg) {
  return *msg->_impl_.kubeletendpoint_;
}
NodeDaemonEndpoints::NodeDaemonEndpoints(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.NodeDaemonEndpoints)
}
NodeDaemonEndpoints::NodeDaemonEndpoints(const NodeDaemonEndpoints& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NodeDaemonEndpoints* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.kubeletendpoint_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_kubeletendpoint()) {
    _this->_impl_.kubeletendpoint_ = new ::k8s::io::api::core::v1::DaemonEndpoint(*from._impl_.kubeletendpoint_);
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.NodeDaemonEndpoints)
}

inline void NodeDaemonEndpoints::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.kubeletendpoint_){nullptr}
  };
}

NodeDaemonEndpoints::~NodeDaemonEndpoints() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.NodeDaemonEndpoints)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NodeDaemonEndpoints::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.kubeletendpoint_;
}

void NodeDaemonEndpoints::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NodeDaemonEndpoints::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.NodeDaemonEndpoints)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.kubeletendpoint_ != nullptr);
    _impl_.kubeletendpoint_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NodeDaemonEndpoints::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .k8s.io.api.core.v1.DaemonEndpoint kubeletEndpoint = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_kubeletendpoint(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NodeDaemonEndpoints::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.NodeDaemonEndpoints)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .k8s.io.api.core.v1.DaemonEndpoint kubeletEndpoint = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::kubeletendpoint(this),
        _Internal::kubeletendpoint(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.NodeDaemonEndpoints)
  return target;
}

size_t NodeDaemonEndpoints::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.NodeDaemonEndpoints)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .k8s.io.api.core.v1.DaemonEndpoint kubeletEndpoint = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.kubeletendpoint_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NodeDaemonEndpoints::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NodeDaemonEndpoints::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NodeDaemonEndpoints::GetClassData() const { return &_class_data_; }


void NodeDaemonEndpoints::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NodeDaemonEndpoints*>(&to_msg);
  auto& from = static_cast<const NodeDaemonEndpoints&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.NodeDaemonEndpoints)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_kubeletendpoint()) {
    _this->_internal_mutable_kubeletendpoint()->::k8s::io::api::core::v1::DaemonEndpoint::MergeFrom(
        from._internal_kubeletendpoint());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NodeDaemonEndpoints::CopyFrom(const NodeDaemonEndpoints& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.NodeDaemonEndpoints)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NodeDaemonEndpoints::IsInitialized() const {
  return true;
}

void NodeDaemonEndpoints::InternalSwap(NodeDaemonEndpoints* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.kubeletendpoint_, other->_impl_.kubeletendpoint_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NodeDaemonEndpoints::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[112]);
}

// ===================================================================

class NodeList::_Internal {
 public:
  using HasBits = decltype(std::declval<NodeList>()._impl_._has_bits_);
  static const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& metadata(const NodeList* msg);
  static void set_has_metadata(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta&
NodeList::_Internal::metadata(const NodeList* msg) {
  return *msg->_impl_.metadata_;
}
void NodeList::clear_metadata() {
  if (_impl_.metadata_ != nullptr) _impl_.metadata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
NodeList::NodeList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.NodeList)
}
NodeList::NodeList(const NodeList& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NodeList* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.items_){from._impl_.items_}
    , decltype(_impl_.metadata_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_metadata()) {
    _this->_impl_.metadata_ = new ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta(*from._impl_.metadata_);
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.NodeList)
}

inline void NodeList::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.items_){arena}
    , decltype(_impl_.metadata_){nullptr}
  };
}

NodeList::~NodeList() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.NodeList)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NodeList::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.items_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.metadata_;
}

void NodeList::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NodeList::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.NodeList)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.items_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.metadata_ != nullptr);
    _impl_.metadata_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NodeList::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_metadata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .k8s.io.api.core.v1.Node items = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_items(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NodeList::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.NodeList)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::metadata(this),
        _Internal::metadata(this).GetCachedSize(), target, stream);
  }

  // repeated .k8s.io.api.core.v1.Node items = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_items_size()); i < n; i++) {
    const auto& repfield = this->_internal_items(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.NodeList)
  return target;
}

size_t NodeList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.NodeList)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .k8s.io.api.core.v1.Node items = 2;
  total_size += 1UL * this->_internal_items_size();
  for (const auto& msg : this->_impl_.items_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.metadata_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NodeList::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NodeList::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NodeList::GetClassData() const { return &_class_data_; }


void NodeList::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NodeList*>(&to_msg);
  auto& from = static_cast<const NodeList&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.NodeList)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.items_.MergeFrom(from._impl_.items_);
  if (from._internal_has_metadata()) {
    _this->_internal_mutable_metadata()->::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta::MergeFrom(
        from._internal_metadata());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NodeList::CopyFrom(const NodeList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.NodeList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NodeList::IsInitialized() const {
  return true;
}

void NodeList::InternalSwap(NodeList* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.items_.InternalSwap(&other->_impl_.items_);
  swap(_impl_.metadata_, other->_impl_.metadata_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NodeList::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[113]);
}

// ===================================================================

class NodeProxyOptions::_Internal {
 public:
  using HasBits = decltype(std::declval<NodeProxyOptions>()._impl_._has_bits_);
  static void set_has_path(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

NodeProxyOptions::NodeProxyOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.NodeProxyOptions)
}
NodeProxyOptions::NodeProxyOptions(const NodeProxyOptions& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NodeProxyOptions* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.path_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_path()) {
    _this->_impl_.path_.Set(from._internal_path(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.NodeProxyOptions)
}

inline void NodeProxyOptions::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.path_){}
  };
  _impl_.path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NodeProxyOptions::~NodeProxyOptions() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.NodeProxyOptions)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NodeProxyOptions::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.path_.Destroy();
}

void NodeProxyOptions::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NodeProxyOptions::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.NodeProxyOptions)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.path_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NodeProxyOptions::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes path = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_path();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NodeProxyOptions::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.NodeProxyOptions)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes path = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_path(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.NodeProxyOptions)
  return target;
}

size_t NodeProxyOptions::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.NodeProxyOptions)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes path = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_path());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NodeProxyOptions::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NodeProxyOptions::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NodeProxyOptions::GetClassData() const { return &_class_data_; }


void NodeProxyOptions::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NodeProxyOptions*>(&to_msg);
  auto& from = static_cast<const NodeProxyOptions&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.NodeProxyOptions)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_path()) {
    _this->_internal_set_path(from._internal_path());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NodeProxyOptions::CopyFrom(const NodeProxyOptions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.NodeProxyOptions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NodeProxyOptions::IsInitialized() const {
  return true;
}

void NodeProxyOptions::InternalSwap(NodeProxyOptions* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.path_, lhs_arena,
      &other->_impl_.path_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata NodeProxyOptions::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[114]);
}

// ===================================================================

NodeResources_CapacityEntry_DoNotUse::NodeResources_CapacityEntry_DoNotUse() {}
NodeResources_CapacityEntry_DoNotUse::NodeResources_CapacityEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void NodeResources_CapacityEntry_DoNotUse::MergeFrom(const NodeResources_CapacityEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata NodeResources_CapacityEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[115]);
}

// ===================================================================

class NodeResources::_Internal {
 public:
};

void NodeResources::clear_capacity() {
  _impl_.capacity_.Clear();
}
NodeResources::NodeResources(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &NodeResources::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.NodeResources)
}
NodeResources::NodeResources(const NodeResources& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NodeResources* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_.capacity_)*/{}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.capacity_.MergeFrom(from._impl_.capacity_);
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.NodeResources)
}

inline void NodeResources::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_.capacity_)*/{::_pbi::ArenaInitialized(), arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

NodeResources::~NodeResources() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.NodeResources)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void NodeResources::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.capacity_.Destruct();
  _impl_.capacity_.~MapField();
}

void NodeResources::ArenaDtor(void* object) {
  NodeResources* _this = reinterpret_cast< NodeResources* >(object);
  _this->_impl_.capacity_.Destruct();
}
void NodeResources::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NodeResources::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.NodeResources)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.capacity_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NodeResources::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // map<string, .k8s.io.apimachinery.pkg.api.resource.Quantity> capacity = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.capacity_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NodeResources::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.NodeResources)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // map<string, .k8s.io.apimachinery.pkg.api.resource.Quantity> capacity = 1;
  if (!this->_internal_capacity().empty()) {
    using MapType = ::_pb::Map<std::string, ::k8s::io::apimachinery::pkg::api::resource::Quantity>;
    using WireHelper = NodeResources_CapacityEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_capacity();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "k8s.io.api.core.v1.NodeResources.CapacityEntry.key");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(1, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(1, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.NodeResources)
  return target;
}

size_t NodeResources::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.NodeResources)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, .k8s.io.apimachinery.pkg.api.resource.Quantity> capacity = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_capacity_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::k8s::io::apimachinery::pkg::api::resource::Quantity >::const_iterator
      it = this->_internal_capacity().begin();
      it != this->_internal_capacity().end(); ++it) {
    total_size += NodeResources_CapacityEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NodeResources::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NodeResources::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NodeResources::GetClassData() const { return &_class_data_; }


void NodeResources::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NodeResources*>(&to_msg);
  auto& from = static_cast<const NodeResources&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.NodeResources)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.capacity_.MergeFrom(from._impl_.capacity_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NodeResources::CopyFrom(const NodeResources& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.NodeResources)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NodeResources::IsInitialized() const {
  return true;
}

void NodeResources::InternalSwap(NodeResources* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.capacity_.InternalSwap(&other->_impl_.capacity_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NodeResources::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[116]);
}

// ===================================================================

class NodeSelector::_Internal {
 public:
};

NodeSelector::NodeSelector(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.NodeSelector)
}
NodeSelector::NodeSelector(const NodeSelector& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NodeSelector* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.nodeselectorterms_){from._impl_.nodeselectorterms_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.NodeSelector)
}

inline void NodeSelector::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.nodeselectorterms_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

NodeSelector::~NodeSelector() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.NodeSelector)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NodeSelector::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.nodeselectorterms_.~RepeatedPtrField();
}

void NodeSelector::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NodeSelector::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.NodeSelector)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.nodeselectorterms_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NodeSelector::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .k8s.io.api.core.v1.NodeSelectorTerm nodeSelectorTerms = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_nodeselectorterms(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NodeSelector::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.NodeSelector)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .k8s.io.api.core.v1.NodeSelectorTerm nodeSelectorTerms = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_nodeselectorterms_size()); i < n; i++) {
    const auto& repfield = this->_internal_nodeselectorterms(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.NodeSelector)
  return target;
}

size_t NodeSelector::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.NodeSelector)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .k8s.io.api.core.v1.NodeSelectorTerm nodeSelectorTerms = 1;
  total_size += 1UL * this->_internal_nodeselectorterms_size();
  for (const auto& msg : this->_impl_.nodeselectorterms_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NodeSelector::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NodeSelector::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NodeSelector::GetClassData() const { return &_class_data_; }


void NodeSelector::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NodeSelector*>(&to_msg);
  auto& from = static_cast<const NodeSelector&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.NodeSelector)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.nodeselectorterms_.MergeFrom(from._impl_.nodeselectorterms_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NodeSelector::CopyFrom(const NodeSelector& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.NodeSelector)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NodeSelector::IsInitialized() const {
  return true;
}

void NodeSelector::InternalSwap(NodeSelector* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.nodeselectorterms_.InternalSwap(&other->_impl_.nodeselectorterms_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NodeSelector::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[117]);
}

// ===================================================================

class NodeSelectorRequirement::_Internal {
 public:
  using HasBits = decltype(std::declval<NodeSelectorRequirement>()._impl_._has_bits_);
  static void set_has_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_operator_(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

NodeSelectorRequirement::NodeSelectorRequirement(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.NodeSelectorRequirement)
}
NodeSelectorRequirement::NodeSelectorRequirement(const NodeSelectorRequirement& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NodeSelectorRequirement* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.values_){from._impl_.values_}
    , decltype(_impl_.key_){}
    , decltype(_impl_.operator__){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_key()) {
    _this->_impl_.key_.Set(from._internal_key(), 
      _this->GetArenaForAllocation());
  }
  _impl_.operator__.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.operator__.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_operator_()) {
    _this->_impl_.operator__.Set(from._internal_operator_(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.NodeSelectorRequirement)
}

inline void NodeSelectorRequirement::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.values_){arena}
    , decltype(_impl_.key_){}
    , decltype(_impl_.operator__){}
  };
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.operator__.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.operator__.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NodeSelectorRequirement::~NodeSelectorRequirement() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.NodeSelectorRequirement)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NodeSelectorRequirement::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.values_.~RepeatedPtrField();
  _impl_.key_.Destroy();
  _impl_.operator__.Destroy();
}

void NodeSelectorRequirement::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NodeSelectorRequirement::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.NodeSelectorRequirement)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.values_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.key_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.operator__.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NodeSelectorRequirement::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes operator = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_operator_();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string values = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_values();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "k8s.io.api.core.v1.NodeSelectorRequirement.values");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NodeSelectorRequirement::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.NodeSelectorRequirement)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes key = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_key(), target);
  }

  // optional bytes operator = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_operator_(), target);
  }

  // repeated string values = 3;
  for (int i = 0, n = this->_internal_values_size(); i < n; i++) {
    const auto& s = this->_internal_values(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "k8s.io.api.core.v1.NodeSelectorRequirement.values");
    target = stream->WriteString(3, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.NodeSelectorRequirement)
  return target;
}

size_t NodeSelectorRequirement::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.NodeSelectorRequirement)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string values = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.values_.size());
  for (int i = 0, n = _impl_.values_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.values_.Get(i));
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes key = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_key());
    }

    // optional bytes operator = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_operator_());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NodeSelectorRequirement::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NodeSelectorRequirement::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NodeSelectorRequirement::GetClassData() const { return &_class_data_; }


void NodeSelectorRequirement::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NodeSelectorRequirement*>(&to_msg);
  auto& from = static_cast<const NodeSelectorRequirement&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.NodeSelectorRequirement)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.values_.MergeFrom(from._impl_.values_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_key(from._internal_key());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_operator_(from._internal_operator_());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NodeSelectorRequirement::CopyFrom(const NodeSelectorRequirement& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.NodeSelectorRequirement)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NodeSelectorRequirement::IsInitialized() const {
  return true;
}

void NodeSelectorRequirement::InternalSwap(NodeSelectorRequirement* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.values_.InternalSwap(&other->_impl_.values_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.key_, lhs_arena,
      &other->_impl_.key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.operator__, lhs_arena,
      &other->_impl_.operator__, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata NodeSelectorRequirement::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[118]);
}

// ===================================================================

class NodeSelectorTerm::_Internal {
 public:
};

NodeSelectorTerm::NodeSelectorTerm(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.NodeSelectorTerm)
}
NodeSelectorTerm::NodeSelectorTerm(const NodeSelectorTerm& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NodeSelectorTerm* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.matchexpressions_){from._impl_.matchexpressions_}
    , decltype(_impl_.matchfields_){from._impl_.matchfields_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.NodeSelectorTerm)
}

inline void NodeSelectorTerm::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.matchexpressions_){arena}
    , decltype(_impl_.matchfields_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

NodeSelectorTerm::~NodeSelectorTerm() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.NodeSelectorTerm)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NodeSelectorTerm::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.matchexpressions_.~RepeatedPtrField();
  _impl_.matchfields_.~RepeatedPtrField();
}

void NodeSelectorTerm::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NodeSelectorTerm::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.NodeSelectorTerm)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.matchexpressions_.Clear();
  _impl_.matchfields_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NodeSelectorTerm::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .k8s.io.api.core.v1.NodeSelectorRequirement matchExpressions = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_matchexpressions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .k8s.io.api.core.v1.NodeSelectorRequirement matchFields = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_matchfields(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NodeSelectorTerm::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.NodeSelectorTerm)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .k8s.io.api.core.v1.NodeSelectorRequirement matchExpressions = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_matchexpressions_size()); i < n; i++) {
    const auto& repfield = this->_internal_matchexpressions(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .k8s.io.api.core.v1.NodeSelectorRequirement matchFields = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_matchfields_size()); i < n; i++) {
    const auto& repfield = this->_internal_matchfields(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.NodeSelectorTerm)
  return target;
}

size_t NodeSelectorTerm::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.NodeSelectorTerm)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .k8s.io.api.core.v1.NodeSelectorRequirement matchExpressions = 1;
  total_size += 1UL * this->_internal_matchexpressions_size();
  for (const auto& msg : this->_impl_.matchexpressions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .k8s.io.api.core.v1.NodeSelectorRequirement matchFields = 2;
  total_size += 1UL * this->_internal_matchfields_size();
  for (const auto& msg : this->_impl_.matchfields_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NodeSelectorTerm::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NodeSelectorTerm::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NodeSelectorTerm::GetClassData() const { return &_class_data_; }


void NodeSelectorTerm::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NodeSelectorTerm*>(&to_msg);
  auto& from = static_cast<const NodeSelectorTerm&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.NodeSelectorTerm)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.matchexpressions_.MergeFrom(from._impl_.matchexpressions_);
  _this->_impl_.matchfields_.MergeFrom(from._impl_.matchfields_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NodeSelectorTerm::CopyFrom(const NodeSelectorTerm& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.NodeSelectorTerm)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NodeSelectorTerm::IsInitialized() const {
  return true;
}

void NodeSelectorTerm::InternalSwap(NodeSelectorTerm* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.matchexpressions_.InternalSwap(&other->_impl_.matchexpressions_);
  _impl_.matchfields_.InternalSwap(&other->_impl_.matchfields_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NodeSelectorTerm::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[119]);
}

// ===================================================================

class NodeSpec::_Internal {
 public:
  using HasBits = decltype(std::declval<NodeSpec>()._impl_._has_bits_);
  static void set_has_podcidr(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_providerid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_unschedulable(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::k8s::io::api::core::v1::NodeConfigSource& configsource(const NodeSpec* msg);
  static void set_has_configsource(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_externalid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::k8s::io::api::core::v1::NodeConfigSource&
NodeSpec::_Internal::configsource(const NodeSpec* msg) {
  return *msg->_impl_.configsource_;
}
NodeSpec::NodeSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.NodeSpec)
}
NodeSpec::NodeSpec(const NodeSpec& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NodeSpec* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.taints_){from._impl_.taints_}
    , decltype(_impl_.podcidrs_){from._impl_.podcidrs_}
    , decltype(_impl_.podcidr_){}
    , decltype(_impl_.externalid_){}
    , decltype(_impl_.providerid_){}
    , decltype(_impl_.configsource_){nullptr}
    , decltype(_impl_.unschedulable_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.podcidr_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.podcidr_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_podcidr()) {
    _this->_impl_.podcidr_.Set(from._internal_podcidr(), 
      _this->GetArenaForAllocation());
  }
  _impl_.externalid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.externalid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_externalid()) {
    _this->_impl_.externalid_.Set(from._internal_externalid(), 
      _this->GetArenaForAllocation());
  }
  _impl_.providerid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.providerid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_providerid()) {
    _this->_impl_.providerid_.Set(from._internal_providerid(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_configsource()) {
    _this->_impl_.configsource_ = new ::k8s::io::api::core::v1::NodeConfigSource(*from._impl_.configsource_);
  }
  _this->_impl_.unschedulable_ = from._impl_.unschedulable_;
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.NodeSpec)
}

inline void NodeSpec::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.taints_){arena}
    , decltype(_impl_.podcidrs_){arena}
    , decltype(_impl_.podcidr_){}
    , decltype(_impl_.externalid_){}
    , decltype(_impl_.providerid_){}
    , decltype(_impl_.configsource_){nullptr}
    , decltype(_impl_.unschedulable_){false}
  };
  _impl_.podcidr_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.podcidr_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.externalid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.externalid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.providerid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.providerid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NodeSpec::~NodeSpec() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.NodeSpec)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NodeSpec::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.taints_.~RepeatedPtrField();
  _impl_.podcidrs_.~RepeatedPtrField();
  _impl_.podcidr_.Destroy();
  _impl_.externalid_.Destroy();
  _impl_.providerid_.Destroy();
  if (this != internal_default_instance()) delete _impl_.configsource_;
}

void NodeSpec::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NodeSpec::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.NodeSpec)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.taints_.Clear();
  _impl_.podcidrs_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.podcidr_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.externalid_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.providerid_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.configsource_ != nullptr);
      _impl_.configsource_->Clear();
    }
  }
  _impl_.unschedulable_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NodeSpec::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes podCIDR = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_podcidr();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes externalID = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_externalid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes providerID = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_providerid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool unschedulable = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_unschedulable(&has_bits);
          _impl_.unschedulable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .k8s.io.api.core.v1.Taint taints = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_taints(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.NodeConfigSource configSource = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_configsource(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string podCIDRs = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_podcidrs();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "k8s.io.api.core.v1.NodeSpec.podCIDRs");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NodeSpec::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.NodeSpec)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes podCIDR = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_podcidr(), target);
  }

  // optional bytes externalID = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_externalid(), target);
  }

  // optional bytes providerID = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_providerid(), target);
  }

  // optional bool unschedulable = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_unschedulable(), target);
  }

  // repeated .k8s.io.api.core.v1.Taint taints = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_taints_size()); i < n; i++) {
    const auto& repfield = this->_internal_taints(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.NodeConfigSource configSource = 6;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::configsource(this),
        _Internal::configsource(this).GetCachedSize(), target, stream);
  }

  // repeated string podCIDRs = 7;
  for (int i = 0, n = this->_internal_podcidrs_size(); i < n; i++) {
    const auto& s = this->_internal_podcidrs(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "k8s.io.api.core.v1.NodeSpec.podCIDRs");
    target = stream->WriteString(7, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.NodeSpec)
  return target;
}

size_t NodeSpec::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.NodeSpec)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .k8s.io.api.core.v1.Taint taints = 5;
  total_size += 1UL * this->_internal_taints_size();
  for (const auto& msg : this->_impl_.taints_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated string podCIDRs = 7;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.podcidrs_.size());
  for (int i = 0, n = _impl_.podcidrs_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.podcidrs_.Get(i));
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional bytes podCIDR = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_podcidr());
    }

    // optional bytes externalID = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_externalid());
    }

    // optional bytes providerID = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_providerid());
    }

    // optional .k8s.io.api.core.v1.NodeConfigSource configSource = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.configsource_);
    }

    // optional bool unschedulable = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NodeSpec::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NodeSpec::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NodeSpec::GetClassData() const { return &_class_data_; }


void NodeSpec::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NodeSpec*>(&to_msg);
  auto& from = static_cast<const NodeSpec&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.NodeSpec)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.taints_.MergeFrom(from._impl_.taints_);
  _this->_impl_.podcidrs_.MergeFrom(from._impl_.podcidrs_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_podcidr(from._internal_podcidr());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_externalid(from._internal_externalid());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_providerid(from._internal_providerid());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_configsource()->::k8s::io::api::core::v1::NodeConfigSource::MergeFrom(
          from._internal_configsource());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.unschedulable_ = from._impl_.unschedulable_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NodeSpec::CopyFrom(const NodeSpec& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.NodeSpec)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NodeSpec::IsInitialized() const {
  return true;
}

void NodeSpec::InternalSwap(NodeSpec* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.taints_.InternalSwap(&other->_impl_.taints_);
  _impl_.podcidrs_.InternalSwap(&other->_impl_.podcidrs_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.podcidr_, lhs_arena,
      &other->_impl_.podcidr_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.externalid_, lhs_arena,
      &other->_impl_.externalid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.providerid_, lhs_arena,
      &other->_impl_.providerid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NodeSpec, _impl_.unschedulable_)
      + sizeof(NodeSpec::_impl_.unschedulable_)
      - PROTOBUF_FIELD_OFFSET(NodeSpec, _impl_.configsource_)>(
          reinterpret_cast<char*>(&_impl_.configsource_),
          reinterpret_cast<char*>(&other->_impl_.configsource_));
}

::PROTOBUF_NAMESPACE_ID::Metadata NodeSpec::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[120]);
}

// ===================================================================

NodeStatus_CapacityEntry_DoNotUse::NodeStatus_CapacityEntry_DoNotUse() {}
NodeStatus_CapacityEntry_DoNotUse::NodeStatus_CapacityEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void NodeStatus_CapacityEntry_DoNotUse::MergeFrom(const NodeStatus_CapacityEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata NodeStatus_CapacityEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[121]);
}

// ===================================================================

NodeStatus_AllocatableEntry_DoNotUse::NodeStatus_AllocatableEntry_DoNotUse() {}
NodeStatus_AllocatableEntry_DoNotUse::NodeStatus_AllocatableEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void NodeStatus_AllocatableEntry_DoNotUse::MergeFrom(const NodeStatus_AllocatableEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata NodeStatus_AllocatableEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[122]);
}

// ===================================================================

class NodeStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<NodeStatus>()._impl_._has_bits_);
  static void set_has_phase(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::k8s::io::api::core::v1::NodeDaemonEndpoints& daemonendpoints(const NodeStatus* msg);
  static void set_has_daemonendpoints(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::k8s::io::api::core::v1::NodeSystemInfo& nodeinfo(const NodeStatus* msg);
  static void set_has_nodeinfo(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::k8s::io::api::core::v1::NodeConfigStatus& config(const NodeStatus* msg);
  static void set_has_config(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::k8s::io::api::core::v1::NodeDaemonEndpoints&
NodeStatus::_Internal::daemonendpoints(const NodeStatus* msg) {
  return *msg->_impl_.daemonendpoints_;
}
const ::k8s::io::api::core::v1::NodeSystemInfo&
NodeStatus::_Internal::nodeinfo(const NodeStatus* msg) {
  return *msg->_impl_.nodeinfo_;
}
const ::k8s::io::api::core::v1::NodeConfigStatus&
NodeStatus::_Internal::config(const NodeStatus* msg) {
  return *msg->_impl_.config_;
}
void NodeStatus::clear_capacity() {
  _impl_.capacity_.Clear();
}
void NodeStatus::clear_allocatable() {
  _impl_.allocatable_.Clear();
}
NodeStatus::NodeStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &NodeStatus::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.NodeStatus)
}
NodeStatus::NodeStatus(const NodeStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NodeStatus* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_.capacity_)*/{}
    , /*decltype(_impl_.allocatable_)*/{}
    , decltype(_impl_.conditions_){from._impl_.conditions_}
    , decltype(_impl_.addresses_){from._impl_.addresses_}
    , decltype(_impl_.images_){from._impl_.images_}
    , decltype(_impl_.volumesinuse_){from._impl_.volumesinuse_}
    , decltype(_impl_.volumesattached_){from._impl_.volumesattached_}
    , decltype(_impl_.phase_){}
    , decltype(_impl_.daemonendpoints_){nullptr}
    , decltype(_impl_.nodeinfo_){nullptr}
    , decltype(_impl_.config_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.capacity_.MergeFrom(from._impl_.capacity_);
  _this->_impl_.allocatable_.MergeFrom(from._impl_.allocatable_);
  _impl_.phase_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.phase_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_phase()) {
    _this->_impl_.phase_.Set(from._internal_phase(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_daemonendpoints()) {
    _this->_impl_.daemonendpoints_ = new ::k8s::io::api::core::v1::NodeDaemonEndpoints(*from._impl_.daemonendpoints_);
  }
  if (from._internal_has_nodeinfo()) {
    _this->_impl_.nodeinfo_ = new ::k8s::io::api::core::v1::NodeSystemInfo(*from._impl_.nodeinfo_);
  }
  if (from._internal_has_config()) {
    _this->_impl_.config_ = new ::k8s::io::api::core::v1::NodeConfigStatus(*from._impl_.config_);
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.NodeStatus)
}

inline void NodeStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_.capacity_)*/{::_pbi::ArenaInitialized(), arena}
    , /*decltype(_impl_.allocatable_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.conditions_){arena}
    , decltype(_impl_.addresses_){arena}
    , decltype(_impl_.images_){arena}
    , decltype(_impl_.volumesinuse_){arena}
    , decltype(_impl_.volumesattached_){arena}
    , decltype(_impl_.phase_){}
    , decltype(_impl_.daemonendpoints_){nullptr}
    , decltype(_impl_.nodeinfo_){nullptr}
    , decltype(_impl_.config_){nullptr}
  };
  _impl_.phase_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.phase_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NodeStatus::~NodeStatus() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.NodeStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void NodeStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.capacity_.Destruct();
  _impl_.capacity_.~MapField();
  _impl_.allocatable_.Destruct();
  _impl_.allocatable_.~MapField();
  _impl_.conditions_.~RepeatedPtrField();
  _impl_.addresses_.~RepeatedPtrField();
  _impl_.images_.~RepeatedPtrField();
  _impl_.volumesinuse_.~RepeatedPtrField();
  _impl_.volumesattached_.~RepeatedPtrField();
  _impl_.phase_.Destroy();
  if (this != internal_default_instance()) delete _impl_.daemonendpoints_;
  if (this != internal_default_instance()) delete _impl_.nodeinfo_;
  if (this != internal_default_instance()) delete _impl_.config_;
}

void NodeStatus::ArenaDtor(void* object) {
  NodeStatus* _this = reinterpret_cast< NodeStatus* >(object);
  _this->_impl_.capacity_.Destruct();
  _this->_impl_.allocatable_.Destruct();
}
void NodeStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NodeStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.NodeStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.capacity_.Clear();
  _impl_.allocatable_.Clear();
  _impl_.conditions_.Clear();
  _impl_.addresses_.Clear();
  _impl_.images_.Clear();
  _impl_.volumesinuse_.Clear();
  _impl_.volumesattached_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.phase_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.daemonendpoints_ != nullptr);
      _impl_.daemonendpoints_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.nodeinfo_ != nullptr);
      _impl_.nodeinfo_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.config_ != nullptr);
      _impl_.config_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NodeStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // map<string, .k8s.io.apimachinery.pkg.api.resource.Quantity> capacity = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.capacity_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // map<string, .k8s.io.apimachinery.pkg.api.resource.Quantity> allocatable = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.allocatable_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bytes phase = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_phase();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .k8s.io.api.core.v1.NodeCondition conditions = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_conditions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .k8s.io.api.core.v1.NodeAddress addresses = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_addresses(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.NodeDaemonEndpoints daemonEndpoints = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_daemonendpoints(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.NodeSystemInfo nodeInfo = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_nodeinfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .k8s.io.api.core.v1.ContainerImage images = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_images(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string volumesInUse = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_volumesinuse();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "k8s.io.api.core.v1.NodeStatus.volumesInUse");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .k8s.io.api.core.v1.AttachedVolume volumesAttached = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_volumesattached(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.NodeConfigStatus config = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_config(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NodeStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.NodeStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // map<string, .k8s.io.apimachinery.pkg.api.resource.Quantity> capacity = 1;
  if (!this->_internal_capacity().empty()) {
    using MapType = ::_pb::Map<std::string, ::k8s::io::apimachinery::pkg::api::resource::Quantity>;
    using WireHelper = NodeStatus_CapacityEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_capacity();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "k8s.io.api.core.v1.NodeStatus.CapacityEntry.key");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(1, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(1, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  // map<string, .k8s.io.apimachinery.pkg.api.resource.Quantity> allocatable = 2;
  if (!this->_internal_allocatable().empty()) {
    using MapType = ::_pb::Map<std::string, ::k8s::io::apimachinery::pkg::api::resource::Quantity>;
    using WireHelper = NodeStatus_AllocatableEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_allocatable();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "k8s.io.api.core.v1.NodeStatus.AllocatableEntry.key");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(2, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(2, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes phase = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_phase(), target);
  }

  // repeated .k8s.io.api.core.v1.NodeCondition conditions = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_conditions_size()); i < n; i++) {
    const auto& repfield = this->_internal_conditions(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .k8s.io.api.core.v1.NodeAddress addresses = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_addresses_size()); i < n; i++) {
    const auto& repfield = this->_internal_addresses(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.NodeDaemonEndpoints daemonEndpoints = 6;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::daemonendpoints(this),
        _Internal::daemonendpoints(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.NodeSystemInfo nodeInfo = 7;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::nodeinfo(this),
        _Internal::nodeinfo(this).GetCachedSize(), target, stream);
  }

  // repeated .k8s.io.api.core.v1.ContainerImage images = 8;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_images_size()); i < n; i++) {
    const auto& repfield = this->_internal_images(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(8, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated string volumesInUse = 9;
  for (int i = 0, n = this->_internal_volumesinuse_size(); i < n; i++) {
    const auto& s = this->_internal_volumesinuse(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "k8s.io.api.core.v1.NodeStatus.volumesInUse");
    target = stream->WriteString(9, s, target);
  }

  // repeated .k8s.io.api.core.v1.AttachedVolume volumesAttached = 10;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_volumesattached_size()); i < n; i++) {
    const auto& repfield = this->_internal_volumesattached(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(10, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.NodeConfigStatus config = 11;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::config(this),
        _Internal::config(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.NodeStatus)
  return target;
}

size_t NodeStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.NodeStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, .k8s.io.apimachinery.pkg.api.resource.Quantity> capacity = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_capacity_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::k8s::io::apimachinery::pkg::api::resource::Quantity >::const_iterator
      it = this->_internal_capacity().begin();
      it != this->_internal_capacity().end(); ++it) {
    total_size += NodeStatus_CapacityEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // map<string, .k8s.io.apimachinery.pkg.api.resource.Quantity> allocatable = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_allocatable_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::k8s::io::apimachinery::pkg::api::resource::Quantity >::const_iterator
      it = this->_internal_allocatable().begin();
      it != this->_internal_allocatable().end(); ++it) {
    total_size += NodeStatus_AllocatableEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // repeated .k8s.io.api.core.v1.NodeCondition conditions = 4;
  total_size += 1UL * this->_internal_conditions_size();
  for (const auto& msg : this->_impl_.conditions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .k8s.io.api.core.v1.NodeAddress addresses = 5;
  total_size += 1UL * this->_internal_addresses_size();
  for (const auto& msg : this->_impl_.addresses_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .k8s.io.api.core.v1.ContainerImage images = 8;
  total_size += 1UL * this->_internal_images_size();
  for (const auto& msg : this->_impl_.images_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated string volumesInUse = 9;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.volumesinuse_.size());
  for (int i = 0, n = _impl_.volumesinuse_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.volumesinuse_.Get(i));
  }

  // repeated .k8s.io.api.core.v1.AttachedVolume volumesAttached = 10;
  total_size += 1UL * this->_internal_volumesattached_size();
  for (const auto& msg : this->_impl_.volumesattached_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional bytes phase = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_phase());
    }

    // optional .k8s.io.api.core.v1.NodeDaemonEndpoints daemonEndpoints = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.daemonendpoints_);
    }

    // optional .k8s.io.api.core.v1.NodeSystemInfo nodeInfo = 7;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.nodeinfo_);
    }

    // optional .k8s.io.api.core.v1.NodeConfigStatus config = 11;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.config_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NodeStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NodeStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NodeStatus::GetClassData() const { return &_class_data_; }


void NodeStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NodeStatus*>(&to_msg);
  auto& from = static_cast<const NodeStatus&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.NodeStatus)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.capacity_.MergeFrom(from._impl_.capacity_);
  _this->_impl_.allocatable_.MergeFrom(from._impl_.allocatable_);
  _this->_impl_.conditions_.MergeFrom(from._impl_.conditions_);
  _this->_impl_.addresses_.MergeFrom(from._impl_.addresses_);
  _this->_impl_.images_.MergeFrom(from._impl_.images_);
  _this->_impl_.volumesinuse_.MergeFrom(from._impl_.volumesinuse_);
  _this->_impl_.volumesattached_.MergeFrom(from._impl_.volumesattached_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_phase(from._internal_phase());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_daemonendpoints()->::k8s::io::api::core::v1::NodeDaemonEndpoints::MergeFrom(
          from._internal_daemonendpoints());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_nodeinfo()->::k8s::io::api::core::v1::NodeSystemInfo::MergeFrom(
          from._internal_nodeinfo());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_config()->::k8s::io::api::core::v1::NodeConfigStatus::MergeFrom(
          from._internal_config());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NodeStatus::CopyFrom(const NodeStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.NodeStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NodeStatus::IsInitialized() const {
  return true;
}

void NodeStatus::InternalSwap(NodeStatus* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.capacity_.InternalSwap(&other->_impl_.capacity_);
  _impl_.allocatable_.InternalSwap(&other->_impl_.allocatable_);
  _impl_.conditions_.InternalSwap(&other->_impl_.conditions_);
  _impl_.addresses_.InternalSwap(&other->_impl_.addresses_);
  _impl_.images_.InternalSwap(&other->_impl_.images_);
  _impl_.volumesinuse_.InternalSwap(&other->_impl_.volumesinuse_);
  _impl_.volumesattached_.InternalSwap(&other->_impl_.volumesattached_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.phase_, lhs_arena,
      &other->_impl_.phase_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NodeStatus, _impl_.config_)
      + sizeof(NodeStatus::_impl_.config_)
      - PROTOBUF_FIELD_OFFSET(NodeStatus, _impl_.daemonendpoints_)>(
          reinterpret_cast<char*>(&_impl_.daemonendpoints_),
          reinterpret_cast<char*>(&other->_impl_.daemonendpoints_));
}

::PROTOBUF_NAMESPACE_ID::Metadata NodeStatus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[123]);
}

// ===================================================================

class NodeSystemInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<NodeSystemInfo>()._impl_._has_bits_);
  static void set_has_machineid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_systemuuid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_bootid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_kernelversion(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_osimage(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_containerruntimeversion(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_kubeletversion(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_kubeproxyversion(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_operatingsystem(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_architecture(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
};

NodeSystemInfo::NodeSystemInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.NodeSystemInfo)
}
NodeSystemInfo::NodeSystemInfo(const NodeSystemInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NodeSystemInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.machineid_){}
    , decltype(_impl_.systemuuid_){}
    , decltype(_impl_.bootid_){}
    , decltype(_impl_.kernelversion_){}
    , decltype(_impl_.osimage_){}
    , decltype(_impl_.containerruntimeversion_){}
    , decltype(_impl_.kubeletversion_){}
    , decltype(_impl_.kubeproxyversion_){}
    , decltype(_impl_.operatingsystem_){}
    , decltype(_impl_.architecture_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.machineid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.machineid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_machineid()) {
    _this->_impl_.machineid_.Set(from._internal_machineid(), 
      _this->GetArenaForAllocation());
  }
  _impl_.systemuuid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.systemuuid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_systemuuid()) {
    _this->_impl_.systemuuid_.Set(from._internal_systemuuid(), 
      _this->GetArenaForAllocation());
  }
  _impl_.bootid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.bootid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_bootid()) {
    _this->_impl_.bootid_.Set(from._internal_bootid(), 
      _this->GetArenaForAllocation());
  }
  _impl_.kernelversion_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.kernelversion_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_kernelversion()) {
    _this->_impl_.kernelversion_.Set(from._internal_kernelversion(), 
      _this->GetArenaForAllocation());
  }
  _impl_.osimage_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.osimage_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_osimage()) {
    _this->_impl_.osimage_.Set(from._internal_osimage(), 
      _this->GetArenaForAllocation());
  }
  _impl_.containerruntimeversion_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.containerruntimeversion_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_containerruntimeversion()) {
    _this->_impl_.containerruntimeversion_.Set(from._internal_containerruntimeversion(), 
      _this->GetArenaForAllocation());
  }
  _impl_.kubeletversion_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.kubeletversion_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_kubeletversion()) {
    _this->_impl_.kubeletversion_.Set(from._internal_kubeletversion(), 
      _this->GetArenaForAllocation());
  }
  _impl_.kubeproxyversion_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.kubeproxyversion_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_kubeproxyversion()) {
    _this->_impl_.kubeproxyversion_.Set(from._internal_kubeproxyversion(), 
      _this->GetArenaForAllocation());
  }
  _impl_.operatingsystem_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.operatingsystem_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_operatingsystem()) {
    _this->_impl_.operatingsystem_.Set(from._internal_operatingsystem(), 
      _this->GetArenaForAllocation());
  }
  _impl_.architecture_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.architecture_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_architecture()) {
    _this->_impl_.architecture_.Set(from._internal_architecture(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.NodeSystemInfo)
}

inline void NodeSystemInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.machineid_){}
    , decltype(_impl_.systemuuid_){}
    , decltype(_impl_.bootid_){}
    , decltype(_impl_.kernelversion_){}
    , decltype(_impl_.osimage_){}
    , decltype(_impl_.containerruntimeversion_){}
    , decltype(_impl_.kubeletversion_){}
    , decltype(_impl_.kubeproxyversion_){}
    , decltype(_impl_.operatingsystem_){}
    , decltype(_impl_.architecture_){}
  };
  _impl_.machineid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.machineid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.systemuuid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.systemuuid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.bootid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.bootid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.kernelversion_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.kernelversion_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.osimage_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.osimage_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.containerruntimeversion_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.containerruntimeversion_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.kubeletversion_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.kubeletversion_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.kubeproxyversion_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.kubeproxyversion_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.operatingsystem_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.operatingsystem_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.architecture_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.architecture_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NodeSystemInfo::~NodeSystemInfo() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.NodeSystemInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NodeSystemInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.machineid_.Destroy();
  _impl_.systemuuid_.Destroy();
  _impl_.bootid_.Destroy();
  _impl_.kernelversion_.Destroy();
  _impl_.osimage_.Destroy();
  _impl_.containerruntimeversion_.Destroy();
  _impl_.kubeletversion_.Destroy();
  _impl_.kubeproxyversion_.Destroy();
  _impl_.operatingsystem_.Destroy();
  _impl_.architecture_.Destroy();
}

void NodeSystemInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NodeSystemInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.NodeSystemInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.machineid_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.systemuuid_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.bootid_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.kernelversion_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.osimage_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      _impl_.containerruntimeversion_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000040u) {
      _impl_.kubeletversion_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000080u) {
      _impl_.kubeproxyversion_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      _impl_.operatingsystem_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000200u) {
      _impl_.architecture_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NodeSystemInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes machineID = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_machineid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes systemUUID = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_systemuuid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes bootID = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_bootid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes kernelVersion = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_kernelversion();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes osImage = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_osimage();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes containerRuntimeVersion = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_containerruntimeversion();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes kubeletVersion = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_kubeletversion();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes kubeProxyVersion = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_kubeproxyversion();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes operatingSystem = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_operatingsystem();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes architecture = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_architecture();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NodeSystemInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.NodeSystemInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes machineID = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_machineid(), target);
  }

  // optional bytes systemUUID = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_systemuuid(), target);
  }

  // optional bytes bootID = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_bootid(), target);
  }

  // optional bytes kernelVersion = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_kernelversion(), target);
  }

  // optional bytes osImage = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_osimage(), target);
  }

  // optional bytes containerRuntimeVersion = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->WriteBytesMaybeAliased(
        6, this->_internal_containerruntimeversion(), target);
  }

  // optional bytes kubeletVersion = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->WriteBytesMaybeAliased(
        7, this->_internal_kubeletversion(), target);
  }

  // optional bytes kubeProxyVersion = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->WriteBytesMaybeAliased(
        8, this->_internal_kubeproxyversion(), target);
  }

  // optional bytes operatingSystem = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->WriteBytesMaybeAliased(
        9, this->_internal_operatingsystem(), target);
  }

  // optional bytes architecture = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->WriteBytesMaybeAliased(
        10, this->_internal_architecture(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.NodeSystemInfo)
  return target;
}

size_t NodeSystemInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.NodeSystemInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bytes machineID = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_machineid());
    }

    // optional bytes systemUUID = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_systemuuid());
    }

    // optional bytes bootID = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_bootid());
    }

    // optional bytes kernelVersion = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_kernelversion());
    }

    // optional bytes osImage = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_osimage());
    }

    // optional bytes containerRuntimeVersion = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_containerruntimeversion());
    }

    // optional bytes kubeletVersion = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_kubeletversion());
    }

    // optional bytes kubeProxyVersion = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_kubeproxyversion());
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional bytes operatingSystem = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_operatingsystem());
    }

    // optional bytes architecture = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_architecture());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NodeSystemInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NodeSystemInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NodeSystemInfo::GetClassData() const { return &_class_data_; }


void NodeSystemInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NodeSystemInfo*>(&to_msg);
  auto& from = static_cast<const NodeSystemInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.NodeSystemInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_machineid(from._internal_machineid());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_systemuuid(from._internal_systemuuid());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_bootid(from._internal_bootid());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_kernelversion(from._internal_kernelversion());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_osimage(from._internal_osimage());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_set_containerruntimeversion(from._internal_containerruntimeversion());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_set_kubeletversion(from._internal_kubeletversion());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_set_kubeproxyversion(from._internal_kubeproxyversion());
    }
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_internal_set_operatingsystem(from._internal_operatingsystem());
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_internal_set_architecture(from._internal_architecture());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NodeSystemInfo::CopyFrom(const NodeSystemInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.NodeSystemInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NodeSystemInfo::IsInitialized() const {
  return true;
}

void NodeSystemInfo::InternalSwap(NodeSystemInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.machineid_, lhs_arena,
      &other->_impl_.machineid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.systemuuid_, lhs_arena,
      &other->_impl_.systemuuid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.bootid_, lhs_arena,
      &other->_impl_.bootid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.kernelversion_, lhs_arena,
      &other->_impl_.kernelversion_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.osimage_, lhs_arena,
      &other->_impl_.osimage_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.containerruntimeversion_, lhs_arena,
      &other->_impl_.containerruntimeversion_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.kubeletversion_, lhs_arena,
      &other->_impl_.kubeletversion_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.kubeproxyversion_, lhs_arena,
      &other->_impl_.kubeproxyversion_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.operatingsystem_, lhs_arena,
      &other->_impl_.operatingsystem_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.architecture_, lhs_arena,
      &other->_impl_.architecture_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata NodeSystemInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[124]);
}

// ===================================================================

class ObjectFieldSelector::_Internal {
 public:
  using HasBits = decltype(std::declval<ObjectFieldSelector>()._impl_._has_bits_);
  static void set_has_apiversion(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_fieldpath(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ObjectFieldSelector::ObjectFieldSelector(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.ObjectFieldSelector)
}
ObjectFieldSelector::ObjectFieldSelector(const ObjectFieldSelector& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ObjectFieldSelector* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.apiversion_){}
    , decltype(_impl_.fieldpath_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.apiversion_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.apiversion_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_apiversion()) {
    _this->_impl_.apiversion_.Set(from._internal_apiversion(), 
      _this->GetArenaForAllocation());
  }
  _impl_.fieldpath_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fieldpath_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_fieldpath()) {
    _this->_impl_.fieldpath_.Set(from._internal_fieldpath(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.ObjectFieldSelector)
}

inline void ObjectFieldSelector::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.apiversion_){}
    , decltype(_impl_.fieldpath_){}
  };
  _impl_.apiversion_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.apiversion_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.fieldpath_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fieldpath_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ObjectFieldSelector::~ObjectFieldSelector() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.ObjectFieldSelector)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ObjectFieldSelector::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.apiversion_.Destroy();
  _impl_.fieldpath_.Destroy();
}

void ObjectFieldSelector::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ObjectFieldSelector::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.ObjectFieldSelector)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.apiversion_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.fieldpath_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ObjectFieldSelector::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes apiVersion = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_apiversion();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes fieldPath = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_fieldpath();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ObjectFieldSelector::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.ObjectFieldSelector)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes apiVersion = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_apiversion(), target);
  }

  // optional bytes fieldPath = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_fieldpath(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.ObjectFieldSelector)
  return target;
}

size_t ObjectFieldSelector::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.ObjectFieldSelector)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes apiVersion = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_apiversion());
    }

    // optional bytes fieldPath = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_fieldpath());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ObjectFieldSelector::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ObjectFieldSelector::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ObjectFieldSelector::GetClassData() const { return &_class_data_; }


void ObjectFieldSelector::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ObjectFieldSelector*>(&to_msg);
  auto& from = static_cast<const ObjectFieldSelector&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.ObjectFieldSelector)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_apiversion(from._internal_apiversion());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_fieldpath(from._internal_fieldpath());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ObjectFieldSelector::CopyFrom(const ObjectFieldSelector& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.ObjectFieldSelector)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ObjectFieldSelector::IsInitialized() const {
  return true;
}

void ObjectFieldSelector::InternalSwap(ObjectFieldSelector* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.apiversion_, lhs_arena,
      &other->_impl_.apiversion_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.fieldpath_, lhs_arena,
      &other->_impl_.fieldpath_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ObjectFieldSelector::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[125]);
}

// ===================================================================

class ObjectReference::_Internal {
 public:
  using HasBits = decltype(std::declval<ObjectReference>()._impl_._has_bits_);
  static void set_has_kind(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_namespace_(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_uid(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_apiversion(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_resourceversion(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_fieldpath(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

ObjectReference::ObjectReference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.ObjectReference)
}
ObjectReference::ObjectReference(const ObjectReference& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ObjectReference* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.kind_){}
    , decltype(_impl_.namespace__){}
    , decltype(_impl_.name_){}
    , decltype(_impl_.uid_){}
    , decltype(_impl_.apiversion_){}
    , decltype(_impl_.resourceversion_){}
    , decltype(_impl_.fieldpath_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.kind_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.kind_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_kind()) {
    _this->_impl_.kind_.Set(from._internal_kind(), 
      _this->GetArenaForAllocation());
  }
  _impl_.namespace__.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.namespace__.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_namespace_()) {
    _this->_impl_.namespace__.Set(from._internal_namespace_(), 
      _this->GetArenaForAllocation());
  }
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.uid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.uid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_uid()) {
    _this->_impl_.uid_.Set(from._internal_uid(), 
      _this->GetArenaForAllocation());
  }
  _impl_.apiversion_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.apiversion_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_apiversion()) {
    _this->_impl_.apiversion_.Set(from._internal_apiversion(), 
      _this->GetArenaForAllocation());
  }
  _impl_.resourceversion_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.resourceversion_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_resourceversion()) {
    _this->_impl_.resourceversion_.Set(from._internal_resourceversion(), 
      _this->GetArenaForAllocation());
  }
  _impl_.fieldpath_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fieldpath_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_fieldpath()) {
    _this->_impl_.fieldpath_.Set(from._internal_fieldpath(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.ObjectReference)
}

inline void ObjectReference::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.kind_){}
    , decltype(_impl_.namespace__){}
    , decltype(_impl_.name_){}
    , decltype(_impl_.uid_){}
    , decltype(_impl_.apiversion_){}
    , decltype(_impl_.resourceversion_){}
    , decltype(_impl_.fieldpath_){}
  };
  _impl_.kind_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.kind_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.namespace__.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.namespace__.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.uid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.uid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.apiversion_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.apiversion_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.resourceversion_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.resourceversion_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.fieldpath_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fieldpath_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ObjectReference::~ObjectReference() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.ObjectReference)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ObjectReference::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.kind_.Destroy();
  _impl_.namespace__.Destroy();
  _impl_.name_.Destroy();
  _impl_.uid_.Destroy();
  _impl_.apiversion_.Destroy();
  _impl_.resourceversion_.Destroy();
  _impl_.fieldpath_.Destroy();
}

void ObjectReference::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ObjectReference::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.ObjectReference)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.kind_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.namespace__.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.uid_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.apiversion_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      _impl_.resourceversion_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000040u) {
      _impl_.fieldpath_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ObjectReference::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes kind = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_kind();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes namespace = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_namespace_();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes uid = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_uid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes apiVersion = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_apiversion();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes resourceVersion = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_resourceversion();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes fieldPath = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_fieldpath();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ObjectReference::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.ObjectReference)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes kind = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_kind(), target);
  }

  // optional bytes namespace = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_namespace_(), target);
  }

  // optional bytes name = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_name(), target);
  }

  // optional bytes uid = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_uid(), target);
  }

  // optional bytes apiVersion = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_apiversion(), target);
  }

  // optional bytes resourceVersion = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->WriteBytesMaybeAliased(
        6, this->_internal_resourceversion(), target);
  }

  // optional bytes fieldPath = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->WriteBytesMaybeAliased(
        7, this->_internal_fieldpath(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.ObjectReference)
  return target;
}

size_t ObjectReference::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.ObjectReference)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional bytes kind = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_kind());
    }

    // optional bytes namespace = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_namespace_());
    }

    // optional bytes name = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_name());
    }

    // optional bytes uid = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_uid());
    }

    // optional bytes apiVersion = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_apiversion());
    }

    // optional bytes resourceVersion = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_resourceversion());
    }

    // optional bytes fieldPath = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_fieldpath());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ObjectReference::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ObjectReference::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ObjectReference::GetClassData() const { return &_class_data_; }


void ObjectReference::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ObjectReference*>(&to_msg);
  auto& from = static_cast<const ObjectReference&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.ObjectReference)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_kind(from._internal_kind());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_namespace_(from._internal_namespace_());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_uid(from._internal_uid());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_apiversion(from._internal_apiversion());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_set_resourceversion(from._internal_resourceversion());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_set_fieldpath(from._internal_fieldpath());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ObjectReference::CopyFrom(const ObjectReference& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.ObjectReference)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ObjectReference::IsInitialized() const {
  return true;
}

void ObjectReference::InternalSwap(ObjectReference* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.kind_, lhs_arena,
      &other->_impl_.kind_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.namespace__, lhs_arena,
      &other->_impl_.namespace__, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.uid_, lhs_arena,
      &other->_impl_.uid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.apiversion_, lhs_arena,
      &other->_impl_.apiversion_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.resourceversion_, lhs_arena,
      &other->_impl_.resourceversion_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.fieldpath_, lhs_arena,
      &other->_impl_.fieldpath_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ObjectReference::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[126]);
}

// ===================================================================

class PersistentVolume::_Internal {
 public:
  using HasBits = decltype(std::declval<PersistentVolume>()._impl_._has_bits_);
  static const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& metadata(const PersistentVolume* msg);
  static void set_has_metadata(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::k8s::io::api::core::v1::PersistentVolumeSpec& spec(const PersistentVolume* msg);
  static void set_has_spec(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::k8s::io::api::core::v1::PersistentVolumeStatus& status(const PersistentVolume* msg);
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta&
PersistentVolume::_Internal::metadata(const PersistentVolume* msg) {
  return *msg->_impl_.metadata_;
}
const ::k8s::io::api::core::v1::PersistentVolumeSpec&
PersistentVolume::_Internal::spec(const PersistentVolume* msg) {
  return *msg->_impl_.spec_;
}
const ::k8s::io::api::core::v1::PersistentVolumeStatus&
PersistentVolume::_Internal::status(const PersistentVolume* msg) {
  return *msg->_impl_.status_;
}
void PersistentVolume::clear_metadata() {
  if (_impl_.metadata_ != nullptr) _impl_.metadata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
PersistentVolume::PersistentVolume(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.PersistentVolume)
}
PersistentVolume::PersistentVolume(const PersistentVolume& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PersistentVolume* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.metadata_){nullptr}
    , decltype(_impl_.spec_){nullptr}
    , decltype(_impl_.status_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_metadata()) {
    _this->_impl_.metadata_ = new ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta(*from._impl_.metadata_);
  }
  if (from._internal_has_spec()) {
    _this->_impl_.spec_ = new ::k8s::io::api::core::v1::PersistentVolumeSpec(*from._impl_.spec_);
  }
  if (from._internal_has_status()) {
    _this->_impl_.status_ = new ::k8s::io::api::core::v1::PersistentVolumeStatus(*from._impl_.status_);
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.PersistentVolume)
}

inline void PersistentVolume::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.metadata_){nullptr}
    , decltype(_impl_.spec_){nullptr}
    , decltype(_impl_.status_){nullptr}
  };
}

PersistentVolume::~PersistentVolume() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.PersistentVolume)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PersistentVolume::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.metadata_;
  if (this != internal_default_instance()) delete _impl_.spec_;
  if (this != internal_default_instance()) delete _impl_.status_;
}

void PersistentVolume::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PersistentVolume::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.PersistentVolume)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.metadata_ != nullptr);
      _impl_.metadata_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.spec_ != nullptr);
      _impl_.spec_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.status_ != nullptr);
      _impl_.status_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PersistentVolume::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_metadata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.PersistentVolumeSpec spec = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_spec(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.PersistentVolumeStatus status = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_status(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PersistentVolume::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.PersistentVolume)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::metadata(this),
        _Internal::metadata(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.PersistentVolumeSpec spec = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::spec(this),
        _Internal::spec(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.PersistentVolumeStatus status = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::status(this),
        _Internal::status(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.PersistentVolume)
  return target;
}

size_t PersistentVolume::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.PersistentVolume)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.metadata_);
    }

    // optional .k8s.io.api.core.v1.PersistentVolumeSpec spec = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.spec_);
    }

    // optional .k8s.io.api.core.v1.PersistentVolumeStatus status = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.status_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PersistentVolume::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PersistentVolume::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PersistentVolume::GetClassData() const { return &_class_data_; }


void PersistentVolume::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PersistentVolume*>(&to_msg);
  auto& from = static_cast<const PersistentVolume&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.PersistentVolume)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_metadata()->::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta::MergeFrom(
          from._internal_metadata());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_spec()->::k8s::io::api::core::v1::PersistentVolumeSpec::MergeFrom(
          from._internal_spec());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_status()->::k8s::io::api::core::v1::PersistentVolumeStatus::MergeFrom(
          from._internal_status());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PersistentVolume::CopyFrom(const PersistentVolume& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.PersistentVolume)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PersistentVolume::IsInitialized() const {
  return true;
}

void PersistentVolume::InternalSwap(PersistentVolume* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PersistentVolume, _impl_.status_)
      + sizeof(PersistentVolume::_impl_.status_)
      - PROTOBUF_FIELD_OFFSET(PersistentVolume, _impl_.metadata_)>(
          reinterpret_cast<char*>(&_impl_.metadata_),
          reinterpret_cast<char*>(&other->_impl_.metadata_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PersistentVolume::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[127]);
}

// ===================================================================

class PersistentVolumeClaim::_Internal {
 public:
  using HasBits = decltype(std::declval<PersistentVolumeClaim>()._impl_._has_bits_);
  static const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& metadata(const PersistentVolumeClaim* msg);
  static void set_has_metadata(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::k8s::io::api::core::v1::PersistentVolumeClaimSpec& spec(const PersistentVolumeClaim* msg);
  static void set_has_spec(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::k8s::io::api::core::v1::PersistentVolumeClaimStatus& status(const PersistentVolumeClaim* msg);
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta&
PersistentVolumeClaim::_Internal::metadata(const PersistentVolumeClaim* msg) {
  return *msg->_impl_.metadata_;
}
const ::k8s::io::api::core::v1::PersistentVolumeClaimSpec&
PersistentVolumeClaim::_Internal::spec(const PersistentVolumeClaim* msg) {
  return *msg->_impl_.spec_;
}
const ::k8s::io::api::core::v1::PersistentVolumeClaimStatus&
PersistentVolumeClaim::_Internal::status(const PersistentVolumeClaim* msg) {
  return *msg->_impl_.status_;
}
void PersistentVolumeClaim::clear_metadata() {
  if (_impl_.metadata_ != nullptr) _impl_.metadata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
PersistentVolumeClaim::PersistentVolumeClaim(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.PersistentVolumeClaim)
}
PersistentVolumeClaim::PersistentVolumeClaim(const PersistentVolumeClaim& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PersistentVolumeClaim* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.metadata_){nullptr}
    , decltype(_impl_.spec_){nullptr}
    , decltype(_impl_.status_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_metadata()) {
    _this->_impl_.metadata_ = new ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta(*from._impl_.metadata_);
  }
  if (from._internal_has_spec()) {
    _this->_impl_.spec_ = new ::k8s::io::api::core::v1::PersistentVolumeClaimSpec(*from._impl_.spec_);
  }
  if (from._internal_has_status()) {
    _this->_impl_.status_ = new ::k8s::io::api::core::v1::PersistentVolumeClaimStatus(*from._impl_.status_);
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.PersistentVolumeClaim)
}

inline void PersistentVolumeClaim::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.metadata_){nullptr}
    , decltype(_impl_.spec_){nullptr}
    , decltype(_impl_.status_){nullptr}
  };
}

PersistentVolumeClaim::~PersistentVolumeClaim() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.PersistentVolumeClaim)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PersistentVolumeClaim::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.metadata_;
  if (this != internal_default_instance()) delete _impl_.spec_;
  if (this != internal_default_instance()) delete _impl_.status_;
}

void PersistentVolumeClaim::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PersistentVolumeClaim::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.PersistentVolumeClaim)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.metadata_ != nullptr);
      _impl_.metadata_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.spec_ != nullptr);
      _impl_.spec_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.status_ != nullptr);
      _impl_.status_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PersistentVolumeClaim::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_metadata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.PersistentVolumeClaimSpec spec = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_spec(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.PersistentVolumeClaimStatus status = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_status(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PersistentVolumeClaim::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.PersistentVolumeClaim)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::metadata(this),
        _Internal::metadata(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.PersistentVolumeClaimSpec spec = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::spec(this),
        _Internal::spec(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.PersistentVolumeClaimStatus status = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::status(this),
        _Internal::status(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.PersistentVolumeClaim)
  return target;
}

size_t PersistentVolumeClaim::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.PersistentVolumeClaim)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.metadata_);
    }

    // optional .k8s.io.api.core.v1.PersistentVolumeClaimSpec spec = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.spec_);
    }

    // optional .k8s.io.api.core.v1.PersistentVolumeClaimStatus status = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.status_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PersistentVolumeClaim::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PersistentVolumeClaim::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PersistentVolumeClaim::GetClassData() const { return &_class_data_; }


void PersistentVolumeClaim::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PersistentVolumeClaim*>(&to_msg);
  auto& from = static_cast<const PersistentVolumeClaim&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.PersistentVolumeClaim)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_metadata()->::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta::MergeFrom(
          from._internal_metadata());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_spec()->::k8s::io::api::core::v1::PersistentVolumeClaimSpec::MergeFrom(
          from._internal_spec());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_status()->::k8s::io::api::core::v1::PersistentVolumeClaimStatus::MergeFrom(
          from._internal_status());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PersistentVolumeClaim::CopyFrom(const PersistentVolumeClaim& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.PersistentVolumeClaim)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PersistentVolumeClaim::IsInitialized() const {
  return true;
}

void PersistentVolumeClaim::InternalSwap(PersistentVolumeClaim* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PersistentVolumeClaim, _impl_.status_)
      + sizeof(PersistentVolumeClaim::_impl_.status_)
      - PROTOBUF_FIELD_OFFSET(PersistentVolumeClaim, _impl_.metadata_)>(
          reinterpret_cast<char*>(&_impl_.metadata_),
          reinterpret_cast<char*>(&other->_impl_.metadata_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PersistentVolumeClaim::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[128]);
}

// ===================================================================

class PersistentVolumeClaimCondition::_Internal {
 public:
  using HasBits = decltype(std::declval<PersistentVolumeClaimCondition>()._impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::k8s::io::apimachinery::pkg::apis::meta::v1::Time& lastprobetime(const PersistentVolumeClaimCondition* msg);
  static void set_has_lastprobetime(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::k8s::io::apimachinery::pkg::apis::meta::v1::Time& lasttransitiontime(const PersistentVolumeClaimCondition* msg);
  static void set_has_lasttransitiontime(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_reason(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_message(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::k8s::io::apimachinery::pkg::apis::meta::v1::Time&
PersistentVolumeClaimCondition::_Internal::lastprobetime(const PersistentVolumeClaimCondition* msg) {
  return *msg->_impl_.lastprobetime_;
}
const ::k8s::io::apimachinery::pkg::apis::meta::v1::Time&
PersistentVolumeClaimCondition::_Internal::lasttransitiontime(const PersistentVolumeClaimCondition* msg) {
  return *msg->_impl_.lasttransitiontime_;
}
void PersistentVolumeClaimCondition::clear_lastprobetime() {
  if (_impl_.lastprobetime_ != nullptr) _impl_.lastprobetime_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
void PersistentVolumeClaimCondition::clear_lasttransitiontime() {
  if (_impl_.lasttransitiontime_ != nullptr) _impl_.lasttransitiontime_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
PersistentVolumeClaimCondition::PersistentVolumeClaimCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.PersistentVolumeClaimCondition)
}
PersistentVolumeClaimCondition::PersistentVolumeClaimCondition(const PersistentVolumeClaimCondition& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PersistentVolumeClaimCondition* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.type_){}
    , decltype(_impl_.status_){}
    , decltype(_impl_.reason_){}
    , decltype(_impl_.message_){}
    , decltype(_impl_.lastprobetime_){nullptr}
    , decltype(_impl_.lasttransitiontime_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_type()) {
    _this->_impl_.type_.Set(from._internal_type(), 
      _this->GetArenaForAllocation());
  }
  _impl_.status_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.status_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_status()) {
    _this->_impl_.status_.Set(from._internal_status(), 
      _this->GetArenaForAllocation());
  }
  _impl_.reason_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.reason_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_reason()) {
    _this->_impl_.reason_.Set(from._internal_reason(), 
      _this->GetArenaForAllocation());
  }
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_message()) {
    _this->_impl_.message_.Set(from._internal_message(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_lastprobetime()) {
    _this->_impl_.lastprobetime_ = new ::k8s::io::apimachinery::pkg::apis::meta::v1::Time(*from._impl_.lastprobetime_);
  }
  if (from._internal_has_lasttransitiontime()) {
    _this->_impl_.lasttransitiontime_ = new ::k8s::io::apimachinery::pkg::apis::meta::v1::Time(*from._impl_.lasttransitiontime_);
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.PersistentVolumeClaimCondition)
}

inline void PersistentVolumeClaimCondition::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.type_){}
    , decltype(_impl_.status_){}
    , decltype(_impl_.reason_){}
    , decltype(_impl_.message_){}
    , decltype(_impl_.lastprobetime_){nullptr}
    , decltype(_impl_.lasttransitiontime_){nullptr}
  };
  _impl_.type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.status_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.status_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.reason_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.reason_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PersistentVolumeClaimCondition::~PersistentVolumeClaimCondition() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.PersistentVolumeClaimCondition)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PersistentVolumeClaimCondition::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.type_.Destroy();
  _impl_.status_.Destroy();
  _impl_.reason_.Destroy();
  _impl_.message_.Destroy();
  if (this != internal_default_instance()) delete _impl_.lastprobetime_;
  if (this != internal_default_instance()) delete _impl_.lasttransitiontime_;
}

void PersistentVolumeClaimCondition::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PersistentVolumeClaimCondition::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.PersistentVolumeClaimCondition)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.type_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.status_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.reason_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.message_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.lastprobetime_ != nullptr);
      _impl_.lastprobetime_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.lasttransitiontime_ != nullptr);
      _impl_.lasttransitiontime_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PersistentVolumeClaimCondition::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes status = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_status();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastProbeTime = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_lastprobetime(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_lasttransitiontime(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes reason = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_reason();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes message = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PersistentVolumeClaimCondition::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.PersistentVolumeClaimCondition)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_type(), target);
  }

  // optional bytes status = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_status(), target);
  }

  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastProbeTime = 3;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::lastprobetime(this),
        _Internal::lastprobetime(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 4;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::lasttransitiontime(this),
        _Internal::lasttransitiontime(this).GetCachedSize(), target, stream);
  }

  // optional bytes reason = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_reason(), target);
  }

  // optional bytes message = 6;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        6, this->_internal_message(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.PersistentVolumeClaimCondition)
  return target;
}

size_t PersistentVolumeClaimCondition::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.PersistentVolumeClaimCondition)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional bytes type = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_type());
    }

    // optional bytes status = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_status());
    }

    // optional bytes reason = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_reason());
    }

    // optional bytes message = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_message());
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastProbeTime = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.lastprobetime_);
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.lasttransitiontime_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PersistentVolumeClaimCondition::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PersistentVolumeClaimCondition::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PersistentVolumeClaimCondition::GetClassData() const { return &_class_data_; }


void PersistentVolumeClaimCondition::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PersistentVolumeClaimCondition*>(&to_msg);
  auto& from = static_cast<const PersistentVolumeClaimCondition&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.PersistentVolumeClaimCondition)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_type(from._internal_type());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_status(from._internal_status());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_reason(from._internal_reason());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_message(from._internal_message());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_lastprobetime()->::k8s::io::apimachinery::pkg::apis::meta::v1::Time::MergeFrom(
          from._internal_lastprobetime());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_lasttransitiontime()->::k8s::io::apimachinery::pkg::apis::meta::v1::Time::MergeFrom(
          from._internal_lasttransitiontime());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PersistentVolumeClaimCondition::CopyFrom(const PersistentVolumeClaimCondition& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.PersistentVolumeClaimCondition)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PersistentVolumeClaimCondition::IsInitialized() const {
  return true;
}

void PersistentVolumeClaimCondition::InternalSwap(PersistentVolumeClaimCondition* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.type_, lhs_arena,
      &other->_impl_.type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.status_, lhs_arena,
      &other->_impl_.status_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.reason_, lhs_arena,
      &other->_impl_.reason_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.message_, lhs_arena,
      &other->_impl_.message_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PersistentVolumeClaimCondition, _impl_.lasttransitiontime_)
      + sizeof(PersistentVolumeClaimCondition::_impl_.lasttransitiontime_)
      - PROTOBUF_FIELD_OFFSET(PersistentVolumeClaimCondition, _impl_.lastprobetime_)>(
          reinterpret_cast<char*>(&_impl_.lastprobetime_),
          reinterpret_cast<char*>(&other->_impl_.lastprobetime_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PersistentVolumeClaimCondition::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[129]);
}

// ===================================================================

class PersistentVolumeClaimList::_Internal {
 public:
  using HasBits = decltype(std::declval<PersistentVolumeClaimList>()._impl_._has_bits_);
  static const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& metadata(const PersistentVolumeClaimList* msg);
  static void set_has_metadata(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta&
PersistentVolumeClaimList::_Internal::metadata(const PersistentVolumeClaimList* msg) {
  return *msg->_impl_.metadata_;
}
void PersistentVolumeClaimList::clear_metadata() {
  if (_impl_.metadata_ != nullptr) _impl_.metadata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
PersistentVolumeClaimList::PersistentVolumeClaimList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.PersistentVolumeClaimList)
}
PersistentVolumeClaimList::PersistentVolumeClaimList(const PersistentVolumeClaimList& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PersistentVolumeClaimList* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.items_){from._impl_.items_}
    , decltype(_impl_.metadata_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_metadata()) {
    _this->_impl_.metadata_ = new ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta(*from._impl_.metadata_);
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.PersistentVolumeClaimList)
}

inline void PersistentVolumeClaimList::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.items_){arena}
    , decltype(_impl_.metadata_){nullptr}
  };
}

PersistentVolumeClaimList::~PersistentVolumeClaimList() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.PersistentVolumeClaimList)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PersistentVolumeClaimList::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.items_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.metadata_;
}

void PersistentVolumeClaimList::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PersistentVolumeClaimList::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.PersistentVolumeClaimList)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.items_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.metadata_ != nullptr);
    _impl_.metadata_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PersistentVolumeClaimList::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_metadata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .k8s.io.api.core.v1.PersistentVolumeClaim items = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_items(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PersistentVolumeClaimList::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.PersistentVolumeClaimList)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::metadata(this),
        _Internal::metadata(this).GetCachedSize(), target, stream);
  }

  // repeated .k8s.io.api.core.v1.PersistentVolumeClaim items = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_items_size()); i < n; i++) {
    const auto& repfield = this->_internal_items(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.PersistentVolumeClaimList)
  return target;
}

size_t PersistentVolumeClaimList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.PersistentVolumeClaimList)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .k8s.io.api.core.v1.PersistentVolumeClaim items = 2;
  total_size += 1UL * this->_internal_items_size();
  for (const auto& msg : this->_impl_.items_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.metadata_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PersistentVolumeClaimList::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PersistentVolumeClaimList::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PersistentVolumeClaimList::GetClassData() const { return &_class_data_; }


void PersistentVolumeClaimList::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PersistentVolumeClaimList*>(&to_msg);
  auto& from = static_cast<const PersistentVolumeClaimList&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.PersistentVolumeClaimList)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.items_.MergeFrom(from._impl_.items_);
  if (from._internal_has_metadata()) {
    _this->_internal_mutable_metadata()->::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta::MergeFrom(
        from._internal_metadata());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PersistentVolumeClaimList::CopyFrom(const PersistentVolumeClaimList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.PersistentVolumeClaimList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PersistentVolumeClaimList::IsInitialized() const {
  return true;
}

void PersistentVolumeClaimList::InternalSwap(PersistentVolumeClaimList* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.items_.InternalSwap(&other->_impl_.items_);
  swap(_impl_.metadata_, other->_impl_.metadata_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PersistentVolumeClaimList::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[130]);
}

// ===================================================================

class PersistentVolumeClaimSpec::_Internal {
 public:
  using HasBits = decltype(std::declval<PersistentVolumeClaimSpec>()._impl_._has_bits_);
  static const ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector& selector(const PersistentVolumeClaimSpec* msg);
  static void set_has_selector(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::k8s::io::api::core::v1::VolumeResourceRequirements& resources(const PersistentVolumeClaimSpec* msg);
  static void set_has_resources(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_volumename(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_storageclassname(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_volumemode(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::k8s::io::api::core::v1::TypedLocalObjectReference& datasource(const PersistentVolumeClaimSpec* msg);
  static void set_has_datasource(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::k8s::io::api::core::v1::TypedObjectReference& datasourceref(const PersistentVolumeClaimSpec* msg);
  static void set_has_datasourceref(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_volumeattributesclassname(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector&
PersistentVolumeClaimSpec::_Internal::selector(const PersistentVolumeClaimSpec* msg) {
  return *msg->_impl_.selector_;
}
const ::k8s::io::api::core::v1::VolumeResourceRequirements&
PersistentVolumeClaimSpec::_Internal::resources(const PersistentVolumeClaimSpec* msg) {
  return *msg->_impl_.resources_;
}
const ::k8s::io::api::core::v1::TypedLocalObjectReference&
PersistentVolumeClaimSpec::_Internal::datasource(const PersistentVolumeClaimSpec* msg) {
  return *msg->_impl_.datasource_;
}
const ::k8s::io::api::core::v1::TypedObjectReference&
PersistentVolumeClaimSpec::_Internal::datasourceref(const PersistentVolumeClaimSpec* msg) {
  return *msg->_impl_.datasourceref_;
}
void PersistentVolumeClaimSpec::clear_selector() {
  if (_impl_.selector_ != nullptr) _impl_.selector_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
PersistentVolumeClaimSpec::PersistentVolumeClaimSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.PersistentVolumeClaimSpec)
}
PersistentVolumeClaimSpec::PersistentVolumeClaimSpec(const PersistentVolumeClaimSpec& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PersistentVolumeClaimSpec* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.accessmodes_){from._impl_.accessmodes_}
    , decltype(_impl_.volumename_){}
    , decltype(_impl_.storageclassname_){}
    , decltype(_impl_.volumemode_){}
    , decltype(_impl_.volumeattributesclassname_){}
    , decltype(_impl_.resources_){nullptr}
    , decltype(_impl_.selector_){nullptr}
    , decltype(_impl_.datasource_){nullptr}
    , decltype(_impl_.datasourceref_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.volumename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.volumename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_volumename()) {
    _this->_impl_.volumename_.Set(from._internal_volumename(), 
      _this->GetArenaForAllocation());
  }
  _impl_.storageclassname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.storageclassname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_storageclassname()) {
    _this->_impl_.storageclassname_.Set(from._internal_storageclassname(), 
      _this->GetArenaForAllocation());
  }
  _impl_.volumemode_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.volumemode_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_volumemode()) {
    _this->_impl_.volumemode_.Set(from._internal_volumemode(), 
      _this->GetArenaForAllocation());
  }
  _impl_.volumeattributesclassname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.volumeattributesclassname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_volumeattributesclassname()) {
    _this->_impl_.volumeattributesclassname_.Set(from._internal_volumeattributesclassname(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_resources()) {
    _this->_impl_.resources_ = new ::k8s::io::api::core::v1::VolumeResourceRequirements(*from._impl_.resources_);
  }
  if (from._internal_has_selector()) {
    _this->_impl_.selector_ = new ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector(*from._impl_.selector_);
  }
  if (from._internal_has_datasource()) {
    _this->_impl_.datasource_ = new ::k8s::io::api::core::v1::TypedLocalObjectReference(*from._impl_.datasource_);
  }
  if (from._internal_has_datasourceref()) {
    _this->_impl_.datasourceref_ = new ::k8s::io::api::core::v1::TypedObjectReference(*from._impl_.datasourceref_);
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.PersistentVolumeClaimSpec)
}

inline void PersistentVolumeClaimSpec::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.accessmodes_){arena}
    , decltype(_impl_.volumename_){}
    , decltype(_impl_.storageclassname_){}
    , decltype(_impl_.volumemode_){}
    , decltype(_impl_.volumeattributesclassname_){}
    , decltype(_impl_.resources_){nullptr}
    , decltype(_impl_.selector_){nullptr}
    , decltype(_impl_.datasource_){nullptr}
    , decltype(_impl_.datasourceref_){nullptr}
  };
  _impl_.volumename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.volumename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.storageclassname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.storageclassname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.volumemode_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.volumemode_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.volumeattributesclassname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.volumeattributesclassname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PersistentVolumeClaimSpec::~PersistentVolumeClaimSpec() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.PersistentVolumeClaimSpec)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PersistentVolumeClaimSpec::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.accessmodes_.~RepeatedPtrField();
  _impl_.volumename_.Destroy();
  _impl_.storageclassname_.Destroy();
  _impl_.volumemode_.Destroy();
  _impl_.volumeattributesclassname_.Destroy();
  if (this != internal_default_instance()) delete _impl_.resources_;
  if (this != internal_default_instance()) delete _impl_.selector_;
  if (this != internal_default_instance()) delete _impl_.datasource_;
  if (this != internal_default_instance()) delete _impl_.datasourceref_;
}

void PersistentVolumeClaimSpec::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PersistentVolumeClaimSpec::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.PersistentVolumeClaimSpec)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.accessmodes_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.volumename_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.storageclassname_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.volumemode_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.volumeattributesclassname_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.resources_ != nullptr);
      _impl_.resources_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.selector_ != nullptr);
      _impl_.selector_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(_impl_.datasource_ != nullptr);
      _impl_.datasource_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(_impl_.datasourceref_ != nullptr);
      _impl_.datasourceref_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PersistentVolumeClaimSpec::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string accessModes = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_accessmodes();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "k8s.io.api.core.v1.PersistentVolumeClaimSpec.accessModes");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.VolumeResourceRequirements resources = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_resources(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes volumeName = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_volumename();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_selector(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes storageClassName = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_storageclassname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes volumeMode = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_volumemode();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.TypedLocalObjectReference dataSource = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_datasource(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.TypedObjectReference dataSourceRef = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_datasourceref(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes volumeAttributesClassName = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_volumeattributesclassname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PersistentVolumeClaimSpec::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.PersistentVolumeClaimSpec)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string accessModes = 1;
  for (int i = 0, n = this->_internal_accessmodes_size(); i < n; i++) {
    const auto& s = this->_internal_accessmodes(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "k8s.io.api.core.v1.PersistentVolumeClaimSpec.accessModes");
    target = stream->WriteString(1, s, target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional .k8s.io.api.core.v1.VolumeResourceRequirements resources = 2;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::resources(this),
        _Internal::resources(this).GetCachedSize(), target, stream);
  }

  // optional bytes volumeName = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_volumename(), target);
  }

  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 4;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::selector(this),
        _Internal::selector(this).GetCachedSize(), target, stream);
  }

  // optional bytes storageClassName = 5;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_storageclassname(), target);
  }

  // optional bytes volumeMode = 6;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        6, this->_internal_volumemode(), target);
  }

  // optional .k8s.io.api.core.v1.TypedLocalObjectReference dataSource = 7;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::datasource(this),
        _Internal::datasource(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.TypedObjectReference dataSourceRef = 8;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::datasourceref(this),
        _Internal::datasourceref(this).GetCachedSize(), target, stream);
  }

  // optional bytes volumeAttributesClassName = 9;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        9, this->_internal_volumeattributesclassname(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.PersistentVolumeClaimSpec)
  return target;
}

size_t PersistentVolumeClaimSpec::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.PersistentVolumeClaimSpec)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string accessModes = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.accessmodes_.size());
  for (int i = 0, n = _impl_.accessmodes_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.accessmodes_.Get(i));
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bytes volumeName = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_volumename());
    }

    // optional bytes storageClassName = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_storageclassname());
    }

    // optional bytes volumeMode = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_volumemode());
    }

    // optional bytes volumeAttributesClassName = 9;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_volumeattributesclassname());
    }

    // optional .k8s.io.api.core.v1.VolumeResourceRequirements resources = 2;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.resources_);
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.selector_);
    }

    // optional .k8s.io.api.core.v1.TypedLocalObjectReference dataSource = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.datasource_);
    }

    // optional .k8s.io.api.core.v1.TypedObjectReference dataSourceRef = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.datasourceref_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PersistentVolumeClaimSpec::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PersistentVolumeClaimSpec::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PersistentVolumeClaimSpec::GetClassData() const { return &_class_data_; }


void PersistentVolumeClaimSpec::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PersistentVolumeClaimSpec*>(&to_msg);
  auto& from = static_cast<const PersistentVolumeClaimSpec&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.PersistentVolumeClaimSpec)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.accessmodes_.MergeFrom(from._impl_.accessmodes_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_volumename(from._internal_volumename());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_storageclassname(from._internal_storageclassname());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_volumemode(from._internal_volumemode());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_volumeattributesclassname(from._internal_volumeattributesclassname());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_resources()->::k8s::io::api::core::v1::VolumeResourceRequirements::MergeFrom(
          from._internal_resources());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_selector()->::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector::MergeFrom(
          from._internal_selector());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_datasource()->::k8s::io::api::core::v1::TypedLocalObjectReference::MergeFrom(
          from._internal_datasource());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_mutable_datasourceref()->::k8s::io::api::core::v1::TypedObjectReference::MergeFrom(
          from._internal_datasourceref());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PersistentVolumeClaimSpec::CopyFrom(const PersistentVolumeClaimSpec& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.PersistentVolumeClaimSpec)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PersistentVolumeClaimSpec::IsInitialized() const {
  return true;
}

void PersistentVolumeClaimSpec::InternalSwap(PersistentVolumeClaimSpec* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.accessmodes_.InternalSwap(&other->_impl_.accessmodes_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.volumename_, lhs_arena,
      &other->_impl_.volumename_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.storageclassname_, lhs_arena,
      &other->_impl_.storageclassname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.volumemode_, lhs_arena,
      &other->_impl_.volumemode_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.volumeattributesclassname_, lhs_arena,
      &other->_impl_.volumeattributesclassname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PersistentVolumeClaimSpec, _impl_.datasourceref_)
      + sizeof(PersistentVolumeClaimSpec::_impl_.datasourceref_)
      - PROTOBUF_FIELD_OFFSET(PersistentVolumeClaimSpec, _impl_.resources_)>(
          reinterpret_cast<char*>(&_impl_.resources_),
          reinterpret_cast<char*>(&other->_impl_.resources_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PersistentVolumeClaimSpec::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[131]);
}

// ===================================================================

PersistentVolumeClaimStatus_CapacityEntry_DoNotUse::PersistentVolumeClaimStatus_CapacityEntry_DoNotUse() {}
PersistentVolumeClaimStatus_CapacityEntry_DoNotUse::PersistentVolumeClaimStatus_CapacityEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void PersistentVolumeClaimStatus_CapacityEntry_DoNotUse::MergeFrom(const PersistentVolumeClaimStatus_CapacityEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata PersistentVolumeClaimStatus_CapacityEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[132]);
}

// ===================================================================

PersistentVolumeClaimStatus_AllocatedResourcesEntry_DoNotUse::PersistentVolumeClaimStatus_AllocatedResourcesEntry_DoNotUse() {}
PersistentVolumeClaimStatus_AllocatedResourcesEntry_DoNotUse::PersistentVolumeClaimStatus_AllocatedResourcesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void PersistentVolumeClaimStatus_AllocatedResourcesEntry_DoNotUse::MergeFrom(const PersistentVolumeClaimStatus_AllocatedResourcesEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata PersistentVolumeClaimStatus_AllocatedResourcesEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[133]);
}

// ===================================================================

PersistentVolumeClaimStatus_AllocatedResourceStatusesEntry_DoNotUse::PersistentVolumeClaimStatus_AllocatedResourceStatusesEntry_DoNotUse() {}
PersistentVolumeClaimStatus_AllocatedResourceStatusesEntry_DoNotUse::PersistentVolumeClaimStatus_AllocatedResourceStatusesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void PersistentVolumeClaimStatus_AllocatedResourceStatusesEntry_DoNotUse::MergeFrom(const PersistentVolumeClaimStatus_AllocatedResourceStatusesEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata PersistentVolumeClaimStatus_AllocatedResourceStatusesEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[134]);
}

// ===================================================================

class PersistentVolumeClaimStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<PersistentVolumeClaimStatus>()._impl_._has_bits_);
  static void set_has_phase(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_currentvolumeattributesclassname(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::k8s::io::api::core::v1::ModifyVolumeStatus& modifyvolumestatus(const PersistentVolumeClaimStatus* msg);
  static void set_has_modifyvolumestatus(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::k8s::io::api::core::v1::ModifyVolumeStatus&
PersistentVolumeClaimStatus::_Internal::modifyvolumestatus(const PersistentVolumeClaimStatus* msg) {
  return *msg->_impl_.modifyvolumestatus_;
}
void PersistentVolumeClaimStatus::clear_capacity() {
  _impl_.capacity_.Clear();
}
void PersistentVolumeClaimStatus::clear_allocatedresources() {
  _impl_.allocatedresources_.Clear();
}
PersistentVolumeClaimStatus::PersistentVolumeClaimStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &PersistentVolumeClaimStatus::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.PersistentVolumeClaimStatus)
}
PersistentVolumeClaimStatus::PersistentVolumeClaimStatus(const PersistentVolumeClaimStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PersistentVolumeClaimStatus* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.accessmodes_){from._impl_.accessmodes_}
    , /*decltype(_impl_.capacity_)*/{}
    , decltype(_impl_.conditions_){from._impl_.conditions_}
    , /*decltype(_impl_.allocatedresources_)*/{}
    , /*decltype(_impl_.allocatedresourcestatuses_)*/{}
    , decltype(_impl_.phase_){}
    , decltype(_impl_.currentvolumeattributesclassname_){}
    , decltype(_impl_.modifyvolumestatus_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.capacity_.MergeFrom(from._impl_.capacity_);
  _this->_impl_.allocatedresources_.MergeFrom(from._impl_.allocatedresources_);
  _this->_impl_.allocatedresourcestatuses_.MergeFrom(from._impl_.allocatedresourcestatuses_);
  _impl_.phase_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.phase_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_phase()) {
    _this->_impl_.phase_.Set(from._internal_phase(), 
      _this->GetArenaForAllocation());
  }
  _impl_.currentvolumeattributesclassname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.currentvolumeattributesclassname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_currentvolumeattributesclassname()) {
    _this->_impl_.currentvolumeattributesclassname_.Set(from._internal_currentvolumeattributesclassname(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_modifyvolumestatus()) {
    _this->_impl_.modifyvolumestatus_ = new ::k8s::io::api::core::v1::ModifyVolumeStatus(*from._impl_.modifyvolumestatus_);
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.PersistentVolumeClaimStatus)
}

inline void PersistentVolumeClaimStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.accessmodes_){arena}
    , /*decltype(_impl_.capacity_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.conditions_){arena}
    , /*decltype(_impl_.allocatedresources_)*/{::_pbi::ArenaInitialized(), arena}
    , /*decltype(_impl_.allocatedresourcestatuses_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.phase_){}
    , decltype(_impl_.currentvolumeattributesclassname_){}
    , decltype(_impl_.modifyvolumestatus_){nullptr}
  };
  _impl_.phase_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.phase_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.currentvolumeattributesclassname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.currentvolumeattributesclassname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PersistentVolumeClaimStatus::~PersistentVolumeClaimStatus() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.PersistentVolumeClaimStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void PersistentVolumeClaimStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.accessmodes_.~RepeatedPtrField();
  _impl_.capacity_.Destruct();
  _impl_.capacity_.~MapField();
  _impl_.conditions_.~RepeatedPtrField();
  _impl_.allocatedresources_.Destruct();
  _impl_.allocatedresources_.~MapField();
  _impl_.allocatedresourcestatuses_.Destruct();
  _impl_.allocatedresourcestatuses_.~MapField();
  _impl_.phase_.Destroy();
  _impl_.currentvolumeattributesclassname_.Destroy();
  if (this != internal_default_instance()) delete _impl_.modifyvolumestatus_;
}

void PersistentVolumeClaimStatus::ArenaDtor(void* object) {
  PersistentVolumeClaimStatus* _this = reinterpret_cast< PersistentVolumeClaimStatus* >(object);
  _this->_impl_.capacity_.Destruct();
  _this->_impl_.allocatedresources_.Destruct();
  _this->_impl_.allocatedresourcestatuses_.Destruct();
}
void PersistentVolumeClaimStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PersistentVolumeClaimStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.PersistentVolumeClaimStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.accessmodes_.Clear();
  _impl_.capacity_.Clear();
  _impl_.conditions_.Clear();
  _impl_.allocatedresources_.Clear();
  _impl_.allocatedresourcestatuses_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.phase_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.currentvolumeattributesclassname_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.modifyvolumestatus_ != nullptr);
      _impl_.modifyvolumestatus_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PersistentVolumeClaimStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes phase = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_phase();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string accessModes = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_accessmodes();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "k8s.io.api.core.v1.PersistentVolumeClaimStatus.accessModes");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // map<string, .k8s.io.apimachinery.pkg.api.resource.Quantity> capacity = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.capacity_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .k8s.io.api.core.v1.PersistentVolumeClaimCondition conditions = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_conditions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // map<string, .k8s.io.apimachinery.pkg.api.resource.Quantity> allocatedResources = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.allocatedresources_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // map<string, string> allocatedResourceStatuses = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.allocatedresourcestatuses_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bytes currentVolumeAttributesClassName = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_currentvolumeattributesclassname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.ModifyVolumeStatus modifyVolumeStatus = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_modifyvolumestatus(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PersistentVolumeClaimStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.PersistentVolumeClaimStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes phase = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_phase(), target);
  }

  // repeated string accessModes = 2;
  for (int i = 0, n = this->_internal_accessmodes_size(); i < n; i++) {
    const auto& s = this->_internal_accessmodes(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "k8s.io.api.core.v1.PersistentVolumeClaimStatus.accessModes");
    target = stream->WriteString(2, s, target);
  }

  // map<string, .k8s.io.apimachinery.pkg.api.resource.Quantity> capacity = 3;
  if (!this->_internal_capacity().empty()) {
    using MapType = ::_pb::Map<std::string, ::k8s::io::apimachinery::pkg::api::resource::Quantity>;
    using WireHelper = PersistentVolumeClaimStatus_CapacityEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_capacity();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "k8s.io.api.core.v1.PersistentVolumeClaimStatus.CapacityEntry.key");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(3, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(3, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  // repeated .k8s.io.api.core.v1.PersistentVolumeClaimCondition conditions = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_conditions_size()); i < n; i++) {
    const auto& repfield = this->_internal_conditions(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // map<string, .k8s.io.apimachinery.pkg.api.resource.Quantity> allocatedResources = 5;
  if (!this->_internal_allocatedresources().empty()) {
    using MapType = ::_pb::Map<std::string, ::k8s::io::apimachinery::pkg::api::resource::Quantity>;
    using WireHelper = PersistentVolumeClaimStatus_AllocatedResourcesEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_allocatedresources();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "k8s.io.api.core.v1.PersistentVolumeClaimStatus.AllocatedResourcesEntry.key");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(5, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(5, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  // map<string, string> allocatedResourceStatuses = 7;
  if (!this->_internal_allocatedresourcestatuses().empty()) {
    using MapType = ::_pb::Map<std::string, std::string>;
    using WireHelper = PersistentVolumeClaimStatus_AllocatedResourceStatusesEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_allocatedresourcestatuses();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "k8s.io.api.core.v1.PersistentVolumeClaimStatus.AllocatedResourceStatusesEntry.key");
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        entry.second.data(), static_cast<int>(entry.second.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "k8s.io.api.core.v1.PersistentVolumeClaimStatus.AllocatedResourceStatusesEntry.value");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(7, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(7, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  // optional bytes currentVolumeAttributesClassName = 8;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        8, this->_internal_currentvolumeattributesclassname(), target);
  }

  // optional .k8s.io.api.core.v1.ModifyVolumeStatus modifyVolumeStatus = 9;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::modifyvolumestatus(this),
        _Internal::modifyvolumestatus(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.PersistentVolumeClaimStatus)
  return target;
}

size_t PersistentVolumeClaimStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.PersistentVolumeClaimStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string accessModes = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.accessmodes_.size());
  for (int i = 0, n = _impl_.accessmodes_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.accessmodes_.Get(i));
  }

  // map<string, .k8s.io.apimachinery.pkg.api.resource.Quantity> capacity = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_capacity_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::k8s::io::apimachinery::pkg::api::resource::Quantity >::const_iterator
      it = this->_internal_capacity().begin();
      it != this->_internal_capacity().end(); ++it) {
    total_size += PersistentVolumeClaimStatus_CapacityEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // repeated .k8s.io.api.core.v1.PersistentVolumeClaimCondition conditions = 4;
  total_size += 1UL * this->_internal_conditions_size();
  for (const auto& msg : this->_impl_.conditions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // map<string, .k8s.io.apimachinery.pkg.api.resource.Quantity> allocatedResources = 5;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_allocatedresources_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::k8s::io::apimachinery::pkg::api::resource::Quantity >::const_iterator
      it = this->_internal_allocatedresources().begin();
      it != this->_internal_allocatedresources().end(); ++it) {
    total_size += PersistentVolumeClaimStatus_AllocatedResourcesEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // map<string, string> allocatedResourceStatuses = 7;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_allocatedresourcestatuses_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
      it = this->_internal_allocatedresourcestatuses().begin();
      it != this->_internal_allocatedresourcestatuses().end(); ++it) {
    total_size += PersistentVolumeClaimStatus_AllocatedResourceStatusesEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bytes phase = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_phase());
    }

    // optional bytes currentVolumeAttributesClassName = 8;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_currentvolumeattributesclassname());
    }

    // optional .k8s.io.api.core.v1.ModifyVolumeStatus modifyVolumeStatus = 9;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.modifyvolumestatus_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PersistentVolumeClaimStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PersistentVolumeClaimStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PersistentVolumeClaimStatus::GetClassData() const { return &_class_data_; }


void PersistentVolumeClaimStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PersistentVolumeClaimStatus*>(&to_msg);
  auto& from = static_cast<const PersistentVolumeClaimStatus&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.PersistentVolumeClaimStatus)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.accessmodes_.MergeFrom(from._impl_.accessmodes_);
  _this->_impl_.capacity_.MergeFrom(from._impl_.capacity_);
  _this->_impl_.conditions_.MergeFrom(from._impl_.conditions_);
  _this->_impl_.allocatedresources_.MergeFrom(from._impl_.allocatedresources_);
  _this->_impl_.allocatedresourcestatuses_.MergeFrom(from._impl_.allocatedresourcestatuses_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_phase(from._internal_phase());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_currentvolumeattributesclassname(from._internal_currentvolumeattributesclassname());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_modifyvolumestatus()->::k8s::io::api::core::v1::ModifyVolumeStatus::MergeFrom(
          from._internal_modifyvolumestatus());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PersistentVolumeClaimStatus::CopyFrom(const PersistentVolumeClaimStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.PersistentVolumeClaimStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PersistentVolumeClaimStatus::IsInitialized() const {
  return true;
}

void PersistentVolumeClaimStatus::InternalSwap(PersistentVolumeClaimStatus* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.accessmodes_.InternalSwap(&other->_impl_.accessmodes_);
  _impl_.capacity_.InternalSwap(&other->_impl_.capacity_);
  _impl_.conditions_.InternalSwap(&other->_impl_.conditions_);
  _impl_.allocatedresources_.InternalSwap(&other->_impl_.allocatedresources_);
  _impl_.allocatedresourcestatuses_.InternalSwap(&other->_impl_.allocatedresourcestatuses_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.phase_, lhs_arena,
      &other->_impl_.phase_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.currentvolumeattributesclassname_, lhs_arena,
      &other->_impl_.currentvolumeattributesclassname_, rhs_arena
  );
  swap(_impl_.modifyvolumestatus_, other->_impl_.modifyvolumestatus_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PersistentVolumeClaimStatus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[135]);
}

// ===================================================================

class PersistentVolumeClaimTemplate::_Internal {
 public:
  using HasBits = decltype(std::declval<PersistentVolumeClaimTemplate>()._impl_._has_bits_);
  static const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& metadata(const PersistentVolumeClaimTemplate* msg);
  static void set_has_metadata(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::k8s::io::api::core::v1::PersistentVolumeClaimSpec& spec(const PersistentVolumeClaimTemplate* msg);
  static void set_has_spec(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta&
PersistentVolumeClaimTemplate::_Internal::metadata(const PersistentVolumeClaimTemplate* msg) {
  return *msg->_impl_.metadata_;
}
const ::k8s::io::api::core::v1::PersistentVolumeClaimSpec&
PersistentVolumeClaimTemplate::_Internal::spec(const PersistentVolumeClaimTemplate* msg) {
  return *msg->_impl_.spec_;
}
void PersistentVolumeClaimTemplate::clear_metadata() {
  if (_impl_.metadata_ != nullptr) _impl_.metadata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
PersistentVolumeClaimTemplate::PersistentVolumeClaimTemplate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.PersistentVolumeClaimTemplate)
}
PersistentVolumeClaimTemplate::PersistentVolumeClaimTemplate(const PersistentVolumeClaimTemplate& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PersistentVolumeClaimTemplate* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.metadata_){nullptr}
    , decltype(_impl_.spec_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_metadata()) {
    _this->_impl_.metadata_ = new ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta(*from._impl_.metadata_);
  }
  if (from._internal_has_spec()) {
    _this->_impl_.spec_ = new ::k8s::io::api::core::v1::PersistentVolumeClaimSpec(*from._impl_.spec_);
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.PersistentVolumeClaimTemplate)
}

inline void PersistentVolumeClaimTemplate::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.metadata_){nullptr}
    , decltype(_impl_.spec_){nullptr}
  };
}

PersistentVolumeClaimTemplate::~PersistentVolumeClaimTemplate() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.PersistentVolumeClaimTemplate)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PersistentVolumeClaimTemplate::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.metadata_;
  if (this != internal_default_instance()) delete _impl_.spec_;
}

void PersistentVolumeClaimTemplate::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PersistentVolumeClaimTemplate::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.PersistentVolumeClaimTemplate)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.metadata_ != nullptr);
      _impl_.metadata_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.spec_ != nullptr);
      _impl_.spec_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PersistentVolumeClaimTemplate::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_metadata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.PersistentVolumeClaimSpec spec = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_spec(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PersistentVolumeClaimTemplate::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.PersistentVolumeClaimTemplate)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::metadata(this),
        _Internal::metadata(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.PersistentVolumeClaimSpec spec = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::spec(this),
        _Internal::spec(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.PersistentVolumeClaimTemplate)
  return target;
}

size_t PersistentVolumeClaimTemplate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.PersistentVolumeClaimTemplate)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.metadata_);
    }

    // optional .k8s.io.api.core.v1.PersistentVolumeClaimSpec spec = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.spec_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PersistentVolumeClaimTemplate::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PersistentVolumeClaimTemplate::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PersistentVolumeClaimTemplate::GetClassData() const { return &_class_data_; }


void PersistentVolumeClaimTemplate::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PersistentVolumeClaimTemplate*>(&to_msg);
  auto& from = static_cast<const PersistentVolumeClaimTemplate&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.PersistentVolumeClaimTemplate)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_metadata()->::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta::MergeFrom(
          from._internal_metadata());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_spec()->::k8s::io::api::core::v1::PersistentVolumeClaimSpec::MergeFrom(
          from._internal_spec());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PersistentVolumeClaimTemplate::CopyFrom(const PersistentVolumeClaimTemplate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.PersistentVolumeClaimTemplate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PersistentVolumeClaimTemplate::IsInitialized() const {
  return true;
}

void PersistentVolumeClaimTemplate::InternalSwap(PersistentVolumeClaimTemplate* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PersistentVolumeClaimTemplate, _impl_.spec_)
      + sizeof(PersistentVolumeClaimTemplate::_impl_.spec_)
      - PROTOBUF_FIELD_OFFSET(PersistentVolumeClaimTemplate, _impl_.metadata_)>(
          reinterpret_cast<char*>(&_impl_.metadata_),
          reinterpret_cast<char*>(&other->_impl_.metadata_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PersistentVolumeClaimTemplate::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[136]);
}

// ===================================================================

class PersistentVolumeClaimVolumeSource::_Internal {
 public:
  using HasBits = decltype(std::declval<PersistentVolumeClaimVolumeSource>()._impl_._has_bits_);
  static void set_has_claimname(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_readonly(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

PersistentVolumeClaimVolumeSource::PersistentVolumeClaimVolumeSource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.PersistentVolumeClaimVolumeSource)
}
PersistentVolumeClaimVolumeSource::PersistentVolumeClaimVolumeSource(const PersistentVolumeClaimVolumeSource& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PersistentVolumeClaimVolumeSource* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.claimname_){}
    , decltype(_impl_.readonly_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.claimname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.claimname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_claimname()) {
    _this->_impl_.claimname_.Set(from._internal_claimname(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.readonly_ = from._impl_.readonly_;
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.PersistentVolumeClaimVolumeSource)
}

inline void PersistentVolumeClaimVolumeSource::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.claimname_){}
    , decltype(_impl_.readonly_){false}
  };
  _impl_.claimname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.claimname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PersistentVolumeClaimVolumeSource::~PersistentVolumeClaimVolumeSource() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.PersistentVolumeClaimVolumeSource)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PersistentVolumeClaimVolumeSource::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.claimname_.Destroy();
}

void PersistentVolumeClaimVolumeSource::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PersistentVolumeClaimVolumeSource::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.PersistentVolumeClaimVolumeSource)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.claimname_.ClearNonDefaultToEmpty();
  }
  _impl_.readonly_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PersistentVolumeClaimVolumeSource::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes claimName = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_claimname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool readOnly = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_readonly(&has_bits);
          _impl_.readonly_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PersistentVolumeClaimVolumeSource::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.PersistentVolumeClaimVolumeSource)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes claimName = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_claimname(), target);
  }

  // optional bool readOnly = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_readonly(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.PersistentVolumeClaimVolumeSource)
  return target;
}

size_t PersistentVolumeClaimVolumeSource::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.PersistentVolumeClaimVolumeSource)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes claimName = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_claimname());
    }

    // optional bool readOnly = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PersistentVolumeClaimVolumeSource::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PersistentVolumeClaimVolumeSource::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PersistentVolumeClaimVolumeSource::GetClassData() const { return &_class_data_; }


void PersistentVolumeClaimVolumeSource::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PersistentVolumeClaimVolumeSource*>(&to_msg);
  auto& from = static_cast<const PersistentVolumeClaimVolumeSource&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.PersistentVolumeClaimVolumeSource)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_claimname(from._internal_claimname());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.readonly_ = from._impl_.readonly_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PersistentVolumeClaimVolumeSource::CopyFrom(const PersistentVolumeClaimVolumeSource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.PersistentVolumeClaimVolumeSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PersistentVolumeClaimVolumeSource::IsInitialized() const {
  return true;
}

void PersistentVolumeClaimVolumeSource::InternalSwap(PersistentVolumeClaimVolumeSource* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.claimname_, lhs_arena,
      &other->_impl_.claimname_, rhs_arena
  );
  swap(_impl_.readonly_, other->_impl_.readonly_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PersistentVolumeClaimVolumeSource::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[137]);
}

// ===================================================================

class PersistentVolumeList::_Internal {
 public:
  using HasBits = decltype(std::declval<PersistentVolumeList>()._impl_._has_bits_);
  static const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& metadata(const PersistentVolumeList* msg);
  static void set_has_metadata(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta&
PersistentVolumeList::_Internal::metadata(const PersistentVolumeList* msg) {
  return *msg->_impl_.metadata_;
}
void PersistentVolumeList::clear_metadata() {
  if (_impl_.metadata_ != nullptr) _impl_.metadata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
PersistentVolumeList::PersistentVolumeList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.PersistentVolumeList)
}
PersistentVolumeList::PersistentVolumeList(const PersistentVolumeList& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PersistentVolumeList* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.items_){from._impl_.items_}
    , decltype(_impl_.metadata_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_metadata()) {
    _this->_impl_.metadata_ = new ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta(*from._impl_.metadata_);
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.PersistentVolumeList)
}

inline void PersistentVolumeList::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.items_){arena}
    , decltype(_impl_.metadata_){nullptr}
  };
}

PersistentVolumeList::~PersistentVolumeList() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.PersistentVolumeList)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PersistentVolumeList::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.items_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.metadata_;
}

void PersistentVolumeList::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PersistentVolumeList::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.PersistentVolumeList)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.items_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.metadata_ != nullptr);
    _impl_.metadata_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PersistentVolumeList::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_metadata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .k8s.io.api.core.v1.PersistentVolume items = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_items(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PersistentVolumeList::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.PersistentVolumeList)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::metadata(this),
        _Internal::metadata(this).GetCachedSize(), target, stream);
  }

  // repeated .k8s.io.api.core.v1.PersistentVolume items = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_items_size()); i < n; i++) {
    const auto& repfield = this->_internal_items(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.PersistentVolumeList)
  return target;
}

size_t PersistentVolumeList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.PersistentVolumeList)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .k8s.io.api.core.v1.PersistentVolume items = 2;
  total_size += 1UL * this->_internal_items_size();
  for (const auto& msg : this->_impl_.items_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.metadata_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PersistentVolumeList::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PersistentVolumeList::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PersistentVolumeList::GetClassData() const { return &_class_data_; }


void PersistentVolumeList::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PersistentVolumeList*>(&to_msg);
  auto& from = static_cast<const PersistentVolumeList&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.PersistentVolumeList)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.items_.MergeFrom(from._impl_.items_);
  if (from._internal_has_metadata()) {
    _this->_internal_mutable_metadata()->::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta::MergeFrom(
        from._internal_metadata());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PersistentVolumeList::CopyFrom(const PersistentVolumeList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.PersistentVolumeList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PersistentVolumeList::IsInitialized() const {
  return true;
}

void PersistentVolumeList::InternalSwap(PersistentVolumeList* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.items_.InternalSwap(&other->_impl_.items_);
  swap(_impl_.metadata_, other->_impl_.metadata_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PersistentVolumeList::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[138]);
}

// ===================================================================

class PersistentVolumeSource::_Internal {
 public:
  using HasBits = decltype(std::declval<PersistentVolumeSource>()._impl_._has_bits_);
  static const ::k8s::io::api::core::v1::GCEPersistentDiskVolumeSource& gcepersistentdisk(const PersistentVolumeSource* msg);
  static void set_has_gcepersistentdisk(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::k8s::io::api::core::v1::AWSElasticBlockStoreVolumeSource& awselasticblockstore(const PersistentVolumeSource* msg);
  static void set_has_awselasticblockstore(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::k8s::io::api::core::v1::HostPathVolumeSource& hostpath(const PersistentVolumeSource* msg);
  static void set_has_hostpath(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::k8s::io::api::core::v1::GlusterfsPersistentVolumeSource& glusterfs(const PersistentVolumeSource* msg);
  static void set_has_glusterfs(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::k8s::io::api::core::v1::NFSVolumeSource& nfs(const PersistentVolumeSource* msg);
  static void set_has_nfs(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::k8s::io::api::core::v1::RBDPersistentVolumeSource& rbd(const PersistentVolumeSource* msg);
  static void set_has_rbd(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::k8s::io::api::core::v1::ISCSIPersistentVolumeSource& iscsi(const PersistentVolumeSource* msg);
  static void set_has_iscsi(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::k8s::io::api::core::v1::CinderPersistentVolumeSource& cinder(const PersistentVolumeSource* msg);
  static void set_has_cinder(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::k8s::io::api::core::v1::CephFSPersistentVolumeSource& cephfs(const PersistentVolumeSource* msg);
  static void set_has_cephfs(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static const ::k8s::io::api::core::v1::FCVolumeSource& fc(const PersistentVolumeSource* msg);
  static void set_has_fc(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static const ::k8s::io::api::core::v1::FlockerVolumeSource& flocker(const PersistentVolumeSource* msg);
  static void set_has_flocker(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static const ::k8s::io::api::core::v1::FlexPersistentVolumeSource& flexvolume(const PersistentVolumeSource* msg);
  static void set_has_flexvolume(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static const ::k8s::io::api::core::v1::AzureFilePersistentVolumeSource& azurefile(const PersistentVolumeSource* msg);
  static void set_has_azurefile(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static const ::k8s::io::api::core::v1::VsphereVirtualDiskVolumeSource& vspherevolume(const PersistentVolumeSource* msg);
  static void set_has_vspherevolume(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static const ::k8s::io::api::core::v1::QuobyteVolumeSource& quobyte(const PersistentVolumeSource* msg);
  static void set_has_quobyte(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static const ::k8s::io::api::core::v1::AzureDiskVolumeSource& azuredisk(const PersistentVolumeSource* msg);
  static void set_has_azuredisk(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static const ::k8s::io::api::core::v1::PhotonPersistentDiskVolumeSource& photonpersistentdisk(const PersistentVolumeSource* msg);
  static void set_has_photonpersistentdisk(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static const ::k8s::io::api::core::v1::PortworxVolumeSource& portworxvolume(const PersistentVolumeSource* msg);
  static void set_has_portworxvolume(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static const ::k8s::io::api::core::v1::ScaleIOPersistentVolumeSource& scaleio(const PersistentVolumeSource* msg);
  static void set_has_scaleio(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static const ::k8s::io::api::core::v1::LocalVolumeSource& local(const PersistentVolumeSource* msg);
  static void set_has_local(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static const ::k8s::io::api::core::v1::StorageOSPersistentVolumeSource& storageos(const PersistentVolumeSource* msg);
  static void set_has_storageos(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static const ::k8s::io::api::core::v1::CSIPersistentVolumeSource& csi(const PersistentVolumeSource* msg);
  static void set_has_csi(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
};

const ::k8s::io::api::core::v1::GCEPersistentDiskVolumeSource&
PersistentVolumeSource::_Internal::gcepersistentdisk(const PersistentVolumeSource* msg) {
  return *msg->_impl_.gcepersistentdisk_;
}
const ::k8s::io::api::core::v1::AWSElasticBlockStoreVolumeSource&
PersistentVolumeSource::_Internal::awselasticblockstore(const PersistentVolumeSource* msg) {
  return *msg->_impl_.awselasticblockstore_;
}
const ::k8s::io::api::core::v1::HostPathVolumeSource&
PersistentVolumeSource::_Internal::hostpath(const PersistentVolumeSource* msg) {
  return *msg->_impl_.hostpath_;
}
const ::k8s::io::api::core::v1::GlusterfsPersistentVolumeSource&
PersistentVolumeSource::_Internal::glusterfs(const PersistentVolumeSource* msg) {
  return *msg->_impl_.glusterfs_;
}
const ::k8s::io::api::core::v1::NFSVolumeSource&
PersistentVolumeSource::_Internal::nfs(const PersistentVolumeSource* msg) {
  return *msg->_impl_.nfs_;
}
const ::k8s::io::api::core::v1::RBDPersistentVolumeSource&
PersistentVolumeSource::_Internal::rbd(const PersistentVolumeSource* msg) {
  return *msg->_impl_.rbd_;
}
const ::k8s::io::api::core::v1::ISCSIPersistentVolumeSource&
PersistentVolumeSource::_Internal::iscsi(const PersistentVolumeSource* msg) {
  return *msg->_impl_.iscsi_;
}
const ::k8s::io::api::core::v1::CinderPersistentVolumeSource&
PersistentVolumeSource::_Internal::cinder(const PersistentVolumeSource* msg) {
  return *msg->_impl_.cinder_;
}
const ::k8s::io::api::core::v1::CephFSPersistentVolumeSource&
PersistentVolumeSource::_Internal::cephfs(const PersistentVolumeSource* msg) {
  return *msg->_impl_.cephfs_;
}
const ::k8s::io::api::core::v1::FCVolumeSource&
PersistentVolumeSource::_Internal::fc(const PersistentVolumeSource* msg) {
  return *msg->_impl_.fc_;
}
const ::k8s::io::api::core::v1::FlockerVolumeSource&
PersistentVolumeSource::_Internal::flocker(const PersistentVolumeSource* msg) {
  return *msg->_impl_.flocker_;
}
const ::k8s::io::api::core::v1::FlexPersistentVolumeSource&
PersistentVolumeSource::_Internal::flexvolume(const PersistentVolumeSource* msg) {
  return *msg->_impl_.flexvolume_;
}
const ::k8s::io::api::core::v1::AzureFilePersistentVolumeSource&
PersistentVolumeSource::_Internal::azurefile(const PersistentVolumeSource* msg) {
  return *msg->_impl_.azurefile_;
}
const ::k8s::io::api::core::v1::VsphereVirtualDiskVolumeSource&
PersistentVolumeSource::_Internal::vspherevolume(const PersistentVolumeSource* msg) {
  return *msg->_impl_.vspherevolume_;
}
const ::k8s::io::api::core::v1::QuobyteVolumeSource&
PersistentVolumeSource::_Internal::quobyte(const PersistentVolumeSource* msg) {
  return *msg->_impl_.quobyte_;
}
const ::k8s::io::api::core::v1::AzureDiskVolumeSource&
PersistentVolumeSource::_Internal::azuredisk(const PersistentVolumeSource* msg) {
  return *msg->_impl_.azuredisk_;
}
const ::k8s::io::api::core::v1::PhotonPersistentDiskVolumeSource&
PersistentVolumeSource::_Internal::photonpersistentdisk(const PersistentVolumeSource* msg) {
  return *msg->_impl_.photonpersistentdisk_;
}
const ::k8s::io::api::core::v1::PortworxVolumeSource&
PersistentVolumeSource::_Internal::portworxvolume(const PersistentVolumeSource* msg) {
  return *msg->_impl_.portworxvolume_;
}
const ::k8s::io::api::core::v1::ScaleIOPersistentVolumeSource&
PersistentVolumeSource::_Internal::scaleio(const PersistentVolumeSource* msg) {
  return *msg->_impl_.scaleio_;
}
const ::k8s::io::api::core::v1::LocalVolumeSource&
PersistentVolumeSource::_Internal::local(const PersistentVolumeSource* msg) {
  return *msg->_impl_.local_;
}
const ::k8s::io::api::core::v1::StorageOSPersistentVolumeSource&
PersistentVolumeSource::_Internal::storageos(const PersistentVolumeSource* msg) {
  return *msg->_impl_.storageos_;
}
const ::k8s::io::api::core::v1::CSIPersistentVolumeSource&
PersistentVolumeSource::_Internal::csi(const PersistentVolumeSource* msg) {
  return *msg->_impl_.csi_;
}
PersistentVolumeSource::PersistentVolumeSource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.PersistentVolumeSource)
}
PersistentVolumeSource::PersistentVolumeSource(const PersistentVolumeSource& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PersistentVolumeSource* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.gcepersistentdisk_){nullptr}
    , decltype(_impl_.awselasticblockstore_){nullptr}
    , decltype(_impl_.hostpath_){nullptr}
    , decltype(_impl_.glusterfs_){nullptr}
    , decltype(_impl_.nfs_){nullptr}
    , decltype(_impl_.rbd_){nullptr}
    , decltype(_impl_.iscsi_){nullptr}
    , decltype(_impl_.cinder_){nullptr}
    , decltype(_impl_.cephfs_){nullptr}
    , decltype(_impl_.fc_){nullptr}
    , decltype(_impl_.flocker_){nullptr}
    , decltype(_impl_.flexvolume_){nullptr}
    , decltype(_impl_.azurefile_){nullptr}
    , decltype(_impl_.vspherevolume_){nullptr}
    , decltype(_impl_.quobyte_){nullptr}
    , decltype(_impl_.azuredisk_){nullptr}
    , decltype(_impl_.photonpersistentdisk_){nullptr}
    , decltype(_impl_.portworxvolume_){nullptr}
    , decltype(_impl_.scaleio_){nullptr}
    , decltype(_impl_.local_){nullptr}
    , decltype(_impl_.storageos_){nullptr}
    , decltype(_impl_.csi_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_gcepersistentdisk()) {
    _this->_impl_.gcepersistentdisk_ = new ::k8s::io::api::core::v1::GCEPersistentDiskVolumeSource(*from._impl_.gcepersistentdisk_);
  }
  if (from._internal_has_awselasticblockstore()) {
    _this->_impl_.awselasticblockstore_ = new ::k8s::io::api::core::v1::AWSElasticBlockStoreVolumeSource(*from._impl_.awselasticblockstore_);
  }
  if (from._internal_has_hostpath()) {
    _this->_impl_.hostpath_ = new ::k8s::io::api::core::v1::HostPathVolumeSource(*from._impl_.hostpath_);
  }
  if (from._internal_has_glusterfs()) {
    _this->_impl_.glusterfs_ = new ::k8s::io::api::core::v1::GlusterfsPersistentVolumeSource(*from._impl_.glusterfs_);
  }
  if (from._internal_has_nfs()) {
    _this->_impl_.nfs_ = new ::k8s::io::api::core::v1::NFSVolumeSource(*from._impl_.nfs_);
  }
  if (from._internal_has_rbd()) {
    _this->_impl_.rbd_ = new ::k8s::io::api::core::v1::RBDPersistentVolumeSource(*from._impl_.rbd_);
  }
  if (from._internal_has_iscsi()) {
    _this->_impl_.iscsi_ = new ::k8s::io::api::core::v1::ISCSIPersistentVolumeSource(*from._impl_.iscsi_);
  }
  if (from._internal_has_cinder()) {
    _this->_impl_.cinder_ = new ::k8s::io::api::core::v1::CinderPersistentVolumeSource(*from._impl_.cinder_);
  }
  if (from._internal_has_cephfs()) {
    _this->_impl_.cephfs_ = new ::k8s::io::api::core::v1::CephFSPersistentVolumeSource(*from._impl_.cephfs_);
  }
  if (from._internal_has_fc()) {
    _this->_impl_.fc_ = new ::k8s::io::api::core::v1::FCVolumeSource(*from._impl_.fc_);
  }
  if (from._internal_has_flocker()) {
    _this->_impl_.flocker_ = new ::k8s::io::api::core::v1::FlockerVolumeSource(*from._impl_.flocker_);
  }
  if (from._internal_has_flexvolume()) {
    _this->_impl_.flexvolume_ = new ::k8s::io::api::core::v1::FlexPersistentVolumeSource(*from._impl_.flexvolume_);
  }
  if (from._internal_has_azurefile()) {
    _this->_impl_.azurefile_ = new ::k8s::io::api::core::v1::AzureFilePersistentVolumeSource(*from._impl_.azurefile_);
  }
  if (from._internal_has_vspherevolume()) {
    _this->_impl_.vspherevolume_ = new ::k8s::io::api::core::v1::VsphereVirtualDiskVolumeSource(*from._impl_.vspherevolume_);
  }
  if (from._internal_has_quobyte()) {
    _this->_impl_.quobyte_ = new ::k8s::io::api::core::v1::QuobyteVolumeSource(*from._impl_.quobyte_);
  }
  if (from._internal_has_azuredisk()) {
    _this->_impl_.azuredisk_ = new ::k8s::io::api::core::v1::AzureDiskVolumeSource(*from._impl_.azuredisk_);
  }
  if (from._internal_has_photonpersistentdisk()) {
    _this->_impl_.photonpersistentdisk_ = new ::k8s::io::api::core::v1::PhotonPersistentDiskVolumeSource(*from._impl_.photonpersistentdisk_);
  }
  if (from._internal_has_portworxvolume()) {
    _this->_impl_.portworxvolume_ = new ::k8s::io::api::core::v1::PortworxVolumeSource(*from._impl_.portworxvolume_);
  }
  if (from._internal_has_scaleio()) {
    _this->_impl_.scaleio_ = new ::k8s::io::api::core::v1::ScaleIOPersistentVolumeSource(*from._impl_.scaleio_);
  }
  if (from._internal_has_local()) {
    _this->_impl_.local_ = new ::k8s::io::api::core::v1::LocalVolumeSource(*from._impl_.local_);
  }
  if (from._internal_has_storageos()) {
    _this->_impl_.storageos_ = new ::k8s::io::api::core::v1::StorageOSPersistentVolumeSource(*from._impl_.storageos_);
  }
  if (from._internal_has_csi()) {
    _this->_impl_.csi_ = new ::k8s::io::api::core::v1::CSIPersistentVolumeSource(*from._impl_.csi_);
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.PersistentVolumeSource)
}

inline void PersistentVolumeSource::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.gcepersistentdisk_){nullptr}
    , decltype(_impl_.awselasticblockstore_){nullptr}
    , decltype(_impl_.hostpath_){nullptr}
    , decltype(_impl_.glusterfs_){nullptr}
    , decltype(_impl_.nfs_){nullptr}
    , decltype(_impl_.rbd_){nullptr}
    , decltype(_impl_.iscsi_){nullptr}
    , decltype(_impl_.cinder_){nullptr}
    , decltype(_impl_.cephfs_){nullptr}
    , decltype(_impl_.fc_){nullptr}
    , decltype(_impl_.flocker_){nullptr}
    , decltype(_impl_.flexvolume_){nullptr}
    , decltype(_impl_.azurefile_){nullptr}
    , decltype(_impl_.vspherevolume_){nullptr}
    , decltype(_impl_.quobyte_){nullptr}
    , decltype(_impl_.azuredisk_){nullptr}
    , decltype(_impl_.photonpersistentdisk_){nullptr}
    , decltype(_impl_.portworxvolume_){nullptr}
    , decltype(_impl_.scaleio_){nullptr}
    , decltype(_impl_.local_){nullptr}
    , decltype(_impl_.storageos_){nullptr}
    , decltype(_impl_.csi_){nullptr}
  };
}

PersistentVolumeSource::~PersistentVolumeSource() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.PersistentVolumeSource)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PersistentVolumeSource::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.gcepersistentdisk_;
  if (this != internal_default_instance()) delete _impl_.awselasticblockstore_;
  if (this != internal_default_instance()) delete _impl_.hostpath_;
  if (this != internal_default_instance()) delete _impl_.glusterfs_;
  if (this != internal_default_instance()) delete _impl_.nfs_;
  if (this != internal_default_instance()) delete _impl_.rbd_;
  if (this != internal_default_instance()) delete _impl_.iscsi_;
  if (this != internal_default_instance()) delete _impl_.cinder_;
  if (this != internal_default_instance()) delete _impl_.cephfs_;
  if (this != internal_default_instance()) delete _impl_.fc_;
  if (this != internal_default_instance()) delete _impl_.flocker_;
  if (this != internal_default_instance()) delete _impl_.flexvolume_;
  if (this != internal_default_instance()) delete _impl_.azurefile_;
  if (this != internal_default_instance()) delete _impl_.vspherevolume_;
  if (this != internal_default_instance()) delete _impl_.quobyte_;
  if (this != internal_default_instance()) delete _impl_.azuredisk_;
  if (this != internal_default_instance()) delete _impl_.photonpersistentdisk_;
  if (this != internal_default_instance()) delete _impl_.portworxvolume_;
  if (this != internal_default_instance()) delete _impl_.scaleio_;
  if (this != internal_default_instance()) delete _impl_.local_;
  if (this != internal_default_instance()) delete _impl_.storageos_;
  if (this != internal_default_instance()) delete _impl_.csi_;
}

void PersistentVolumeSource::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PersistentVolumeSource::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.PersistentVolumeSource)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.gcepersistentdisk_ != nullptr);
      _impl_.gcepersistentdisk_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.awselasticblockstore_ != nullptr);
      _impl_.awselasticblockstore_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.hostpath_ != nullptr);
      _impl_.hostpath_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.glusterfs_ != nullptr);
      _impl_.glusterfs_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.nfs_ != nullptr);
      _impl_.nfs_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.rbd_ != nullptr);
      _impl_.rbd_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(_impl_.iscsi_ != nullptr);
      _impl_.iscsi_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(_impl_.cinder_ != nullptr);
      _impl_.cinder_->Clear();
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      GOOGLE_DCHECK(_impl_.cephfs_ != nullptr);
      _impl_.cephfs_->Clear();
    }
    if (cached_has_bits & 0x00000200u) {
      GOOGLE_DCHECK(_impl_.fc_ != nullptr);
      _impl_.fc_->Clear();
    }
    if (cached_has_bits & 0x00000400u) {
      GOOGLE_DCHECK(_impl_.flocker_ != nullptr);
      _impl_.flocker_->Clear();
    }
    if (cached_has_bits & 0x00000800u) {
      GOOGLE_DCHECK(_impl_.flexvolume_ != nullptr);
      _impl_.flexvolume_->Clear();
    }
    if (cached_has_bits & 0x00001000u) {
      GOOGLE_DCHECK(_impl_.azurefile_ != nullptr);
      _impl_.azurefile_->Clear();
    }
    if (cached_has_bits & 0x00002000u) {
      GOOGLE_DCHECK(_impl_.vspherevolume_ != nullptr);
      _impl_.vspherevolume_->Clear();
    }
    if (cached_has_bits & 0x00004000u) {
      GOOGLE_DCHECK(_impl_.quobyte_ != nullptr);
      _impl_.quobyte_->Clear();
    }
    if (cached_has_bits & 0x00008000u) {
      GOOGLE_DCHECK(_impl_.azuredisk_ != nullptr);
      _impl_.azuredisk_->Clear();
    }
  }
  if (cached_has_bits & 0x003f0000u) {
    if (cached_has_bits & 0x00010000u) {
      GOOGLE_DCHECK(_impl_.photonpersistentdisk_ != nullptr);
      _impl_.photonpersistentdisk_->Clear();
    }
    if (cached_has_bits & 0x00020000u) {
      GOOGLE_DCHECK(_impl_.portworxvolume_ != nullptr);
      _impl_.portworxvolume_->Clear();
    }
    if (cached_has_bits & 0x00040000u) {
      GOOGLE_DCHECK(_impl_.scaleio_ != nullptr);
      _impl_.scaleio_->Clear();
    }
    if (cached_has_bits & 0x00080000u) {
      GOOGLE_DCHECK(_impl_.local_ != nullptr);
      _impl_.local_->Clear();
    }
    if (cached_has_bits & 0x00100000u) {
      GOOGLE_DCHECK(_impl_.storageos_ != nullptr);
      _impl_.storageos_->Clear();
    }
    if (cached_has_bits & 0x00200000u) {
      GOOGLE_DCHECK(_impl_.csi_ != nullptr);
      _impl_.csi_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PersistentVolumeSource::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .k8s.io.api.core.v1.GCEPersistentDiskVolumeSource gcePersistentDisk = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_gcepersistentdisk(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.AWSElasticBlockStoreVolumeSource awsElasticBlockStore = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_awselasticblockstore(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.HostPathVolumeSource hostPath = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_hostpath(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.GlusterfsPersistentVolumeSource glusterfs = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_glusterfs(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.NFSVolumeSource nfs = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_nfs(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.RBDPersistentVolumeSource rbd = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_rbd(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.ISCSIPersistentVolumeSource iscsi = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_iscsi(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.CinderPersistentVolumeSource cinder = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_cinder(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.CephFSPersistentVolumeSource cephfs = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_cephfs(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.FCVolumeSource fc = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_fc(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.FlockerVolumeSource flocker = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_flocker(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.FlexPersistentVolumeSource flexVolume = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_flexvolume(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.AzureFilePersistentVolumeSource azureFile = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_azurefile(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.VsphereVirtualDiskVolumeSource vsphereVolume = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_vspherevolume(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.QuobyteVolumeSource quobyte = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_quobyte(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.AzureDiskVolumeSource azureDisk = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_azuredisk(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.PhotonPersistentDiskVolumeSource photonPersistentDisk = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          ptr = ctx->ParseMessage(_internal_mutable_photonpersistentdisk(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.PortworxVolumeSource portworxVolume = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          ptr = ctx->ParseMessage(_internal_mutable_portworxvolume(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.ScaleIOPersistentVolumeSource scaleIO = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          ptr = ctx->ParseMessage(_internal_mutable_scaleio(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.LocalVolumeSource local = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_local(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.StorageOSPersistentVolumeSource storageos = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          ptr = ctx->ParseMessage(_internal_mutable_storageos(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.CSIPersistentVolumeSource csi = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 178)) {
          ptr = ctx->ParseMessage(_internal_mutable_csi(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PersistentVolumeSource::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.PersistentVolumeSource)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .k8s.io.api.core.v1.GCEPersistentDiskVolumeSource gcePersistentDisk = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::gcepersistentdisk(this),
        _Internal::gcepersistentdisk(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.AWSElasticBlockStoreVolumeSource awsElasticBlockStore = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::awselasticblockstore(this),
        _Internal::awselasticblockstore(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.HostPathVolumeSource hostPath = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::hostpath(this),
        _Internal::hostpath(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.GlusterfsPersistentVolumeSource glusterfs = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::glusterfs(this),
        _Internal::glusterfs(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.NFSVolumeSource nfs = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::nfs(this),
        _Internal::nfs(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.RBDPersistentVolumeSource rbd = 6;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::rbd(this),
        _Internal::rbd(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.ISCSIPersistentVolumeSource iscsi = 7;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::iscsi(this),
        _Internal::iscsi(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.CinderPersistentVolumeSource cinder = 8;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::cinder(this),
        _Internal::cinder(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.CephFSPersistentVolumeSource cephfs = 9;
  if (cached_has_bits & 0x00000100u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::cephfs(this),
        _Internal::cephfs(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.FCVolumeSource fc = 10;
  if (cached_has_bits & 0x00000200u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::fc(this),
        _Internal::fc(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.FlockerVolumeSource flocker = 11;
  if (cached_has_bits & 0x00000400u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::flocker(this),
        _Internal::flocker(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.FlexPersistentVolumeSource flexVolume = 12;
  if (cached_has_bits & 0x00000800u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, _Internal::flexvolume(this),
        _Internal::flexvolume(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.AzureFilePersistentVolumeSource azureFile = 13;
  if (cached_has_bits & 0x00001000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(13, _Internal::azurefile(this),
        _Internal::azurefile(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.VsphereVirtualDiskVolumeSource vsphereVolume = 14;
  if (cached_has_bits & 0x00002000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(14, _Internal::vspherevolume(this),
        _Internal::vspherevolume(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.QuobyteVolumeSource quobyte = 15;
  if (cached_has_bits & 0x00004000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(15, _Internal::quobyte(this),
        _Internal::quobyte(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.AzureDiskVolumeSource azureDisk = 16;
  if (cached_has_bits & 0x00008000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(16, _Internal::azuredisk(this),
        _Internal::azuredisk(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.PhotonPersistentDiskVolumeSource photonPersistentDisk = 17;
  if (cached_has_bits & 0x00010000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(17, _Internal::photonpersistentdisk(this),
        _Internal::photonpersistentdisk(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.PortworxVolumeSource portworxVolume = 18;
  if (cached_has_bits & 0x00020000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(18, _Internal::portworxvolume(this),
        _Internal::portworxvolume(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.ScaleIOPersistentVolumeSource scaleIO = 19;
  if (cached_has_bits & 0x00040000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(19, _Internal::scaleio(this),
        _Internal::scaleio(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.LocalVolumeSource local = 20;
  if (cached_has_bits & 0x00080000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(20, _Internal::local(this),
        _Internal::local(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.StorageOSPersistentVolumeSource storageos = 21;
  if (cached_has_bits & 0x00100000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(21, _Internal::storageos(this),
        _Internal::storageos(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.CSIPersistentVolumeSource csi = 22;
  if (cached_has_bits & 0x00200000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(22, _Internal::csi(this),
        _Internal::csi(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.PersistentVolumeSource)
  return target;
}

size_t PersistentVolumeSource::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.PersistentVolumeSource)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .k8s.io.api.core.v1.GCEPersistentDiskVolumeSource gcePersistentDisk = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.gcepersistentdisk_);
    }

    // optional .k8s.io.api.core.v1.AWSElasticBlockStoreVolumeSource awsElasticBlockStore = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.awselasticblockstore_);
    }

    // optional .k8s.io.api.core.v1.HostPathVolumeSource hostPath = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.hostpath_);
    }

    // optional .k8s.io.api.core.v1.GlusterfsPersistentVolumeSource glusterfs = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.glusterfs_);
    }

    // optional .k8s.io.api.core.v1.NFSVolumeSource nfs = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.nfs_);
    }

    // optional .k8s.io.api.core.v1.RBDPersistentVolumeSource rbd = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.rbd_);
    }

    // optional .k8s.io.api.core.v1.ISCSIPersistentVolumeSource iscsi = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.iscsi_);
    }

    // optional .k8s.io.api.core.v1.CinderPersistentVolumeSource cinder = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.cinder_);
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional .k8s.io.api.core.v1.CephFSPersistentVolumeSource cephfs = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.cephfs_);
    }

    // optional .k8s.io.api.core.v1.FCVolumeSource fc = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.fc_);
    }

    // optional .k8s.io.api.core.v1.FlockerVolumeSource flocker = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.flocker_);
    }

    // optional .k8s.io.api.core.v1.FlexPersistentVolumeSource flexVolume = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.flexvolume_);
    }

    // optional .k8s.io.api.core.v1.AzureFilePersistentVolumeSource azureFile = 13;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.azurefile_);
    }

    // optional .k8s.io.api.core.v1.VsphereVirtualDiskVolumeSource vsphereVolume = 14;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.vspherevolume_);
    }

    // optional .k8s.io.api.core.v1.QuobyteVolumeSource quobyte = 15;
    if (cached_has_bits & 0x00004000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.quobyte_);
    }

    // optional .k8s.io.api.core.v1.AzureDiskVolumeSource azureDisk = 16;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.azuredisk_);
    }

  }
  if (cached_has_bits & 0x003f0000u) {
    // optional .k8s.io.api.core.v1.PhotonPersistentDiskVolumeSource photonPersistentDisk = 17;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.photonpersistentdisk_);
    }

    // optional .k8s.io.api.core.v1.PortworxVolumeSource portworxVolume = 18;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.portworxvolume_);
    }

    // optional .k8s.io.api.core.v1.ScaleIOPersistentVolumeSource scaleIO = 19;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.scaleio_);
    }

    // optional .k8s.io.api.core.v1.LocalVolumeSource local = 20;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.local_);
    }

    // optional .k8s.io.api.core.v1.StorageOSPersistentVolumeSource storageos = 21;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.storageos_);
    }

    // optional .k8s.io.api.core.v1.CSIPersistentVolumeSource csi = 22;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.csi_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PersistentVolumeSource::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PersistentVolumeSource::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PersistentVolumeSource::GetClassData() const { return &_class_data_; }


void PersistentVolumeSource::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PersistentVolumeSource*>(&to_msg);
  auto& from = static_cast<const PersistentVolumeSource&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.PersistentVolumeSource)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_gcepersistentdisk()->::k8s::io::api::core::v1::GCEPersistentDiskVolumeSource::MergeFrom(
          from._internal_gcepersistentdisk());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_awselasticblockstore()->::k8s::io::api::core::v1::AWSElasticBlockStoreVolumeSource::MergeFrom(
          from._internal_awselasticblockstore());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_hostpath()->::k8s::io::api::core::v1::HostPathVolumeSource::MergeFrom(
          from._internal_hostpath());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_glusterfs()->::k8s::io::api::core::v1::GlusterfsPersistentVolumeSource::MergeFrom(
          from._internal_glusterfs());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_nfs()->::k8s::io::api::core::v1::NFSVolumeSource::MergeFrom(
          from._internal_nfs());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_rbd()->::k8s::io::api::core::v1::RBDPersistentVolumeSource::MergeFrom(
          from._internal_rbd());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_iscsi()->::k8s::io::api::core::v1::ISCSIPersistentVolumeSource::MergeFrom(
          from._internal_iscsi());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_mutable_cinder()->::k8s::io::api::core::v1::CinderPersistentVolumeSource::MergeFrom(
          from._internal_cinder());
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_internal_mutable_cephfs()->::k8s::io::api::core::v1::CephFSPersistentVolumeSource::MergeFrom(
          from._internal_cephfs());
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_internal_mutable_fc()->::k8s::io::api::core::v1::FCVolumeSource::MergeFrom(
          from._internal_fc());
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_internal_mutable_flocker()->::k8s::io::api::core::v1::FlockerVolumeSource::MergeFrom(
          from._internal_flocker());
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_internal_mutable_flexvolume()->::k8s::io::api::core::v1::FlexPersistentVolumeSource::MergeFrom(
          from._internal_flexvolume());
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_internal_mutable_azurefile()->::k8s::io::api::core::v1::AzureFilePersistentVolumeSource::MergeFrom(
          from._internal_azurefile());
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_internal_mutable_vspherevolume()->::k8s::io::api::core::v1::VsphereVirtualDiskVolumeSource::MergeFrom(
          from._internal_vspherevolume());
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_internal_mutable_quobyte()->::k8s::io::api::core::v1::QuobyteVolumeSource::MergeFrom(
          from._internal_quobyte());
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_internal_mutable_azuredisk()->::k8s::io::api::core::v1::AzureDiskVolumeSource::MergeFrom(
          from._internal_azuredisk());
    }
  }
  if (cached_has_bits & 0x003f0000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_internal_mutable_photonpersistentdisk()->::k8s::io::api::core::v1::PhotonPersistentDiskVolumeSource::MergeFrom(
          from._internal_photonpersistentdisk());
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_internal_mutable_portworxvolume()->::k8s::io::api::core::v1::PortworxVolumeSource::MergeFrom(
          from._internal_portworxvolume());
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_internal_mutable_scaleio()->::k8s::io::api::core::v1::ScaleIOPersistentVolumeSource::MergeFrom(
          from._internal_scaleio());
    }
    if (cached_has_bits & 0x00080000u) {
      _this->_internal_mutable_local()->::k8s::io::api::core::v1::LocalVolumeSource::MergeFrom(
          from._internal_local());
    }
    if (cached_has_bits & 0x00100000u) {
      _this->_internal_mutable_storageos()->::k8s::io::api::core::v1::StorageOSPersistentVolumeSource::MergeFrom(
          from._internal_storageos());
    }
    if (cached_has_bits & 0x00200000u) {
      _this->_internal_mutable_csi()->::k8s::io::api::core::v1::CSIPersistentVolumeSource::MergeFrom(
          from._internal_csi());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PersistentVolumeSource::CopyFrom(const PersistentVolumeSource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.PersistentVolumeSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PersistentVolumeSource::IsInitialized() const {
  return true;
}

void PersistentVolumeSource::InternalSwap(PersistentVolumeSource* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PersistentVolumeSource, _impl_.csi_)
      + sizeof(PersistentVolumeSource::_impl_.csi_)
      - PROTOBUF_FIELD_OFFSET(PersistentVolumeSource, _impl_.gcepersistentdisk_)>(
          reinterpret_cast<char*>(&_impl_.gcepersistentdisk_),
          reinterpret_cast<char*>(&other->_impl_.gcepersistentdisk_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PersistentVolumeSource::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[139]);
}

// ===================================================================

PersistentVolumeSpec_CapacityEntry_DoNotUse::PersistentVolumeSpec_CapacityEntry_DoNotUse() {}
PersistentVolumeSpec_CapacityEntry_DoNotUse::PersistentVolumeSpec_CapacityEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void PersistentVolumeSpec_CapacityEntry_DoNotUse::MergeFrom(const PersistentVolumeSpec_CapacityEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata PersistentVolumeSpec_CapacityEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[140]);
}

// ===================================================================

class PersistentVolumeSpec::_Internal {
 public:
  using HasBits = decltype(std::declval<PersistentVolumeSpec>()._impl_._has_bits_);
  static const ::k8s::io::api::core::v1::PersistentVolumeSource& persistentvolumesource(const PersistentVolumeSpec* msg);
  static void set_has_persistentvolumesource(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::k8s::io::api::core::v1::ObjectReference& claimref(const PersistentVolumeSpec* msg);
  static void set_has_claimref(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_persistentvolumereclaimpolicy(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_storageclassname(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_volumemode(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::k8s::io::api::core::v1::VolumeNodeAffinity& nodeaffinity(const PersistentVolumeSpec* msg);
  static void set_has_nodeaffinity(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_volumeattributesclassname(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::k8s::io::api::core::v1::PersistentVolumeSource&
PersistentVolumeSpec::_Internal::persistentvolumesource(const PersistentVolumeSpec* msg) {
  return *msg->_impl_.persistentvolumesource_;
}
const ::k8s::io::api::core::v1::ObjectReference&
PersistentVolumeSpec::_Internal::claimref(const PersistentVolumeSpec* msg) {
  return *msg->_impl_.claimref_;
}
const ::k8s::io::api::core::v1::VolumeNodeAffinity&
PersistentVolumeSpec::_Internal::nodeaffinity(const PersistentVolumeSpec* msg) {
  return *msg->_impl_.nodeaffinity_;
}
void PersistentVolumeSpec::clear_capacity() {
  _impl_.capacity_.Clear();
}
PersistentVolumeSpec::PersistentVolumeSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &PersistentVolumeSpec::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.PersistentVolumeSpec)
}
PersistentVolumeSpec::PersistentVolumeSpec(const PersistentVolumeSpec& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PersistentVolumeSpec* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_.capacity_)*/{}
    , decltype(_impl_.accessmodes_){from._impl_.accessmodes_}
    , decltype(_impl_.mountoptions_){from._impl_.mountoptions_}
    , decltype(_impl_.persistentvolumereclaimpolicy_){}
    , decltype(_impl_.storageclassname_){}
    , decltype(_impl_.volumemode_){}
    , decltype(_impl_.volumeattributesclassname_){}
    , decltype(_impl_.persistentvolumesource_){nullptr}
    , decltype(_impl_.claimref_){nullptr}
    , decltype(_impl_.nodeaffinity_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.capacity_.MergeFrom(from._impl_.capacity_);
  _impl_.persistentvolumereclaimpolicy_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.persistentvolumereclaimpolicy_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_persistentvolumereclaimpolicy()) {
    _this->_impl_.persistentvolumereclaimpolicy_.Set(from._internal_persistentvolumereclaimpolicy(), 
      _this->GetArenaForAllocation());
  }
  _impl_.storageclassname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.storageclassname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_storageclassname()) {
    _this->_impl_.storageclassname_.Set(from._internal_storageclassname(), 
      _this->GetArenaForAllocation());
  }
  _impl_.volumemode_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.volumemode_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_volumemode()) {
    _this->_impl_.volumemode_.Set(from._internal_volumemode(), 
      _this->GetArenaForAllocation());
  }
  _impl_.volumeattributesclassname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.volumeattributesclassname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_volumeattributesclassname()) {
    _this->_impl_.volumeattributesclassname_.Set(from._internal_volumeattributesclassname(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_persistentvolumesource()) {
    _this->_impl_.persistentvolumesource_ = new ::k8s::io::api::core::v1::PersistentVolumeSource(*from._impl_.persistentvolumesource_);
  }
  if (from._internal_has_claimref()) {
    _this->_impl_.claimref_ = new ::k8s::io::api::core::v1::ObjectReference(*from._impl_.claimref_);
  }
  if (from._internal_has_nodeaffinity()) {
    _this->_impl_.nodeaffinity_ = new ::k8s::io::api::core::v1::VolumeNodeAffinity(*from._impl_.nodeaffinity_);
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.PersistentVolumeSpec)
}

inline void PersistentVolumeSpec::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_.capacity_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.accessmodes_){arena}
    , decltype(_impl_.mountoptions_){arena}
    , decltype(_impl_.persistentvolumereclaimpolicy_){}
    , decltype(_impl_.storageclassname_){}
    , decltype(_impl_.volumemode_){}
    , decltype(_impl_.volumeattributesclassname_){}
    , decltype(_impl_.persistentvolumesource_){nullptr}
    , decltype(_impl_.claimref_){nullptr}
    , decltype(_impl_.nodeaffinity_){nullptr}
  };
  _impl_.persistentvolumereclaimpolicy_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.persistentvolumereclaimpolicy_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.storageclassname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.storageclassname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.volumemode_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.volumemode_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.volumeattributesclassname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.volumeattributesclassname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PersistentVolumeSpec::~PersistentVolumeSpec() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.PersistentVolumeSpec)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void PersistentVolumeSpec::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.capacity_.Destruct();
  _impl_.capacity_.~MapField();
  _impl_.accessmodes_.~RepeatedPtrField();
  _impl_.mountoptions_.~RepeatedPtrField();
  _impl_.persistentvolumereclaimpolicy_.Destroy();
  _impl_.storageclassname_.Destroy();
  _impl_.volumemode_.Destroy();
  _impl_.volumeattributesclassname_.Destroy();
  if (this != internal_default_instance()) delete _impl_.persistentvolumesource_;
  if (this != internal_default_instance()) delete _impl_.claimref_;
  if (this != internal_default_instance()) delete _impl_.nodeaffinity_;
}

void PersistentVolumeSpec::ArenaDtor(void* object) {
  PersistentVolumeSpec* _this = reinterpret_cast< PersistentVolumeSpec* >(object);
  _this->_impl_.capacity_.Destruct();
}
void PersistentVolumeSpec::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PersistentVolumeSpec::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.PersistentVolumeSpec)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.capacity_.Clear();
  _impl_.accessmodes_.Clear();
  _impl_.mountoptions_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.persistentvolumereclaimpolicy_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.storageclassname_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.volumemode_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.volumeattributesclassname_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.persistentvolumesource_ != nullptr);
      _impl_.persistentvolumesource_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.claimref_ != nullptr);
      _impl_.claimref_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(_impl_.nodeaffinity_ != nullptr);
      _impl_.nodeaffinity_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PersistentVolumeSpec::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // map<string, .k8s.io.apimachinery.pkg.api.resource.Quantity> capacity = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.capacity_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.PersistentVolumeSource persistentVolumeSource = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_persistentvolumesource(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string accessModes = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_accessmodes();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "k8s.io.api.core.v1.PersistentVolumeSpec.accessModes");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.ObjectReference claimRef = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_claimref(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes persistentVolumeReclaimPolicy = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_persistentvolumereclaimpolicy();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes storageClassName = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_storageclassname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string mountOptions = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_mountoptions();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "k8s.io.api.core.v1.PersistentVolumeSpec.mountOptions");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bytes volumeMode = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_volumemode();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.VolumeNodeAffinity nodeAffinity = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_nodeaffinity(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes volumeAttributesClassName = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_volumeattributesclassname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PersistentVolumeSpec::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.PersistentVolumeSpec)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // map<string, .k8s.io.apimachinery.pkg.api.resource.Quantity> capacity = 1;
  if (!this->_internal_capacity().empty()) {
    using MapType = ::_pb::Map<std::string, ::k8s::io::apimachinery::pkg::api::resource::Quantity>;
    using WireHelper = PersistentVolumeSpec_CapacityEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_capacity();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "k8s.io.api.core.v1.PersistentVolumeSpec.CapacityEntry.key");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(1, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(1, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional .k8s.io.api.core.v1.PersistentVolumeSource persistentVolumeSource = 2;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::persistentvolumesource(this),
        _Internal::persistentvolumesource(this).GetCachedSize(), target, stream);
  }

  // repeated string accessModes = 3;
  for (int i = 0, n = this->_internal_accessmodes_size(); i < n; i++) {
    const auto& s = this->_internal_accessmodes(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "k8s.io.api.core.v1.PersistentVolumeSpec.accessModes");
    target = stream->WriteString(3, s, target);
  }

  // optional .k8s.io.api.core.v1.ObjectReference claimRef = 4;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::claimref(this),
        _Internal::claimref(this).GetCachedSize(), target, stream);
  }

  // optional bytes persistentVolumeReclaimPolicy = 5;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_persistentvolumereclaimpolicy(), target);
  }

  // optional bytes storageClassName = 6;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        6, this->_internal_storageclassname(), target);
  }

  // repeated string mountOptions = 7;
  for (int i = 0, n = this->_internal_mountoptions_size(); i < n; i++) {
    const auto& s = this->_internal_mountoptions(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "k8s.io.api.core.v1.PersistentVolumeSpec.mountOptions");
    target = stream->WriteString(7, s, target);
  }

  // optional bytes volumeMode = 8;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        8, this->_internal_volumemode(), target);
  }

  // optional .k8s.io.api.core.v1.VolumeNodeAffinity nodeAffinity = 9;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::nodeaffinity(this),
        _Internal::nodeaffinity(this).GetCachedSize(), target, stream);
  }

  // optional bytes volumeAttributesClassName = 10;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        10, this->_internal_volumeattributesclassname(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.PersistentVolumeSpec)
  return target;
}

size_t PersistentVolumeSpec::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.PersistentVolumeSpec)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, .k8s.io.apimachinery.pkg.api.resource.Quantity> capacity = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_capacity_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::k8s::io::apimachinery::pkg::api::resource::Quantity >::const_iterator
      it = this->_internal_capacity().begin();
      it != this->_internal_capacity().end(); ++it) {
    total_size += PersistentVolumeSpec_CapacityEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // repeated string accessModes = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.accessmodes_.size());
  for (int i = 0, n = _impl_.accessmodes_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.accessmodes_.Get(i));
  }

  // repeated string mountOptions = 7;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.mountoptions_.size());
  for (int i = 0, n = _impl_.mountoptions_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.mountoptions_.Get(i));
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional bytes persistentVolumeReclaimPolicy = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_persistentvolumereclaimpolicy());
    }

    // optional bytes storageClassName = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_storageclassname());
    }

    // optional bytes volumeMode = 8;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_volumemode());
    }

    // optional bytes volumeAttributesClassName = 10;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_volumeattributesclassname());
    }

    // optional .k8s.io.api.core.v1.PersistentVolumeSource persistentVolumeSource = 2;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.persistentvolumesource_);
    }

    // optional .k8s.io.api.core.v1.ObjectReference claimRef = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.claimref_);
    }

    // optional .k8s.io.api.core.v1.VolumeNodeAffinity nodeAffinity = 9;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.nodeaffinity_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PersistentVolumeSpec::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PersistentVolumeSpec::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PersistentVolumeSpec::GetClassData() const { return &_class_data_; }


void PersistentVolumeSpec::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PersistentVolumeSpec*>(&to_msg);
  auto& from = static_cast<const PersistentVolumeSpec&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.PersistentVolumeSpec)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.capacity_.MergeFrom(from._impl_.capacity_);
  _this->_impl_.accessmodes_.MergeFrom(from._impl_.accessmodes_);
  _this->_impl_.mountoptions_.MergeFrom(from._impl_.mountoptions_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_persistentvolumereclaimpolicy(from._internal_persistentvolumereclaimpolicy());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_storageclassname(from._internal_storageclassname());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_volumemode(from._internal_volumemode());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_volumeattributesclassname(from._internal_volumeattributesclassname());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_persistentvolumesource()->::k8s::io::api::core::v1::PersistentVolumeSource::MergeFrom(
          from._internal_persistentvolumesource());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_claimref()->::k8s::io::api::core::v1::ObjectReference::MergeFrom(
          from._internal_claimref());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_nodeaffinity()->::k8s::io::api::core::v1::VolumeNodeAffinity::MergeFrom(
          from._internal_nodeaffinity());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PersistentVolumeSpec::CopyFrom(const PersistentVolumeSpec& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.PersistentVolumeSpec)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PersistentVolumeSpec::IsInitialized() const {
  return true;
}

void PersistentVolumeSpec::InternalSwap(PersistentVolumeSpec* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.capacity_.InternalSwap(&other->_impl_.capacity_);
  _impl_.accessmodes_.InternalSwap(&other->_impl_.accessmodes_);
  _impl_.mountoptions_.InternalSwap(&other->_impl_.mountoptions_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.persistentvolumereclaimpolicy_, lhs_arena,
      &other->_impl_.persistentvolumereclaimpolicy_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.storageclassname_, lhs_arena,
      &other->_impl_.storageclassname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.volumemode_, lhs_arena,
      &other->_impl_.volumemode_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.volumeattributesclassname_, lhs_arena,
      &other->_impl_.volumeattributesclassname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PersistentVolumeSpec, _impl_.nodeaffinity_)
      + sizeof(PersistentVolumeSpec::_impl_.nodeaffinity_)
      - PROTOBUF_FIELD_OFFSET(PersistentVolumeSpec, _impl_.persistentvolumesource_)>(
          reinterpret_cast<char*>(&_impl_.persistentvolumesource_),
          reinterpret_cast<char*>(&other->_impl_.persistentvolumesource_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PersistentVolumeSpec::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[141]);
}

// ===================================================================

class PersistentVolumeStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<PersistentVolumeStatus>()._impl_._has_bits_);
  static void set_has_phase(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_message(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_reason(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::k8s::io::apimachinery::pkg::apis::meta::v1::Time& lastphasetransitiontime(const PersistentVolumeStatus* msg);
  static void set_has_lastphasetransitiontime(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::k8s::io::apimachinery::pkg::apis::meta::v1::Time&
PersistentVolumeStatus::_Internal::lastphasetransitiontime(const PersistentVolumeStatus* msg) {
  return *msg->_impl_.lastphasetransitiontime_;
}
void PersistentVolumeStatus::clear_lastphasetransitiontime() {
  if (_impl_.lastphasetransitiontime_ != nullptr) _impl_.lastphasetransitiontime_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
PersistentVolumeStatus::PersistentVolumeStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.PersistentVolumeStatus)
}
PersistentVolumeStatus::PersistentVolumeStatus(const PersistentVolumeStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PersistentVolumeStatus* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.phase_){}
    , decltype(_impl_.message_){}
    , decltype(_impl_.reason_){}
    , decltype(_impl_.lastphasetransitiontime_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.phase_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.phase_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_phase()) {
    _this->_impl_.phase_.Set(from._internal_phase(), 
      _this->GetArenaForAllocation());
  }
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_message()) {
    _this->_impl_.message_.Set(from._internal_message(), 
      _this->GetArenaForAllocation());
  }
  _impl_.reason_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.reason_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_reason()) {
    _this->_impl_.reason_.Set(from._internal_reason(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_lastphasetransitiontime()) {
    _this->_impl_.lastphasetransitiontime_ = new ::k8s::io::apimachinery::pkg::apis::meta::v1::Time(*from._impl_.lastphasetransitiontime_);
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.PersistentVolumeStatus)
}

inline void PersistentVolumeStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.phase_){}
    , decltype(_impl_.message_){}
    , decltype(_impl_.reason_){}
    , decltype(_impl_.lastphasetransitiontime_){nullptr}
  };
  _impl_.phase_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.phase_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.reason_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.reason_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PersistentVolumeStatus::~PersistentVolumeStatus() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.PersistentVolumeStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PersistentVolumeStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.phase_.Destroy();
  _impl_.message_.Destroy();
  _impl_.reason_.Destroy();
  if (this != internal_default_instance()) delete _impl_.lastphasetransitiontime_;
}

void PersistentVolumeStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PersistentVolumeStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.PersistentVolumeStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.phase_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.message_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.reason_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.lastphasetransitiontime_ != nullptr);
      _impl_.lastphasetransitiontime_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PersistentVolumeStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes phase = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_phase();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes message = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes reason = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_reason();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastPhaseTransitionTime = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_lastphasetransitiontime(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PersistentVolumeStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.PersistentVolumeStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes phase = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_phase(), target);
  }

  // optional bytes message = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_message(), target);
  }

  // optional bytes reason = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_reason(), target);
  }

  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastPhaseTransitionTime = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::lastphasetransitiontime(this),
        _Internal::lastphasetransitiontime(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.PersistentVolumeStatus)
  return target;
}

size_t PersistentVolumeStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.PersistentVolumeStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional bytes phase = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_phase());
    }

    // optional bytes message = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_message());
    }

    // optional bytes reason = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_reason());
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastPhaseTransitionTime = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.lastphasetransitiontime_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PersistentVolumeStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PersistentVolumeStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PersistentVolumeStatus::GetClassData() const { return &_class_data_; }


void PersistentVolumeStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PersistentVolumeStatus*>(&to_msg);
  auto& from = static_cast<const PersistentVolumeStatus&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.PersistentVolumeStatus)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_phase(from._internal_phase());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_message(from._internal_message());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_reason(from._internal_reason());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_lastphasetransitiontime()->::k8s::io::apimachinery::pkg::apis::meta::v1::Time::MergeFrom(
          from._internal_lastphasetransitiontime());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PersistentVolumeStatus::CopyFrom(const PersistentVolumeStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.PersistentVolumeStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PersistentVolumeStatus::IsInitialized() const {
  return true;
}

void PersistentVolumeStatus::InternalSwap(PersistentVolumeStatus* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.phase_, lhs_arena,
      &other->_impl_.phase_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.message_, lhs_arena,
      &other->_impl_.message_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.reason_, lhs_arena,
      &other->_impl_.reason_, rhs_arena
  );
  swap(_impl_.lastphasetransitiontime_, other->_impl_.lastphasetransitiontime_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PersistentVolumeStatus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[142]);
}

// ===================================================================

class PhotonPersistentDiskVolumeSource::_Internal {
 public:
  using HasBits = decltype(std::declval<PhotonPersistentDiskVolumeSource>()._impl_._has_bits_);
  static void set_has_pdid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_fstype(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

PhotonPersistentDiskVolumeSource::PhotonPersistentDiskVolumeSource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.PhotonPersistentDiskVolumeSource)
}
PhotonPersistentDiskVolumeSource::PhotonPersistentDiskVolumeSource(const PhotonPersistentDiskVolumeSource& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PhotonPersistentDiskVolumeSource* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pdid_){}
    , decltype(_impl_.fstype_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.pdid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pdid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_pdid()) {
    _this->_impl_.pdid_.Set(from._internal_pdid(), 
      _this->GetArenaForAllocation());
  }
  _impl_.fstype_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fstype_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_fstype()) {
    _this->_impl_.fstype_.Set(from._internal_fstype(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.PhotonPersistentDiskVolumeSource)
}

inline void PhotonPersistentDiskVolumeSource::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pdid_){}
    , decltype(_impl_.fstype_){}
  };
  _impl_.pdid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pdid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.fstype_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fstype_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PhotonPersistentDiskVolumeSource::~PhotonPersistentDiskVolumeSource() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.PhotonPersistentDiskVolumeSource)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PhotonPersistentDiskVolumeSource::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.pdid_.Destroy();
  _impl_.fstype_.Destroy();
}

void PhotonPersistentDiskVolumeSource::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PhotonPersistentDiskVolumeSource::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.PhotonPersistentDiskVolumeSource)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.pdid_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.fstype_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PhotonPersistentDiskVolumeSource::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes pdID = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_pdid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes fsType = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_fstype();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PhotonPersistentDiskVolumeSource::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.PhotonPersistentDiskVolumeSource)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes pdID = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_pdid(), target);
  }

  // optional bytes fsType = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_fstype(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.PhotonPersistentDiskVolumeSource)
  return target;
}

size_t PhotonPersistentDiskVolumeSource::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.PhotonPersistentDiskVolumeSource)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes pdID = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_pdid());
    }

    // optional bytes fsType = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_fstype());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PhotonPersistentDiskVolumeSource::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PhotonPersistentDiskVolumeSource::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PhotonPersistentDiskVolumeSource::GetClassData() const { return &_class_data_; }


void PhotonPersistentDiskVolumeSource::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PhotonPersistentDiskVolumeSource*>(&to_msg);
  auto& from = static_cast<const PhotonPersistentDiskVolumeSource&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.PhotonPersistentDiskVolumeSource)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_pdid(from._internal_pdid());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_fstype(from._internal_fstype());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PhotonPersistentDiskVolumeSource::CopyFrom(const PhotonPersistentDiskVolumeSource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.PhotonPersistentDiskVolumeSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PhotonPersistentDiskVolumeSource::IsInitialized() const {
  return true;
}

void PhotonPersistentDiskVolumeSource::InternalSwap(PhotonPersistentDiskVolumeSource* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.pdid_, lhs_arena,
      &other->_impl_.pdid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.fstype_, lhs_arena,
      &other->_impl_.fstype_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata PhotonPersistentDiskVolumeSource::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[143]);
}

// ===================================================================

class Pod::_Internal {
 public:
  using HasBits = decltype(std::declval<Pod>()._impl_._has_bits_);
  static const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& metadata(const Pod* msg);
  static void set_has_metadata(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::k8s::io::api::core::v1::PodSpec& spec(const Pod* msg);
  static void set_has_spec(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::k8s::io::api::core::v1::PodStatus& status(const Pod* msg);
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta&
Pod::_Internal::metadata(const Pod* msg) {
  return *msg->_impl_.metadata_;
}
const ::k8s::io::api::core::v1::PodSpec&
Pod::_Internal::spec(const Pod* msg) {
  return *msg->_impl_.spec_;
}
const ::k8s::io::api::core::v1::PodStatus&
Pod::_Internal::status(const Pod* msg) {
  return *msg->_impl_.status_;
}
void Pod::clear_metadata() {
  if (_impl_.metadata_ != nullptr) _impl_.metadata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
Pod::Pod(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.Pod)
}
Pod::Pod(const Pod& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Pod* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.metadata_){nullptr}
    , decltype(_impl_.spec_){nullptr}
    , decltype(_impl_.status_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_metadata()) {
    _this->_impl_.metadata_ = new ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta(*from._impl_.metadata_);
  }
  if (from._internal_has_spec()) {
    _this->_impl_.spec_ = new ::k8s::io::api::core::v1::PodSpec(*from._impl_.spec_);
  }
  if (from._internal_has_status()) {
    _this->_impl_.status_ = new ::k8s::io::api::core::v1::PodStatus(*from._impl_.status_);
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.Pod)
}

inline void Pod::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.metadata_){nullptr}
    , decltype(_impl_.spec_){nullptr}
    , decltype(_impl_.status_){nullptr}
  };
}

Pod::~Pod() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.Pod)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Pod::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.metadata_;
  if (this != internal_default_instance()) delete _impl_.spec_;
  if (this != internal_default_instance()) delete _impl_.status_;
}

void Pod::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Pod::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.Pod)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.metadata_ != nullptr);
      _impl_.metadata_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.spec_ != nullptr);
      _impl_.spec_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.status_ != nullptr);
      _impl_.status_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Pod::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_metadata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.PodSpec spec = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_spec(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.PodStatus status = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_status(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Pod::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.Pod)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::metadata(this),
        _Internal::metadata(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.PodSpec spec = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::spec(this),
        _Internal::spec(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.PodStatus status = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::status(this),
        _Internal::status(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.Pod)
  return target;
}

size_t Pod::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.Pod)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.metadata_);
    }

    // optional .k8s.io.api.core.v1.PodSpec spec = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.spec_);
    }

    // optional .k8s.io.api.core.v1.PodStatus status = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.status_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Pod::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Pod::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Pod::GetClassData() const { return &_class_data_; }


void Pod::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Pod*>(&to_msg);
  auto& from = static_cast<const Pod&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.Pod)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_metadata()->::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta::MergeFrom(
          from._internal_metadata());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_spec()->::k8s::io::api::core::v1::PodSpec::MergeFrom(
          from._internal_spec());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_status()->::k8s::io::api::core::v1::PodStatus::MergeFrom(
          from._internal_status());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Pod::CopyFrom(const Pod& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.Pod)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Pod::IsInitialized() const {
  return true;
}

void Pod::InternalSwap(Pod* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Pod, _impl_.status_)
      + sizeof(Pod::_impl_.status_)
      - PROTOBUF_FIELD_OFFSET(Pod, _impl_.metadata_)>(
          reinterpret_cast<char*>(&_impl_.metadata_),
          reinterpret_cast<char*>(&other->_impl_.metadata_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Pod::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[144]);
}

// ===================================================================

class PodAffinity::_Internal {
 public:
};

PodAffinity::PodAffinity(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.PodAffinity)
}
PodAffinity::PodAffinity(const PodAffinity& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PodAffinity* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.requiredduringschedulingignoredduringexecution_){from._impl_.requiredduringschedulingignoredduringexecution_}
    , decltype(_impl_.preferredduringschedulingignoredduringexecution_){from._impl_.preferredduringschedulingignoredduringexecution_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.PodAffinity)
}

inline void PodAffinity::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.requiredduringschedulingignoredduringexecution_){arena}
    , decltype(_impl_.preferredduringschedulingignoredduringexecution_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

PodAffinity::~PodAffinity() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.PodAffinity)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PodAffinity::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.requiredduringschedulingignoredduringexecution_.~RepeatedPtrField();
  _impl_.preferredduringschedulingignoredduringexecution_.~RepeatedPtrField();
}

void PodAffinity::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PodAffinity::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.PodAffinity)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.requiredduringschedulingignoredduringexecution_.Clear();
  _impl_.preferredduringschedulingignoredduringexecution_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PodAffinity::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .k8s.io.api.core.v1.PodAffinityTerm requiredDuringSchedulingIgnoredDuringExecution = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_requiredduringschedulingignoredduringexecution(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .k8s.io.api.core.v1.WeightedPodAffinityTerm preferredDuringSchedulingIgnoredDuringExecution = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_preferredduringschedulingignoredduringexecution(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PodAffinity::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.PodAffinity)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .k8s.io.api.core.v1.PodAffinityTerm requiredDuringSchedulingIgnoredDuringExecution = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_requiredduringschedulingignoredduringexecution_size()); i < n; i++) {
    const auto& repfield = this->_internal_requiredduringschedulingignoredduringexecution(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .k8s.io.api.core.v1.WeightedPodAffinityTerm preferredDuringSchedulingIgnoredDuringExecution = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_preferredduringschedulingignoredduringexecution_size()); i < n; i++) {
    const auto& repfield = this->_internal_preferredduringschedulingignoredduringexecution(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.PodAffinity)
  return target;
}

size_t PodAffinity::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.PodAffinity)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .k8s.io.api.core.v1.PodAffinityTerm requiredDuringSchedulingIgnoredDuringExecution = 1;
  total_size += 1UL * this->_internal_requiredduringschedulingignoredduringexecution_size();
  for (const auto& msg : this->_impl_.requiredduringschedulingignoredduringexecution_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .k8s.io.api.core.v1.WeightedPodAffinityTerm preferredDuringSchedulingIgnoredDuringExecution = 2;
  total_size += 1UL * this->_internal_preferredduringschedulingignoredduringexecution_size();
  for (const auto& msg : this->_impl_.preferredduringschedulingignoredduringexecution_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PodAffinity::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PodAffinity::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PodAffinity::GetClassData() const { return &_class_data_; }


void PodAffinity::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PodAffinity*>(&to_msg);
  auto& from = static_cast<const PodAffinity&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.PodAffinity)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.requiredduringschedulingignoredduringexecution_.MergeFrom(from._impl_.requiredduringschedulingignoredduringexecution_);
  _this->_impl_.preferredduringschedulingignoredduringexecution_.MergeFrom(from._impl_.preferredduringschedulingignoredduringexecution_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PodAffinity::CopyFrom(const PodAffinity& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.PodAffinity)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PodAffinity::IsInitialized() const {
  return true;
}

void PodAffinity::InternalSwap(PodAffinity* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.requiredduringschedulingignoredduringexecution_.InternalSwap(&other->_impl_.requiredduringschedulingignoredduringexecution_);
  _impl_.preferredduringschedulingignoredduringexecution_.InternalSwap(&other->_impl_.preferredduringschedulingignoredduringexecution_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PodAffinity::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[145]);
}

// ===================================================================

class PodAffinityTerm::_Internal {
 public:
  using HasBits = decltype(std::declval<PodAffinityTerm>()._impl_._has_bits_);
  static const ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector& labelselector(const PodAffinityTerm* msg);
  static void set_has_labelselector(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_topologykey(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector& namespaceselector(const PodAffinityTerm* msg);
  static void set_has_namespaceselector(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector&
PodAffinityTerm::_Internal::labelselector(const PodAffinityTerm* msg) {
  return *msg->_impl_.labelselector_;
}
const ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector&
PodAffinityTerm::_Internal::namespaceselector(const PodAffinityTerm* msg) {
  return *msg->_impl_.namespaceselector_;
}
void PodAffinityTerm::clear_labelselector() {
  if (_impl_.labelselector_ != nullptr) _impl_.labelselector_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void PodAffinityTerm::clear_namespaceselector() {
  if (_impl_.namespaceselector_ != nullptr) _impl_.namespaceselector_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
PodAffinityTerm::PodAffinityTerm(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.PodAffinityTerm)
}
PodAffinityTerm::PodAffinityTerm(const PodAffinityTerm& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PodAffinityTerm* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.namespaces_){from._impl_.namespaces_}
    , decltype(_impl_.matchlabelkeys_){from._impl_.matchlabelkeys_}
    , decltype(_impl_.mismatchlabelkeys_){from._impl_.mismatchlabelkeys_}
    , decltype(_impl_.topologykey_){}
    , decltype(_impl_.labelselector_){nullptr}
    , decltype(_impl_.namespaceselector_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.topologykey_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.topologykey_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_topologykey()) {
    _this->_impl_.topologykey_.Set(from._internal_topologykey(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_labelselector()) {
    _this->_impl_.labelselector_ = new ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector(*from._impl_.labelselector_);
  }
  if (from._internal_has_namespaceselector()) {
    _this->_impl_.namespaceselector_ = new ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector(*from._impl_.namespaceselector_);
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.PodAffinityTerm)
}

inline void PodAffinityTerm::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.namespaces_){arena}
    , decltype(_impl_.matchlabelkeys_){arena}
    , decltype(_impl_.mismatchlabelkeys_){arena}
    , decltype(_impl_.topologykey_){}
    , decltype(_impl_.labelselector_){nullptr}
    , decltype(_impl_.namespaceselector_){nullptr}
  };
  _impl_.topologykey_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.topologykey_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PodAffinityTerm::~PodAffinityTerm() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.PodAffinityTerm)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PodAffinityTerm::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.namespaces_.~RepeatedPtrField();
  _impl_.matchlabelkeys_.~RepeatedPtrField();
  _impl_.mismatchlabelkeys_.~RepeatedPtrField();
  _impl_.topologykey_.Destroy();
  if (this != internal_default_instance()) delete _impl_.labelselector_;
  if (this != internal_default_instance()) delete _impl_.namespaceselector_;
}

void PodAffinityTerm::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PodAffinityTerm::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.PodAffinityTerm)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.namespaces_.Clear();
  _impl_.matchlabelkeys_.Clear();
  _impl_.mismatchlabelkeys_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.topologykey_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.labelselector_ != nullptr);
      _impl_.labelselector_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.namespaceselector_ != nullptr);
      _impl_.namespaceselector_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PodAffinityTerm::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector labelSelector = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_labelselector(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string namespaces = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_namespaces();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "k8s.io.api.core.v1.PodAffinityTerm.namespaces");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bytes topologyKey = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_topologykey();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_namespaceselector(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string matchLabelKeys = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_matchlabelkeys();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "k8s.io.api.core.v1.PodAffinityTerm.matchLabelKeys");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string mismatchLabelKeys = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_mismatchlabelkeys();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "k8s.io.api.core.v1.PodAffinityTerm.mismatchLabelKeys");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PodAffinityTerm::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.PodAffinityTerm)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector labelSelector = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::labelselector(this),
        _Internal::labelselector(this).GetCachedSize(), target, stream);
  }

  // repeated string namespaces = 2;
  for (int i = 0, n = this->_internal_namespaces_size(); i < n; i++) {
    const auto& s = this->_internal_namespaces(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "k8s.io.api.core.v1.PodAffinityTerm.namespaces");
    target = stream->WriteString(2, s, target);
  }

  // optional bytes topologyKey = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_topologykey(), target);
  }

  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::namespaceselector(this),
        _Internal::namespaceselector(this).GetCachedSize(), target, stream);
  }

  // repeated string matchLabelKeys = 5;
  for (int i = 0, n = this->_internal_matchlabelkeys_size(); i < n; i++) {
    const auto& s = this->_internal_matchlabelkeys(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "k8s.io.api.core.v1.PodAffinityTerm.matchLabelKeys");
    target = stream->WriteString(5, s, target);
  }

  // repeated string mismatchLabelKeys = 6;
  for (int i = 0, n = this->_internal_mismatchlabelkeys_size(); i < n; i++) {
    const auto& s = this->_internal_mismatchlabelkeys(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "k8s.io.api.core.v1.PodAffinityTerm.mismatchLabelKeys");
    target = stream->WriteString(6, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.PodAffinityTerm)
  return target;
}

size_t PodAffinityTerm::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.PodAffinityTerm)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string namespaces = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.namespaces_.size());
  for (int i = 0, n = _impl_.namespaces_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.namespaces_.Get(i));
  }

  // repeated string matchLabelKeys = 5;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.matchlabelkeys_.size());
  for (int i = 0, n = _impl_.matchlabelkeys_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.matchlabelkeys_.Get(i));
  }

  // repeated string mismatchLabelKeys = 6;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.mismatchlabelkeys_.size());
  for (int i = 0, n = _impl_.mismatchlabelkeys_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.mismatchlabelkeys_.Get(i));
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bytes topologyKey = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_topologykey());
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector labelSelector = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.labelselector_);
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.namespaceselector_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PodAffinityTerm::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PodAffinityTerm::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PodAffinityTerm::GetClassData() const { return &_class_data_; }


void PodAffinityTerm::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PodAffinityTerm*>(&to_msg);
  auto& from = static_cast<const PodAffinityTerm&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.PodAffinityTerm)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.namespaces_.MergeFrom(from._impl_.namespaces_);
  _this->_impl_.matchlabelkeys_.MergeFrom(from._impl_.matchlabelkeys_);
  _this->_impl_.mismatchlabelkeys_.MergeFrom(from._impl_.mismatchlabelkeys_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_topologykey(from._internal_topologykey());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_labelselector()->::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector::MergeFrom(
          from._internal_labelselector());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_namespaceselector()->::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector::MergeFrom(
          from._internal_namespaceselector());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PodAffinityTerm::CopyFrom(const PodAffinityTerm& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.PodAffinityTerm)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PodAffinityTerm::IsInitialized() const {
  return true;
}

void PodAffinityTerm::InternalSwap(PodAffinityTerm* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.namespaces_.InternalSwap(&other->_impl_.namespaces_);
  _impl_.matchlabelkeys_.InternalSwap(&other->_impl_.matchlabelkeys_);
  _impl_.mismatchlabelkeys_.InternalSwap(&other->_impl_.mismatchlabelkeys_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.topologykey_, lhs_arena,
      &other->_impl_.topologykey_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PodAffinityTerm, _impl_.namespaceselector_)
      + sizeof(PodAffinityTerm::_impl_.namespaceselector_)
      - PROTOBUF_FIELD_OFFSET(PodAffinityTerm, _impl_.labelselector_)>(
          reinterpret_cast<char*>(&_impl_.labelselector_),
          reinterpret_cast<char*>(&other->_impl_.labelselector_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PodAffinityTerm::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[146]);
}

// ===================================================================

class PodAntiAffinity::_Internal {
 public:
};

PodAntiAffinity::PodAntiAffinity(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.PodAntiAffinity)
}
PodAntiAffinity::PodAntiAffinity(const PodAntiAffinity& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PodAntiAffinity* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.requiredduringschedulingignoredduringexecution_){from._impl_.requiredduringschedulingignoredduringexecution_}
    , decltype(_impl_.preferredduringschedulingignoredduringexecution_){from._impl_.preferredduringschedulingignoredduringexecution_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.PodAntiAffinity)
}

inline void PodAntiAffinity::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.requiredduringschedulingignoredduringexecution_){arena}
    , decltype(_impl_.preferredduringschedulingignoredduringexecution_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

PodAntiAffinity::~PodAntiAffinity() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.PodAntiAffinity)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PodAntiAffinity::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.requiredduringschedulingignoredduringexecution_.~RepeatedPtrField();
  _impl_.preferredduringschedulingignoredduringexecution_.~RepeatedPtrField();
}

void PodAntiAffinity::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PodAntiAffinity::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.PodAntiAffinity)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.requiredduringschedulingignoredduringexecution_.Clear();
  _impl_.preferredduringschedulingignoredduringexecution_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PodAntiAffinity::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .k8s.io.api.core.v1.PodAffinityTerm requiredDuringSchedulingIgnoredDuringExecution = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_requiredduringschedulingignoredduringexecution(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .k8s.io.api.core.v1.WeightedPodAffinityTerm preferredDuringSchedulingIgnoredDuringExecution = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_preferredduringschedulingignoredduringexecution(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PodAntiAffinity::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.PodAntiAffinity)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .k8s.io.api.core.v1.PodAffinityTerm requiredDuringSchedulingIgnoredDuringExecution = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_requiredduringschedulingignoredduringexecution_size()); i < n; i++) {
    const auto& repfield = this->_internal_requiredduringschedulingignoredduringexecution(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .k8s.io.api.core.v1.WeightedPodAffinityTerm preferredDuringSchedulingIgnoredDuringExecution = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_preferredduringschedulingignoredduringexecution_size()); i < n; i++) {
    const auto& repfield = this->_internal_preferredduringschedulingignoredduringexecution(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.PodAntiAffinity)
  return target;
}

size_t PodAntiAffinity::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.PodAntiAffinity)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .k8s.io.api.core.v1.PodAffinityTerm requiredDuringSchedulingIgnoredDuringExecution = 1;
  total_size += 1UL * this->_internal_requiredduringschedulingignoredduringexecution_size();
  for (const auto& msg : this->_impl_.requiredduringschedulingignoredduringexecution_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .k8s.io.api.core.v1.WeightedPodAffinityTerm preferredDuringSchedulingIgnoredDuringExecution = 2;
  total_size += 1UL * this->_internal_preferredduringschedulingignoredduringexecution_size();
  for (const auto& msg : this->_impl_.preferredduringschedulingignoredduringexecution_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PodAntiAffinity::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PodAntiAffinity::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PodAntiAffinity::GetClassData() const { return &_class_data_; }


void PodAntiAffinity::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PodAntiAffinity*>(&to_msg);
  auto& from = static_cast<const PodAntiAffinity&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.PodAntiAffinity)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.requiredduringschedulingignoredduringexecution_.MergeFrom(from._impl_.requiredduringschedulingignoredduringexecution_);
  _this->_impl_.preferredduringschedulingignoredduringexecution_.MergeFrom(from._impl_.preferredduringschedulingignoredduringexecution_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PodAntiAffinity::CopyFrom(const PodAntiAffinity& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.PodAntiAffinity)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PodAntiAffinity::IsInitialized() const {
  return true;
}

void PodAntiAffinity::InternalSwap(PodAntiAffinity* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.requiredduringschedulingignoredduringexecution_.InternalSwap(&other->_impl_.requiredduringschedulingignoredduringexecution_);
  _impl_.preferredduringschedulingignoredduringexecution_.InternalSwap(&other->_impl_.preferredduringschedulingignoredduringexecution_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PodAntiAffinity::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[147]);
}

// ===================================================================

class PodAttachOptions::_Internal {
 public:
  using HasBits = decltype(std::declval<PodAttachOptions>()._impl_._has_bits_);
  static void set_has_stdin(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_stdout(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_stderr(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_tty(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_container(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

PodAttachOptions::PodAttachOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.PodAttachOptions)
}
PodAttachOptions::PodAttachOptions(const PodAttachOptions& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PodAttachOptions* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.container_){}
    , decltype(_impl_.stdin_){}
    , decltype(_impl_.stdout_){}
    , decltype(_impl_.stderr_){}
    , decltype(_impl_.tty_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.container_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.container_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_container()) {
    _this->_impl_.container_.Set(from._internal_container(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.stdin_, &from._impl_.stdin_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.tty_) -
    reinterpret_cast<char*>(&_impl_.stdin_)) + sizeof(_impl_.tty_));
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.PodAttachOptions)
}

inline void PodAttachOptions::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.container_){}
    , decltype(_impl_.stdin_){false}
    , decltype(_impl_.stdout_){false}
    , decltype(_impl_.stderr_){false}
    , decltype(_impl_.tty_){false}
  };
  _impl_.container_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.container_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PodAttachOptions::~PodAttachOptions() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.PodAttachOptions)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PodAttachOptions::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.container_.Destroy();
}

void PodAttachOptions::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PodAttachOptions::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.PodAttachOptions)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.container_.ClearNonDefaultToEmpty();
  }
  ::memset(&_impl_.stdin_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.tty_) -
      reinterpret_cast<char*>(&_impl_.stdin_)) + sizeof(_impl_.tty_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PodAttachOptions::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool stdin = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_stdin(&has_bits);
          _impl_.stdin_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool stdout = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_stdout(&has_bits);
          _impl_.stdout_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool stderr = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_stderr(&has_bits);
          _impl_.stderr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool tty = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_tty(&has_bits);
          _impl_.tty_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes container = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_container();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PodAttachOptions::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.PodAttachOptions)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool stdin = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_stdin(), target);
  }

  // optional bool stdout = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_stdout(), target);
  }

  // optional bool stderr = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_stderr(), target);
  }

  // optional bool tty = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_tty(), target);
  }

  // optional bytes container = 5;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_container(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.PodAttachOptions)
  return target;
}

size_t PodAttachOptions::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.PodAttachOptions)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional bytes container = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_container());
    }

    // optional bool stdin = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional bool stdout = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional bool stderr = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional bool tty = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PodAttachOptions::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PodAttachOptions::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PodAttachOptions::GetClassData() const { return &_class_data_; }


void PodAttachOptions::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PodAttachOptions*>(&to_msg);
  auto& from = static_cast<const PodAttachOptions&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.PodAttachOptions)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_container(from._internal_container());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.stdin_ = from._impl_.stdin_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.stdout_ = from._impl_.stdout_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.stderr_ = from._impl_.stderr_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.tty_ = from._impl_.tty_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PodAttachOptions::CopyFrom(const PodAttachOptions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.PodAttachOptions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PodAttachOptions::IsInitialized() const {
  return true;
}

void PodAttachOptions::InternalSwap(PodAttachOptions* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.container_, lhs_arena,
      &other->_impl_.container_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PodAttachOptions, _impl_.tty_)
      + sizeof(PodAttachOptions::_impl_.tty_)
      - PROTOBUF_FIELD_OFFSET(PodAttachOptions, _impl_.stdin_)>(
          reinterpret_cast<char*>(&_impl_.stdin_),
          reinterpret_cast<char*>(&other->_impl_.stdin_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PodAttachOptions::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[148]);
}

// ===================================================================

class PodCondition::_Internal {
 public:
  using HasBits = decltype(std::declval<PodCondition>()._impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::k8s::io::apimachinery::pkg::apis::meta::v1::Time& lastprobetime(const PodCondition* msg);
  static void set_has_lastprobetime(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::k8s::io::apimachinery::pkg::apis::meta::v1::Time& lasttransitiontime(const PodCondition* msg);
  static void set_has_lasttransitiontime(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_reason(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_message(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::k8s::io::apimachinery::pkg::apis::meta::v1::Time&
PodCondition::_Internal::lastprobetime(const PodCondition* msg) {
  return *msg->_impl_.lastprobetime_;
}
const ::k8s::io::apimachinery::pkg::apis::meta::v1::Time&
PodCondition::_Internal::lasttransitiontime(const PodCondition* msg) {
  return *msg->_impl_.lasttransitiontime_;
}
void PodCondition::clear_lastprobetime() {
  if (_impl_.lastprobetime_ != nullptr) _impl_.lastprobetime_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
void PodCondition::clear_lasttransitiontime() {
  if (_impl_.lasttransitiontime_ != nullptr) _impl_.lasttransitiontime_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
PodCondition::PodCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.PodCondition)
}
PodCondition::PodCondition(const PodCondition& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PodCondition* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.type_){}
    , decltype(_impl_.status_){}
    , decltype(_impl_.reason_){}
    , decltype(_impl_.message_){}
    , decltype(_impl_.lastprobetime_){nullptr}
    , decltype(_impl_.lasttransitiontime_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_type()) {
    _this->_impl_.type_.Set(from._internal_type(), 
      _this->GetArenaForAllocation());
  }
  _impl_.status_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.status_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_status()) {
    _this->_impl_.status_.Set(from._internal_status(), 
      _this->GetArenaForAllocation());
  }
  _impl_.reason_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.reason_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_reason()) {
    _this->_impl_.reason_.Set(from._internal_reason(), 
      _this->GetArenaForAllocation());
  }
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_message()) {
    _this->_impl_.message_.Set(from._internal_message(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_lastprobetime()) {
    _this->_impl_.lastprobetime_ = new ::k8s::io::apimachinery::pkg::apis::meta::v1::Time(*from._impl_.lastprobetime_);
  }
  if (from._internal_has_lasttransitiontime()) {
    _this->_impl_.lasttransitiontime_ = new ::k8s::io::apimachinery::pkg::apis::meta::v1::Time(*from._impl_.lasttransitiontime_);
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.PodCondition)
}

inline void PodCondition::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.type_){}
    , decltype(_impl_.status_){}
    , decltype(_impl_.reason_){}
    , decltype(_impl_.message_){}
    , decltype(_impl_.lastprobetime_){nullptr}
    , decltype(_impl_.lasttransitiontime_){nullptr}
  };
  _impl_.type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.status_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.status_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.reason_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.reason_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PodCondition::~PodCondition() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.PodCondition)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PodCondition::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.type_.Destroy();
  _impl_.status_.Destroy();
  _impl_.reason_.Destroy();
  _impl_.message_.Destroy();
  if (this != internal_default_instance()) delete _impl_.lastprobetime_;
  if (this != internal_default_instance()) delete _impl_.lasttransitiontime_;
}

void PodCondition::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PodCondition::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.PodCondition)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.type_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.status_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.reason_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.message_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.lastprobetime_ != nullptr);
      _impl_.lastprobetime_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.lasttransitiontime_ != nullptr);
      _impl_.lasttransitiontime_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PodCondition::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes status = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_status();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastProbeTime = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_lastprobetime(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_lasttransitiontime(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes reason = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_reason();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes message = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PodCondition::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.PodCondition)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_type(), target);
  }

  // optional bytes status = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_status(), target);
  }

  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastProbeTime = 3;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::lastprobetime(this),
        _Internal::lastprobetime(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 4;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::lasttransitiontime(this),
        _Internal::lasttransitiontime(this).GetCachedSize(), target, stream);
  }

  // optional bytes reason = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_reason(), target);
  }

  // optional bytes message = 6;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        6, this->_internal_message(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.PodCondition)
  return target;
}

size_t PodCondition::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.PodCondition)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional bytes type = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_type());
    }

    // optional bytes status = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_status());
    }

    // optional bytes reason = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_reason());
    }

    // optional bytes message = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_message());
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastProbeTime = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.lastprobetime_);
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.lasttransitiontime_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PodCondition::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PodCondition::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PodCondition::GetClassData() const { return &_class_data_; }


void PodCondition::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PodCondition*>(&to_msg);
  auto& from = static_cast<const PodCondition&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.PodCondition)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_type(from._internal_type());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_status(from._internal_status());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_reason(from._internal_reason());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_message(from._internal_message());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_lastprobetime()->::k8s::io::apimachinery::pkg::apis::meta::v1::Time::MergeFrom(
          from._internal_lastprobetime());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_lasttransitiontime()->::k8s::io::apimachinery::pkg::apis::meta::v1::Time::MergeFrom(
          from._internal_lasttransitiontime());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PodCondition::CopyFrom(const PodCondition& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.PodCondition)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PodCondition::IsInitialized() const {
  return true;
}

void PodCondition::InternalSwap(PodCondition* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.type_, lhs_arena,
      &other->_impl_.type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.status_, lhs_arena,
      &other->_impl_.status_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.reason_, lhs_arena,
      &other->_impl_.reason_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.message_, lhs_arena,
      &other->_impl_.message_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PodCondition, _impl_.lasttransitiontime_)
      + sizeof(PodCondition::_impl_.lasttransitiontime_)
      - PROTOBUF_FIELD_OFFSET(PodCondition, _impl_.lastprobetime_)>(
          reinterpret_cast<char*>(&_impl_.lastprobetime_),
          reinterpret_cast<char*>(&other->_impl_.lastprobetime_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PodCondition::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[149]);
}

// ===================================================================

class PodDNSConfig::_Internal {
 public:
};

PodDNSConfig::PodDNSConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.PodDNSConfig)
}
PodDNSConfig::PodDNSConfig(const PodDNSConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PodDNSConfig* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.nameservers_){from._impl_.nameservers_}
    , decltype(_impl_.searches_){from._impl_.searches_}
    , decltype(_impl_.options_){from._impl_.options_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.PodDNSConfig)
}

inline void PodDNSConfig::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.nameservers_){arena}
    , decltype(_impl_.searches_){arena}
    , decltype(_impl_.options_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

PodDNSConfig::~PodDNSConfig() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.PodDNSConfig)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PodDNSConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.nameservers_.~RepeatedPtrField();
  _impl_.searches_.~RepeatedPtrField();
  _impl_.options_.~RepeatedPtrField();
}

void PodDNSConfig::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PodDNSConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.PodDNSConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.nameservers_.Clear();
  _impl_.searches_.Clear();
  _impl_.options_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PodDNSConfig::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string nameservers = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_nameservers();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "k8s.io.api.core.v1.PodDNSConfig.nameservers");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string searches = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_searches();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "k8s.io.api.core.v1.PodDNSConfig.searches");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .k8s.io.api.core.v1.PodDNSConfigOption options = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_options(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PodDNSConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.PodDNSConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string nameservers = 1;
  for (int i = 0, n = this->_internal_nameservers_size(); i < n; i++) {
    const auto& s = this->_internal_nameservers(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "k8s.io.api.core.v1.PodDNSConfig.nameservers");
    target = stream->WriteString(1, s, target);
  }

  // repeated string searches = 2;
  for (int i = 0, n = this->_internal_searches_size(); i < n; i++) {
    const auto& s = this->_internal_searches(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "k8s.io.api.core.v1.PodDNSConfig.searches");
    target = stream->WriteString(2, s, target);
  }

  // repeated .k8s.io.api.core.v1.PodDNSConfigOption options = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_options_size()); i < n; i++) {
    const auto& repfield = this->_internal_options(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.PodDNSConfig)
  return target;
}

size_t PodDNSConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.PodDNSConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string nameservers = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.nameservers_.size());
  for (int i = 0, n = _impl_.nameservers_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.nameservers_.Get(i));
  }

  // repeated string searches = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.searches_.size());
  for (int i = 0, n = _impl_.searches_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.searches_.Get(i));
  }

  // repeated .k8s.io.api.core.v1.PodDNSConfigOption options = 3;
  total_size += 1UL * this->_internal_options_size();
  for (const auto& msg : this->_impl_.options_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PodDNSConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PodDNSConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PodDNSConfig::GetClassData() const { return &_class_data_; }


void PodDNSConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PodDNSConfig*>(&to_msg);
  auto& from = static_cast<const PodDNSConfig&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.PodDNSConfig)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.nameservers_.MergeFrom(from._impl_.nameservers_);
  _this->_impl_.searches_.MergeFrom(from._impl_.searches_);
  _this->_impl_.options_.MergeFrom(from._impl_.options_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PodDNSConfig::CopyFrom(const PodDNSConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.PodDNSConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PodDNSConfig::IsInitialized() const {
  return true;
}

void PodDNSConfig::InternalSwap(PodDNSConfig* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.nameservers_.InternalSwap(&other->_impl_.nameservers_);
  _impl_.searches_.InternalSwap(&other->_impl_.searches_);
  _impl_.options_.InternalSwap(&other->_impl_.options_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PodDNSConfig::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[150]);
}

// ===================================================================

class PodDNSConfigOption::_Internal {
 public:
  using HasBits = decltype(std::declval<PodDNSConfigOption>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

PodDNSConfigOption::PodDNSConfigOption(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.PodDNSConfigOption)
}
PodDNSConfigOption::PodDNSConfigOption(const PodDNSConfigOption& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PodDNSConfigOption* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.value_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_value()) {
    _this->_impl_.value_.Set(from._internal_value(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.PodDNSConfigOption)
}

inline void PodDNSConfigOption::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.value_){}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PodDNSConfigOption::~PodDNSConfigOption() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.PodDNSConfigOption)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PodDNSConfigOption::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.value_.Destroy();
}

void PodDNSConfigOption::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PodDNSConfigOption::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.PodDNSConfigOption)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.value_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PodDNSConfigOption::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PodDNSConfigOption::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.PodDNSConfigOption)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional bytes value = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.PodDNSConfigOption)
  return target;
}

size_t PodDNSConfigOption::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.PodDNSConfigOption)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_name());
    }

    // optional bytes value = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_value());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PodDNSConfigOption::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PodDNSConfigOption::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PodDNSConfigOption::GetClassData() const { return &_class_data_; }


void PodDNSConfigOption::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PodDNSConfigOption*>(&to_msg);
  auto& from = static_cast<const PodDNSConfigOption&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.PodDNSConfigOption)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_value(from._internal_value());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PodDNSConfigOption::CopyFrom(const PodDNSConfigOption& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.PodDNSConfigOption)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PodDNSConfigOption::IsInitialized() const {
  return true;
}

void PodDNSConfigOption::InternalSwap(PodDNSConfigOption* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.value_, lhs_arena,
      &other->_impl_.value_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata PodDNSConfigOption::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[151]);
}

// ===================================================================

class PodExecOptions::_Internal {
 public:
  using HasBits = decltype(std::declval<PodExecOptions>()._impl_._has_bits_);
  static void set_has_stdin(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_stdout(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_stderr(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_tty(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_container(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

PodExecOptions::PodExecOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.PodExecOptions)
}
PodExecOptions::PodExecOptions(const PodExecOptions& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PodExecOptions* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.command_){from._impl_.command_}
    , decltype(_impl_.container_){}
    , decltype(_impl_.stdin_){}
    , decltype(_impl_.stdout_){}
    , decltype(_impl_.stderr_){}
    , decltype(_impl_.tty_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.container_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.container_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_container()) {
    _this->_impl_.container_.Set(from._internal_container(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.stdin_, &from._impl_.stdin_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.tty_) -
    reinterpret_cast<char*>(&_impl_.stdin_)) + sizeof(_impl_.tty_));
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.PodExecOptions)
}

inline void PodExecOptions::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.command_){arena}
    , decltype(_impl_.container_){}
    , decltype(_impl_.stdin_){false}
    , decltype(_impl_.stdout_){false}
    , decltype(_impl_.stderr_){false}
    , decltype(_impl_.tty_){false}
  };
  _impl_.container_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.container_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PodExecOptions::~PodExecOptions() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.PodExecOptions)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PodExecOptions::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.command_.~RepeatedPtrField();
  _impl_.container_.Destroy();
}

void PodExecOptions::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PodExecOptions::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.PodExecOptions)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.command_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.container_.ClearNonDefaultToEmpty();
  }
  ::memset(&_impl_.stdin_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.tty_) -
      reinterpret_cast<char*>(&_impl_.stdin_)) + sizeof(_impl_.tty_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PodExecOptions::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool stdin = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_stdin(&has_bits);
          _impl_.stdin_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool stdout = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_stdout(&has_bits);
          _impl_.stdout_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool stderr = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_stderr(&has_bits);
          _impl_.stderr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool tty = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_tty(&has_bits);
          _impl_.tty_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes container = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_container();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string command = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_command();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "k8s.io.api.core.v1.PodExecOptions.command");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PodExecOptions::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.PodExecOptions)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool stdin = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_stdin(), target);
  }

  // optional bool stdout = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_stdout(), target);
  }

  // optional bool stderr = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_stderr(), target);
  }

  // optional bool tty = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_tty(), target);
  }

  // optional bytes container = 5;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_container(), target);
  }

  // repeated string command = 6;
  for (int i = 0, n = this->_internal_command_size(); i < n; i++) {
    const auto& s = this->_internal_command(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "k8s.io.api.core.v1.PodExecOptions.command");
    target = stream->WriteString(6, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.PodExecOptions)
  return target;
}

size_t PodExecOptions::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.PodExecOptions)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string command = 6;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.command_.size());
  for (int i = 0, n = _impl_.command_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.command_.Get(i));
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional bytes container = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_container());
    }

    // optional bool stdin = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional bool stdout = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional bool stderr = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional bool tty = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PodExecOptions::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PodExecOptions::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PodExecOptions::GetClassData() const { return &_class_data_; }


void PodExecOptions::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PodExecOptions*>(&to_msg);
  auto& from = static_cast<const PodExecOptions&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.PodExecOptions)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.command_.MergeFrom(from._impl_.command_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_container(from._internal_container());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.stdin_ = from._impl_.stdin_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.stdout_ = from._impl_.stdout_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.stderr_ = from._impl_.stderr_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.tty_ = from._impl_.tty_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PodExecOptions::CopyFrom(const PodExecOptions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.PodExecOptions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PodExecOptions::IsInitialized() const {
  return true;
}

void PodExecOptions::InternalSwap(PodExecOptions* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.command_.InternalSwap(&other->_impl_.command_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.container_, lhs_arena,
      &other->_impl_.container_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PodExecOptions, _impl_.tty_)
      + sizeof(PodExecOptions::_impl_.tty_)
      - PROTOBUF_FIELD_OFFSET(PodExecOptions, _impl_.stdin_)>(
          reinterpret_cast<char*>(&_impl_.stdin_),
          reinterpret_cast<char*>(&other->_impl_.stdin_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PodExecOptions::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[152]);
}

// ===================================================================

class PodIP::_Internal {
 public:
  using HasBits = decltype(std::declval<PodIP>()._impl_._has_bits_);
  static void set_has_ip(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

PodIP::PodIP(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.PodIP)
}
PodIP::PodIP(const PodIP& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PodIP* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ip_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.ip_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ip_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ip()) {
    _this->_impl_.ip_.Set(from._internal_ip(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.PodIP)
}

inline void PodIP::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ip_){}
  };
  _impl_.ip_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ip_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PodIP::~PodIP() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.PodIP)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PodIP::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.ip_.Destroy();
}

void PodIP::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PodIP::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.PodIP)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.ip_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PodIP::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes ip = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_ip();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PodIP::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.PodIP)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes ip = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_ip(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.PodIP)
  return target;
}

size_t PodIP::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.PodIP)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes ip = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_ip());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PodIP::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PodIP::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PodIP::GetClassData() const { return &_class_data_; }


void PodIP::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PodIP*>(&to_msg);
  auto& from = static_cast<const PodIP&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.PodIP)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_ip()) {
    _this->_internal_set_ip(from._internal_ip());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PodIP::CopyFrom(const PodIP& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.PodIP)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PodIP::IsInitialized() const {
  return true;
}

void PodIP::InternalSwap(PodIP* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.ip_, lhs_arena,
      &other->_impl_.ip_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata PodIP::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[153]);
}

// ===================================================================

class PodList::_Internal {
 public:
  using HasBits = decltype(std::declval<PodList>()._impl_._has_bits_);
  static const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& metadata(const PodList* msg);
  static void set_has_metadata(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta&
PodList::_Internal::metadata(const PodList* msg) {
  return *msg->_impl_.metadata_;
}
void PodList::clear_metadata() {
  if (_impl_.metadata_ != nullptr) _impl_.metadata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
PodList::PodList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.PodList)
}
PodList::PodList(const PodList& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PodList* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.items_){from._impl_.items_}
    , decltype(_impl_.metadata_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_metadata()) {
    _this->_impl_.metadata_ = new ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta(*from._impl_.metadata_);
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.PodList)
}

inline void PodList::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.items_){arena}
    , decltype(_impl_.metadata_){nullptr}
  };
}

PodList::~PodList() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.PodList)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PodList::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.items_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.metadata_;
}

void PodList::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PodList::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.PodList)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.items_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.metadata_ != nullptr);
    _impl_.metadata_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PodList::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_metadata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .k8s.io.api.core.v1.Pod items = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_items(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PodList::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.PodList)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::metadata(this),
        _Internal::metadata(this).GetCachedSize(), target, stream);
  }

  // repeated .k8s.io.api.core.v1.Pod items = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_items_size()); i < n; i++) {
    const auto& repfield = this->_internal_items(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.PodList)
  return target;
}

size_t PodList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.PodList)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .k8s.io.api.core.v1.Pod items = 2;
  total_size += 1UL * this->_internal_items_size();
  for (const auto& msg : this->_impl_.items_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.metadata_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PodList::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PodList::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PodList::GetClassData() const { return &_class_data_; }


void PodList::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PodList*>(&to_msg);
  auto& from = static_cast<const PodList&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.PodList)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.items_.MergeFrom(from._impl_.items_);
  if (from._internal_has_metadata()) {
    _this->_internal_mutable_metadata()->::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta::MergeFrom(
        from._internal_metadata());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PodList::CopyFrom(const PodList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.PodList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PodList::IsInitialized() const {
  return true;
}

void PodList::InternalSwap(PodList* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.items_.InternalSwap(&other->_impl_.items_);
  swap(_impl_.metadata_, other->_impl_.metadata_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PodList::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[154]);
}

// ===================================================================

class PodLogOptions::_Internal {
 public:
  using HasBits = decltype(std::declval<PodLogOptions>()._impl_._has_bits_);
  static void set_has_container(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_follow(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_previous(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_sinceseconds(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::k8s::io::apimachinery::pkg::apis::meta::v1::Time& sincetime(const PodLogOptions* msg);
  static void set_has_sincetime(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_timestamps(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_taillines(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_limitbytes(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_insecureskiptlsverifybackend(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
};

const ::k8s::io::apimachinery::pkg::apis::meta::v1::Time&
PodLogOptions::_Internal::sincetime(const PodLogOptions* msg) {
  return *msg->_impl_.sincetime_;
}
void PodLogOptions::clear_sincetime() {
  if (_impl_.sincetime_ != nullptr) _impl_.sincetime_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
PodLogOptions::PodLogOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.PodLogOptions)
}
PodLogOptions::PodLogOptions(const PodLogOptions& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PodLogOptions* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.container_){}
    , decltype(_impl_.sincetime_){nullptr}
    , decltype(_impl_.sinceseconds_){}
    , decltype(_impl_.taillines_){}
    , decltype(_impl_.limitbytes_){}
    , decltype(_impl_.follow_){}
    , decltype(_impl_.previous_){}
    , decltype(_impl_.timestamps_){}
    , decltype(_impl_.insecureskiptlsverifybackend_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.container_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.container_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_container()) {
    _this->_impl_.container_.Set(from._internal_container(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_sincetime()) {
    _this->_impl_.sincetime_ = new ::k8s::io::apimachinery::pkg::apis::meta::v1::Time(*from._impl_.sincetime_);
  }
  ::memcpy(&_impl_.sinceseconds_, &from._impl_.sinceseconds_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.insecureskiptlsverifybackend_) -
    reinterpret_cast<char*>(&_impl_.sinceseconds_)) + sizeof(_impl_.insecureskiptlsverifybackend_));
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.PodLogOptions)
}

inline void PodLogOptions::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.container_){}
    , decltype(_impl_.sincetime_){nullptr}
    , decltype(_impl_.sinceseconds_){int64_t{0}}
    , decltype(_impl_.taillines_){int64_t{0}}
    , decltype(_impl_.limitbytes_){int64_t{0}}
    , decltype(_impl_.follow_){false}
    , decltype(_impl_.previous_){false}
    , decltype(_impl_.timestamps_){false}
    , decltype(_impl_.insecureskiptlsverifybackend_){false}
  };
  _impl_.container_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.container_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PodLogOptions::~PodLogOptions() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.PodLogOptions)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PodLogOptions::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.container_.Destroy();
  if (this != internal_default_instance()) delete _impl_.sincetime_;
}

void PodLogOptions::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PodLogOptions::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.PodLogOptions)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.container_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.sincetime_ != nullptr);
      _impl_.sincetime_->Clear();
    }
  }
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&_impl_.sinceseconds_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.timestamps_) -
        reinterpret_cast<char*>(&_impl_.sinceseconds_)) + sizeof(_impl_.timestamps_));
  }
  _impl_.insecureskiptlsverifybackend_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PodLogOptions::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes container = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_container();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool follow = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_follow(&has_bits);
          _impl_.follow_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool previous = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_previous(&has_bits);
          _impl_.previous_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 sinceSeconds = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_sinceseconds(&has_bits);
          _impl_.sinceseconds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time sinceTime = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_sincetime(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool timestamps = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_timestamps(&has_bits);
          _impl_.timestamps_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 tailLines = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_taillines(&has_bits);
          _impl_.taillines_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 limitBytes = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_limitbytes(&has_bits);
          _impl_.limitbytes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool insecureSkipTLSVerifyBackend = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_insecureskiptlsverifybackend(&has_bits);
          _impl_.insecureskiptlsverifybackend_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PodLogOptions::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.PodLogOptions)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes container = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_container(), target);
  }

  // optional bool follow = 2;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_follow(), target);
  }

  // optional bool previous = 3;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_previous(), target);
  }

  // optional int64 sinceSeconds = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_sinceseconds(), target);
  }

  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time sinceTime = 5;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::sincetime(this),
        _Internal::sincetime(this).GetCachedSize(), target, stream);
  }

  // optional bool timestamps = 6;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_timestamps(), target);
  }

  // optional int64 tailLines = 7;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(7, this->_internal_taillines(), target);
  }

  // optional int64 limitBytes = 8;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(8, this->_internal_limitbytes(), target);
  }

  // optional bool insecureSkipTLSVerifyBackend = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(9, this->_internal_insecureskiptlsverifybackend(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.PodLogOptions)
  return target;
}

size_t PodLogOptions::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.PodLogOptions)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bytes container = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_container());
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time sinceTime = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.sincetime_);
    }

    // optional int64 sinceSeconds = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_sinceseconds());
    }

    // optional int64 tailLines = 7;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_taillines());
    }

    // optional int64 limitBytes = 8;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_limitbytes());
    }

    // optional bool follow = 2;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

    // optional bool previous = 3;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional bool timestamps = 6;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  // optional bool insecureSkipTLSVerifyBackend = 9;
  if (cached_has_bits & 0x00000100u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PodLogOptions::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PodLogOptions::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PodLogOptions::GetClassData() const { return &_class_data_; }


void PodLogOptions::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PodLogOptions*>(&to_msg);
  auto& from = static_cast<const PodLogOptions&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.PodLogOptions)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_container(from._internal_container());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_sincetime()->::k8s::io::apimachinery::pkg::apis::meta::v1::Time::MergeFrom(
          from._internal_sincetime());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.sinceseconds_ = from._impl_.sinceseconds_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.taillines_ = from._impl_.taillines_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.limitbytes_ = from._impl_.limitbytes_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.follow_ = from._impl_.follow_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.previous_ = from._impl_.previous_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.timestamps_ = from._impl_.timestamps_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _this->_internal_set_insecureskiptlsverifybackend(from._internal_insecureskiptlsverifybackend());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PodLogOptions::CopyFrom(const PodLogOptions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.PodLogOptions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PodLogOptions::IsInitialized() const {
  return true;
}

void PodLogOptions::InternalSwap(PodLogOptions* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.container_, lhs_arena,
      &other->_impl_.container_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PodLogOptions, _impl_.insecureskiptlsverifybackend_)
      + sizeof(PodLogOptions::_impl_.insecureskiptlsverifybackend_)
      - PROTOBUF_FIELD_OFFSET(PodLogOptions, _impl_.sincetime_)>(
          reinterpret_cast<char*>(&_impl_.sincetime_),
          reinterpret_cast<char*>(&other->_impl_.sincetime_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PodLogOptions::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[155]);
}

// ===================================================================

class PodOS::_Internal {
 public:
  using HasBits = decltype(std::declval<PodOS>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

PodOS::PodOS(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.PodOS)
}
PodOS::PodOS(const PodOS& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PodOS* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.PodOS)
}

inline void PodOS::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PodOS::~PodOS() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.PodOS)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PodOS::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void PodOS::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PodOS::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.PodOS)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.name_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PodOS::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PodOS::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.PodOS)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.PodOS)
  return target;
}

size_t PodOS::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.PodOS)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes name = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PodOS::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PodOS::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PodOS::GetClassData() const { return &_class_data_; }


void PodOS::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PodOS*>(&to_msg);
  auto& from = static_cast<const PodOS&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.PodOS)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_name()) {
    _this->_internal_set_name(from._internal_name());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PodOS::CopyFrom(const PodOS& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.PodOS)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PodOS::IsInitialized() const {
  return true;
}

void PodOS::InternalSwap(PodOS* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata PodOS::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[156]);
}

// ===================================================================

class PodPortForwardOptions::_Internal {
 public:
};

PodPortForwardOptions::PodPortForwardOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.PodPortForwardOptions)
}
PodPortForwardOptions::PodPortForwardOptions(const PodPortForwardOptions& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PodPortForwardOptions* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.ports_){from._impl_.ports_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.PodPortForwardOptions)
}

inline void PodPortForwardOptions::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.ports_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

PodPortForwardOptions::~PodPortForwardOptions() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.PodPortForwardOptions)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PodPortForwardOptions::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.ports_.~RepeatedField();
}

void PodPortForwardOptions::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PodPortForwardOptions::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.PodPortForwardOptions)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.ports_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PodPortForwardOptions::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int32 ports = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_ports(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<8>(ptr));
        } else if (static_cast<uint8_t>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_ports(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PodPortForwardOptions::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.PodPortForwardOptions)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int32 ports = 1;
  for (int i = 0, n = this->_internal_ports_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_ports(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.PodPortForwardOptions)
  return target;
}

size_t PodPortForwardOptions::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.PodPortForwardOptions)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 ports = 1;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.ports_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_ports_size());
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PodPortForwardOptions::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PodPortForwardOptions::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PodPortForwardOptions::GetClassData() const { return &_class_data_; }


void PodPortForwardOptions::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PodPortForwardOptions*>(&to_msg);
  auto& from = static_cast<const PodPortForwardOptions&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.PodPortForwardOptions)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.ports_.MergeFrom(from._impl_.ports_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PodPortForwardOptions::CopyFrom(const PodPortForwardOptions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.PodPortForwardOptions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PodPortForwardOptions::IsInitialized() const {
  return true;
}

void PodPortForwardOptions::InternalSwap(PodPortForwardOptions* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.ports_.InternalSwap(&other->_impl_.ports_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PodPortForwardOptions::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[157]);
}

// ===================================================================

class PodProxyOptions::_Internal {
 public:
  using HasBits = decltype(std::declval<PodProxyOptions>()._impl_._has_bits_);
  static void set_has_path(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

PodProxyOptions::PodProxyOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.PodProxyOptions)
}
PodProxyOptions::PodProxyOptions(const PodProxyOptions& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PodProxyOptions* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.path_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_path()) {
    _this->_impl_.path_.Set(from._internal_path(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.PodProxyOptions)
}

inline void PodProxyOptions::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.path_){}
  };
  _impl_.path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PodProxyOptions::~PodProxyOptions() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.PodProxyOptions)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PodProxyOptions::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.path_.Destroy();
}

void PodProxyOptions::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PodProxyOptions::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.PodProxyOptions)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.path_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PodProxyOptions::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes path = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_path();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PodProxyOptions::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.PodProxyOptions)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes path = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_path(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.PodProxyOptions)
  return target;
}

size_t PodProxyOptions::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.PodProxyOptions)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes path = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_path());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PodProxyOptions::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PodProxyOptions::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PodProxyOptions::GetClassData() const { return &_class_data_; }


void PodProxyOptions::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PodProxyOptions*>(&to_msg);
  auto& from = static_cast<const PodProxyOptions&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.PodProxyOptions)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_path()) {
    _this->_internal_set_path(from._internal_path());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PodProxyOptions::CopyFrom(const PodProxyOptions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.PodProxyOptions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PodProxyOptions::IsInitialized() const {
  return true;
}

void PodProxyOptions::InternalSwap(PodProxyOptions* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.path_, lhs_arena,
      &other->_impl_.path_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata PodProxyOptions::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[158]);
}

// ===================================================================

class PodReadinessGate::_Internal {
 public:
  using HasBits = decltype(std::declval<PodReadinessGate>()._impl_._has_bits_);
  static void set_has_conditiontype(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

PodReadinessGate::PodReadinessGate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.PodReadinessGate)
}
PodReadinessGate::PodReadinessGate(const PodReadinessGate& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PodReadinessGate* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.conditiontype_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.conditiontype_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.conditiontype_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_conditiontype()) {
    _this->_impl_.conditiontype_.Set(from._internal_conditiontype(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.PodReadinessGate)
}

inline void PodReadinessGate::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.conditiontype_){}
  };
  _impl_.conditiontype_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.conditiontype_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PodReadinessGate::~PodReadinessGate() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.PodReadinessGate)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PodReadinessGate::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.conditiontype_.Destroy();
}

void PodReadinessGate::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PodReadinessGate::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.PodReadinessGate)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.conditiontype_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PodReadinessGate::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes conditionType = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_conditiontype();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PodReadinessGate::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.PodReadinessGate)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes conditionType = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_conditiontype(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.PodReadinessGate)
  return target;
}

size_t PodReadinessGate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.PodReadinessGate)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes conditionType = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_conditiontype());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PodReadinessGate::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PodReadinessGate::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PodReadinessGate::GetClassData() const { return &_class_data_; }


void PodReadinessGate::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PodReadinessGate*>(&to_msg);
  auto& from = static_cast<const PodReadinessGate&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.PodReadinessGate)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_conditiontype()) {
    _this->_internal_set_conditiontype(from._internal_conditiontype());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PodReadinessGate::CopyFrom(const PodReadinessGate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.PodReadinessGate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PodReadinessGate::IsInitialized() const {
  return true;
}

void PodReadinessGate::InternalSwap(PodReadinessGate* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.conditiontype_, lhs_arena,
      &other->_impl_.conditiontype_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata PodReadinessGate::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[159]);
}

// ===================================================================

class PodResourceClaim::_Internal {
 public:
  using HasBits = decltype(std::declval<PodResourceClaim>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::k8s::io::api::core::v1::ClaimSource& source(const PodResourceClaim* msg);
  static void set_has_source(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::k8s::io::api::core::v1::ClaimSource&
PodResourceClaim::_Internal::source(const PodResourceClaim* msg) {
  return *msg->_impl_.source_;
}
PodResourceClaim::PodResourceClaim(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.PodResourceClaim)
}
PodResourceClaim::PodResourceClaim(const PodResourceClaim& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PodResourceClaim* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.source_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_source()) {
    _this->_impl_.source_ = new ::k8s::io::api::core::v1::ClaimSource(*from._impl_.source_);
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.PodResourceClaim)
}

inline void PodResourceClaim::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.source_){nullptr}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PodResourceClaim::~PodResourceClaim() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.PodResourceClaim)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PodResourceClaim::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.source_;
}

void PodResourceClaim::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PodResourceClaim::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.PodResourceClaim)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.source_ != nullptr);
      _impl_.source_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PodResourceClaim::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.ClaimSource source = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_source(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PodResourceClaim::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.PodResourceClaim)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional .k8s.io.api.core.v1.ClaimSource source = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::source(this),
        _Internal::source(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.PodResourceClaim)
  return target;
}

size_t PodResourceClaim::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.PodResourceClaim)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_name());
    }

    // optional .k8s.io.api.core.v1.ClaimSource source = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.source_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PodResourceClaim::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PodResourceClaim::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PodResourceClaim::GetClassData() const { return &_class_data_; }


void PodResourceClaim::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PodResourceClaim*>(&to_msg);
  auto& from = static_cast<const PodResourceClaim&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.PodResourceClaim)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_source()->::k8s::io::api::core::v1::ClaimSource::MergeFrom(
          from._internal_source());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PodResourceClaim::CopyFrom(const PodResourceClaim& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.PodResourceClaim)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PodResourceClaim::IsInitialized() const {
  return true;
}

void PodResourceClaim::InternalSwap(PodResourceClaim* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  swap(_impl_.source_, other->_impl_.source_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PodResourceClaim::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[160]);
}

// ===================================================================

class PodResourceClaimStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<PodResourceClaimStatus>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_resourceclaimname(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

PodResourceClaimStatus::PodResourceClaimStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.PodResourceClaimStatus)
}
PodResourceClaimStatus::PodResourceClaimStatus(const PodResourceClaimStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PodResourceClaimStatus* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.resourceclaimname_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.resourceclaimname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.resourceclaimname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_resourceclaimname()) {
    _this->_impl_.resourceclaimname_.Set(from._internal_resourceclaimname(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.PodResourceClaimStatus)
}

inline void PodResourceClaimStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.resourceclaimname_){}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.resourceclaimname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.resourceclaimname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PodResourceClaimStatus::~PodResourceClaimStatus() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.PodResourceClaimStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PodResourceClaimStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.resourceclaimname_.Destroy();
}

void PodResourceClaimStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PodResourceClaimStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.PodResourceClaimStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.resourceclaimname_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PodResourceClaimStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes resourceClaimName = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_resourceclaimname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PodResourceClaimStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.PodResourceClaimStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional bytes resourceClaimName = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_resourceclaimname(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.PodResourceClaimStatus)
  return target;
}

size_t PodResourceClaimStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.PodResourceClaimStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_name());
    }

    // optional bytes resourceClaimName = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_resourceclaimname());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PodResourceClaimStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PodResourceClaimStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PodResourceClaimStatus::GetClassData() const { return &_class_data_; }


void PodResourceClaimStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PodResourceClaimStatus*>(&to_msg);
  auto& from = static_cast<const PodResourceClaimStatus&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.PodResourceClaimStatus)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_resourceclaimname(from._internal_resourceclaimname());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PodResourceClaimStatus::CopyFrom(const PodResourceClaimStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.PodResourceClaimStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PodResourceClaimStatus::IsInitialized() const {
  return true;
}

void PodResourceClaimStatus::InternalSwap(PodResourceClaimStatus* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.resourceclaimname_, lhs_arena,
      &other->_impl_.resourceclaimname_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata PodResourceClaimStatus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[161]);
}

// ===================================================================

class PodSchedulingGate::_Internal {
 public:
  using HasBits = decltype(std::declval<PodSchedulingGate>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

PodSchedulingGate::PodSchedulingGate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.PodSchedulingGate)
}
PodSchedulingGate::PodSchedulingGate(const PodSchedulingGate& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PodSchedulingGate* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.PodSchedulingGate)
}

inline void PodSchedulingGate::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PodSchedulingGate::~PodSchedulingGate() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.PodSchedulingGate)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PodSchedulingGate::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void PodSchedulingGate::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PodSchedulingGate::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.PodSchedulingGate)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.name_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PodSchedulingGate::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PodSchedulingGate::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.PodSchedulingGate)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.PodSchedulingGate)
  return target;
}

size_t PodSchedulingGate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.PodSchedulingGate)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes name = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PodSchedulingGate::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PodSchedulingGate::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PodSchedulingGate::GetClassData() const { return &_class_data_; }


void PodSchedulingGate::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PodSchedulingGate*>(&to_msg);
  auto& from = static_cast<const PodSchedulingGate&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.PodSchedulingGate)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_name()) {
    _this->_internal_set_name(from._internal_name());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PodSchedulingGate::CopyFrom(const PodSchedulingGate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.PodSchedulingGate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PodSchedulingGate::IsInitialized() const {
  return true;
}

void PodSchedulingGate::InternalSwap(PodSchedulingGate* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata PodSchedulingGate::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[162]);
}

// ===================================================================

class PodSecurityContext::_Internal {
 public:
  using HasBits = decltype(std::declval<PodSecurityContext>()._impl_._has_bits_);
  static const ::k8s::io::api::core::v1::SELinuxOptions& selinuxoptions(const PodSecurityContext* msg);
  static void set_has_selinuxoptions(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::k8s::io::api::core::v1::WindowsSecurityContextOptions& windowsoptions(const PodSecurityContext* msg);
  static void set_has_windowsoptions(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_runasuser(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_runasgroup(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_runasnonroot(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_fsgroup(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_fsgroupchangepolicy(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::k8s::io::api::core::v1::SeccompProfile& seccompprofile(const PodSecurityContext* msg);
  static void set_has_seccompprofile(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::k8s::io::api::core::v1::SELinuxOptions&
PodSecurityContext::_Internal::selinuxoptions(const PodSecurityContext* msg) {
  return *msg->_impl_.selinuxoptions_;
}
const ::k8s::io::api::core::v1::WindowsSecurityContextOptions&
PodSecurityContext::_Internal::windowsoptions(const PodSecurityContext* msg) {
  return *msg->_impl_.windowsoptions_;
}
const ::k8s::io::api::core::v1::SeccompProfile&
PodSecurityContext::_Internal::seccompprofile(const PodSecurityContext* msg) {
  return *msg->_impl_.seccompprofile_;
}
PodSecurityContext::PodSecurityContext(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.PodSecurityContext)
}
PodSecurityContext::PodSecurityContext(const PodSecurityContext& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PodSecurityContext* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.supplementalgroups_){from._impl_.supplementalgroups_}
    , decltype(_impl_.sysctls_){from._impl_.sysctls_}
    , decltype(_impl_.fsgroupchangepolicy_){}
    , decltype(_impl_.selinuxoptions_){nullptr}
    , decltype(_impl_.windowsoptions_){nullptr}
    , decltype(_impl_.seccompprofile_){nullptr}
    , decltype(_impl_.runasuser_){}
    , decltype(_impl_.fsgroup_){}
    , decltype(_impl_.runasgroup_){}
    , decltype(_impl_.runasnonroot_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.fsgroupchangepolicy_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fsgroupchangepolicy_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_fsgroupchangepolicy()) {
    _this->_impl_.fsgroupchangepolicy_.Set(from._internal_fsgroupchangepolicy(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_selinuxoptions()) {
    _this->_impl_.selinuxoptions_ = new ::k8s::io::api::core::v1::SELinuxOptions(*from._impl_.selinuxoptions_);
  }
  if (from._internal_has_windowsoptions()) {
    _this->_impl_.windowsoptions_ = new ::k8s::io::api::core::v1::WindowsSecurityContextOptions(*from._impl_.windowsoptions_);
  }
  if (from._internal_has_seccompprofile()) {
    _this->_impl_.seccompprofile_ = new ::k8s::io::api::core::v1::SeccompProfile(*from._impl_.seccompprofile_);
  }
  ::memcpy(&_impl_.runasuser_, &from._impl_.runasuser_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.runasnonroot_) -
    reinterpret_cast<char*>(&_impl_.runasuser_)) + sizeof(_impl_.runasnonroot_));
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.PodSecurityContext)
}

inline void PodSecurityContext::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.supplementalgroups_){arena}
    , decltype(_impl_.sysctls_){arena}
    , decltype(_impl_.fsgroupchangepolicy_){}
    , decltype(_impl_.selinuxoptions_){nullptr}
    , decltype(_impl_.windowsoptions_){nullptr}
    , decltype(_impl_.seccompprofile_){nullptr}
    , decltype(_impl_.runasuser_){int64_t{0}}
    , decltype(_impl_.fsgroup_){int64_t{0}}
    , decltype(_impl_.runasgroup_){int64_t{0}}
    , decltype(_impl_.runasnonroot_){false}
  };
  _impl_.fsgroupchangepolicy_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fsgroupchangepolicy_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PodSecurityContext::~PodSecurityContext() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.PodSecurityContext)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PodSecurityContext::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.supplementalgroups_.~RepeatedField();
  _impl_.sysctls_.~RepeatedPtrField();
  _impl_.fsgroupchangepolicy_.Destroy();
  if (this != internal_default_instance()) delete _impl_.selinuxoptions_;
  if (this != internal_default_instance()) delete _impl_.windowsoptions_;
  if (this != internal_default_instance()) delete _impl_.seccompprofile_;
}

void PodSecurityContext::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PodSecurityContext::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.PodSecurityContext)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.supplementalgroups_.Clear();
  _impl_.sysctls_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.fsgroupchangepolicy_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.selinuxoptions_ != nullptr);
      _impl_.selinuxoptions_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.windowsoptions_ != nullptr);
      _impl_.windowsoptions_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.seccompprofile_ != nullptr);
      _impl_.seccompprofile_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&_impl_.runasuser_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.runasnonroot_) -
        reinterpret_cast<char*>(&_impl_.runasuser_)) + sizeof(_impl_.runasnonroot_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PodSecurityContext::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .k8s.io.api.core.v1.SELinuxOptions seLinuxOptions = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_selinuxoptions(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 runAsUser = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_runasuser(&has_bits);
          _impl_.runasuser_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool runAsNonRoot = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_runasnonroot(&has_bits);
          _impl_.runasnonroot_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int64 supplementalGroups = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_supplementalgroups(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<32>(ptr));
        } else if (static_cast<uint8_t>(tag) == 34) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_supplementalgroups(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 fsGroup = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_fsgroup(&has_bits);
          _impl_.fsgroup_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 runAsGroup = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_runasgroup(&has_bits);
          _impl_.runasgroup_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .k8s.io.api.core.v1.Sysctl sysctls = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_sysctls(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.WindowsSecurityContextOptions windowsOptions = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_windowsoptions(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes fsGroupChangePolicy = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_fsgroupchangepolicy();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.SeccompProfile seccompProfile = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_seccompprofile(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PodSecurityContext::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.PodSecurityContext)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .k8s.io.api.core.v1.SELinuxOptions seLinuxOptions = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::selinuxoptions(this),
        _Internal::selinuxoptions(this).GetCachedSize(), target, stream);
  }

  // optional int64 runAsUser = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_runasuser(), target);
  }

  // optional bool runAsNonRoot = 3;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_runasnonroot(), target);
  }

  // repeated int64 supplementalGroups = 4;
  for (int i = 0, n = this->_internal_supplementalgroups_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_supplementalgroups(i), target);
  }

  // optional int64 fsGroup = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(5, this->_internal_fsgroup(), target);
  }

  // optional int64 runAsGroup = 6;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(6, this->_internal_runasgroup(), target);
  }

  // repeated .k8s.io.api.core.v1.Sysctl sysctls = 7;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_sysctls_size()); i < n; i++) {
    const auto& repfield = this->_internal_sysctls(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.WindowsSecurityContextOptions windowsOptions = 8;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::windowsoptions(this),
        _Internal::windowsoptions(this).GetCachedSize(), target, stream);
  }

  // optional bytes fsGroupChangePolicy = 9;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        9, this->_internal_fsgroupchangepolicy(), target);
  }

  // optional .k8s.io.api.core.v1.SeccompProfile seccompProfile = 10;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::seccompprofile(this),
        _Internal::seccompprofile(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.PodSecurityContext)
  return target;
}

size_t PodSecurityContext::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.PodSecurityContext)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int64 supplementalGroups = 4;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int64Size(this->_impl_.supplementalgroups_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_supplementalgroups_size());
    total_size += data_size;
  }

  // repeated .k8s.io.api.core.v1.Sysctl sysctls = 7;
  total_size += 1UL * this->_internal_sysctls_size();
  for (const auto& msg : this->_impl_.sysctls_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bytes fsGroupChangePolicy = 9;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_fsgroupchangepolicy());
    }

    // optional .k8s.io.api.core.v1.SELinuxOptions seLinuxOptions = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.selinuxoptions_);
    }

    // optional .k8s.io.api.core.v1.WindowsSecurityContextOptions windowsOptions = 8;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.windowsoptions_);
    }

    // optional .k8s.io.api.core.v1.SeccompProfile seccompProfile = 10;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.seccompprofile_);
    }

    // optional int64 runAsUser = 2;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_runasuser());
    }

    // optional int64 fsGroup = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_fsgroup());
    }

    // optional int64 runAsGroup = 6;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_runasgroup());
    }

    // optional bool runAsNonRoot = 3;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PodSecurityContext::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PodSecurityContext::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PodSecurityContext::GetClassData() const { return &_class_data_; }


void PodSecurityContext::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PodSecurityContext*>(&to_msg);
  auto& from = static_cast<const PodSecurityContext&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.PodSecurityContext)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.supplementalgroups_.MergeFrom(from._impl_.supplementalgroups_);
  _this->_impl_.sysctls_.MergeFrom(from._impl_.sysctls_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_fsgroupchangepolicy(from._internal_fsgroupchangepolicy());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_selinuxoptions()->::k8s::io::api::core::v1::SELinuxOptions::MergeFrom(
          from._internal_selinuxoptions());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_windowsoptions()->::k8s::io::api::core::v1::WindowsSecurityContextOptions::MergeFrom(
          from._internal_windowsoptions());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_seccompprofile()->::k8s::io::api::core::v1::SeccompProfile::MergeFrom(
          from._internal_seccompprofile());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.runasuser_ = from._impl_.runasuser_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.fsgroup_ = from._impl_.fsgroup_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.runasgroup_ = from._impl_.runasgroup_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.runasnonroot_ = from._impl_.runasnonroot_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PodSecurityContext::CopyFrom(const PodSecurityContext& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.PodSecurityContext)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PodSecurityContext::IsInitialized() const {
  return true;
}

void PodSecurityContext::InternalSwap(PodSecurityContext* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.supplementalgroups_.InternalSwap(&other->_impl_.supplementalgroups_);
  _impl_.sysctls_.InternalSwap(&other->_impl_.sysctls_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.fsgroupchangepolicy_, lhs_arena,
      &other->_impl_.fsgroupchangepolicy_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PodSecurityContext, _impl_.runasnonroot_)
      + sizeof(PodSecurityContext::_impl_.runasnonroot_)
      - PROTOBUF_FIELD_OFFSET(PodSecurityContext, _impl_.selinuxoptions_)>(
          reinterpret_cast<char*>(&_impl_.selinuxoptions_),
          reinterpret_cast<char*>(&other->_impl_.selinuxoptions_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PodSecurityContext::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[163]);
}

// ===================================================================

class PodSignature::_Internal {
 public:
  using HasBits = decltype(std::declval<PodSignature>()._impl_._has_bits_);
  static const ::k8s::io::apimachinery::pkg::apis::meta::v1::OwnerReference& podcontroller(const PodSignature* msg);
  static void set_has_podcontroller(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::k8s::io::apimachinery::pkg::apis::meta::v1::OwnerReference&
PodSignature::_Internal::podcontroller(const PodSignature* msg) {
  return *msg->_impl_.podcontroller_;
}
void PodSignature::clear_podcontroller() {
  if (_impl_.podcontroller_ != nullptr) _impl_.podcontroller_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
PodSignature::PodSignature(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.PodSignature)
}
PodSignature::PodSignature(const PodSignature& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PodSignature* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.podcontroller_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_podcontroller()) {
    _this->_impl_.podcontroller_ = new ::k8s::io::apimachinery::pkg::apis::meta::v1::OwnerReference(*from._impl_.podcontroller_);
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.PodSignature)
}

inline void PodSignature::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.podcontroller_){nullptr}
  };
}

PodSignature::~PodSignature() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.PodSignature)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PodSignature::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.podcontroller_;
}

void PodSignature::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PodSignature::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.PodSignature)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.podcontroller_ != nullptr);
    _impl_.podcontroller_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PodSignature::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .k8s.io.apimachinery.pkg.apis.meta.v1.OwnerReference podController = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_podcontroller(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PodSignature::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.PodSignature)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.OwnerReference podController = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::podcontroller(this),
        _Internal::podcontroller(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.PodSignature)
  return target;
}

size_t PodSignature::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.PodSignature)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.OwnerReference podController = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.podcontroller_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PodSignature::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PodSignature::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PodSignature::GetClassData() const { return &_class_data_; }


void PodSignature::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PodSignature*>(&to_msg);
  auto& from = static_cast<const PodSignature&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.PodSignature)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_podcontroller()) {
    _this->_internal_mutable_podcontroller()->::k8s::io::apimachinery::pkg::apis::meta::v1::OwnerReference::MergeFrom(
        from._internal_podcontroller());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PodSignature::CopyFrom(const PodSignature& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.PodSignature)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PodSignature::IsInitialized() const {
  return true;
}

void PodSignature::InternalSwap(PodSignature* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.podcontroller_, other->_impl_.podcontroller_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PodSignature::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[164]);
}

// ===================================================================

PodSpec_NodeSelectorEntry_DoNotUse::PodSpec_NodeSelectorEntry_DoNotUse() {}
PodSpec_NodeSelectorEntry_DoNotUse::PodSpec_NodeSelectorEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void PodSpec_NodeSelectorEntry_DoNotUse::MergeFrom(const PodSpec_NodeSelectorEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata PodSpec_NodeSelectorEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[165]);
}

// ===================================================================

PodSpec_OverheadEntry_DoNotUse::PodSpec_OverheadEntry_DoNotUse() {}
PodSpec_OverheadEntry_DoNotUse::PodSpec_OverheadEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void PodSpec_OverheadEntry_DoNotUse::MergeFrom(const PodSpec_OverheadEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata PodSpec_OverheadEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[166]);
}

// ===================================================================

class PodSpec::_Internal {
 public:
  using HasBits = decltype(std::declval<PodSpec>()._impl_._has_bits_);
  static void set_has_restartpolicy(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_terminationgraceperiodseconds(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_activedeadlineseconds(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_dnspolicy(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_serviceaccountname(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_serviceaccount(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_automountserviceaccounttoken(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_nodename(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_hostnetwork(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_hostpid(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static void set_has_hostipc(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static void set_has_shareprocessnamespace(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static const ::k8s::io::api::core::v1::PodSecurityContext& securitycontext(const PodSpec* msg);
  static void set_has_securitycontext(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_hostname(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_subdomain(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::k8s::io::api::core::v1::Affinity& affinity(const PodSpec* msg);
  static void set_has_affinity(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_schedulername(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_priorityclassname(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_priority(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static const ::k8s::io::api::core::v1::PodDNSConfig& dnsconfig(const PodSpec* msg);
  static void set_has_dnsconfig(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_runtimeclassname(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_enableservicelinks(HasBits* has_bits) {
    (*has_bits)[0] |= 8388608u;
  }
  static void set_has_preemptionpolicy(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_sethostnameasfqdn(HasBits* has_bits) {
    (*has_bits)[0] |= 16777216u;
  }
  static const ::k8s::io::api::core::v1::PodOS& os(const PodSpec* msg);
  static void set_has_os(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_hostusers(HasBits* has_bits) {
    (*has_bits)[0] |= 33554432u;
  }
};

const ::k8s::io::api::core::v1::PodSecurityContext&
PodSpec::_Internal::securitycontext(const PodSpec* msg) {
  return *msg->_impl_.securitycontext_;
}
const ::k8s::io::api::core::v1::Affinity&
PodSpec::_Internal::affinity(const PodSpec* msg) {
  return *msg->_impl_.affinity_;
}
const ::k8s::io::api::core::v1::PodDNSConfig&
PodSpec::_Internal::dnsconfig(const PodSpec* msg) {
  return *msg->_impl_.dnsconfig_;
}
const ::k8s::io::api::core::v1::PodOS&
PodSpec::_Internal::os(const PodSpec* msg) {
  return *msg->_impl_.os_;
}
void PodSpec::clear_overhead() {
  _impl_.overhead_.Clear();
}
PodSpec::PodSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &PodSpec::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.PodSpec)
}
PodSpec::PodSpec(const PodSpec& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PodSpec* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.volumes_){from._impl_.volumes_}
    , decltype(_impl_.containers_){from._impl_.containers_}
    , /*decltype(_impl_.nodeselector_)*/{}
    , decltype(_impl_.imagepullsecrets_){from._impl_.imagepullsecrets_}
    , decltype(_impl_.initcontainers_){from._impl_.initcontainers_}
    , decltype(_impl_.tolerations_){from._impl_.tolerations_}
    , decltype(_impl_.hostaliases_){from._impl_.hostaliases_}
    , decltype(_impl_.readinessgates_){from._impl_.readinessgates_}
    , /*decltype(_impl_.overhead_)*/{}
    , decltype(_impl_.topologyspreadconstraints_){from._impl_.topologyspreadconstraints_}
    , decltype(_impl_.ephemeralcontainers_){from._impl_.ephemeralcontainers_}
    , decltype(_impl_.schedulinggates_){from._impl_.schedulinggates_}
    , decltype(_impl_.resourceclaims_){from._impl_.resourceclaims_}
    , decltype(_impl_.restartpolicy_){}
    , decltype(_impl_.dnspolicy_){}
    , decltype(_impl_.serviceaccountname_){}
    , decltype(_impl_.serviceaccount_){}
    , decltype(_impl_.nodename_){}
    , decltype(_impl_.hostname_){}
    , decltype(_impl_.subdomain_){}
    , decltype(_impl_.schedulername_){}
    , decltype(_impl_.priorityclassname_){}
    , decltype(_impl_.runtimeclassname_){}
    , decltype(_impl_.preemptionpolicy_){}
    , decltype(_impl_.securitycontext_){nullptr}
    , decltype(_impl_.affinity_){nullptr}
    , decltype(_impl_.dnsconfig_){nullptr}
    , decltype(_impl_.os_){nullptr}
    , decltype(_impl_.terminationgraceperiodseconds_){}
    , decltype(_impl_.activedeadlineseconds_){}
    , decltype(_impl_.automountserviceaccounttoken_){}
    , decltype(_impl_.hostnetwork_){}
    , decltype(_impl_.hostpid_){}
    , decltype(_impl_.hostipc_){}
    , decltype(_impl_.priority_){}
    , decltype(_impl_.shareprocessnamespace_){}
    , decltype(_impl_.enableservicelinks_){}
    , decltype(_impl_.sethostnameasfqdn_){}
    , decltype(_impl_.hostusers_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.nodeselector_.MergeFrom(from._impl_.nodeselector_);
  _this->_impl_.overhead_.MergeFrom(from._impl_.overhead_);
  _impl_.restartpolicy_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.restartpolicy_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_restartpolicy()) {
    _this->_impl_.restartpolicy_.Set(from._internal_restartpolicy(), 
      _this->GetArenaForAllocation());
  }
  _impl_.dnspolicy_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.dnspolicy_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_dnspolicy()) {
    _this->_impl_.dnspolicy_.Set(from._internal_dnspolicy(), 
      _this->GetArenaForAllocation());
  }
  _impl_.serviceaccountname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.serviceaccountname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_serviceaccountname()) {
    _this->_impl_.serviceaccountname_.Set(from._internal_serviceaccountname(), 
      _this->GetArenaForAllocation());
  }
  _impl_.serviceaccount_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.serviceaccount_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_serviceaccount()) {
    _this->_impl_.serviceaccount_.Set(from._internal_serviceaccount(), 
      _this->GetArenaForAllocation());
  }
  _impl_.nodename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nodename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_nodename()) {
    _this->_impl_.nodename_.Set(from._internal_nodename(), 
      _this->GetArenaForAllocation());
  }
  _impl_.hostname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hostname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_hostname()) {
    _this->_impl_.hostname_.Set(from._internal_hostname(), 
      _this->GetArenaForAllocation());
  }
  _impl_.subdomain_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.subdomain_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_subdomain()) {
    _this->_impl_.subdomain_.Set(from._internal_subdomain(), 
      _this->GetArenaForAllocation());
  }
  _impl_.schedulername_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.schedulername_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_schedulername()) {
    _this->_impl_.schedulername_.Set(from._internal_schedulername(), 
      _this->GetArenaForAllocation());
  }
  _impl_.priorityclassname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.priorityclassname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_priorityclassname()) {
    _this->_impl_.priorityclassname_.Set(from._internal_priorityclassname(), 
      _this->GetArenaForAllocation());
  }
  _impl_.runtimeclassname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.runtimeclassname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_runtimeclassname()) {
    _this->_impl_.runtimeclassname_.Set(from._internal_runtimeclassname(), 
      _this->GetArenaForAllocation());
  }
  _impl_.preemptionpolicy_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.preemptionpolicy_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_preemptionpolicy()) {
    _this->_impl_.preemptionpolicy_.Set(from._internal_preemptionpolicy(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_securitycontext()) {
    _this->_impl_.securitycontext_ = new ::k8s::io::api::core::v1::PodSecurityContext(*from._impl_.securitycontext_);
  }
  if (from._internal_has_affinity()) {
    _this->_impl_.affinity_ = new ::k8s::io::api::core::v1::Affinity(*from._impl_.affinity_);
  }
  if (from._internal_has_dnsconfig()) {
    _this->_impl_.dnsconfig_ = new ::k8s::io::api::core::v1::PodDNSConfig(*from._impl_.dnsconfig_);
  }
  if (from._internal_has_os()) {
    _this->_impl_.os_ = new ::k8s::io::api::core::v1::PodOS(*from._impl_.os_);
  }
  ::memcpy(&_impl_.terminationgraceperiodseconds_, &from._impl_.terminationgraceperiodseconds_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.hostusers_) -
    reinterpret_cast<char*>(&_impl_.terminationgraceperiodseconds_)) + sizeof(_impl_.hostusers_));
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.PodSpec)
}

inline void PodSpec::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.volumes_){arena}
    , decltype(_impl_.containers_){arena}
    , /*decltype(_impl_.nodeselector_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.imagepullsecrets_){arena}
    , decltype(_impl_.initcontainers_){arena}
    , decltype(_impl_.tolerations_){arena}
    , decltype(_impl_.hostaliases_){arena}
    , decltype(_impl_.readinessgates_){arena}
    , /*decltype(_impl_.overhead_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.topologyspreadconstraints_){arena}
    , decltype(_impl_.ephemeralcontainers_){arena}
    , decltype(_impl_.schedulinggates_){arena}
    , decltype(_impl_.resourceclaims_){arena}
    , decltype(_impl_.restartpolicy_){}
    , decltype(_impl_.dnspolicy_){}
    , decltype(_impl_.serviceaccountname_){}
    , decltype(_impl_.serviceaccount_){}
    , decltype(_impl_.nodename_){}
    , decltype(_impl_.hostname_){}
    , decltype(_impl_.subdomain_){}
    , decltype(_impl_.schedulername_){}
    , decltype(_impl_.priorityclassname_){}
    , decltype(_impl_.runtimeclassname_){}
    , decltype(_impl_.preemptionpolicy_){}
    , decltype(_impl_.securitycontext_){nullptr}
    , decltype(_impl_.affinity_){nullptr}
    , decltype(_impl_.dnsconfig_){nullptr}
    , decltype(_impl_.os_){nullptr}
    , decltype(_impl_.terminationgraceperiodseconds_){int64_t{0}}
    , decltype(_impl_.activedeadlineseconds_){int64_t{0}}
    , decltype(_impl_.automountserviceaccounttoken_){false}
    , decltype(_impl_.hostnetwork_){false}
    , decltype(_impl_.hostpid_){false}
    , decltype(_impl_.hostipc_){false}
    , decltype(_impl_.priority_){0}
    , decltype(_impl_.shareprocessnamespace_){false}
    , decltype(_impl_.enableservicelinks_){false}
    , decltype(_impl_.sethostnameasfqdn_){false}
    , decltype(_impl_.hostusers_){false}
  };
  _impl_.restartpolicy_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.restartpolicy_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.dnspolicy_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.dnspolicy_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.serviceaccountname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.serviceaccountname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.serviceaccount_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.serviceaccount_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.nodename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nodename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.hostname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hostname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.subdomain_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.subdomain_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.schedulername_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.schedulername_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.priorityclassname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.priorityclassname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.runtimeclassname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.runtimeclassname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.preemptionpolicy_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.preemptionpolicy_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PodSpec::~PodSpec() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.PodSpec)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void PodSpec::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.volumes_.~RepeatedPtrField();
  _impl_.containers_.~RepeatedPtrField();
  _impl_.nodeselector_.Destruct();
  _impl_.nodeselector_.~MapField();
  _impl_.imagepullsecrets_.~RepeatedPtrField();
  _impl_.initcontainers_.~RepeatedPtrField();
  _impl_.tolerations_.~RepeatedPtrField();
  _impl_.hostaliases_.~RepeatedPtrField();
  _impl_.readinessgates_.~RepeatedPtrField();
  _impl_.overhead_.Destruct();
  _impl_.overhead_.~MapField();
  _impl_.topologyspreadconstraints_.~RepeatedPtrField();
  _impl_.ephemeralcontainers_.~RepeatedPtrField();
  _impl_.schedulinggates_.~RepeatedPtrField();
  _impl_.resourceclaims_.~RepeatedPtrField();
  _impl_.restartpolicy_.Destroy();
  _impl_.dnspolicy_.Destroy();
  _impl_.serviceaccountname_.Destroy();
  _impl_.serviceaccount_.Destroy();
  _impl_.nodename_.Destroy();
  _impl_.hostname_.Destroy();
  _impl_.subdomain_.Destroy();
  _impl_.schedulername_.Destroy();
  _impl_.priorityclassname_.Destroy();
  _impl_.runtimeclassname_.Destroy();
  _impl_.preemptionpolicy_.Destroy();
  if (this != internal_default_instance()) delete _impl_.securitycontext_;
  if (this != internal_default_instance()) delete _impl_.affinity_;
  if (this != internal_default_instance()) delete _impl_.dnsconfig_;
  if (this != internal_default_instance()) delete _impl_.os_;
}

void PodSpec::ArenaDtor(void* object) {
  PodSpec* _this = reinterpret_cast< PodSpec* >(object);
  _this->_impl_.nodeselector_.Destruct();
  _this->_impl_.overhead_.Destruct();
}
void PodSpec::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PodSpec::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.PodSpec)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.volumes_.Clear();
  _impl_.containers_.Clear();
  _impl_.nodeselector_.Clear();
  _impl_.imagepullsecrets_.Clear();
  _impl_.initcontainers_.Clear();
  _impl_.tolerations_.Clear();
  _impl_.hostaliases_.Clear();
  _impl_.readinessgates_.Clear();
  _impl_.overhead_.Clear();
  _impl_.topologyspreadconstraints_.Clear();
  _impl_.ephemeralcontainers_.Clear();
  _impl_.schedulinggates_.Clear();
  _impl_.resourceclaims_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.restartpolicy_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.dnspolicy_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.serviceaccountname_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.serviceaccount_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.nodename_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      _impl_.hostname_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000040u) {
      _impl_.subdomain_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000080u) {
      _impl_.schedulername_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00007f00u) {
    if (cached_has_bits & 0x00000100u) {
      _impl_.priorityclassname_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000200u) {
      _impl_.runtimeclassname_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000400u) {
      _impl_.preemptionpolicy_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000800u) {
      GOOGLE_DCHECK(_impl_.securitycontext_ != nullptr);
      _impl_.securitycontext_->Clear();
    }
    if (cached_has_bits & 0x00001000u) {
      GOOGLE_DCHECK(_impl_.affinity_ != nullptr);
      _impl_.affinity_->Clear();
    }
    if (cached_has_bits & 0x00002000u) {
      GOOGLE_DCHECK(_impl_.dnsconfig_ != nullptr);
      _impl_.dnsconfig_->Clear();
    }
    if (cached_has_bits & 0x00004000u) {
      GOOGLE_DCHECK(_impl_.os_ != nullptr);
      _impl_.os_->Clear();
    }
  }
  _impl_.terminationgraceperiodseconds_ = int64_t{0};
  if (cached_has_bits & 0x00ff0000u) {
    ::memset(&_impl_.activedeadlineseconds_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.enableservicelinks_) -
        reinterpret_cast<char*>(&_impl_.activedeadlineseconds_)) + sizeof(_impl_.enableservicelinks_));
  }
  if (cached_has_bits & 0x03000000u) {
    ::memset(&_impl_.sethostnameasfqdn_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.hostusers_) -
        reinterpret_cast<char*>(&_impl_.sethostnameasfqdn_)) + sizeof(_impl_.hostusers_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PodSpec::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .k8s.io.api.core.v1.Volume volumes = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_volumes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .k8s.io.api.core.v1.Container containers = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_containers(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bytes restartPolicy = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_restartpolicy();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 terminationGracePeriodSeconds = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_terminationgraceperiodseconds(&has_bits);
          _impl_.terminationgraceperiodseconds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 activeDeadlineSeconds = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_activedeadlineseconds(&has_bits);
          _impl_.activedeadlineseconds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes dnsPolicy = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_dnspolicy();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // map<string, string> nodeSelector = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.nodeselector_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bytes serviceAccountName = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_serviceaccountname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes serviceAccount = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_serviceaccount();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes nodeName = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_nodename();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool hostNetwork = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_hostnetwork(&has_bits);
          _impl_.hostnetwork_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool hostPID = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_hostpid(&has_bits);
          _impl_.hostpid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool hostIPC = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_hostipc(&has_bits);
          _impl_.hostipc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.PodSecurityContext securityContext = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_securitycontext(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .k8s.io.api.core.v1.LocalObjectReference imagePullSecrets = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_imagepullsecrets(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<122>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bytes hostname = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          auto str = _internal_mutable_hostname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes subdomain = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          auto str = _internal_mutable_subdomain();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.Affinity affinity = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          ptr = ctx->ParseMessage(_internal_mutable_affinity(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes schedulerName = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          auto str = _internal_mutable_schedulername();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .k8s.io.api.core.v1.Container initContainers = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_initcontainers(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<162>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool automountServiceAccountToken = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _Internal::set_has_automountserviceaccounttoken(&has_bits);
          _impl_.automountserviceaccounttoken_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .k8s.io.api.core.v1.Toleration tolerations = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 178)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_tolerations(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<178>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .k8s.io.api.core.v1.HostAlias hostAliases = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 186)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_hostaliases(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<186>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bytes priorityClassName = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 194)) {
          auto str = _internal_mutable_priorityclassname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 priority = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 200)) {
          _Internal::set_has_priority(&has_bits);
          _impl_.priority_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.PodDNSConfig dnsConfig = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 210)) {
          ptr = ctx->ParseMessage(_internal_mutable_dnsconfig(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool shareProcessNamespace = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 216)) {
          _Internal::set_has_shareprocessnamespace(&has_bits);
          _impl_.shareprocessnamespace_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .k8s.io.api.core.v1.PodReadinessGate readinessGates = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 226)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_readinessgates(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<226>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bytes runtimeClassName = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 234)) {
          auto str = _internal_mutable_runtimeclassname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool enableServiceLinks = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 240)) {
          _Internal::set_has_enableservicelinks(&has_bits);
          _impl_.enableservicelinks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes preemptionPolicy = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 250)) {
          auto str = _internal_mutable_preemptionpolicy();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // map<string, .k8s.io.apimachinery.pkg.api.resource.Quantity> overhead = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 2)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(&_impl_.overhead_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<258>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .k8s.io.api.core.v1.TopologySpreadConstraint topologySpreadConstraints = 33;
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_topologyspreadconstraints(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<266>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .k8s.io.api.core.v1.EphemeralContainer ephemeralContainers = 34;
      case 34:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_ephemeralcontainers(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<274>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool setHostnameAsFQDN = 35;
      case 35:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_sethostnameasfqdn(&has_bits);
          _impl_.sethostnameasfqdn_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.PodOS os = 36;
      case 36:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_os(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool hostUsers = 37;
      case 37:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_hostusers(&has_bits);
          _impl_.hostusers_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .k8s.io.api.core.v1.PodSchedulingGate schedulingGates = 38;
      case 38:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_schedulinggates(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<306>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .k8s.io.api.core.v1.PodResourceClaim resourceClaims = 39;
      case 39:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_resourceclaims(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<314>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PodSpec::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.PodSpec)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .k8s.io.api.core.v1.Volume volumes = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_volumes_size()); i < n; i++) {
    const auto& repfield = this->_internal_volumes(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .k8s.io.api.core.v1.Container containers = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_containers_size()); i < n; i++) {
    const auto& repfield = this->_internal_containers(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes restartPolicy = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_restartpolicy(), target);
  }

  // optional int64 terminationGracePeriodSeconds = 4;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_terminationgraceperiodseconds(), target);
  }

  // optional int64 activeDeadlineSeconds = 5;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(5, this->_internal_activedeadlineseconds(), target);
  }

  // optional bytes dnsPolicy = 6;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        6, this->_internal_dnspolicy(), target);
  }

  // map<string, string> nodeSelector = 7;
  if (!this->_internal_nodeselector().empty()) {
    using MapType = ::_pb::Map<std::string, std::string>;
    using WireHelper = PodSpec_NodeSelectorEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_nodeselector();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "k8s.io.api.core.v1.PodSpec.NodeSelectorEntry.key");
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        entry.second.data(), static_cast<int>(entry.second.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "k8s.io.api.core.v1.PodSpec.NodeSelectorEntry.value");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(7, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(7, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  // optional bytes serviceAccountName = 8;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        8, this->_internal_serviceaccountname(), target);
  }

  // optional bytes serviceAccount = 9;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        9, this->_internal_serviceaccount(), target);
  }

  // optional bytes nodeName = 10;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteBytesMaybeAliased(
        10, this->_internal_nodename(), target);
  }

  // optional bool hostNetwork = 11;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(11, this->_internal_hostnetwork(), target);
  }

  // optional bool hostPID = 12;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(12, this->_internal_hostpid(), target);
  }

  // optional bool hostIPC = 13;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(13, this->_internal_hostipc(), target);
  }

  // optional .k8s.io.api.core.v1.PodSecurityContext securityContext = 14;
  if (cached_has_bits & 0x00000800u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(14, _Internal::securitycontext(this),
        _Internal::securitycontext(this).GetCachedSize(), target, stream);
  }

  // repeated .k8s.io.api.core.v1.LocalObjectReference imagePullSecrets = 15;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_imagepullsecrets_size()); i < n; i++) {
    const auto& repfield = this->_internal_imagepullsecrets(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(15, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bytes hostname = 16;
  if (cached_has_bits & 0x00000020u) {
    target = stream->WriteBytesMaybeAliased(
        16, this->_internal_hostname(), target);
  }

  // optional bytes subdomain = 17;
  if (cached_has_bits & 0x00000040u) {
    target = stream->WriteBytesMaybeAliased(
        17, this->_internal_subdomain(), target);
  }

  // optional .k8s.io.api.core.v1.Affinity affinity = 18;
  if (cached_has_bits & 0x00001000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(18, _Internal::affinity(this),
        _Internal::affinity(this).GetCachedSize(), target, stream);
  }

  // optional bytes schedulerName = 19;
  if (cached_has_bits & 0x00000080u) {
    target = stream->WriteBytesMaybeAliased(
        19, this->_internal_schedulername(), target);
  }

  // repeated .k8s.io.api.core.v1.Container initContainers = 20;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_initcontainers_size()); i < n; i++) {
    const auto& repfield = this->_internal_initcontainers(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(20, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bool automountServiceAccountToken = 21;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(21, this->_internal_automountserviceaccounttoken(), target);
  }

  // repeated .k8s.io.api.core.v1.Toleration tolerations = 22;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_tolerations_size()); i < n; i++) {
    const auto& repfield = this->_internal_tolerations(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(22, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .k8s.io.api.core.v1.HostAlias hostAliases = 23;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_hostaliases_size()); i < n; i++) {
    const auto& repfield = this->_internal_hostaliases(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(23, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bytes priorityClassName = 24;
  if (cached_has_bits & 0x00000100u) {
    target = stream->WriteBytesMaybeAliased(
        24, this->_internal_priorityclassname(), target);
  }

  // optional int32 priority = 25;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(25, this->_internal_priority(), target);
  }

  // optional .k8s.io.api.core.v1.PodDNSConfig dnsConfig = 26;
  if (cached_has_bits & 0x00002000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(26, _Internal::dnsconfig(this),
        _Internal::dnsconfig(this).GetCachedSize(), target, stream);
  }

  // optional bool shareProcessNamespace = 27;
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(27, this->_internal_shareprocessnamespace(), target);
  }

  // repeated .k8s.io.api.core.v1.PodReadinessGate readinessGates = 28;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_readinessgates_size()); i < n; i++) {
    const auto& repfield = this->_internal_readinessgates(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(28, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bytes runtimeClassName = 29;
  if (cached_has_bits & 0x00000200u) {
    target = stream->WriteBytesMaybeAliased(
        29, this->_internal_runtimeclassname(), target);
  }

  // optional bool enableServiceLinks = 30;
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(30, this->_internal_enableservicelinks(), target);
  }

  // optional bytes preemptionPolicy = 31;
  if (cached_has_bits & 0x00000400u) {
    target = stream->WriteBytesMaybeAliased(
        31, this->_internal_preemptionpolicy(), target);
  }

  // map<string, .k8s.io.apimachinery.pkg.api.resource.Quantity> overhead = 32;
  if (!this->_internal_overhead().empty()) {
    using MapType = ::_pb::Map<std::string, ::k8s::io::apimachinery::pkg::api::resource::Quantity>;
    using WireHelper = PodSpec_OverheadEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_overhead();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "k8s.io.api.core.v1.PodSpec.OverheadEntry.key");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(32, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(32, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  // repeated .k8s.io.api.core.v1.TopologySpreadConstraint topologySpreadConstraints = 33;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_topologyspreadconstraints_size()); i < n; i++) {
    const auto& repfield = this->_internal_topologyspreadconstraints(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(33, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .k8s.io.api.core.v1.EphemeralContainer ephemeralContainers = 34;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_ephemeralcontainers_size()); i < n; i++) {
    const auto& repfield = this->_internal_ephemeralcontainers(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(34, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bool setHostnameAsFQDN = 35;
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(35, this->_internal_sethostnameasfqdn(), target);
  }

  // optional .k8s.io.api.core.v1.PodOS os = 36;
  if (cached_has_bits & 0x00004000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(36, _Internal::os(this),
        _Internal::os(this).GetCachedSize(), target, stream);
  }

  // optional bool hostUsers = 37;
  if (cached_has_bits & 0x02000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(37, this->_internal_hostusers(), target);
  }

  // repeated .k8s.io.api.core.v1.PodSchedulingGate schedulingGates = 38;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_schedulinggates_size()); i < n; i++) {
    const auto& repfield = this->_internal_schedulinggates(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(38, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .k8s.io.api.core.v1.PodResourceClaim resourceClaims = 39;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_resourceclaims_size()); i < n; i++) {
    const auto& repfield = this->_internal_resourceclaims(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(39, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.PodSpec)
  return target;
}

size_t PodSpec::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.PodSpec)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .k8s.io.api.core.v1.Volume volumes = 1;
  total_size += 1UL * this->_internal_volumes_size();
  for (const auto& msg : this->_impl_.volumes_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .k8s.io.api.core.v1.Container containers = 2;
  total_size += 1UL * this->_internal_containers_size();
  for (const auto& msg : this->_impl_.containers_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // map<string, string> nodeSelector = 7;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_nodeselector_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
      it = this->_internal_nodeselector().begin();
      it != this->_internal_nodeselector().end(); ++it) {
    total_size += PodSpec_NodeSelectorEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // repeated .k8s.io.api.core.v1.LocalObjectReference imagePullSecrets = 15;
  total_size += 1UL * this->_internal_imagepullsecrets_size();
  for (const auto& msg : this->_impl_.imagepullsecrets_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .k8s.io.api.core.v1.Container initContainers = 20;
  total_size += 2UL * this->_internal_initcontainers_size();
  for (const auto& msg : this->_impl_.initcontainers_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .k8s.io.api.core.v1.Toleration tolerations = 22;
  total_size += 2UL * this->_internal_tolerations_size();
  for (const auto& msg : this->_impl_.tolerations_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .k8s.io.api.core.v1.HostAlias hostAliases = 23;
  total_size += 2UL * this->_internal_hostaliases_size();
  for (const auto& msg : this->_impl_.hostaliases_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .k8s.io.api.core.v1.PodReadinessGate readinessGates = 28;
  total_size += 2UL * this->_internal_readinessgates_size();
  for (const auto& msg : this->_impl_.readinessgates_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // map<string, .k8s.io.apimachinery.pkg.api.resource.Quantity> overhead = 32;
  total_size += 2 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_overhead_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::k8s::io::apimachinery::pkg::api::resource::Quantity >::const_iterator
      it = this->_internal_overhead().begin();
      it != this->_internal_overhead().end(); ++it) {
    total_size += PodSpec_OverheadEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // repeated .k8s.io.api.core.v1.TopologySpreadConstraint topologySpreadConstraints = 33;
  total_size += 2UL * this->_internal_topologyspreadconstraints_size();
  for (const auto& msg : this->_impl_.topologyspreadconstraints_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .k8s.io.api.core.v1.EphemeralContainer ephemeralContainers = 34;
  total_size += 2UL * this->_internal_ephemeralcontainers_size();
  for (const auto& msg : this->_impl_.ephemeralcontainers_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .k8s.io.api.core.v1.PodSchedulingGate schedulingGates = 38;
  total_size += 2UL * this->_internal_schedulinggates_size();
  for (const auto& msg : this->_impl_.schedulinggates_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .k8s.io.api.core.v1.PodResourceClaim resourceClaims = 39;
  total_size += 2UL * this->_internal_resourceclaims_size();
  for (const auto& msg : this->_impl_.resourceclaims_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bytes restartPolicy = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_restartpolicy());
    }

    // optional bytes dnsPolicy = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_dnspolicy());
    }

    // optional bytes serviceAccountName = 8;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_serviceaccountname());
    }

    // optional bytes serviceAccount = 9;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_serviceaccount());
    }

    // optional bytes nodeName = 10;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_nodename());
    }

    // optional bytes hostname = 16;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_hostname());
    }

    // optional bytes subdomain = 17;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_subdomain());
    }

    // optional bytes schedulerName = 19;
    if (cached_has_bits & 0x00000080u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_schedulername());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional bytes priorityClassName = 24;
    if (cached_has_bits & 0x00000100u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_priorityclassname());
    }

    // optional bytes runtimeClassName = 29;
    if (cached_has_bits & 0x00000200u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_runtimeclassname());
    }

    // optional bytes preemptionPolicy = 31;
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_preemptionpolicy());
    }

    // optional .k8s.io.api.core.v1.PodSecurityContext securityContext = 14;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.securitycontext_);
    }

    // optional .k8s.io.api.core.v1.Affinity affinity = 18;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.affinity_);
    }

    // optional .k8s.io.api.core.v1.PodDNSConfig dnsConfig = 26;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dnsconfig_);
    }

    // optional .k8s.io.api.core.v1.PodOS os = 36;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.os_);
    }

    // optional int64 terminationGracePeriodSeconds = 4;
    if (cached_has_bits & 0x00008000u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_terminationgraceperiodseconds());
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional int64 activeDeadlineSeconds = 5;
    if (cached_has_bits & 0x00010000u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_activedeadlineseconds());
    }

    // optional bool automountServiceAccountToken = 21;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 + 1;
    }

    // optional bool hostNetwork = 11;
    if (cached_has_bits & 0x00040000u) {
      total_size += 1 + 1;
    }

    // optional bool hostPID = 12;
    if (cached_has_bits & 0x00080000u) {
      total_size += 1 + 1;
    }

    // optional bool hostIPC = 13;
    if (cached_has_bits & 0x00100000u) {
      total_size += 1 + 1;
    }

    // optional int32 priority = 25;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_priority());
    }

    // optional bool shareProcessNamespace = 27;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 + 1;
    }

    // optional bool enableServiceLinks = 30;
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 + 1;
    }

  }
  if (cached_has_bits & 0x03000000u) {
    // optional bool setHostnameAsFQDN = 35;
    if (cached_has_bits & 0x01000000u) {
      total_size += 2 + 1;
    }

    // optional bool hostUsers = 37;
    if (cached_has_bits & 0x02000000u) {
      total_size += 2 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PodSpec::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PodSpec::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PodSpec::GetClassData() const { return &_class_data_; }


void PodSpec::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PodSpec*>(&to_msg);
  auto& from = static_cast<const PodSpec&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.PodSpec)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.volumes_.MergeFrom(from._impl_.volumes_);
  _this->_impl_.containers_.MergeFrom(from._impl_.containers_);
  _this->_impl_.nodeselector_.MergeFrom(from._impl_.nodeselector_);
  _this->_impl_.imagepullsecrets_.MergeFrom(from._impl_.imagepullsecrets_);
  _this->_impl_.initcontainers_.MergeFrom(from._impl_.initcontainers_);
  _this->_impl_.tolerations_.MergeFrom(from._impl_.tolerations_);
  _this->_impl_.hostaliases_.MergeFrom(from._impl_.hostaliases_);
  _this->_impl_.readinessgates_.MergeFrom(from._impl_.readinessgates_);
  _this->_impl_.overhead_.MergeFrom(from._impl_.overhead_);
  _this->_impl_.topologyspreadconstraints_.MergeFrom(from._impl_.topologyspreadconstraints_);
  _this->_impl_.ephemeralcontainers_.MergeFrom(from._impl_.ephemeralcontainers_);
  _this->_impl_.schedulinggates_.MergeFrom(from._impl_.schedulinggates_);
  _this->_impl_.resourceclaims_.MergeFrom(from._impl_.resourceclaims_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_restartpolicy(from._internal_restartpolicy());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_dnspolicy(from._internal_dnspolicy());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_serviceaccountname(from._internal_serviceaccountname());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_serviceaccount(from._internal_serviceaccount());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_nodename(from._internal_nodename());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_set_hostname(from._internal_hostname());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_set_subdomain(from._internal_subdomain());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_set_schedulername(from._internal_schedulername());
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_internal_set_priorityclassname(from._internal_priorityclassname());
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_internal_set_runtimeclassname(from._internal_runtimeclassname());
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_internal_set_preemptionpolicy(from._internal_preemptionpolicy());
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_internal_mutable_securitycontext()->::k8s::io::api::core::v1::PodSecurityContext::MergeFrom(
          from._internal_securitycontext());
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_internal_mutable_affinity()->::k8s::io::api::core::v1::Affinity::MergeFrom(
          from._internal_affinity());
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_internal_mutable_dnsconfig()->::k8s::io::api::core::v1::PodDNSConfig::MergeFrom(
          from._internal_dnsconfig());
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_internal_mutable_os()->::k8s::io::api::core::v1::PodOS::MergeFrom(
          from._internal_os());
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.terminationgraceperiodseconds_ = from._impl_.terminationgraceperiodseconds_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_impl_.activedeadlineseconds_ = from._impl_.activedeadlineseconds_;
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_impl_.automountserviceaccounttoken_ = from._impl_.automountserviceaccounttoken_;
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_impl_.hostnetwork_ = from._impl_.hostnetwork_;
    }
    if (cached_has_bits & 0x00080000u) {
      _this->_impl_.hostpid_ = from._impl_.hostpid_;
    }
    if (cached_has_bits & 0x00100000u) {
      _this->_impl_.hostipc_ = from._impl_.hostipc_;
    }
    if (cached_has_bits & 0x00200000u) {
      _this->_impl_.priority_ = from._impl_.priority_;
    }
    if (cached_has_bits & 0x00400000u) {
      _this->_impl_.shareprocessnamespace_ = from._impl_.shareprocessnamespace_;
    }
    if (cached_has_bits & 0x00800000u) {
      _this->_impl_.enableservicelinks_ = from._impl_.enableservicelinks_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x03000000u) {
    if (cached_has_bits & 0x01000000u) {
      _this->_impl_.sethostnameasfqdn_ = from._impl_.sethostnameasfqdn_;
    }
    if (cached_has_bits & 0x02000000u) {
      _this->_impl_.hostusers_ = from._impl_.hostusers_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PodSpec::CopyFrom(const PodSpec& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.PodSpec)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PodSpec::IsInitialized() const {
  return true;
}

void PodSpec::InternalSwap(PodSpec* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.volumes_.InternalSwap(&other->_impl_.volumes_);
  _impl_.containers_.InternalSwap(&other->_impl_.containers_);
  _impl_.nodeselector_.InternalSwap(&other->_impl_.nodeselector_);
  _impl_.imagepullsecrets_.InternalSwap(&other->_impl_.imagepullsecrets_);
  _impl_.initcontainers_.InternalSwap(&other->_impl_.initcontainers_);
  _impl_.tolerations_.InternalSwap(&other->_impl_.tolerations_);
  _impl_.hostaliases_.InternalSwap(&other->_impl_.hostaliases_);
  _impl_.readinessgates_.InternalSwap(&other->_impl_.readinessgates_);
  _impl_.overhead_.InternalSwap(&other->_impl_.overhead_);
  _impl_.topologyspreadconstraints_.InternalSwap(&other->_impl_.topologyspreadconstraints_);
  _impl_.ephemeralcontainers_.InternalSwap(&other->_impl_.ephemeralcontainers_);
  _impl_.schedulinggates_.InternalSwap(&other->_impl_.schedulinggates_);
  _impl_.resourceclaims_.InternalSwap(&other->_impl_.resourceclaims_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.restartpolicy_, lhs_arena,
      &other->_impl_.restartpolicy_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.dnspolicy_, lhs_arena,
      &other->_impl_.dnspolicy_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.serviceaccountname_, lhs_arena,
      &other->_impl_.serviceaccountname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.serviceaccount_, lhs_arena,
      &other->_impl_.serviceaccount_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.nodename_, lhs_arena,
      &other->_impl_.nodename_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.hostname_, lhs_arena,
      &other->_impl_.hostname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.subdomain_, lhs_arena,
      &other->_impl_.subdomain_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.schedulername_, lhs_arena,
      &other->_impl_.schedulername_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.priorityclassname_, lhs_arena,
      &other->_impl_.priorityclassname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.runtimeclassname_, lhs_arena,
      &other->_impl_.runtimeclassname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.preemptionpolicy_, lhs_arena,
      &other->_impl_.preemptionpolicy_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PodSpec, _impl_.hostusers_)
      + sizeof(PodSpec::_impl_.hostusers_)
      - PROTOBUF_FIELD_OFFSET(PodSpec, _impl_.securitycontext_)>(
          reinterpret_cast<char*>(&_impl_.securitycontext_),
          reinterpret_cast<char*>(&other->_impl_.securitycontext_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PodSpec::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[167]);
}

// ===================================================================

class PodStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<PodStatus>()._impl_._has_bits_);
  static void set_has_phase(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_message(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_reason(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_nominatednodename(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_hostip(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_podip(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::k8s::io::apimachinery::pkg::apis::meta::v1::Time& starttime(const PodStatus* msg);
  static void set_has_starttime(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_qosclass(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_resize(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

const ::k8s::io::apimachinery::pkg::apis::meta::v1::Time&
PodStatus::_Internal::starttime(const PodStatus* msg) {
  return *msg->_impl_.starttime_;
}
void PodStatus::clear_starttime() {
  if (_impl_.starttime_ != nullptr) _impl_.starttime_->Clear();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
PodStatus::PodStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.PodStatus)
}
PodStatus::PodStatus(const PodStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PodStatus* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.conditions_){from._impl_.conditions_}
    , decltype(_impl_.containerstatuses_){from._impl_.containerstatuses_}
    , decltype(_impl_.initcontainerstatuses_){from._impl_.initcontainerstatuses_}
    , decltype(_impl_.podips_){from._impl_.podips_}
    , decltype(_impl_.ephemeralcontainerstatuses_){from._impl_.ephemeralcontainerstatuses_}
    , decltype(_impl_.resourceclaimstatuses_){from._impl_.resourceclaimstatuses_}
    , decltype(_impl_.hostips_){from._impl_.hostips_}
    , decltype(_impl_.phase_){}
    , decltype(_impl_.message_){}
    , decltype(_impl_.reason_){}
    , decltype(_impl_.hostip_){}
    , decltype(_impl_.podip_){}
    , decltype(_impl_.qosclass_){}
    , decltype(_impl_.nominatednodename_){}
    , decltype(_impl_.resize_){}
    , decltype(_impl_.starttime_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.phase_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.phase_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_phase()) {
    _this->_impl_.phase_.Set(from._internal_phase(), 
      _this->GetArenaForAllocation());
  }
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_message()) {
    _this->_impl_.message_.Set(from._internal_message(), 
      _this->GetArenaForAllocation());
  }
  _impl_.reason_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.reason_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_reason()) {
    _this->_impl_.reason_.Set(from._internal_reason(), 
      _this->GetArenaForAllocation());
  }
  _impl_.hostip_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hostip_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_hostip()) {
    _this->_impl_.hostip_.Set(from._internal_hostip(), 
      _this->GetArenaForAllocation());
  }
  _impl_.podip_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.podip_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_podip()) {
    _this->_impl_.podip_.Set(from._internal_podip(), 
      _this->GetArenaForAllocation());
  }
  _impl_.qosclass_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.qosclass_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_qosclass()) {
    _this->_impl_.qosclass_.Set(from._internal_qosclass(), 
      _this->GetArenaForAllocation());
  }
  _impl_.nominatednodename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nominatednodename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_nominatednodename()) {
    _this->_impl_.nominatednodename_.Set(from._internal_nominatednodename(), 
      _this->GetArenaForAllocation());
  }
  _impl_.resize_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.resize_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_resize()) {
    _this->_impl_.resize_.Set(from._internal_resize(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_starttime()) {
    _this->_impl_.starttime_ = new ::k8s::io::apimachinery::pkg::apis::meta::v1::Time(*from._impl_.starttime_);
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.PodStatus)
}

inline void PodStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.conditions_){arena}
    , decltype(_impl_.containerstatuses_){arena}
    , decltype(_impl_.initcontainerstatuses_){arena}
    , decltype(_impl_.podips_){arena}
    , decltype(_impl_.ephemeralcontainerstatuses_){arena}
    , decltype(_impl_.resourceclaimstatuses_){arena}
    , decltype(_impl_.hostips_){arena}
    , decltype(_impl_.phase_){}
    , decltype(_impl_.message_){}
    , decltype(_impl_.reason_){}
    , decltype(_impl_.hostip_){}
    , decltype(_impl_.podip_){}
    , decltype(_impl_.qosclass_){}
    , decltype(_impl_.nominatednodename_){}
    , decltype(_impl_.resize_){}
    , decltype(_impl_.starttime_){nullptr}
  };
  _impl_.phase_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.phase_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.reason_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.reason_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.hostip_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hostip_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.podip_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.podip_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.qosclass_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.qosclass_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.nominatednodename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nominatednodename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.resize_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.resize_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PodStatus::~PodStatus() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.PodStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PodStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.conditions_.~RepeatedPtrField();
  _impl_.containerstatuses_.~RepeatedPtrField();
  _impl_.initcontainerstatuses_.~RepeatedPtrField();
  _impl_.podips_.~RepeatedPtrField();
  _impl_.ephemeralcontainerstatuses_.~RepeatedPtrField();
  _impl_.resourceclaimstatuses_.~RepeatedPtrField();
  _impl_.hostips_.~RepeatedPtrField();
  _impl_.phase_.Destroy();
  _impl_.message_.Destroy();
  _impl_.reason_.Destroy();
  _impl_.hostip_.Destroy();
  _impl_.podip_.Destroy();
  _impl_.qosclass_.Destroy();
  _impl_.nominatednodename_.Destroy();
  _impl_.resize_.Destroy();
  if (this != internal_default_instance()) delete _impl_.starttime_;
}

void PodStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PodStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.PodStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.conditions_.Clear();
  _impl_.containerstatuses_.Clear();
  _impl_.initcontainerstatuses_.Clear();
  _impl_.podips_.Clear();
  _impl_.ephemeralcontainerstatuses_.Clear();
  _impl_.resourceclaimstatuses_.Clear();
  _impl_.hostips_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.phase_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.message_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.reason_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.hostip_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.podip_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      _impl_.qosclass_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000040u) {
      _impl_.nominatednodename_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000080u) {
      _impl_.resize_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000100u) {
    GOOGLE_DCHECK(_impl_.starttime_ != nullptr);
    _impl_.starttime_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PodStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes phase = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_phase();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .k8s.io.api.core.v1.PodCondition conditions = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_conditions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bytes message = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes reason = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_reason();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes hostIP = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_hostip();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes podIP = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_podip();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time startTime = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_starttime(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .k8s.io.api.core.v1.ContainerStatus containerStatuses = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_containerstatuses(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bytes qosClass = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_qosclass();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .k8s.io.api.core.v1.ContainerStatus initContainerStatuses = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_initcontainerstatuses(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bytes nominatedNodeName = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          auto str = _internal_mutable_nominatednodename();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .k8s.io.api.core.v1.PodIP podIPs = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_podips(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<98>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .k8s.io.api.core.v1.ContainerStatus ephemeralContainerStatuses = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_ephemeralcontainerstatuses(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<106>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bytes resize = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          auto str = _internal_mutable_resize();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .k8s.io.api.core.v1.PodResourceClaimStatus resourceClaimStatuses = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_resourceclaimstatuses(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<122>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .k8s.io.api.core.v1.HostIP hostIPs = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_hostips(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<130>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PodStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.PodStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes phase = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_phase(), target);
  }

  // repeated .k8s.io.api.core.v1.PodCondition conditions = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_conditions_size()); i < n; i++) {
    const auto& repfield = this->_internal_conditions(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bytes message = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_message(), target);
  }

  // optional bytes reason = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_reason(), target);
  }

  // optional bytes hostIP = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_hostip(), target);
  }

  // optional bytes podIP = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteBytesMaybeAliased(
        6, this->_internal_podip(), target);
  }

  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time startTime = 7;
  if (cached_has_bits & 0x00000100u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::starttime(this),
        _Internal::starttime(this).GetCachedSize(), target, stream);
  }

  // repeated .k8s.io.api.core.v1.ContainerStatus containerStatuses = 8;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_containerstatuses_size()); i < n; i++) {
    const auto& repfield = this->_internal_containerstatuses(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(8, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bytes qosClass = 9;
  if (cached_has_bits & 0x00000020u) {
    target = stream->WriteBytesMaybeAliased(
        9, this->_internal_qosclass(), target);
  }

  // repeated .k8s.io.api.core.v1.ContainerStatus initContainerStatuses = 10;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_initcontainerstatuses_size()); i < n; i++) {
    const auto& repfield = this->_internal_initcontainerstatuses(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(10, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bytes nominatedNodeName = 11;
  if (cached_has_bits & 0x00000040u) {
    target = stream->WriteBytesMaybeAliased(
        11, this->_internal_nominatednodename(), target);
  }

  // repeated .k8s.io.api.core.v1.PodIP podIPs = 12;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_podips_size()); i < n; i++) {
    const auto& repfield = this->_internal_podips(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(12, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .k8s.io.api.core.v1.ContainerStatus ephemeralContainerStatuses = 13;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_ephemeralcontainerstatuses_size()); i < n; i++) {
    const auto& repfield = this->_internal_ephemeralcontainerstatuses(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(13, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bytes resize = 14;
  if (cached_has_bits & 0x00000080u) {
    target = stream->WriteBytesMaybeAliased(
        14, this->_internal_resize(), target);
  }

  // repeated .k8s.io.api.core.v1.PodResourceClaimStatus resourceClaimStatuses = 15;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_resourceclaimstatuses_size()); i < n; i++) {
    const auto& repfield = this->_internal_resourceclaimstatuses(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(15, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .k8s.io.api.core.v1.HostIP hostIPs = 16;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_hostips_size()); i < n; i++) {
    const auto& repfield = this->_internal_hostips(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(16, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.PodStatus)
  return target;
}

size_t PodStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.PodStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .k8s.io.api.core.v1.PodCondition conditions = 2;
  total_size += 1UL * this->_internal_conditions_size();
  for (const auto& msg : this->_impl_.conditions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .k8s.io.api.core.v1.ContainerStatus containerStatuses = 8;
  total_size += 1UL * this->_internal_containerstatuses_size();
  for (const auto& msg : this->_impl_.containerstatuses_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .k8s.io.api.core.v1.ContainerStatus initContainerStatuses = 10;
  total_size += 1UL * this->_internal_initcontainerstatuses_size();
  for (const auto& msg : this->_impl_.initcontainerstatuses_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .k8s.io.api.core.v1.PodIP podIPs = 12;
  total_size += 1UL * this->_internal_podips_size();
  for (const auto& msg : this->_impl_.podips_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .k8s.io.api.core.v1.ContainerStatus ephemeralContainerStatuses = 13;
  total_size += 1UL * this->_internal_ephemeralcontainerstatuses_size();
  for (const auto& msg : this->_impl_.ephemeralcontainerstatuses_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .k8s.io.api.core.v1.PodResourceClaimStatus resourceClaimStatuses = 15;
  total_size += 1UL * this->_internal_resourceclaimstatuses_size();
  for (const auto& msg : this->_impl_.resourceclaimstatuses_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .k8s.io.api.core.v1.HostIP hostIPs = 16;
  total_size += 2UL * this->_internal_hostips_size();
  for (const auto& msg : this->_impl_.hostips_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bytes phase = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_phase());
    }

    // optional bytes message = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_message());
    }

    // optional bytes reason = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_reason());
    }

    // optional bytes hostIP = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_hostip());
    }

    // optional bytes podIP = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_podip());
    }

    // optional bytes qosClass = 9;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_qosclass());
    }

    // optional bytes nominatedNodeName = 11;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_nominatednodename());
    }

    // optional bytes resize = 14;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_resize());
    }

  }
  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time startTime = 7;
  if (cached_has_bits & 0x00000100u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.starttime_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PodStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PodStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PodStatus::GetClassData() const { return &_class_data_; }


void PodStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PodStatus*>(&to_msg);
  auto& from = static_cast<const PodStatus&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.PodStatus)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.conditions_.MergeFrom(from._impl_.conditions_);
  _this->_impl_.containerstatuses_.MergeFrom(from._impl_.containerstatuses_);
  _this->_impl_.initcontainerstatuses_.MergeFrom(from._impl_.initcontainerstatuses_);
  _this->_impl_.podips_.MergeFrom(from._impl_.podips_);
  _this->_impl_.ephemeralcontainerstatuses_.MergeFrom(from._impl_.ephemeralcontainerstatuses_);
  _this->_impl_.resourceclaimstatuses_.MergeFrom(from._impl_.resourceclaimstatuses_);
  _this->_impl_.hostips_.MergeFrom(from._impl_.hostips_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_phase(from._internal_phase());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_message(from._internal_message());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_reason(from._internal_reason());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_hostip(from._internal_hostip());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_podip(from._internal_podip());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_set_qosclass(from._internal_qosclass());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_set_nominatednodename(from._internal_nominatednodename());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_set_resize(from._internal_resize());
    }
  }
  if (cached_has_bits & 0x00000100u) {
    _this->_internal_mutable_starttime()->::k8s::io::apimachinery::pkg::apis::meta::v1::Time::MergeFrom(
        from._internal_starttime());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PodStatus::CopyFrom(const PodStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.PodStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PodStatus::IsInitialized() const {
  return true;
}

void PodStatus::InternalSwap(PodStatus* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.conditions_.InternalSwap(&other->_impl_.conditions_);
  _impl_.containerstatuses_.InternalSwap(&other->_impl_.containerstatuses_);
  _impl_.initcontainerstatuses_.InternalSwap(&other->_impl_.initcontainerstatuses_);
  _impl_.podips_.InternalSwap(&other->_impl_.podips_);
  _impl_.ephemeralcontainerstatuses_.InternalSwap(&other->_impl_.ephemeralcontainerstatuses_);
  _impl_.resourceclaimstatuses_.InternalSwap(&other->_impl_.resourceclaimstatuses_);
  _impl_.hostips_.InternalSwap(&other->_impl_.hostips_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.phase_, lhs_arena,
      &other->_impl_.phase_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.message_, lhs_arena,
      &other->_impl_.message_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.reason_, lhs_arena,
      &other->_impl_.reason_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.hostip_, lhs_arena,
      &other->_impl_.hostip_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.podip_, lhs_arena,
      &other->_impl_.podip_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.qosclass_, lhs_arena,
      &other->_impl_.qosclass_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.nominatednodename_, lhs_arena,
      &other->_impl_.nominatednodename_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.resize_, lhs_arena,
      &other->_impl_.resize_, rhs_arena
  );
  swap(_impl_.starttime_, other->_impl_.starttime_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PodStatus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[168]);
}

// ===================================================================

class PodStatusResult::_Internal {
 public:
  using HasBits = decltype(std::declval<PodStatusResult>()._impl_._has_bits_);
  static const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& metadata(const PodStatusResult* msg);
  static void set_has_metadata(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::k8s::io::api::core::v1::PodStatus& status(const PodStatusResult* msg);
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta&
PodStatusResult::_Internal::metadata(const PodStatusResult* msg) {
  return *msg->_impl_.metadata_;
}
const ::k8s::io::api::core::v1::PodStatus&
PodStatusResult::_Internal::status(const PodStatusResult* msg) {
  return *msg->_impl_.status_;
}
void PodStatusResult::clear_metadata() {
  if (_impl_.metadata_ != nullptr) _impl_.metadata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
PodStatusResult::PodStatusResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.PodStatusResult)
}
PodStatusResult::PodStatusResult(const PodStatusResult& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PodStatusResult* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.metadata_){nullptr}
    , decltype(_impl_.status_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_metadata()) {
    _this->_impl_.metadata_ = new ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta(*from._impl_.metadata_);
  }
  if (from._internal_has_status()) {
    _this->_impl_.status_ = new ::k8s::io::api::core::v1::PodStatus(*from._impl_.status_);
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.PodStatusResult)
}

inline void PodStatusResult::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.metadata_){nullptr}
    , decltype(_impl_.status_){nullptr}
  };
}

PodStatusResult::~PodStatusResult() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.PodStatusResult)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PodStatusResult::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.metadata_;
  if (this != internal_default_instance()) delete _impl_.status_;
}

void PodStatusResult::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PodStatusResult::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.PodStatusResult)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.metadata_ != nullptr);
      _impl_.metadata_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.status_ != nullptr);
      _impl_.status_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PodStatusResult::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_metadata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.PodStatus status = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_status(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PodStatusResult::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.PodStatusResult)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::metadata(this),
        _Internal::metadata(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.PodStatus status = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::status(this),
        _Internal::status(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.PodStatusResult)
  return target;
}

size_t PodStatusResult::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.PodStatusResult)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.metadata_);
    }

    // optional .k8s.io.api.core.v1.PodStatus status = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.status_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PodStatusResult::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PodStatusResult::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PodStatusResult::GetClassData() const { return &_class_data_; }


void PodStatusResult::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PodStatusResult*>(&to_msg);
  auto& from = static_cast<const PodStatusResult&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.PodStatusResult)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_metadata()->::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta::MergeFrom(
          from._internal_metadata());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_status()->::k8s::io::api::core::v1::PodStatus::MergeFrom(
          from._internal_status());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PodStatusResult::CopyFrom(const PodStatusResult& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.PodStatusResult)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PodStatusResult::IsInitialized() const {
  return true;
}

void PodStatusResult::InternalSwap(PodStatusResult* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PodStatusResult, _impl_.status_)
      + sizeof(PodStatusResult::_impl_.status_)
      - PROTOBUF_FIELD_OFFSET(PodStatusResult, _impl_.metadata_)>(
          reinterpret_cast<char*>(&_impl_.metadata_),
          reinterpret_cast<char*>(&other->_impl_.metadata_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PodStatusResult::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[169]);
}

// ===================================================================

class PodTemplate::_Internal {
 public:
  using HasBits = decltype(std::declval<PodTemplate>()._impl_._has_bits_);
  static const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& metadata(const PodTemplate* msg);
  static void set_has_metadata(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::k8s::io::api::core::v1::PodTemplateSpec& template_(const PodTemplate* msg);
  static void set_has_template_(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta&
PodTemplate::_Internal::metadata(const PodTemplate* msg) {
  return *msg->_impl_.metadata_;
}
const ::k8s::io::api::core::v1::PodTemplateSpec&
PodTemplate::_Internal::template_(const PodTemplate* msg) {
  return *msg->_impl_.template__;
}
void PodTemplate::clear_metadata() {
  if (_impl_.metadata_ != nullptr) _impl_.metadata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
PodTemplate::PodTemplate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.PodTemplate)
}
PodTemplate::PodTemplate(const PodTemplate& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PodTemplate* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.metadata_){nullptr}
    , decltype(_impl_.template__){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_metadata()) {
    _this->_impl_.metadata_ = new ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta(*from._impl_.metadata_);
  }
  if (from._internal_has_template_()) {
    _this->_impl_.template__ = new ::k8s::io::api::core::v1::PodTemplateSpec(*from._impl_.template__);
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.PodTemplate)
}

inline void PodTemplate::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.metadata_){nullptr}
    , decltype(_impl_.template__){nullptr}
  };
}

PodTemplate::~PodTemplate() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.PodTemplate)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PodTemplate::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.metadata_;
  if (this != internal_default_instance()) delete _impl_.template__;
}

void PodTemplate::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PodTemplate::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.PodTemplate)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.metadata_ != nullptr);
      _impl_.metadata_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.template__ != nullptr);
      _impl_.template__->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PodTemplate::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_metadata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.PodTemplateSpec template = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_template_(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PodTemplate::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.PodTemplate)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::metadata(this),
        _Internal::metadata(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.PodTemplateSpec template = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::template_(this),
        _Internal::template_(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.PodTemplate)
  return target;
}

size_t PodTemplate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.PodTemplate)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.metadata_);
    }

    // optional .k8s.io.api.core.v1.PodTemplateSpec template = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.template__);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PodTemplate::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PodTemplate::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PodTemplate::GetClassData() const { return &_class_data_; }


void PodTemplate::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PodTemplate*>(&to_msg);
  auto& from = static_cast<const PodTemplate&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.PodTemplate)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_metadata()->::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta::MergeFrom(
          from._internal_metadata());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_template_()->::k8s::io::api::core::v1::PodTemplateSpec::MergeFrom(
          from._internal_template_());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PodTemplate::CopyFrom(const PodTemplate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.PodTemplate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PodTemplate::IsInitialized() const {
  return true;
}

void PodTemplate::InternalSwap(PodTemplate* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PodTemplate, _impl_.template__)
      + sizeof(PodTemplate::_impl_.template__)
      - PROTOBUF_FIELD_OFFSET(PodTemplate, _impl_.metadata_)>(
          reinterpret_cast<char*>(&_impl_.metadata_),
          reinterpret_cast<char*>(&other->_impl_.metadata_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PodTemplate::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[170]);
}

// ===================================================================

class PodTemplateList::_Internal {
 public:
  using HasBits = decltype(std::declval<PodTemplateList>()._impl_._has_bits_);
  static const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& metadata(const PodTemplateList* msg);
  static void set_has_metadata(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta&
PodTemplateList::_Internal::metadata(const PodTemplateList* msg) {
  return *msg->_impl_.metadata_;
}
void PodTemplateList::clear_metadata() {
  if (_impl_.metadata_ != nullptr) _impl_.metadata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
PodTemplateList::PodTemplateList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.PodTemplateList)
}
PodTemplateList::PodTemplateList(const PodTemplateList& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PodTemplateList* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.items_){from._impl_.items_}
    , decltype(_impl_.metadata_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_metadata()) {
    _this->_impl_.metadata_ = new ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta(*from._impl_.metadata_);
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.PodTemplateList)
}

inline void PodTemplateList::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.items_){arena}
    , decltype(_impl_.metadata_){nullptr}
  };
}

PodTemplateList::~PodTemplateList() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.PodTemplateList)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PodTemplateList::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.items_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.metadata_;
}

void PodTemplateList::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PodTemplateList::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.PodTemplateList)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.items_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.metadata_ != nullptr);
    _impl_.metadata_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PodTemplateList::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_metadata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .k8s.io.api.core.v1.PodTemplate items = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_items(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PodTemplateList::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.PodTemplateList)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::metadata(this),
        _Internal::metadata(this).GetCachedSize(), target, stream);
  }

  // repeated .k8s.io.api.core.v1.PodTemplate items = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_items_size()); i < n; i++) {
    const auto& repfield = this->_internal_items(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.PodTemplateList)
  return target;
}

size_t PodTemplateList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.PodTemplateList)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .k8s.io.api.core.v1.PodTemplate items = 2;
  total_size += 1UL * this->_internal_items_size();
  for (const auto& msg : this->_impl_.items_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.metadata_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PodTemplateList::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PodTemplateList::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PodTemplateList::GetClassData() const { return &_class_data_; }


void PodTemplateList::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PodTemplateList*>(&to_msg);
  auto& from = static_cast<const PodTemplateList&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.PodTemplateList)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.items_.MergeFrom(from._impl_.items_);
  if (from._internal_has_metadata()) {
    _this->_internal_mutable_metadata()->::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta::MergeFrom(
        from._internal_metadata());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PodTemplateList::CopyFrom(const PodTemplateList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.PodTemplateList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PodTemplateList::IsInitialized() const {
  return true;
}

void PodTemplateList::InternalSwap(PodTemplateList* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.items_.InternalSwap(&other->_impl_.items_);
  swap(_impl_.metadata_, other->_impl_.metadata_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PodTemplateList::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[171]);
}

// ===================================================================

class PodTemplateSpec::_Internal {
 public:
  using HasBits = decltype(std::declval<PodTemplateSpec>()._impl_._has_bits_);
  static const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& metadata(const PodTemplateSpec* msg);
  static void set_has_metadata(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::k8s::io::api::core::v1::PodSpec& spec(const PodTemplateSpec* msg);
  static void set_has_spec(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta&
PodTemplateSpec::_Internal::metadata(const PodTemplateSpec* msg) {
  return *msg->_impl_.metadata_;
}
const ::k8s::io::api::core::v1::PodSpec&
PodTemplateSpec::_Internal::spec(const PodTemplateSpec* msg) {
  return *msg->_impl_.spec_;
}
void PodTemplateSpec::clear_metadata() {
  if (_impl_.metadata_ != nullptr) _impl_.metadata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
PodTemplateSpec::PodTemplateSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.PodTemplateSpec)
}
PodTemplateSpec::PodTemplateSpec(const PodTemplateSpec& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PodTemplateSpec* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.metadata_){nullptr}
    , decltype(_impl_.spec_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_metadata()) {
    _this->_impl_.metadata_ = new ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta(*from._impl_.metadata_);
  }
  if (from._internal_has_spec()) {
    _this->_impl_.spec_ = new ::k8s::io::api::core::v1::PodSpec(*from._impl_.spec_);
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.PodTemplateSpec)
}

inline void PodTemplateSpec::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.metadata_){nullptr}
    , decltype(_impl_.spec_){nullptr}
  };
}

PodTemplateSpec::~PodTemplateSpec() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.PodTemplateSpec)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PodTemplateSpec::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.metadata_;
  if (this != internal_default_instance()) delete _impl_.spec_;
}

void PodTemplateSpec::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PodTemplateSpec::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.PodTemplateSpec)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.metadata_ != nullptr);
      _impl_.metadata_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.spec_ != nullptr);
      _impl_.spec_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PodTemplateSpec::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_metadata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.PodSpec spec = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_spec(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PodTemplateSpec::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.PodTemplateSpec)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::metadata(this),
        _Internal::metadata(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.PodSpec spec = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::spec(this),
        _Internal::spec(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.PodTemplateSpec)
  return target;
}

size_t PodTemplateSpec::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.PodTemplateSpec)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.metadata_);
    }

    // optional .k8s.io.api.core.v1.PodSpec spec = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.spec_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PodTemplateSpec::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PodTemplateSpec::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PodTemplateSpec::GetClassData() const { return &_class_data_; }


void PodTemplateSpec::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PodTemplateSpec*>(&to_msg);
  auto& from = static_cast<const PodTemplateSpec&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.PodTemplateSpec)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_metadata()->::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta::MergeFrom(
          from._internal_metadata());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_spec()->::k8s::io::api::core::v1::PodSpec::MergeFrom(
          from._internal_spec());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PodTemplateSpec::CopyFrom(const PodTemplateSpec& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.PodTemplateSpec)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PodTemplateSpec::IsInitialized() const {
  return true;
}

void PodTemplateSpec::InternalSwap(PodTemplateSpec* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PodTemplateSpec, _impl_.spec_)
      + sizeof(PodTemplateSpec::_impl_.spec_)
      - PROTOBUF_FIELD_OFFSET(PodTemplateSpec, _impl_.metadata_)>(
          reinterpret_cast<char*>(&_impl_.metadata_),
          reinterpret_cast<char*>(&other->_impl_.metadata_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PodTemplateSpec::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[172]);
}

// ===================================================================

class PortStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<PortStatus>()._impl_._has_bits_);
  static void set_has_port(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_protocol(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

PortStatus::PortStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.PortStatus)
}
PortStatus::PortStatus(const PortStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PortStatus* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.protocol_){}
    , decltype(_impl_.error_){}
    , decltype(_impl_.port_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.protocol_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.protocol_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_protocol()) {
    _this->_impl_.protocol_.Set(from._internal_protocol(), 
      _this->GetArenaForAllocation());
  }
  _impl_.error_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.error_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_error()) {
    _this->_impl_.error_.Set(from._internal_error(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.port_ = from._impl_.port_;
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.PortStatus)
}

inline void PortStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.protocol_){}
    , decltype(_impl_.error_){}
    , decltype(_impl_.port_){0}
  };
  _impl_.protocol_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.protocol_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.error_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.error_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PortStatus::~PortStatus() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.PortStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PortStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.protocol_.Destroy();
  _impl_.error_.Destroy();
}

void PortStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PortStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.PortStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.protocol_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.error_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.port_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PortStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 port = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_port(&has_bits);
          _impl_.port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes protocol = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_protocol();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes error = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_error();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PortStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.PortStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 port = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_port(), target);
  }

  // optional bytes protocol = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_protocol(), target);
  }

  // optional bytes error = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_error(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.PortStatus)
  return target;
}

size_t PortStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.PortStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bytes protocol = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_protocol());
    }

    // optional bytes error = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_error());
    }

    // optional int32 port = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_port());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PortStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PortStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PortStatus::GetClassData() const { return &_class_data_; }


void PortStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PortStatus*>(&to_msg);
  auto& from = static_cast<const PortStatus&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.PortStatus)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_protocol(from._internal_protocol());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_error(from._internal_error());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.port_ = from._impl_.port_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PortStatus::CopyFrom(const PortStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.PortStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PortStatus::IsInitialized() const {
  return true;
}

void PortStatus::InternalSwap(PortStatus* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.protocol_, lhs_arena,
      &other->_impl_.protocol_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.error_, lhs_arena,
      &other->_impl_.error_, rhs_arena
  );
  swap(_impl_.port_, other->_impl_.port_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PortStatus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[173]);
}

// ===================================================================

class PortworxVolumeSource::_Internal {
 public:
  using HasBits = decltype(std::declval<PortworxVolumeSource>()._impl_._has_bits_);
  static void set_has_volumeid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_fstype(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_readonly(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

PortworxVolumeSource::PortworxVolumeSource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.PortworxVolumeSource)
}
PortworxVolumeSource::PortworxVolumeSource(const PortworxVolumeSource& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PortworxVolumeSource* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.volumeid_){}
    , decltype(_impl_.fstype_){}
    , decltype(_impl_.readonly_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.volumeid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.volumeid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_volumeid()) {
    _this->_impl_.volumeid_.Set(from._internal_volumeid(), 
      _this->GetArenaForAllocation());
  }
  _impl_.fstype_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fstype_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_fstype()) {
    _this->_impl_.fstype_.Set(from._internal_fstype(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.readonly_ = from._impl_.readonly_;
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.PortworxVolumeSource)
}

inline void PortworxVolumeSource::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.volumeid_){}
    , decltype(_impl_.fstype_){}
    , decltype(_impl_.readonly_){false}
  };
  _impl_.volumeid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.volumeid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.fstype_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fstype_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PortworxVolumeSource::~PortworxVolumeSource() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.PortworxVolumeSource)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PortworxVolumeSource::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.volumeid_.Destroy();
  _impl_.fstype_.Destroy();
}

void PortworxVolumeSource::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PortworxVolumeSource::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.PortworxVolumeSource)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.volumeid_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.fstype_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.readonly_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PortworxVolumeSource::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes volumeID = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_volumeid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes fsType = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_fstype();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool readOnly = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_readonly(&has_bits);
          _impl_.readonly_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PortworxVolumeSource::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.PortworxVolumeSource)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes volumeID = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_volumeid(), target);
  }

  // optional bytes fsType = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_fstype(), target);
  }

  // optional bool readOnly = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_readonly(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.PortworxVolumeSource)
  return target;
}

size_t PortworxVolumeSource::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.PortworxVolumeSource)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bytes volumeID = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_volumeid());
    }

    // optional bytes fsType = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_fstype());
    }

    // optional bool readOnly = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PortworxVolumeSource::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PortworxVolumeSource::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PortworxVolumeSource::GetClassData() const { return &_class_data_; }


void PortworxVolumeSource::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PortworxVolumeSource*>(&to_msg);
  auto& from = static_cast<const PortworxVolumeSource&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.PortworxVolumeSource)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_volumeid(from._internal_volumeid());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_fstype(from._internal_fstype());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.readonly_ = from._impl_.readonly_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PortworxVolumeSource::CopyFrom(const PortworxVolumeSource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.PortworxVolumeSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PortworxVolumeSource::IsInitialized() const {
  return true;
}

void PortworxVolumeSource::InternalSwap(PortworxVolumeSource* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.volumeid_, lhs_arena,
      &other->_impl_.volumeid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.fstype_, lhs_arena,
      &other->_impl_.fstype_, rhs_arena
  );
  swap(_impl_.readonly_, other->_impl_.readonly_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PortworxVolumeSource::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[174]);
}

// ===================================================================

class Preconditions::_Internal {
 public:
  using HasBits = decltype(std::declval<Preconditions>()._impl_._has_bits_);
  static void set_has_uid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

Preconditions::Preconditions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.Preconditions)
}
Preconditions::Preconditions(const Preconditions& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Preconditions* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.uid_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.uid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.uid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_uid()) {
    _this->_impl_.uid_.Set(from._internal_uid(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.Preconditions)
}

inline void Preconditions::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.uid_){}
  };
  _impl_.uid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.uid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Preconditions::~Preconditions() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.Preconditions)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Preconditions::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.uid_.Destroy();
}

void Preconditions::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Preconditions::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.Preconditions)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.uid_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Preconditions::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes uid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_uid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Preconditions::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.Preconditions)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes uid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_uid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.Preconditions)
  return target;
}

size_t Preconditions::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.Preconditions)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes uid = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_uid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Preconditions::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Preconditions::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Preconditions::GetClassData() const { return &_class_data_; }


void Preconditions::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Preconditions*>(&to_msg);
  auto& from = static_cast<const Preconditions&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.Preconditions)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_uid()) {
    _this->_internal_set_uid(from._internal_uid());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Preconditions::CopyFrom(const Preconditions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.Preconditions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Preconditions::IsInitialized() const {
  return true;
}

void Preconditions::InternalSwap(Preconditions* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.uid_, lhs_arena,
      &other->_impl_.uid_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata Preconditions::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[175]);
}

// ===================================================================

class PreferAvoidPodsEntry::_Internal {
 public:
  using HasBits = decltype(std::declval<PreferAvoidPodsEntry>()._impl_._has_bits_);
  static const ::k8s::io::api::core::v1::PodSignature& podsignature(const PreferAvoidPodsEntry* msg);
  static void set_has_podsignature(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::k8s::io::apimachinery::pkg::apis::meta::v1::Time& evictiontime(const PreferAvoidPodsEntry* msg);
  static void set_has_evictiontime(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_reason(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_message(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::k8s::io::api::core::v1::PodSignature&
PreferAvoidPodsEntry::_Internal::podsignature(const PreferAvoidPodsEntry* msg) {
  return *msg->_impl_.podsignature_;
}
const ::k8s::io::apimachinery::pkg::apis::meta::v1::Time&
PreferAvoidPodsEntry::_Internal::evictiontime(const PreferAvoidPodsEntry* msg) {
  return *msg->_impl_.evictiontime_;
}
void PreferAvoidPodsEntry::clear_evictiontime() {
  if (_impl_.evictiontime_ != nullptr) _impl_.evictiontime_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
PreferAvoidPodsEntry::PreferAvoidPodsEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.PreferAvoidPodsEntry)
}
PreferAvoidPodsEntry::PreferAvoidPodsEntry(const PreferAvoidPodsEntry& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PreferAvoidPodsEntry* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.reason_){}
    , decltype(_impl_.message_){}
    , decltype(_impl_.podsignature_){nullptr}
    , decltype(_impl_.evictiontime_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.reason_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.reason_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_reason()) {
    _this->_impl_.reason_.Set(from._internal_reason(), 
      _this->GetArenaForAllocation());
  }
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_message()) {
    _this->_impl_.message_.Set(from._internal_message(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_podsignature()) {
    _this->_impl_.podsignature_ = new ::k8s::io::api::core::v1::PodSignature(*from._impl_.podsignature_);
  }
  if (from._internal_has_evictiontime()) {
    _this->_impl_.evictiontime_ = new ::k8s::io::apimachinery::pkg::apis::meta::v1::Time(*from._impl_.evictiontime_);
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.PreferAvoidPodsEntry)
}

inline void PreferAvoidPodsEntry::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.reason_){}
    , decltype(_impl_.message_){}
    , decltype(_impl_.podsignature_){nullptr}
    , decltype(_impl_.evictiontime_){nullptr}
  };
  _impl_.reason_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.reason_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PreferAvoidPodsEntry::~PreferAvoidPodsEntry() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.PreferAvoidPodsEntry)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PreferAvoidPodsEntry::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.reason_.Destroy();
  _impl_.message_.Destroy();
  if (this != internal_default_instance()) delete _impl_.podsignature_;
  if (this != internal_default_instance()) delete _impl_.evictiontime_;
}

void PreferAvoidPodsEntry::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PreferAvoidPodsEntry::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.PreferAvoidPodsEntry)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.reason_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.message_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.podsignature_ != nullptr);
      _impl_.podsignature_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.evictiontime_ != nullptr);
      _impl_.evictiontime_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PreferAvoidPodsEntry::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .k8s.io.api.core.v1.PodSignature podSignature = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_podsignature(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time evictionTime = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_evictiontime(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes reason = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_reason();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes message = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PreferAvoidPodsEntry::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.PreferAvoidPodsEntry)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .k8s.io.api.core.v1.PodSignature podSignature = 1;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::podsignature(this),
        _Internal::podsignature(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time evictionTime = 2;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::evictiontime(this),
        _Internal::evictiontime(this).GetCachedSize(), target, stream);
  }

  // optional bytes reason = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_reason(), target);
  }

  // optional bytes message = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_message(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.PreferAvoidPodsEntry)
  return target;
}

size_t PreferAvoidPodsEntry::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.PreferAvoidPodsEntry)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional bytes reason = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_reason());
    }

    // optional bytes message = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_message());
    }

    // optional .k8s.io.api.core.v1.PodSignature podSignature = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.podsignature_);
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time evictionTime = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.evictiontime_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PreferAvoidPodsEntry::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PreferAvoidPodsEntry::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PreferAvoidPodsEntry::GetClassData() const { return &_class_data_; }


void PreferAvoidPodsEntry::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PreferAvoidPodsEntry*>(&to_msg);
  auto& from = static_cast<const PreferAvoidPodsEntry&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.PreferAvoidPodsEntry)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_reason(from._internal_reason());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_message(from._internal_message());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_podsignature()->::k8s::io::api::core::v1::PodSignature::MergeFrom(
          from._internal_podsignature());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_evictiontime()->::k8s::io::apimachinery::pkg::apis::meta::v1::Time::MergeFrom(
          from._internal_evictiontime());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PreferAvoidPodsEntry::CopyFrom(const PreferAvoidPodsEntry& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.PreferAvoidPodsEntry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PreferAvoidPodsEntry::IsInitialized() const {
  return true;
}

void PreferAvoidPodsEntry::InternalSwap(PreferAvoidPodsEntry* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.reason_, lhs_arena,
      &other->_impl_.reason_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.message_, lhs_arena,
      &other->_impl_.message_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PreferAvoidPodsEntry, _impl_.evictiontime_)
      + sizeof(PreferAvoidPodsEntry::_impl_.evictiontime_)
      - PROTOBUF_FIELD_OFFSET(PreferAvoidPodsEntry, _impl_.podsignature_)>(
          reinterpret_cast<char*>(&_impl_.podsignature_),
          reinterpret_cast<char*>(&other->_impl_.podsignature_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PreferAvoidPodsEntry::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[176]);
}

// ===================================================================

class PreferredSchedulingTerm::_Internal {
 public:
  using HasBits = decltype(std::declval<PreferredSchedulingTerm>()._impl_._has_bits_);
  static void set_has_weight(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::k8s::io::api::core::v1::NodeSelectorTerm& preference(const PreferredSchedulingTerm* msg);
  static void set_has_preference(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::k8s::io::api::core::v1::NodeSelectorTerm&
PreferredSchedulingTerm::_Internal::preference(const PreferredSchedulingTerm* msg) {
  return *msg->_impl_.preference_;
}
PreferredSchedulingTerm::PreferredSchedulingTerm(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.PreferredSchedulingTerm)
}
PreferredSchedulingTerm::PreferredSchedulingTerm(const PreferredSchedulingTerm& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PreferredSchedulingTerm* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.preference_){nullptr}
    , decltype(_impl_.weight_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_preference()) {
    _this->_impl_.preference_ = new ::k8s::io::api::core::v1::NodeSelectorTerm(*from._impl_.preference_);
  }
  _this->_impl_.weight_ = from._impl_.weight_;
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.PreferredSchedulingTerm)
}

inline void PreferredSchedulingTerm::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.preference_){nullptr}
    , decltype(_impl_.weight_){0}
  };
}

PreferredSchedulingTerm::~PreferredSchedulingTerm() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.PreferredSchedulingTerm)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PreferredSchedulingTerm::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.preference_;
}

void PreferredSchedulingTerm::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PreferredSchedulingTerm::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.PreferredSchedulingTerm)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.preference_ != nullptr);
    _impl_.preference_->Clear();
  }
  _impl_.weight_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PreferredSchedulingTerm::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 weight = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_weight(&has_bits);
          _impl_.weight_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.NodeSelectorTerm preference = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_preference(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PreferredSchedulingTerm::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.PreferredSchedulingTerm)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 weight = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_weight(), target);
  }

  // optional .k8s.io.api.core.v1.NodeSelectorTerm preference = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::preference(this),
        _Internal::preference(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.PreferredSchedulingTerm)
  return target;
}

size_t PreferredSchedulingTerm::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.PreferredSchedulingTerm)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .k8s.io.api.core.v1.NodeSelectorTerm preference = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.preference_);
    }

    // optional int32 weight = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_weight());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PreferredSchedulingTerm::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PreferredSchedulingTerm::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PreferredSchedulingTerm::GetClassData() const { return &_class_data_; }


void PreferredSchedulingTerm::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PreferredSchedulingTerm*>(&to_msg);
  auto& from = static_cast<const PreferredSchedulingTerm&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.PreferredSchedulingTerm)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_preference()->::k8s::io::api::core::v1::NodeSelectorTerm::MergeFrom(
          from._internal_preference());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.weight_ = from._impl_.weight_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PreferredSchedulingTerm::CopyFrom(const PreferredSchedulingTerm& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.PreferredSchedulingTerm)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PreferredSchedulingTerm::IsInitialized() const {
  return true;
}

void PreferredSchedulingTerm::InternalSwap(PreferredSchedulingTerm* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PreferredSchedulingTerm, _impl_.weight_)
      + sizeof(PreferredSchedulingTerm::_impl_.weight_)
      - PROTOBUF_FIELD_OFFSET(PreferredSchedulingTerm, _impl_.preference_)>(
          reinterpret_cast<char*>(&_impl_.preference_),
          reinterpret_cast<char*>(&other->_impl_.preference_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PreferredSchedulingTerm::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[177]);
}

// ===================================================================

class Probe::_Internal {
 public:
  using HasBits = decltype(std::declval<Probe>()._impl_._has_bits_);
  static const ::k8s::io::api::core::v1::ProbeHandler& handler(const Probe* msg);
  static void set_has_handler(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_initialdelayseconds(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_timeoutseconds(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_periodseconds(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_successthreshold(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_failurethreshold(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_terminationgraceperiodseconds(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

const ::k8s::io::api::core::v1::ProbeHandler&
Probe::_Internal::handler(const Probe* msg) {
  return *msg->_impl_.handler_;
}
Probe::Probe(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.Probe)
}
Probe::Probe(const Probe& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Probe* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.handler_){nullptr}
    , decltype(_impl_.initialdelayseconds_){}
    , decltype(_impl_.timeoutseconds_){}
    , decltype(_impl_.periodseconds_){}
    , decltype(_impl_.successthreshold_){}
    , decltype(_impl_.terminationgraceperiodseconds_){}
    , decltype(_impl_.failurethreshold_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_handler()) {
    _this->_impl_.handler_ = new ::k8s::io::api::core::v1::ProbeHandler(*from._impl_.handler_);
  }
  ::memcpy(&_impl_.initialdelayseconds_, &from._impl_.initialdelayseconds_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.failurethreshold_) -
    reinterpret_cast<char*>(&_impl_.initialdelayseconds_)) + sizeof(_impl_.failurethreshold_));
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.Probe)
}

inline void Probe::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.handler_){nullptr}
    , decltype(_impl_.initialdelayseconds_){0}
    , decltype(_impl_.timeoutseconds_){0}
    , decltype(_impl_.periodseconds_){0}
    , decltype(_impl_.successthreshold_){0}
    , decltype(_impl_.terminationgraceperiodseconds_){int64_t{0}}
    , decltype(_impl_.failurethreshold_){0}
  };
}

Probe::~Probe() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.Probe)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Probe::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.handler_;
}

void Probe::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Probe::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.Probe)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.handler_ != nullptr);
    _impl_.handler_->Clear();
  }
  if (cached_has_bits & 0x0000007eu) {
    ::memset(&_impl_.initialdelayseconds_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.failurethreshold_) -
        reinterpret_cast<char*>(&_impl_.initialdelayseconds_)) + sizeof(_impl_.failurethreshold_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Probe::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .k8s.io.api.core.v1.ProbeHandler handler = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_handler(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 initialDelaySeconds = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_initialdelayseconds(&has_bits);
          _impl_.initialdelayseconds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 timeoutSeconds = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_timeoutseconds(&has_bits);
          _impl_.timeoutseconds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 periodSeconds = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_periodseconds(&has_bits);
          _impl_.periodseconds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 successThreshold = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_successthreshold(&has_bits);
          _impl_.successthreshold_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 failureThreshold = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_failurethreshold(&has_bits);
          _impl_.failurethreshold_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 terminationGracePeriodSeconds = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_terminationgraceperiodseconds(&has_bits);
          _impl_.terminationgraceperiodseconds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Probe::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.Probe)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .k8s.io.api.core.v1.ProbeHandler handler = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::handler(this),
        _Internal::handler(this).GetCachedSize(), target, stream);
  }

  // optional int32 initialDelaySeconds = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_initialdelayseconds(), target);
  }

  // optional int32 timeoutSeconds = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_timeoutseconds(), target);
  }

  // optional int32 periodSeconds = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_periodseconds(), target);
  }

  // optional int32 successThreshold = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_successthreshold(), target);
  }

  // optional int32 failureThreshold = 6;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_failurethreshold(), target);
  }

  // optional int64 terminationGracePeriodSeconds = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(7, this->_internal_terminationgraceperiodseconds(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.Probe)
  return target;
}

size_t Probe::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.Probe)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional .k8s.io.api.core.v1.ProbeHandler handler = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.handler_);
    }

    // optional int32 initialDelaySeconds = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_initialdelayseconds());
    }

    // optional int32 timeoutSeconds = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_timeoutseconds());
    }

    // optional int32 periodSeconds = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_periodseconds());
    }

    // optional int32 successThreshold = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_successthreshold());
    }

    // optional int64 terminationGracePeriodSeconds = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_terminationgraceperiodseconds());
    }

    // optional int32 failureThreshold = 6;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_failurethreshold());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Probe::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Probe::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Probe::GetClassData() const { return &_class_data_; }


void Probe::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Probe*>(&to_msg);
  auto& from = static_cast<const Probe&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.Probe)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_handler()->::k8s::io::api::core::v1::ProbeHandler::MergeFrom(
          from._internal_handler());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.initialdelayseconds_ = from._impl_.initialdelayseconds_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.timeoutseconds_ = from._impl_.timeoutseconds_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.periodseconds_ = from._impl_.periodseconds_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.successthreshold_ = from._impl_.successthreshold_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.terminationgraceperiodseconds_ = from._impl_.terminationgraceperiodseconds_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.failurethreshold_ = from._impl_.failurethreshold_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Probe::CopyFrom(const Probe& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.Probe)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Probe::IsInitialized() const {
  return true;
}

void Probe::InternalSwap(Probe* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Probe, _impl_.failurethreshold_)
      + sizeof(Probe::_impl_.failurethreshold_)
      - PROTOBUF_FIELD_OFFSET(Probe, _impl_.handler_)>(
          reinterpret_cast<char*>(&_impl_.handler_),
          reinterpret_cast<char*>(&other->_impl_.handler_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Probe::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[178]);
}

// ===================================================================

class ProbeHandler::_Internal {
 public:
  using HasBits = decltype(std::declval<ProbeHandler>()._impl_._has_bits_);
  static const ::k8s::io::api::core::v1::ExecAction& exec(const ProbeHandler* msg);
  static void set_has_exec(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::k8s::io::api::core::v1::HTTPGetAction& httpget(const ProbeHandler* msg);
  static void set_has_httpget(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::k8s::io::api::core::v1::TCPSocketAction& tcpsocket(const ProbeHandler* msg);
  static void set_has_tcpsocket(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::k8s::io::api::core::v1::GRPCAction& grpc(const ProbeHandler* msg);
  static void set_has_grpc(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::k8s::io::api::core::v1::ExecAction&
ProbeHandler::_Internal::exec(const ProbeHandler* msg) {
  return *msg->_impl_.exec_;
}
const ::k8s::io::api::core::v1::HTTPGetAction&
ProbeHandler::_Internal::httpget(const ProbeHandler* msg) {
  return *msg->_impl_.httpget_;
}
const ::k8s::io::api::core::v1::TCPSocketAction&
ProbeHandler::_Internal::tcpsocket(const ProbeHandler* msg) {
  return *msg->_impl_.tcpsocket_;
}
const ::k8s::io::api::core::v1::GRPCAction&
ProbeHandler::_Internal::grpc(const ProbeHandler* msg) {
  return *msg->_impl_.grpc_;
}
ProbeHandler::ProbeHandler(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.ProbeHandler)
}
ProbeHandler::ProbeHandler(const ProbeHandler& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ProbeHandler* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.exec_){nullptr}
    , decltype(_impl_.httpget_){nullptr}
    , decltype(_impl_.tcpsocket_){nullptr}
    , decltype(_impl_.grpc_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_exec()) {
    _this->_impl_.exec_ = new ::k8s::io::api::core::v1::ExecAction(*from._impl_.exec_);
  }
  if (from._internal_has_httpget()) {
    _this->_impl_.httpget_ = new ::k8s::io::api::core::v1::HTTPGetAction(*from._impl_.httpget_);
  }
  if (from._internal_has_tcpsocket()) {
    _this->_impl_.tcpsocket_ = new ::k8s::io::api::core::v1::TCPSocketAction(*from._impl_.tcpsocket_);
  }
  if (from._internal_has_grpc()) {
    _this->_impl_.grpc_ = new ::k8s::io::api::core::v1::GRPCAction(*from._impl_.grpc_);
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.ProbeHandler)
}

inline void ProbeHandler::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.exec_){nullptr}
    , decltype(_impl_.httpget_){nullptr}
    , decltype(_impl_.tcpsocket_){nullptr}
    , decltype(_impl_.grpc_){nullptr}
  };
}

ProbeHandler::~ProbeHandler() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.ProbeHandler)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ProbeHandler::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.exec_;
  if (this != internal_default_instance()) delete _impl_.httpget_;
  if (this != internal_default_instance()) delete _impl_.tcpsocket_;
  if (this != internal_default_instance()) delete _impl_.grpc_;
}

void ProbeHandler::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ProbeHandler::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.ProbeHandler)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.exec_ != nullptr);
      _impl_.exec_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.httpget_ != nullptr);
      _impl_.httpget_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.tcpsocket_ != nullptr);
      _impl_.tcpsocket_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.grpc_ != nullptr);
      _impl_.grpc_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ProbeHandler::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .k8s.io.api.core.v1.ExecAction exec = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_exec(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.HTTPGetAction httpGet = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_httpget(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.TCPSocketAction tcpSocket = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_tcpsocket(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.GRPCAction grpc = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_grpc(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ProbeHandler::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.ProbeHandler)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .k8s.io.api.core.v1.ExecAction exec = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::exec(this),
        _Internal::exec(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.HTTPGetAction httpGet = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::httpget(this),
        _Internal::httpget(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.TCPSocketAction tcpSocket = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::tcpsocket(this),
        _Internal::tcpsocket(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.GRPCAction grpc = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::grpc(this),
        _Internal::grpc(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.ProbeHandler)
  return target;
}

size_t ProbeHandler::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.ProbeHandler)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .k8s.io.api.core.v1.ExecAction exec = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.exec_);
    }

    // optional .k8s.io.api.core.v1.HTTPGetAction httpGet = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.httpget_);
    }

    // optional .k8s.io.api.core.v1.TCPSocketAction tcpSocket = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.tcpsocket_);
    }

    // optional .k8s.io.api.core.v1.GRPCAction grpc = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.grpc_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ProbeHandler::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ProbeHandler::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ProbeHandler::GetClassData() const { return &_class_data_; }


void ProbeHandler::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ProbeHandler*>(&to_msg);
  auto& from = static_cast<const ProbeHandler&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.ProbeHandler)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_exec()->::k8s::io::api::core::v1::ExecAction::MergeFrom(
          from._internal_exec());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_httpget()->::k8s::io::api::core::v1::HTTPGetAction::MergeFrom(
          from._internal_httpget());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_tcpsocket()->::k8s::io::api::core::v1::TCPSocketAction::MergeFrom(
          from._internal_tcpsocket());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_grpc()->::k8s::io::api::core::v1::GRPCAction::MergeFrom(
          from._internal_grpc());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ProbeHandler::CopyFrom(const ProbeHandler& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.ProbeHandler)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ProbeHandler::IsInitialized() const {
  return true;
}

void ProbeHandler::InternalSwap(ProbeHandler* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ProbeHandler, _impl_.grpc_)
      + sizeof(ProbeHandler::_impl_.grpc_)
      - PROTOBUF_FIELD_OFFSET(ProbeHandler, _impl_.exec_)>(
          reinterpret_cast<char*>(&_impl_.exec_),
          reinterpret_cast<char*>(&other->_impl_.exec_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ProbeHandler::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[179]);
}

// ===================================================================

class ProjectedVolumeSource::_Internal {
 public:
  using HasBits = decltype(std::declval<ProjectedVolumeSource>()._impl_._has_bits_);
  static void set_has_defaultmode(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ProjectedVolumeSource::ProjectedVolumeSource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.ProjectedVolumeSource)
}
ProjectedVolumeSource::ProjectedVolumeSource(const ProjectedVolumeSource& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ProjectedVolumeSource* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.sources_){from._impl_.sources_}
    , decltype(_impl_.defaultmode_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.defaultmode_ = from._impl_.defaultmode_;
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.ProjectedVolumeSource)
}

inline void ProjectedVolumeSource::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.sources_){arena}
    , decltype(_impl_.defaultmode_){0}
  };
}

ProjectedVolumeSource::~ProjectedVolumeSource() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.ProjectedVolumeSource)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ProjectedVolumeSource::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.sources_.~RepeatedPtrField();
}

void ProjectedVolumeSource::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ProjectedVolumeSource::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.ProjectedVolumeSource)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.sources_.Clear();
  _impl_.defaultmode_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ProjectedVolumeSource::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .k8s.io.api.core.v1.VolumeProjection sources = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_sources(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional int32 defaultMode = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_defaultmode(&has_bits);
          _impl_.defaultmode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ProjectedVolumeSource::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.ProjectedVolumeSource)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .k8s.io.api.core.v1.VolumeProjection sources = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_sources_size()); i < n; i++) {
    const auto& repfield = this->_internal_sources(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 defaultMode = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_defaultmode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.ProjectedVolumeSource)
  return target;
}

size_t ProjectedVolumeSource::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.ProjectedVolumeSource)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .k8s.io.api.core.v1.VolumeProjection sources = 1;
  total_size += 1UL * this->_internal_sources_size();
  for (const auto& msg : this->_impl_.sources_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional int32 defaultMode = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_defaultmode());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ProjectedVolumeSource::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ProjectedVolumeSource::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ProjectedVolumeSource::GetClassData() const { return &_class_data_; }


void ProjectedVolumeSource::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ProjectedVolumeSource*>(&to_msg);
  auto& from = static_cast<const ProjectedVolumeSource&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.ProjectedVolumeSource)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.sources_.MergeFrom(from._impl_.sources_);
  if (from._internal_has_defaultmode()) {
    _this->_internal_set_defaultmode(from._internal_defaultmode());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ProjectedVolumeSource::CopyFrom(const ProjectedVolumeSource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.ProjectedVolumeSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ProjectedVolumeSource::IsInitialized() const {
  return true;
}

void ProjectedVolumeSource::InternalSwap(ProjectedVolumeSource* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.sources_.InternalSwap(&other->_impl_.sources_);
  swap(_impl_.defaultmode_, other->_impl_.defaultmode_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ProjectedVolumeSource::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[180]);
}

// ===================================================================

class QuobyteVolumeSource::_Internal {
 public:
  using HasBits = decltype(std::declval<QuobyteVolumeSource>()._impl_._has_bits_);
  static void set_has_registry(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_volume(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_readonly(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_user(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_group(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_tenant(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

QuobyteVolumeSource::QuobyteVolumeSource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.QuobyteVolumeSource)
}
QuobyteVolumeSource::QuobyteVolumeSource(const QuobyteVolumeSource& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  QuobyteVolumeSource* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.registry_){}
    , decltype(_impl_.volume_){}
    , decltype(_impl_.user_){}
    , decltype(_impl_.group_){}
    , decltype(_impl_.tenant_){}
    , decltype(_impl_.readonly_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.registry_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.registry_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_registry()) {
    _this->_impl_.registry_.Set(from._internal_registry(), 
      _this->GetArenaForAllocation());
  }
  _impl_.volume_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.volume_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_volume()) {
    _this->_impl_.volume_.Set(from._internal_volume(), 
      _this->GetArenaForAllocation());
  }
  _impl_.user_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_user()) {
    _this->_impl_.user_.Set(from._internal_user(), 
      _this->GetArenaForAllocation());
  }
  _impl_.group_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.group_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_group()) {
    _this->_impl_.group_.Set(from._internal_group(), 
      _this->GetArenaForAllocation());
  }
  _impl_.tenant_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tenant_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_tenant()) {
    _this->_impl_.tenant_.Set(from._internal_tenant(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.readonly_ = from._impl_.readonly_;
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.QuobyteVolumeSource)
}

inline void QuobyteVolumeSource::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.registry_){}
    , decltype(_impl_.volume_){}
    , decltype(_impl_.user_){}
    , decltype(_impl_.group_){}
    , decltype(_impl_.tenant_){}
    , decltype(_impl_.readonly_){false}
  };
  _impl_.registry_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.registry_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.volume_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.volume_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.user_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.group_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.group_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.tenant_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tenant_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

QuobyteVolumeSource::~QuobyteVolumeSource() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.QuobyteVolumeSource)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void QuobyteVolumeSource::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.registry_.Destroy();
  _impl_.volume_.Destroy();
  _impl_.user_.Destroy();
  _impl_.group_.Destroy();
  _impl_.tenant_.Destroy();
}

void QuobyteVolumeSource::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void QuobyteVolumeSource::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.QuobyteVolumeSource)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.registry_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.volume_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.user_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.group_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.tenant_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.readonly_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* QuobyteVolumeSource::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes registry = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_registry();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes volume = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_volume();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool readOnly = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_readonly(&has_bits);
          _impl_.readonly_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes user = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_user();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes group = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_group();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes tenant = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_tenant();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* QuobyteVolumeSource::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.QuobyteVolumeSource)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes registry = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_registry(), target);
  }

  // optional bytes volume = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_volume(), target);
  }

  // optional bool readOnly = 3;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_readonly(), target);
  }

  // optional bytes user = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_user(), target);
  }

  // optional bytes group = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_group(), target);
  }

  // optional bytes tenant = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteBytesMaybeAliased(
        6, this->_internal_tenant(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.QuobyteVolumeSource)
  return target;
}

size_t QuobyteVolumeSource::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.QuobyteVolumeSource)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional bytes registry = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_registry());
    }

    // optional bytes volume = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_volume());
    }

    // optional bytes user = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_user());
    }

    // optional bytes group = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_group());
    }

    // optional bytes tenant = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_tenant());
    }

    // optional bool readOnly = 3;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData QuobyteVolumeSource::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    QuobyteVolumeSource::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*QuobyteVolumeSource::GetClassData() const { return &_class_data_; }


void QuobyteVolumeSource::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<QuobyteVolumeSource*>(&to_msg);
  auto& from = static_cast<const QuobyteVolumeSource&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.QuobyteVolumeSource)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_registry(from._internal_registry());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_volume(from._internal_volume());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_user(from._internal_user());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_group(from._internal_group());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_tenant(from._internal_tenant());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.readonly_ = from._impl_.readonly_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void QuobyteVolumeSource::CopyFrom(const QuobyteVolumeSource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.QuobyteVolumeSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool QuobyteVolumeSource::IsInitialized() const {
  return true;
}

void QuobyteVolumeSource::InternalSwap(QuobyteVolumeSource* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.registry_, lhs_arena,
      &other->_impl_.registry_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.volume_, lhs_arena,
      &other->_impl_.volume_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.user_, lhs_arena,
      &other->_impl_.user_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.group_, lhs_arena,
      &other->_impl_.group_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.tenant_, lhs_arena,
      &other->_impl_.tenant_, rhs_arena
  );
  swap(_impl_.readonly_, other->_impl_.readonly_);
}

::PROTOBUF_NAMESPACE_ID::Metadata QuobyteVolumeSource::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[181]);
}

// ===================================================================

class RBDPersistentVolumeSource::_Internal {
 public:
  using HasBits = decltype(std::declval<RBDPersistentVolumeSource>()._impl_._has_bits_);
  static void set_has_image(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_fstype(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_pool(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_user(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_keyring(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::k8s::io::api::core::v1::SecretReference& secretref(const RBDPersistentVolumeSource* msg);
  static void set_has_secretref(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_readonly(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

const ::k8s::io::api::core::v1::SecretReference&
RBDPersistentVolumeSource::_Internal::secretref(const RBDPersistentVolumeSource* msg) {
  return *msg->_impl_.secretref_;
}
RBDPersistentVolumeSource::RBDPersistentVolumeSource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.RBDPersistentVolumeSource)
}
RBDPersistentVolumeSource::RBDPersistentVolumeSource(const RBDPersistentVolumeSource& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RBDPersistentVolumeSource* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.monitors_){from._impl_.monitors_}
    , decltype(_impl_.image_){}
    , decltype(_impl_.fstype_){}
    , decltype(_impl_.pool_){}
    , decltype(_impl_.user_){}
    , decltype(_impl_.keyring_){}
    , decltype(_impl_.secretref_){nullptr}
    , decltype(_impl_.readonly_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.image_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.image_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_image()) {
    _this->_impl_.image_.Set(from._internal_image(), 
      _this->GetArenaForAllocation());
  }
  _impl_.fstype_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fstype_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_fstype()) {
    _this->_impl_.fstype_.Set(from._internal_fstype(), 
      _this->GetArenaForAllocation());
  }
  _impl_.pool_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pool_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_pool()) {
    _this->_impl_.pool_.Set(from._internal_pool(), 
      _this->GetArenaForAllocation());
  }
  _impl_.user_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_user()) {
    _this->_impl_.user_.Set(from._internal_user(), 
      _this->GetArenaForAllocation());
  }
  _impl_.keyring_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.keyring_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_keyring()) {
    _this->_impl_.keyring_.Set(from._internal_keyring(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_secretref()) {
    _this->_impl_.secretref_ = new ::k8s::io::api::core::v1::SecretReference(*from._impl_.secretref_);
  }
  _this->_impl_.readonly_ = from._impl_.readonly_;
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.RBDPersistentVolumeSource)
}

inline void RBDPersistentVolumeSource::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.monitors_){arena}
    , decltype(_impl_.image_){}
    , decltype(_impl_.fstype_){}
    , decltype(_impl_.pool_){}
    , decltype(_impl_.user_){}
    , decltype(_impl_.keyring_){}
    , decltype(_impl_.secretref_){nullptr}
    , decltype(_impl_.readonly_){false}
  };
  _impl_.image_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.image_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.fstype_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fstype_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.pool_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pool_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.user_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.keyring_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.keyring_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

RBDPersistentVolumeSource::~RBDPersistentVolumeSource() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.RBDPersistentVolumeSource)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RBDPersistentVolumeSource::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.monitors_.~RepeatedPtrField();
  _impl_.image_.Destroy();
  _impl_.fstype_.Destroy();
  _impl_.pool_.Destroy();
  _impl_.user_.Destroy();
  _impl_.keyring_.Destroy();
  if (this != internal_default_instance()) delete _impl_.secretref_;
}

void RBDPersistentVolumeSource::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RBDPersistentVolumeSource::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.RBDPersistentVolumeSource)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.monitors_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.image_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.fstype_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.pool_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.user_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.keyring_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.secretref_ != nullptr);
      _impl_.secretref_->Clear();
    }
  }
  _impl_.readonly_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RBDPersistentVolumeSource::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string monitors = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_monitors();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "k8s.io.api.core.v1.RBDPersistentVolumeSource.monitors");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bytes image = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_image();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes fsType = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_fstype();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes pool = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_pool();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes user = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_user();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes keyring = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_keyring();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.SecretReference secretRef = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_secretref(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool readOnly = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_readonly(&has_bits);
          _impl_.readonly_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RBDPersistentVolumeSource::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.RBDPersistentVolumeSource)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string monitors = 1;
  for (int i = 0, n = this->_internal_monitors_size(); i < n; i++) {
    const auto& s = this->_internal_monitors(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "k8s.io.api.core.v1.RBDPersistentVolumeSource.monitors");
    target = stream->WriteString(1, s, target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes image = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_image(), target);
  }

  // optional bytes fsType = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_fstype(), target);
  }

  // optional bytes pool = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_pool(), target);
  }

  // optional bytes user = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_user(), target);
  }

  // optional bytes keyring = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteBytesMaybeAliased(
        6, this->_internal_keyring(), target);
  }

  // optional .k8s.io.api.core.v1.SecretReference secretRef = 7;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::secretref(this),
        _Internal::secretref(this).GetCachedSize(), target, stream);
  }

  // optional bool readOnly = 8;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_readonly(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.RBDPersistentVolumeSource)
  return target;
}

size_t RBDPersistentVolumeSource::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.RBDPersistentVolumeSource)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string monitors = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.monitors_.size());
  for (int i = 0, n = _impl_.monitors_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.monitors_.Get(i));
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional bytes image = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_image());
    }

    // optional bytes fsType = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_fstype());
    }

    // optional bytes pool = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_pool());
    }

    // optional bytes user = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_user());
    }

    // optional bytes keyring = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_keyring());
    }

    // optional .k8s.io.api.core.v1.SecretReference secretRef = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.secretref_);
    }

    // optional bool readOnly = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RBDPersistentVolumeSource::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RBDPersistentVolumeSource::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RBDPersistentVolumeSource::GetClassData() const { return &_class_data_; }


void RBDPersistentVolumeSource::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RBDPersistentVolumeSource*>(&to_msg);
  auto& from = static_cast<const RBDPersistentVolumeSource&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.RBDPersistentVolumeSource)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.monitors_.MergeFrom(from._impl_.monitors_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_image(from._internal_image());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_fstype(from._internal_fstype());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_pool(from._internal_pool());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_user(from._internal_user());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_keyring(from._internal_keyring());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_secretref()->::k8s::io::api::core::v1::SecretReference::MergeFrom(
          from._internal_secretref());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.readonly_ = from._impl_.readonly_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RBDPersistentVolumeSource::CopyFrom(const RBDPersistentVolumeSource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.RBDPersistentVolumeSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RBDPersistentVolumeSource::IsInitialized() const {
  return true;
}

void RBDPersistentVolumeSource::InternalSwap(RBDPersistentVolumeSource* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.monitors_.InternalSwap(&other->_impl_.monitors_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.image_, lhs_arena,
      &other->_impl_.image_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.fstype_, lhs_arena,
      &other->_impl_.fstype_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.pool_, lhs_arena,
      &other->_impl_.pool_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.user_, lhs_arena,
      &other->_impl_.user_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.keyring_, lhs_arena,
      &other->_impl_.keyring_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RBDPersistentVolumeSource, _impl_.readonly_)
      + sizeof(RBDPersistentVolumeSource::_impl_.readonly_)
      - PROTOBUF_FIELD_OFFSET(RBDPersistentVolumeSource, _impl_.secretref_)>(
          reinterpret_cast<char*>(&_impl_.secretref_),
          reinterpret_cast<char*>(&other->_impl_.secretref_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RBDPersistentVolumeSource::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[182]);
}

// ===================================================================

class RBDVolumeSource::_Internal {
 public:
  using HasBits = decltype(std::declval<RBDVolumeSource>()._impl_._has_bits_);
  static void set_has_image(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_fstype(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_pool(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_user(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_keyring(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::k8s::io::api::core::v1::LocalObjectReference& secretref(const RBDVolumeSource* msg);
  static void set_has_secretref(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_readonly(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

const ::k8s::io::api::core::v1::LocalObjectReference&
RBDVolumeSource::_Internal::secretref(const RBDVolumeSource* msg) {
  return *msg->_impl_.secretref_;
}
RBDVolumeSource::RBDVolumeSource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.RBDVolumeSource)
}
RBDVolumeSource::RBDVolumeSource(const RBDVolumeSource& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RBDVolumeSource* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.monitors_){from._impl_.monitors_}
    , decltype(_impl_.image_){}
    , decltype(_impl_.fstype_){}
    , decltype(_impl_.pool_){}
    , decltype(_impl_.user_){}
    , decltype(_impl_.keyring_){}
    , decltype(_impl_.secretref_){nullptr}
    , decltype(_impl_.readonly_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.image_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.image_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_image()) {
    _this->_impl_.image_.Set(from._internal_image(), 
      _this->GetArenaForAllocation());
  }
  _impl_.fstype_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fstype_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_fstype()) {
    _this->_impl_.fstype_.Set(from._internal_fstype(), 
      _this->GetArenaForAllocation());
  }
  _impl_.pool_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pool_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_pool()) {
    _this->_impl_.pool_.Set(from._internal_pool(), 
      _this->GetArenaForAllocation());
  }
  _impl_.user_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_user()) {
    _this->_impl_.user_.Set(from._internal_user(), 
      _this->GetArenaForAllocation());
  }
  _impl_.keyring_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.keyring_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_keyring()) {
    _this->_impl_.keyring_.Set(from._internal_keyring(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_secretref()) {
    _this->_impl_.secretref_ = new ::k8s::io::api::core::v1::LocalObjectReference(*from._impl_.secretref_);
  }
  _this->_impl_.readonly_ = from._impl_.readonly_;
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.RBDVolumeSource)
}

inline void RBDVolumeSource::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.monitors_){arena}
    , decltype(_impl_.image_){}
    , decltype(_impl_.fstype_){}
    , decltype(_impl_.pool_){}
    , decltype(_impl_.user_){}
    , decltype(_impl_.keyring_){}
    , decltype(_impl_.secretref_){nullptr}
    , decltype(_impl_.readonly_){false}
  };
  _impl_.image_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.image_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.fstype_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fstype_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.pool_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pool_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.user_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.keyring_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.keyring_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

RBDVolumeSource::~RBDVolumeSource() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.RBDVolumeSource)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RBDVolumeSource::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.monitors_.~RepeatedPtrField();
  _impl_.image_.Destroy();
  _impl_.fstype_.Destroy();
  _impl_.pool_.Destroy();
  _impl_.user_.Destroy();
  _impl_.keyring_.Destroy();
  if (this != internal_default_instance()) delete _impl_.secretref_;
}

void RBDVolumeSource::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RBDVolumeSource::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.RBDVolumeSource)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.monitors_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.image_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.fstype_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.pool_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.user_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.keyring_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.secretref_ != nullptr);
      _impl_.secretref_->Clear();
    }
  }
  _impl_.readonly_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RBDVolumeSource::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string monitors = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_monitors();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "k8s.io.api.core.v1.RBDVolumeSource.monitors");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bytes image = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_image();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes fsType = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_fstype();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes pool = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_pool();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes user = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_user();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes keyring = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_keyring();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.LocalObjectReference secretRef = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_secretref(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool readOnly = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_readonly(&has_bits);
          _impl_.readonly_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RBDVolumeSource::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.RBDVolumeSource)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string monitors = 1;
  for (int i = 0, n = this->_internal_monitors_size(); i < n; i++) {
    const auto& s = this->_internal_monitors(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "k8s.io.api.core.v1.RBDVolumeSource.monitors");
    target = stream->WriteString(1, s, target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes image = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_image(), target);
  }

  // optional bytes fsType = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_fstype(), target);
  }

  // optional bytes pool = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_pool(), target);
  }

  // optional bytes user = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_user(), target);
  }

  // optional bytes keyring = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteBytesMaybeAliased(
        6, this->_internal_keyring(), target);
  }

  // optional .k8s.io.api.core.v1.LocalObjectReference secretRef = 7;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::secretref(this),
        _Internal::secretref(this).GetCachedSize(), target, stream);
  }

  // optional bool readOnly = 8;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_readonly(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.RBDVolumeSource)
  return target;
}

size_t RBDVolumeSource::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.RBDVolumeSource)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string monitors = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.monitors_.size());
  for (int i = 0, n = _impl_.monitors_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.monitors_.Get(i));
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional bytes image = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_image());
    }

    // optional bytes fsType = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_fstype());
    }

    // optional bytes pool = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_pool());
    }

    // optional bytes user = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_user());
    }

    // optional bytes keyring = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_keyring());
    }

    // optional .k8s.io.api.core.v1.LocalObjectReference secretRef = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.secretref_);
    }

    // optional bool readOnly = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RBDVolumeSource::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RBDVolumeSource::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RBDVolumeSource::GetClassData() const { return &_class_data_; }


void RBDVolumeSource::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RBDVolumeSource*>(&to_msg);
  auto& from = static_cast<const RBDVolumeSource&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.RBDVolumeSource)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.monitors_.MergeFrom(from._impl_.monitors_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_image(from._internal_image());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_fstype(from._internal_fstype());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_pool(from._internal_pool());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_user(from._internal_user());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_keyring(from._internal_keyring());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_secretref()->::k8s::io::api::core::v1::LocalObjectReference::MergeFrom(
          from._internal_secretref());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.readonly_ = from._impl_.readonly_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RBDVolumeSource::CopyFrom(const RBDVolumeSource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.RBDVolumeSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RBDVolumeSource::IsInitialized() const {
  return true;
}

void RBDVolumeSource::InternalSwap(RBDVolumeSource* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.monitors_.InternalSwap(&other->_impl_.monitors_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.image_, lhs_arena,
      &other->_impl_.image_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.fstype_, lhs_arena,
      &other->_impl_.fstype_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.pool_, lhs_arena,
      &other->_impl_.pool_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.user_, lhs_arena,
      &other->_impl_.user_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.keyring_, lhs_arena,
      &other->_impl_.keyring_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RBDVolumeSource, _impl_.readonly_)
      + sizeof(RBDVolumeSource::_impl_.readonly_)
      - PROTOBUF_FIELD_OFFSET(RBDVolumeSource, _impl_.secretref_)>(
          reinterpret_cast<char*>(&_impl_.secretref_),
          reinterpret_cast<char*>(&other->_impl_.secretref_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RBDVolumeSource::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[183]);
}

// ===================================================================

class RangeAllocation::_Internal {
 public:
  using HasBits = decltype(std::declval<RangeAllocation>()._impl_._has_bits_);
  static const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& metadata(const RangeAllocation* msg);
  static void set_has_metadata(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_range(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_data(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta&
RangeAllocation::_Internal::metadata(const RangeAllocation* msg) {
  return *msg->_impl_.metadata_;
}
void RangeAllocation::clear_metadata() {
  if (_impl_.metadata_ != nullptr) _impl_.metadata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
RangeAllocation::RangeAllocation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.RangeAllocation)
}
RangeAllocation::RangeAllocation(const RangeAllocation& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RangeAllocation* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.range_){}
    , decltype(_impl_.data_){}
    , decltype(_impl_.metadata_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.range_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.range_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_range()) {
    _this->_impl_.range_.Set(from._internal_range(), 
      _this->GetArenaForAllocation());
  }
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_data()) {
    _this->_impl_.data_.Set(from._internal_data(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_metadata()) {
    _this->_impl_.metadata_ = new ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta(*from._impl_.metadata_);
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.RangeAllocation)
}

inline void RangeAllocation::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.range_){}
    , decltype(_impl_.data_){}
    , decltype(_impl_.metadata_){nullptr}
  };
  _impl_.range_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.range_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

RangeAllocation::~RangeAllocation() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.RangeAllocation)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RangeAllocation::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.range_.Destroy();
  _impl_.data_.Destroy();
  if (this != internal_default_instance()) delete _impl_.metadata_;
}

void RangeAllocation::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RangeAllocation::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.RangeAllocation)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.range_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.data_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.metadata_ != nullptr);
      _impl_.metadata_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RangeAllocation::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_metadata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes range = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_range();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes data = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RangeAllocation::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.RangeAllocation)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::metadata(this),
        _Internal::metadata(this).GetCachedSize(), target, stream);
  }

  // optional bytes range = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_range(), target);
  }

  // optional bytes data = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.RangeAllocation)
  return target;
}

size_t RangeAllocation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.RangeAllocation)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bytes range = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_range());
    }

    // optional bytes data = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_data());
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.metadata_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RangeAllocation::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RangeAllocation::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RangeAllocation::GetClassData() const { return &_class_data_; }


void RangeAllocation::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RangeAllocation*>(&to_msg);
  auto& from = static_cast<const RangeAllocation&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.RangeAllocation)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_range(from._internal_range());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_data(from._internal_data());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_metadata()->::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta::MergeFrom(
          from._internal_metadata());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RangeAllocation::CopyFrom(const RangeAllocation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.RangeAllocation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RangeAllocation::IsInitialized() const {
  return true;
}

void RangeAllocation::InternalSwap(RangeAllocation* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.range_, lhs_arena,
      &other->_impl_.range_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.data_, lhs_arena,
      &other->_impl_.data_, rhs_arena
  );
  swap(_impl_.metadata_, other->_impl_.metadata_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RangeAllocation::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[184]);
}

// ===================================================================

class ReplicationController::_Internal {
 public:
  using HasBits = decltype(std::declval<ReplicationController>()._impl_._has_bits_);
  static const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& metadata(const ReplicationController* msg);
  static void set_has_metadata(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::k8s::io::api::core::v1::ReplicationControllerSpec& spec(const ReplicationController* msg);
  static void set_has_spec(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::k8s::io::api::core::v1::ReplicationControllerStatus& status(const ReplicationController* msg);
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta&
ReplicationController::_Internal::metadata(const ReplicationController* msg) {
  return *msg->_impl_.metadata_;
}
const ::k8s::io::api::core::v1::ReplicationControllerSpec&
ReplicationController::_Internal::spec(const ReplicationController* msg) {
  return *msg->_impl_.spec_;
}
const ::k8s::io::api::core::v1::ReplicationControllerStatus&
ReplicationController::_Internal::status(const ReplicationController* msg) {
  return *msg->_impl_.status_;
}
void ReplicationController::clear_metadata() {
  if (_impl_.metadata_ != nullptr) _impl_.metadata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
ReplicationController::ReplicationController(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.ReplicationController)
}
ReplicationController::ReplicationController(const ReplicationController& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ReplicationController* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.metadata_){nullptr}
    , decltype(_impl_.spec_){nullptr}
    , decltype(_impl_.status_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_metadata()) {
    _this->_impl_.metadata_ = new ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta(*from._impl_.metadata_);
  }
  if (from._internal_has_spec()) {
    _this->_impl_.spec_ = new ::k8s::io::api::core::v1::ReplicationControllerSpec(*from._impl_.spec_);
  }
  if (from._internal_has_status()) {
    _this->_impl_.status_ = new ::k8s::io::api::core::v1::ReplicationControllerStatus(*from._impl_.status_);
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.ReplicationController)
}

inline void ReplicationController::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.metadata_){nullptr}
    , decltype(_impl_.spec_){nullptr}
    , decltype(_impl_.status_){nullptr}
  };
}

ReplicationController::~ReplicationController() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.ReplicationController)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReplicationController::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.metadata_;
  if (this != internal_default_instance()) delete _impl_.spec_;
  if (this != internal_default_instance()) delete _impl_.status_;
}

void ReplicationController::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReplicationController::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.ReplicationController)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.metadata_ != nullptr);
      _impl_.metadata_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.spec_ != nullptr);
      _impl_.spec_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.status_ != nullptr);
      _impl_.status_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ReplicationController::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_metadata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.ReplicationControllerSpec spec = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_spec(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.ReplicationControllerStatus status = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_status(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReplicationController::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.ReplicationController)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::metadata(this),
        _Internal::metadata(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.ReplicationControllerSpec spec = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::spec(this),
        _Internal::spec(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.ReplicationControllerStatus status = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::status(this),
        _Internal::status(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.ReplicationController)
  return target;
}

size_t ReplicationController::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.ReplicationController)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.metadata_);
    }

    // optional .k8s.io.api.core.v1.ReplicationControllerSpec spec = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.spec_);
    }

    // optional .k8s.io.api.core.v1.ReplicationControllerStatus status = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.status_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReplicationController::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ReplicationController::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReplicationController::GetClassData() const { return &_class_data_; }


void ReplicationController::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ReplicationController*>(&to_msg);
  auto& from = static_cast<const ReplicationController&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.ReplicationController)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_metadata()->::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta::MergeFrom(
          from._internal_metadata());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_spec()->::k8s::io::api::core::v1::ReplicationControllerSpec::MergeFrom(
          from._internal_spec());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_status()->::k8s::io::api::core::v1::ReplicationControllerStatus::MergeFrom(
          from._internal_status());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ReplicationController::CopyFrom(const ReplicationController& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.ReplicationController)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReplicationController::IsInitialized() const {
  return true;
}

void ReplicationController::InternalSwap(ReplicationController* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ReplicationController, _impl_.status_)
      + sizeof(ReplicationController::_impl_.status_)
      - PROTOBUF_FIELD_OFFSET(ReplicationController, _impl_.metadata_)>(
          reinterpret_cast<char*>(&_impl_.metadata_),
          reinterpret_cast<char*>(&other->_impl_.metadata_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ReplicationController::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[185]);
}

// ===================================================================

class ReplicationControllerCondition::_Internal {
 public:
  using HasBits = decltype(std::declval<ReplicationControllerCondition>()._impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::k8s::io::apimachinery::pkg::apis::meta::v1::Time& lasttransitiontime(const ReplicationControllerCondition* msg);
  static void set_has_lasttransitiontime(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_reason(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_message(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::k8s::io::apimachinery::pkg::apis::meta::v1::Time&
ReplicationControllerCondition::_Internal::lasttransitiontime(const ReplicationControllerCondition* msg) {
  return *msg->_impl_.lasttransitiontime_;
}
void ReplicationControllerCondition::clear_lasttransitiontime() {
  if (_impl_.lasttransitiontime_ != nullptr) _impl_.lasttransitiontime_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
ReplicationControllerCondition::ReplicationControllerCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.ReplicationControllerCondition)
}
ReplicationControllerCondition::ReplicationControllerCondition(const ReplicationControllerCondition& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ReplicationControllerCondition* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.type_){}
    , decltype(_impl_.status_){}
    , decltype(_impl_.reason_){}
    , decltype(_impl_.message_){}
    , decltype(_impl_.lasttransitiontime_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_type()) {
    _this->_impl_.type_.Set(from._internal_type(), 
      _this->GetArenaForAllocation());
  }
  _impl_.status_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.status_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_status()) {
    _this->_impl_.status_.Set(from._internal_status(), 
      _this->GetArenaForAllocation());
  }
  _impl_.reason_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.reason_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_reason()) {
    _this->_impl_.reason_.Set(from._internal_reason(), 
      _this->GetArenaForAllocation());
  }
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_message()) {
    _this->_impl_.message_.Set(from._internal_message(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_lasttransitiontime()) {
    _this->_impl_.lasttransitiontime_ = new ::k8s::io::apimachinery::pkg::apis::meta::v1::Time(*from._impl_.lasttransitiontime_);
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.ReplicationControllerCondition)
}

inline void ReplicationControllerCondition::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.type_){}
    , decltype(_impl_.status_){}
    , decltype(_impl_.reason_){}
    , decltype(_impl_.message_){}
    , decltype(_impl_.lasttransitiontime_){nullptr}
  };
  _impl_.type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.status_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.status_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.reason_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.reason_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ReplicationControllerCondition::~ReplicationControllerCondition() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.ReplicationControllerCondition)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReplicationControllerCondition::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.type_.Destroy();
  _impl_.status_.Destroy();
  _impl_.reason_.Destroy();
  _impl_.message_.Destroy();
  if (this != internal_default_instance()) delete _impl_.lasttransitiontime_;
}

void ReplicationControllerCondition::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReplicationControllerCondition::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.ReplicationControllerCondition)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.type_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.status_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.reason_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.message_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.lasttransitiontime_ != nullptr);
      _impl_.lasttransitiontime_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ReplicationControllerCondition::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes status = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_status();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_lasttransitiontime(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes reason = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_reason();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes message = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReplicationControllerCondition::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.ReplicationControllerCondition)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_type(), target);
  }

  // optional bytes status = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_status(), target);
  }

  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::lasttransitiontime(this),
        _Internal::lasttransitiontime(this).GetCachedSize(), target, stream);
  }

  // optional bytes reason = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_reason(), target);
  }

  // optional bytes message = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_message(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.ReplicationControllerCondition)
  return target;
}

size_t ReplicationControllerCondition::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.ReplicationControllerCondition)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional bytes type = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_type());
    }

    // optional bytes status = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_status());
    }

    // optional bytes reason = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_reason());
    }

    // optional bytes message = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_message());
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.lasttransitiontime_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReplicationControllerCondition::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ReplicationControllerCondition::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReplicationControllerCondition::GetClassData() const { return &_class_data_; }


void ReplicationControllerCondition::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ReplicationControllerCondition*>(&to_msg);
  auto& from = static_cast<const ReplicationControllerCondition&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.ReplicationControllerCondition)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_type(from._internal_type());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_status(from._internal_status());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_reason(from._internal_reason());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_message(from._internal_message());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_lasttransitiontime()->::k8s::io::apimachinery::pkg::apis::meta::v1::Time::MergeFrom(
          from._internal_lasttransitiontime());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ReplicationControllerCondition::CopyFrom(const ReplicationControllerCondition& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.ReplicationControllerCondition)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReplicationControllerCondition::IsInitialized() const {
  return true;
}

void ReplicationControllerCondition::InternalSwap(ReplicationControllerCondition* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.type_, lhs_arena,
      &other->_impl_.type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.status_, lhs_arena,
      &other->_impl_.status_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.reason_, lhs_arena,
      &other->_impl_.reason_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.message_, lhs_arena,
      &other->_impl_.message_, rhs_arena
  );
  swap(_impl_.lasttransitiontime_, other->_impl_.lasttransitiontime_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ReplicationControllerCondition::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[186]);
}

// ===================================================================

class ReplicationControllerList::_Internal {
 public:
  using HasBits = decltype(std::declval<ReplicationControllerList>()._impl_._has_bits_);
  static const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& metadata(const ReplicationControllerList* msg);
  static void set_has_metadata(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta&
ReplicationControllerList::_Internal::metadata(const ReplicationControllerList* msg) {
  return *msg->_impl_.metadata_;
}
void ReplicationControllerList::clear_metadata() {
  if (_impl_.metadata_ != nullptr) _impl_.metadata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
ReplicationControllerList::ReplicationControllerList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.ReplicationControllerList)
}
ReplicationControllerList::ReplicationControllerList(const ReplicationControllerList& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ReplicationControllerList* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.items_){from._impl_.items_}
    , decltype(_impl_.metadata_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_metadata()) {
    _this->_impl_.metadata_ = new ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta(*from._impl_.metadata_);
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.ReplicationControllerList)
}

inline void ReplicationControllerList::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.items_){arena}
    , decltype(_impl_.metadata_){nullptr}
  };
}

ReplicationControllerList::~ReplicationControllerList() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.ReplicationControllerList)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReplicationControllerList::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.items_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.metadata_;
}

void ReplicationControllerList::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReplicationControllerList::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.ReplicationControllerList)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.items_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.metadata_ != nullptr);
    _impl_.metadata_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ReplicationControllerList::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_metadata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .k8s.io.api.core.v1.ReplicationController items = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_items(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReplicationControllerList::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.ReplicationControllerList)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::metadata(this),
        _Internal::metadata(this).GetCachedSize(), target, stream);
  }

  // repeated .k8s.io.api.core.v1.ReplicationController items = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_items_size()); i < n; i++) {
    const auto& repfield = this->_internal_items(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.ReplicationControllerList)
  return target;
}

size_t ReplicationControllerList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.ReplicationControllerList)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .k8s.io.api.core.v1.ReplicationController items = 2;
  total_size += 1UL * this->_internal_items_size();
  for (const auto& msg : this->_impl_.items_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.metadata_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReplicationControllerList::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ReplicationControllerList::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReplicationControllerList::GetClassData() const { return &_class_data_; }


void ReplicationControllerList::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ReplicationControllerList*>(&to_msg);
  auto& from = static_cast<const ReplicationControllerList&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.ReplicationControllerList)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.items_.MergeFrom(from._impl_.items_);
  if (from._internal_has_metadata()) {
    _this->_internal_mutable_metadata()->::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta::MergeFrom(
        from._internal_metadata());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ReplicationControllerList::CopyFrom(const ReplicationControllerList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.ReplicationControllerList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReplicationControllerList::IsInitialized() const {
  return true;
}

void ReplicationControllerList::InternalSwap(ReplicationControllerList* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.items_.InternalSwap(&other->_impl_.items_);
  swap(_impl_.metadata_, other->_impl_.metadata_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ReplicationControllerList::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[187]);
}

// ===================================================================

ReplicationControllerSpec_SelectorEntry_DoNotUse::ReplicationControllerSpec_SelectorEntry_DoNotUse() {}
ReplicationControllerSpec_SelectorEntry_DoNotUse::ReplicationControllerSpec_SelectorEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void ReplicationControllerSpec_SelectorEntry_DoNotUse::MergeFrom(const ReplicationControllerSpec_SelectorEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata ReplicationControllerSpec_SelectorEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[188]);
}

// ===================================================================

class ReplicationControllerSpec::_Internal {
 public:
  using HasBits = decltype(std::declval<ReplicationControllerSpec>()._impl_._has_bits_);
  static void set_has_replicas(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_minreadyseconds(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::k8s::io::api::core::v1::PodTemplateSpec& template_(const ReplicationControllerSpec* msg);
  static void set_has_template_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::k8s::io::api::core::v1::PodTemplateSpec&
ReplicationControllerSpec::_Internal::template_(const ReplicationControllerSpec* msg) {
  return *msg->_impl_.template__;
}
ReplicationControllerSpec::ReplicationControllerSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &ReplicationControllerSpec::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.ReplicationControllerSpec)
}
ReplicationControllerSpec::ReplicationControllerSpec(const ReplicationControllerSpec& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ReplicationControllerSpec* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_.selector_)*/{}
    , decltype(_impl_.template__){nullptr}
    , decltype(_impl_.replicas_){}
    , decltype(_impl_.minreadyseconds_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.selector_.MergeFrom(from._impl_.selector_);
  if (from._internal_has_template_()) {
    _this->_impl_.template__ = new ::k8s::io::api::core::v1::PodTemplateSpec(*from._impl_.template__);
  }
  ::memcpy(&_impl_.replicas_, &from._impl_.replicas_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.minreadyseconds_) -
    reinterpret_cast<char*>(&_impl_.replicas_)) + sizeof(_impl_.minreadyseconds_));
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.ReplicationControllerSpec)
}

inline void ReplicationControllerSpec::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_.selector_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.template__){nullptr}
    , decltype(_impl_.replicas_){0}
    , decltype(_impl_.minreadyseconds_){0}
  };
}

ReplicationControllerSpec::~ReplicationControllerSpec() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.ReplicationControllerSpec)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void ReplicationControllerSpec::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.selector_.Destruct();
  _impl_.selector_.~MapField();
  if (this != internal_default_instance()) delete _impl_.template__;
}

void ReplicationControllerSpec::ArenaDtor(void* object) {
  ReplicationControllerSpec* _this = reinterpret_cast< ReplicationControllerSpec* >(object);
  _this->_impl_.selector_.Destruct();
}
void ReplicationControllerSpec::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReplicationControllerSpec::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.ReplicationControllerSpec)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.selector_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.template__ != nullptr);
    _impl_.template__->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.replicas_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.minreadyseconds_) -
        reinterpret_cast<char*>(&_impl_.replicas_)) + sizeof(_impl_.minreadyseconds_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ReplicationControllerSpec::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 replicas = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_replicas(&has_bits);
          _impl_.replicas_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // map<string, string> selector = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.selector_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.PodTemplateSpec template = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_template_(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 minReadySeconds = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_minreadyseconds(&has_bits);
          _impl_.minreadyseconds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReplicationControllerSpec::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.ReplicationControllerSpec)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 replicas = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_replicas(), target);
  }

  // map<string, string> selector = 2;
  if (!this->_internal_selector().empty()) {
    using MapType = ::_pb::Map<std::string, std::string>;
    using WireHelper = ReplicationControllerSpec_SelectorEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_selector();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "k8s.io.api.core.v1.ReplicationControllerSpec.SelectorEntry.key");
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        entry.second.data(), static_cast<int>(entry.second.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "k8s.io.api.core.v1.ReplicationControllerSpec.SelectorEntry.value");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(2, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(2, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  // optional .k8s.io.api.core.v1.PodTemplateSpec template = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::template_(this),
        _Internal::template_(this).GetCachedSize(), target, stream);
  }

  // optional int32 minReadySeconds = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_minreadyseconds(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.ReplicationControllerSpec)
  return target;
}

size_t ReplicationControllerSpec::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.ReplicationControllerSpec)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, string> selector = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_selector_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
      it = this->_internal_selector().begin();
      it != this->_internal_selector().end(); ++it) {
    total_size += ReplicationControllerSpec_SelectorEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .k8s.io.api.core.v1.PodTemplateSpec template = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.template__);
    }

    // optional int32 replicas = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_replicas());
    }

    // optional int32 minReadySeconds = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_minreadyseconds());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReplicationControllerSpec::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ReplicationControllerSpec::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReplicationControllerSpec::GetClassData() const { return &_class_data_; }


void ReplicationControllerSpec::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ReplicationControllerSpec*>(&to_msg);
  auto& from = static_cast<const ReplicationControllerSpec&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.ReplicationControllerSpec)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.selector_.MergeFrom(from._impl_.selector_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_template_()->::k8s::io::api::core::v1::PodTemplateSpec::MergeFrom(
          from._internal_template_());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.replicas_ = from._impl_.replicas_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.minreadyseconds_ = from._impl_.minreadyseconds_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ReplicationControllerSpec::CopyFrom(const ReplicationControllerSpec& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.ReplicationControllerSpec)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReplicationControllerSpec::IsInitialized() const {
  return true;
}

void ReplicationControllerSpec::InternalSwap(ReplicationControllerSpec* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.selector_.InternalSwap(&other->_impl_.selector_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ReplicationControllerSpec, _impl_.minreadyseconds_)
      + sizeof(ReplicationControllerSpec::_impl_.minreadyseconds_)
      - PROTOBUF_FIELD_OFFSET(ReplicationControllerSpec, _impl_.template__)>(
          reinterpret_cast<char*>(&_impl_.template__),
          reinterpret_cast<char*>(&other->_impl_.template__));
}

::PROTOBUF_NAMESPACE_ID::Metadata ReplicationControllerSpec::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[189]);
}

// ===================================================================

class ReplicationControllerStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<ReplicationControllerStatus>()._impl_._has_bits_);
  static void set_has_replicas(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_fullylabeledreplicas(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_readyreplicas(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_availablereplicas(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_observedgeneration(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

ReplicationControllerStatus::ReplicationControllerStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.ReplicationControllerStatus)
}
ReplicationControllerStatus::ReplicationControllerStatus(const ReplicationControllerStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ReplicationControllerStatus* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.conditions_){from._impl_.conditions_}
    , decltype(_impl_.replicas_){}
    , decltype(_impl_.fullylabeledreplicas_){}
    , decltype(_impl_.observedgeneration_){}
    , decltype(_impl_.readyreplicas_){}
    , decltype(_impl_.availablereplicas_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.replicas_, &from._impl_.replicas_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.availablereplicas_) -
    reinterpret_cast<char*>(&_impl_.replicas_)) + sizeof(_impl_.availablereplicas_));
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.ReplicationControllerStatus)
}

inline void ReplicationControllerStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.conditions_){arena}
    , decltype(_impl_.replicas_){0}
    , decltype(_impl_.fullylabeledreplicas_){0}
    , decltype(_impl_.observedgeneration_){int64_t{0}}
    , decltype(_impl_.readyreplicas_){0}
    , decltype(_impl_.availablereplicas_){0}
  };
}

ReplicationControllerStatus::~ReplicationControllerStatus() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.ReplicationControllerStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReplicationControllerStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.conditions_.~RepeatedPtrField();
}

void ReplicationControllerStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReplicationControllerStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.ReplicationControllerStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.conditions_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.replicas_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.availablereplicas_) -
        reinterpret_cast<char*>(&_impl_.replicas_)) + sizeof(_impl_.availablereplicas_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ReplicationControllerStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 replicas = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_replicas(&has_bits);
          _impl_.replicas_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 fullyLabeledReplicas = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_fullylabeledreplicas(&has_bits);
          _impl_.fullylabeledreplicas_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 observedGeneration = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_observedgeneration(&has_bits);
          _impl_.observedgeneration_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 readyReplicas = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_readyreplicas(&has_bits);
          _impl_.readyreplicas_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 availableReplicas = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_availablereplicas(&has_bits);
          _impl_.availablereplicas_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .k8s.io.api.core.v1.ReplicationControllerCondition conditions = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_conditions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReplicationControllerStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.ReplicationControllerStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 replicas = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_replicas(), target);
  }

  // optional int32 fullyLabeledReplicas = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_fullylabeledreplicas(), target);
  }

  // optional int64 observedGeneration = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_observedgeneration(), target);
  }

  // optional int32 readyReplicas = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_readyreplicas(), target);
  }

  // optional int32 availableReplicas = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_availablereplicas(), target);
  }

  // repeated .k8s.io.api.core.v1.ReplicationControllerCondition conditions = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_conditions_size()); i < n; i++) {
    const auto& repfield = this->_internal_conditions(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.ReplicationControllerStatus)
  return target;
}

size_t ReplicationControllerStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.ReplicationControllerStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .k8s.io.api.core.v1.ReplicationControllerCondition conditions = 6;
  total_size += 1UL * this->_internal_conditions_size();
  for (const auto& msg : this->_impl_.conditions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional int32 replicas = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_replicas());
    }

    // optional int32 fullyLabeledReplicas = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_fullylabeledreplicas());
    }

    // optional int64 observedGeneration = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_observedgeneration());
    }

    // optional int32 readyReplicas = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_readyreplicas());
    }

    // optional int32 availableReplicas = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_availablereplicas());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReplicationControllerStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ReplicationControllerStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReplicationControllerStatus::GetClassData() const { return &_class_data_; }


void ReplicationControllerStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ReplicationControllerStatus*>(&to_msg);
  auto& from = static_cast<const ReplicationControllerStatus&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.ReplicationControllerStatus)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.conditions_.MergeFrom(from._impl_.conditions_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.replicas_ = from._impl_.replicas_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.fullylabeledreplicas_ = from._impl_.fullylabeledreplicas_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.observedgeneration_ = from._impl_.observedgeneration_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.readyreplicas_ = from._impl_.readyreplicas_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.availablereplicas_ = from._impl_.availablereplicas_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ReplicationControllerStatus::CopyFrom(const ReplicationControllerStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.ReplicationControllerStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReplicationControllerStatus::IsInitialized() const {
  return true;
}

void ReplicationControllerStatus::InternalSwap(ReplicationControllerStatus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.conditions_.InternalSwap(&other->_impl_.conditions_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ReplicationControllerStatus, _impl_.availablereplicas_)
      + sizeof(ReplicationControllerStatus::_impl_.availablereplicas_)
      - PROTOBUF_FIELD_OFFSET(ReplicationControllerStatus, _impl_.replicas_)>(
          reinterpret_cast<char*>(&_impl_.replicas_),
          reinterpret_cast<char*>(&other->_impl_.replicas_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ReplicationControllerStatus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[190]);
}

// ===================================================================

class ResourceClaim::_Internal {
 public:
  using HasBits = decltype(std::declval<ResourceClaim>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ResourceClaim::ResourceClaim(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.ResourceClaim)
}
ResourceClaim::ResourceClaim(const ResourceClaim& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ResourceClaim* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.ResourceClaim)
}

inline void ResourceClaim::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ResourceClaim::~ResourceClaim() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.ResourceClaim)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ResourceClaim::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void ResourceClaim::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ResourceClaim::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.ResourceClaim)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.name_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ResourceClaim::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ResourceClaim::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.ResourceClaim)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.ResourceClaim)
  return target;
}

size_t ResourceClaim::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.ResourceClaim)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes name = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ResourceClaim::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ResourceClaim::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ResourceClaim::GetClassData() const { return &_class_data_; }


void ResourceClaim::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ResourceClaim*>(&to_msg);
  auto& from = static_cast<const ResourceClaim&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.ResourceClaim)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_name()) {
    _this->_internal_set_name(from._internal_name());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ResourceClaim::CopyFrom(const ResourceClaim& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.ResourceClaim)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResourceClaim::IsInitialized() const {
  return true;
}

void ResourceClaim::InternalSwap(ResourceClaim* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ResourceClaim::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[191]);
}

// ===================================================================

class ResourceFieldSelector::_Internal {
 public:
  using HasBits = decltype(std::declval<ResourceFieldSelector>()._impl_._has_bits_);
  static void set_has_containername(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_resource(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::k8s::io::apimachinery::pkg::api::resource::Quantity& divisor(const ResourceFieldSelector* msg);
  static void set_has_divisor(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::k8s::io::apimachinery::pkg::api::resource::Quantity&
ResourceFieldSelector::_Internal::divisor(const ResourceFieldSelector* msg) {
  return *msg->_impl_.divisor_;
}
void ResourceFieldSelector::clear_divisor() {
  if (_impl_.divisor_ != nullptr) _impl_.divisor_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
ResourceFieldSelector::ResourceFieldSelector(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.ResourceFieldSelector)
}
ResourceFieldSelector::ResourceFieldSelector(const ResourceFieldSelector& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ResourceFieldSelector* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.containername_){}
    , decltype(_impl_.resource_){}
    , decltype(_impl_.divisor_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.containername_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.containername_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_containername()) {
    _this->_impl_.containername_.Set(from._internal_containername(), 
      _this->GetArenaForAllocation());
  }
  _impl_.resource_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.resource_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_resource()) {
    _this->_impl_.resource_.Set(from._internal_resource(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_divisor()) {
    _this->_impl_.divisor_ = new ::k8s::io::apimachinery::pkg::api::resource::Quantity(*from._impl_.divisor_);
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.ResourceFieldSelector)
}

inline void ResourceFieldSelector::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.containername_){}
    , decltype(_impl_.resource_){}
    , decltype(_impl_.divisor_){nullptr}
  };
  _impl_.containername_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.containername_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.resource_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.resource_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ResourceFieldSelector::~ResourceFieldSelector() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.ResourceFieldSelector)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ResourceFieldSelector::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.containername_.Destroy();
  _impl_.resource_.Destroy();
  if (this != internal_default_instance()) delete _impl_.divisor_;
}

void ResourceFieldSelector::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ResourceFieldSelector::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.ResourceFieldSelector)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.containername_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.resource_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.divisor_ != nullptr);
      _impl_.divisor_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ResourceFieldSelector::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes containerName = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_containername();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes resource = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_resource();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.apimachinery.pkg.api.resource.Quantity divisor = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_divisor(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ResourceFieldSelector::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.ResourceFieldSelector)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes containerName = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_containername(), target);
  }

  // optional bytes resource = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_resource(), target);
  }

  // optional .k8s.io.apimachinery.pkg.api.resource.Quantity divisor = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::divisor(this),
        _Internal::divisor(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.ResourceFieldSelector)
  return target;
}

size_t ResourceFieldSelector::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.ResourceFieldSelector)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bytes containerName = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_containername());
    }

    // optional bytes resource = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_resource());
    }

    // optional .k8s.io.apimachinery.pkg.api.resource.Quantity divisor = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.divisor_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ResourceFieldSelector::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ResourceFieldSelector::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ResourceFieldSelector::GetClassData() const { return &_class_data_; }


void ResourceFieldSelector::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ResourceFieldSelector*>(&to_msg);
  auto& from = static_cast<const ResourceFieldSelector&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.ResourceFieldSelector)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_containername(from._internal_containername());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_resource(from._internal_resource());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_divisor()->::k8s::io::apimachinery::pkg::api::resource::Quantity::MergeFrom(
          from._internal_divisor());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ResourceFieldSelector::CopyFrom(const ResourceFieldSelector& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.ResourceFieldSelector)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResourceFieldSelector::IsInitialized() const {
  return true;
}

void ResourceFieldSelector::InternalSwap(ResourceFieldSelector* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.containername_, lhs_arena,
      &other->_impl_.containername_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.resource_, lhs_arena,
      &other->_impl_.resource_, rhs_arena
  );
  swap(_impl_.divisor_, other->_impl_.divisor_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ResourceFieldSelector::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[192]);
}

// ===================================================================

class ResourceQuota::_Internal {
 public:
  using HasBits = decltype(std::declval<ResourceQuota>()._impl_._has_bits_);
  static const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& metadata(const ResourceQuota* msg);
  static void set_has_metadata(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::k8s::io::api::core::v1::ResourceQuotaSpec& spec(const ResourceQuota* msg);
  static void set_has_spec(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::k8s::io::api::core::v1::ResourceQuotaStatus& status(const ResourceQuota* msg);
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta&
ResourceQuota::_Internal::metadata(const ResourceQuota* msg) {
  return *msg->_impl_.metadata_;
}
const ::k8s::io::api::core::v1::ResourceQuotaSpec&
ResourceQuota::_Internal::spec(const ResourceQuota* msg) {
  return *msg->_impl_.spec_;
}
const ::k8s::io::api::core::v1::ResourceQuotaStatus&
ResourceQuota::_Internal::status(const ResourceQuota* msg) {
  return *msg->_impl_.status_;
}
void ResourceQuota::clear_metadata() {
  if (_impl_.metadata_ != nullptr) _impl_.metadata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
ResourceQuota::ResourceQuota(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.ResourceQuota)
}
ResourceQuota::ResourceQuota(const ResourceQuota& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ResourceQuota* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.metadata_){nullptr}
    , decltype(_impl_.spec_){nullptr}
    , decltype(_impl_.status_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_metadata()) {
    _this->_impl_.metadata_ = new ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta(*from._impl_.metadata_);
  }
  if (from._internal_has_spec()) {
    _this->_impl_.spec_ = new ::k8s::io::api::core::v1::ResourceQuotaSpec(*from._impl_.spec_);
  }
  if (from._internal_has_status()) {
    _this->_impl_.status_ = new ::k8s::io::api::core::v1::ResourceQuotaStatus(*from._impl_.status_);
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.ResourceQuota)
}

inline void ResourceQuota::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.metadata_){nullptr}
    , decltype(_impl_.spec_){nullptr}
    , decltype(_impl_.status_){nullptr}
  };
}

ResourceQuota::~ResourceQuota() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.ResourceQuota)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ResourceQuota::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.metadata_;
  if (this != internal_default_instance()) delete _impl_.spec_;
  if (this != internal_default_instance()) delete _impl_.status_;
}

void ResourceQuota::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ResourceQuota::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.ResourceQuota)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.metadata_ != nullptr);
      _impl_.metadata_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.spec_ != nullptr);
      _impl_.spec_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.status_ != nullptr);
      _impl_.status_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ResourceQuota::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_metadata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.ResourceQuotaSpec spec = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_spec(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.ResourceQuotaStatus status = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_status(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ResourceQuota::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.ResourceQuota)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::metadata(this),
        _Internal::metadata(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.ResourceQuotaSpec spec = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::spec(this),
        _Internal::spec(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.ResourceQuotaStatus status = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::status(this),
        _Internal::status(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.ResourceQuota)
  return target;
}

size_t ResourceQuota::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.ResourceQuota)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.metadata_);
    }

    // optional .k8s.io.api.core.v1.ResourceQuotaSpec spec = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.spec_);
    }

    // optional .k8s.io.api.core.v1.ResourceQuotaStatus status = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.status_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ResourceQuota::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ResourceQuota::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ResourceQuota::GetClassData() const { return &_class_data_; }


void ResourceQuota::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ResourceQuota*>(&to_msg);
  auto& from = static_cast<const ResourceQuota&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.ResourceQuota)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_metadata()->::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta::MergeFrom(
          from._internal_metadata());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_spec()->::k8s::io::api::core::v1::ResourceQuotaSpec::MergeFrom(
          from._internal_spec());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_status()->::k8s::io::api::core::v1::ResourceQuotaStatus::MergeFrom(
          from._internal_status());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ResourceQuota::CopyFrom(const ResourceQuota& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.ResourceQuota)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResourceQuota::IsInitialized() const {
  return true;
}

void ResourceQuota::InternalSwap(ResourceQuota* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ResourceQuota, _impl_.status_)
      + sizeof(ResourceQuota::_impl_.status_)
      - PROTOBUF_FIELD_OFFSET(ResourceQuota, _impl_.metadata_)>(
          reinterpret_cast<char*>(&_impl_.metadata_),
          reinterpret_cast<char*>(&other->_impl_.metadata_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ResourceQuota::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[193]);
}

// ===================================================================

class ResourceQuotaList::_Internal {
 public:
  using HasBits = decltype(std::declval<ResourceQuotaList>()._impl_._has_bits_);
  static const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& metadata(const ResourceQuotaList* msg);
  static void set_has_metadata(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta&
ResourceQuotaList::_Internal::metadata(const ResourceQuotaList* msg) {
  return *msg->_impl_.metadata_;
}
void ResourceQuotaList::clear_metadata() {
  if (_impl_.metadata_ != nullptr) _impl_.metadata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
ResourceQuotaList::ResourceQuotaList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.ResourceQuotaList)
}
ResourceQuotaList::ResourceQuotaList(const ResourceQuotaList& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ResourceQuotaList* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.items_){from._impl_.items_}
    , decltype(_impl_.metadata_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_metadata()) {
    _this->_impl_.metadata_ = new ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta(*from._impl_.metadata_);
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.ResourceQuotaList)
}

inline void ResourceQuotaList::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.items_){arena}
    , decltype(_impl_.metadata_){nullptr}
  };
}

ResourceQuotaList::~ResourceQuotaList() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.ResourceQuotaList)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ResourceQuotaList::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.items_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.metadata_;
}

void ResourceQuotaList::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ResourceQuotaList::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.ResourceQuotaList)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.items_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.metadata_ != nullptr);
    _impl_.metadata_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ResourceQuotaList::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_metadata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .k8s.io.api.core.v1.ResourceQuota items = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_items(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ResourceQuotaList::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.ResourceQuotaList)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::metadata(this),
        _Internal::metadata(this).GetCachedSize(), target, stream);
  }

  // repeated .k8s.io.api.core.v1.ResourceQuota items = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_items_size()); i < n; i++) {
    const auto& repfield = this->_internal_items(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.ResourceQuotaList)
  return target;
}

size_t ResourceQuotaList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.ResourceQuotaList)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .k8s.io.api.core.v1.ResourceQuota items = 2;
  total_size += 1UL * this->_internal_items_size();
  for (const auto& msg : this->_impl_.items_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.metadata_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ResourceQuotaList::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ResourceQuotaList::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ResourceQuotaList::GetClassData() const { return &_class_data_; }


void ResourceQuotaList::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ResourceQuotaList*>(&to_msg);
  auto& from = static_cast<const ResourceQuotaList&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.ResourceQuotaList)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.items_.MergeFrom(from._impl_.items_);
  if (from._internal_has_metadata()) {
    _this->_internal_mutable_metadata()->::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta::MergeFrom(
        from._internal_metadata());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ResourceQuotaList::CopyFrom(const ResourceQuotaList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.ResourceQuotaList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResourceQuotaList::IsInitialized() const {
  return true;
}

void ResourceQuotaList::InternalSwap(ResourceQuotaList* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.items_.InternalSwap(&other->_impl_.items_);
  swap(_impl_.metadata_, other->_impl_.metadata_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ResourceQuotaList::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[194]);
}

// ===================================================================

ResourceQuotaSpec_HardEntry_DoNotUse::ResourceQuotaSpec_HardEntry_DoNotUse() {}
ResourceQuotaSpec_HardEntry_DoNotUse::ResourceQuotaSpec_HardEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void ResourceQuotaSpec_HardEntry_DoNotUse::MergeFrom(const ResourceQuotaSpec_HardEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata ResourceQuotaSpec_HardEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[195]);
}

// ===================================================================

class ResourceQuotaSpec::_Internal {
 public:
  using HasBits = decltype(std::declval<ResourceQuotaSpec>()._impl_._has_bits_);
  static const ::k8s::io::api::core::v1::ScopeSelector& scopeselector(const ResourceQuotaSpec* msg);
  static void set_has_scopeselector(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::k8s::io::api::core::v1::ScopeSelector&
ResourceQuotaSpec::_Internal::scopeselector(const ResourceQuotaSpec* msg) {
  return *msg->_impl_.scopeselector_;
}
void ResourceQuotaSpec::clear_hard() {
  _impl_.hard_.Clear();
}
ResourceQuotaSpec::ResourceQuotaSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &ResourceQuotaSpec::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.ResourceQuotaSpec)
}
ResourceQuotaSpec::ResourceQuotaSpec(const ResourceQuotaSpec& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ResourceQuotaSpec* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_.hard_)*/{}
    , decltype(_impl_.scopes_){from._impl_.scopes_}
    , decltype(_impl_.scopeselector_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.hard_.MergeFrom(from._impl_.hard_);
  if (from._internal_has_scopeselector()) {
    _this->_impl_.scopeselector_ = new ::k8s::io::api::core::v1::ScopeSelector(*from._impl_.scopeselector_);
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.ResourceQuotaSpec)
}

inline void ResourceQuotaSpec::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_.hard_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.scopes_){arena}
    , decltype(_impl_.scopeselector_){nullptr}
  };
}

ResourceQuotaSpec::~ResourceQuotaSpec() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.ResourceQuotaSpec)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void ResourceQuotaSpec::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.hard_.Destruct();
  _impl_.hard_.~MapField();
  _impl_.scopes_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.scopeselector_;
}

void ResourceQuotaSpec::ArenaDtor(void* object) {
  ResourceQuotaSpec* _this = reinterpret_cast< ResourceQuotaSpec* >(object);
  _this->_impl_.hard_.Destruct();
}
void ResourceQuotaSpec::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ResourceQuotaSpec::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.ResourceQuotaSpec)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.hard_.Clear();
  _impl_.scopes_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.scopeselector_ != nullptr);
    _impl_.scopeselector_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ResourceQuotaSpec::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // map<string, .k8s.io.apimachinery.pkg.api.resource.Quantity> hard = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.hard_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string scopes = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_scopes();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "k8s.io.api.core.v1.ResourceQuotaSpec.scopes");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.ScopeSelector scopeSelector = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_scopeselector(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ResourceQuotaSpec::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.ResourceQuotaSpec)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // map<string, .k8s.io.apimachinery.pkg.api.resource.Quantity> hard = 1;
  if (!this->_internal_hard().empty()) {
    using MapType = ::_pb::Map<std::string, ::k8s::io::apimachinery::pkg::api::resource::Quantity>;
    using WireHelper = ResourceQuotaSpec_HardEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_hard();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "k8s.io.api.core.v1.ResourceQuotaSpec.HardEntry.key");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(1, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(1, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  // repeated string scopes = 2;
  for (int i = 0, n = this->_internal_scopes_size(); i < n; i++) {
    const auto& s = this->_internal_scopes(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "k8s.io.api.core.v1.ResourceQuotaSpec.scopes");
    target = stream->WriteString(2, s, target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional .k8s.io.api.core.v1.ScopeSelector scopeSelector = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::scopeselector(this),
        _Internal::scopeselector(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.ResourceQuotaSpec)
  return target;
}

size_t ResourceQuotaSpec::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.ResourceQuotaSpec)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, .k8s.io.apimachinery.pkg.api.resource.Quantity> hard = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_hard_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::k8s::io::apimachinery::pkg::api::resource::Quantity >::const_iterator
      it = this->_internal_hard().begin();
      it != this->_internal_hard().end(); ++it) {
    total_size += ResourceQuotaSpec_HardEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // repeated string scopes = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.scopes_.size());
  for (int i = 0, n = _impl_.scopes_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.scopes_.Get(i));
  }

  // optional .k8s.io.api.core.v1.ScopeSelector scopeSelector = 3;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.scopeselector_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ResourceQuotaSpec::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ResourceQuotaSpec::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ResourceQuotaSpec::GetClassData() const { return &_class_data_; }


void ResourceQuotaSpec::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ResourceQuotaSpec*>(&to_msg);
  auto& from = static_cast<const ResourceQuotaSpec&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.ResourceQuotaSpec)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.hard_.MergeFrom(from._impl_.hard_);
  _this->_impl_.scopes_.MergeFrom(from._impl_.scopes_);
  if (from._internal_has_scopeselector()) {
    _this->_internal_mutable_scopeselector()->::k8s::io::api::core::v1::ScopeSelector::MergeFrom(
        from._internal_scopeselector());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ResourceQuotaSpec::CopyFrom(const ResourceQuotaSpec& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.ResourceQuotaSpec)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResourceQuotaSpec::IsInitialized() const {
  return true;
}

void ResourceQuotaSpec::InternalSwap(ResourceQuotaSpec* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.hard_.InternalSwap(&other->_impl_.hard_);
  _impl_.scopes_.InternalSwap(&other->_impl_.scopes_);
  swap(_impl_.scopeselector_, other->_impl_.scopeselector_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ResourceQuotaSpec::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[196]);
}

// ===================================================================

ResourceQuotaStatus_HardEntry_DoNotUse::ResourceQuotaStatus_HardEntry_DoNotUse() {}
ResourceQuotaStatus_HardEntry_DoNotUse::ResourceQuotaStatus_HardEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void ResourceQuotaStatus_HardEntry_DoNotUse::MergeFrom(const ResourceQuotaStatus_HardEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata ResourceQuotaStatus_HardEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[197]);
}

// ===================================================================

ResourceQuotaStatus_UsedEntry_DoNotUse::ResourceQuotaStatus_UsedEntry_DoNotUse() {}
ResourceQuotaStatus_UsedEntry_DoNotUse::ResourceQuotaStatus_UsedEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void ResourceQuotaStatus_UsedEntry_DoNotUse::MergeFrom(const ResourceQuotaStatus_UsedEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata ResourceQuotaStatus_UsedEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[198]);
}

// ===================================================================

class ResourceQuotaStatus::_Internal {
 public:
};

void ResourceQuotaStatus::clear_hard() {
  _impl_.hard_.Clear();
}
void ResourceQuotaStatus::clear_used() {
  _impl_.used_.Clear();
}
ResourceQuotaStatus::ResourceQuotaStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &ResourceQuotaStatus::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.ResourceQuotaStatus)
}
ResourceQuotaStatus::ResourceQuotaStatus(const ResourceQuotaStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ResourceQuotaStatus* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_.hard_)*/{}
    , /*decltype(_impl_.used_)*/{}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.hard_.MergeFrom(from._impl_.hard_);
  _this->_impl_.used_.MergeFrom(from._impl_.used_);
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.ResourceQuotaStatus)
}

inline void ResourceQuotaStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_.hard_)*/{::_pbi::ArenaInitialized(), arena}
    , /*decltype(_impl_.used_)*/{::_pbi::ArenaInitialized(), arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ResourceQuotaStatus::~ResourceQuotaStatus() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.ResourceQuotaStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void ResourceQuotaStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.hard_.Destruct();
  _impl_.hard_.~MapField();
  _impl_.used_.Destruct();
  _impl_.used_.~MapField();
}

void ResourceQuotaStatus::ArenaDtor(void* object) {
  ResourceQuotaStatus* _this = reinterpret_cast< ResourceQuotaStatus* >(object);
  _this->_impl_.hard_.Destruct();
  _this->_impl_.used_.Destruct();
}
void ResourceQuotaStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ResourceQuotaStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.ResourceQuotaStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.hard_.Clear();
  _impl_.used_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ResourceQuotaStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // map<string, .k8s.io.apimachinery.pkg.api.resource.Quantity> hard = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.hard_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // map<string, .k8s.io.apimachinery.pkg.api.resource.Quantity> used = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.used_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ResourceQuotaStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.ResourceQuotaStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // map<string, .k8s.io.apimachinery.pkg.api.resource.Quantity> hard = 1;
  if (!this->_internal_hard().empty()) {
    using MapType = ::_pb::Map<std::string, ::k8s::io::apimachinery::pkg::api::resource::Quantity>;
    using WireHelper = ResourceQuotaStatus_HardEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_hard();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "k8s.io.api.core.v1.ResourceQuotaStatus.HardEntry.key");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(1, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(1, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  // map<string, .k8s.io.apimachinery.pkg.api.resource.Quantity> used = 2;
  if (!this->_internal_used().empty()) {
    using MapType = ::_pb::Map<std::string, ::k8s::io::apimachinery::pkg::api::resource::Quantity>;
    using WireHelper = ResourceQuotaStatus_UsedEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_used();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "k8s.io.api.core.v1.ResourceQuotaStatus.UsedEntry.key");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(2, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(2, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.ResourceQuotaStatus)
  return target;
}

size_t ResourceQuotaStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.ResourceQuotaStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, .k8s.io.apimachinery.pkg.api.resource.Quantity> hard = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_hard_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::k8s::io::apimachinery::pkg::api::resource::Quantity >::const_iterator
      it = this->_internal_hard().begin();
      it != this->_internal_hard().end(); ++it) {
    total_size += ResourceQuotaStatus_HardEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // map<string, .k8s.io.apimachinery.pkg.api.resource.Quantity> used = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_used_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::k8s::io::apimachinery::pkg::api::resource::Quantity >::const_iterator
      it = this->_internal_used().begin();
      it != this->_internal_used().end(); ++it) {
    total_size += ResourceQuotaStatus_UsedEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ResourceQuotaStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ResourceQuotaStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ResourceQuotaStatus::GetClassData() const { return &_class_data_; }


void ResourceQuotaStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ResourceQuotaStatus*>(&to_msg);
  auto& from = static_cast<const ResourceQuotaStatus&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.ResourceQuotaStatus)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.hard_.MergeFrom(from._impl_.hard_);
  _this->_impl_.used_.MergeFrom(from._impl_.used_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ResourceQuotaStatus::CopyFrom(const ResourceQuotaStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.ResourceQuotaStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResourceQuotaStatus::IsInitialized() const {
  return true;
}

void ResourceQuotaStatus::InternalSwap(ResourceQuotaStatus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.hard_.InternalSwap(&other->_impl_.hard_);
  _impl_.used_.InternalSwap(&other->_impl_.used_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ResourceQuotaStatus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[199]);
}

// ===================================================================

ResourceRequirements_LimitsEntry_DoNotUse::ResourceRequirements_LimitsEntry_DoNotUse() {}
ResourceRequirements_LimitsEntry_DoNotUse::ResourceRequirements_LimitsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void ResourceRequirements_LimitsEntry_DoNotUse::MergeFrom(const ResourceRequirements_LimitsEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata ResourceRequirements_LimitsEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[200]);
}

// ===================================================================

ResourceRequirements_RequestsEntry_DoNotUse::ResourceRequirements_RequestsEntry_DoNotUse() {}
ResourceRequirements_RequestsEntry_DoNotUse::ResourceRequirements_RequestsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void ResourceRequirements_RequestsEntry_DoNotUse::MergeFrom(const ResourceRequirements_RequestsEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata ResourceRequirements_RequestsEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[201]);
}

// ===================================================================

class ResourceRequirements::_Internal {
 public:
};

void ResourceRequirements::clear_limits() {
  _impl_.limits_.Clear();
}
void ResourceRequirements::clear_requests() {
  _impl_.requests_.Clear();
}
ResourceRequirements::ResourceRequirements(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &ResourceRequirements::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.ResourceRequirements)
}
ResourceRequirements::ResourceRequirements(const ResourceRequirements& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ResourceRequirements* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_.limits_)*/{}
    , /*decltype(_impl_.requests_)*/{}
    , decltype(_impl_.claims_){from._impl_.claims_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.limits_.MergeFrom(from._impl_.limits_);
  _this->_impl_.requests_.MergeFrom(from._impl_.requests_);
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.ResourceRequirements)
}

inline void ResourceRequirements::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_.limits_)*/{::_pbi::ArenaInitialized(), arena}
    , /*decltype(_impl_.requests_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.claims_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ResourceRequirements::~ResourceRequirements() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.ResourceRequirements)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void ResourceRequirements::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.limits_.Destruct();
  _impl_.limits_.~MapField();
  _impl_.requests_.Destruct();
  _impl_.requests_.~MapField();
  _impl_.claims_.~RepeatedPtrField();
}

void ResourceRequirements::ArenaDtor(void* object) {
  ResourceRequirements* _this = reinterpret_cast< ResourceRequirements* >(object);
  _this->_impl_.limits_.Destruct();
  _this->_impl_.requests_.Destruct();
}
void ResourceRequirements::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ResourceRequirements::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.ResourceRequirements)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.limits_.Clear();
  _impl_.requests_.Clear();
  _impl_.claims_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ResourceRequirements::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // map<string, .k8s.io.apimachinery.pkg.api.resource.Quantity> limits = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.limits_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // map<string, .k8s.io.apimachinery.pkg.api.resource.Quantity> requests = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.requests_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .k8s.io.api.core.v1.ResourceClaim claims = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_claims(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ResourceRequirements::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.ResourceRequirements)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // map<string, .k8s.io.apimachinery.pkg.api.resource.Quantity> limits = 1;
  if (!this->_internal_limits().empty()) {
    using MapType = ::_pb::Map<std::string, ::k8s::io::apimachinery::pkg::api::resource::Quantity>;
    using WireHelper = ResourceRequirements_LimitsEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_limits();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "k8s.io.api.core.v1.ResourceRequirements.LimitsEntry.key");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(1, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(1, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  // map<string, .k8s.io.apimachinery.pkg.api.resource.Quantity> requests = 2;
  if (!this->_internal_requests().empty()) {
    using MapType = ::_pb::Map<std::string, ::k8s::io::apimachinery::pkg::api::resource::Quantity>;
    using WireHelper = ResourceRequirements_RequestsEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_requests();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "k8s.io.api.core.v1.ResourceRequirements.RequestsEntry.key");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(2, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(2, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  // repeated .k8s.io.api.core.v1.ResourceClaim claims = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_claims_size()); i < n; i++) {
    const auto& repfield = this->_internal_claims(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.ResourceRequirements)
  return target;
}

size_t ResourceRequirements::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.ResourceRequirements)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, .k8s.io.apimachinery.pkg.api.resource.Quantity> limits = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_limits_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::k8s::io::apimachinery::pkg::api::resource::Quantity >::const_iterator
      it = this->_internal_limits().begin();
      it != this->_internal_limits().end(); ++it) {
    total_size += ResourceRequirements_LimitsEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // map<string, .k8s.io.apimachinery.pkg.api.resource.Quantity> requests = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_requests_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::k8s::io::apimachinery::pkg::api::resource::Quantity >::const_iterator
      it = this->_internal_requests().begin();
      it != this->_internal_requests().end(); ++it) {
    total_size += ResourceRequirements_RequestsEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // repeated .k8s.io.api.core.v1.ResourceClaim claims = 3;
  total_size += 1UL * this->_internal_claims_size();
  for (const auto& msg : this->_impl_.claims_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ResourceRequirements::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ResourceRequirements::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ResourceRequirements::GetClassData() const { return &_class_data_; }


void ResourceRequirements::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ResourceRequirements*>(&to_msg);
  auto& from = static_cast<const ResourceRequirements&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.ResourceRequirements)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.limits_.MergeFrom(from._impl_.limits_);
  _this->_impl_.requests_.MergeFrom(from._impl_.requests_);
  _this->_impl_.claims_.MergeFrom(from._impl_.claims_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ResourceRequirements::CopyFrom(const ResourceRequirements& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.ResourceRequirements)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResourceRequirements::IsInitialized() const {
  return true;
}

void ResourceRequirements::InternalSwap(ResourceRequirements* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.limits_.InternalSwap(&other->_impl_.limits_);
  _impl_.requests_.InternalSwap(&other->_impl_.requests_);
  _impl_.claims_.InternalSwap(&other->_impl_.claims_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ResourceRequirements::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[202]);
}

// ===================================================================

class SELinuxOptions::_Internal {
 public:
  using HasBits = decltype(std::declval<SELinuxOptions>()._impl_._has_bits_);
  static void set_has_user(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_role(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_level(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

SELinuxOptions::SELinuxOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.SELinuxOptions)
}
SELinuxOptions::SELinuxOptions(const SELinuxOptions& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SELinuxOptions* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.user_){}
    , decltype(_impl_.role_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.level_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.user_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_user()) {
    _this->_impl_.user_.Set(from._internal_user(), 
      _this->GetArenaForAllocation());
  }
  _impl_.role_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.role_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_role()) {
    _this->_impl_.role_.Set(from._internal_role(), 
      _this->GetArenaForAllocation());
  }
  _impl_.type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_type()) {
    _this->_impl_.type_.Set(from._internal_type(), 
      _this->GetArenaForAllocation());
  }
  _impl_.level_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.level_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_level()) {
    _this->_impl_.level_.Set(from._internal_level(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.SELinuxOptions)
}

inline void SELinuxOptions::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.user_){}
    , decltype(_impl_.role_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.level_){}
  };
  _impl_.user_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.role_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.role_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.level_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.level_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SELinuxOptions::~SELinuxOptions() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.SELinuxOptions)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SELinuxOptions::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.user_.Destroy();
  _impl_.role_.Destroy();
  _impl_.type_.Destroy();
  _impl_.level_.Destroy();
}

void SELinuxOptions::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SELinuxOptions::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.SELinuxOptions)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.user_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.role_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.type_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.level_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SELinuxOptions::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes user = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_user();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes role = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_role();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes level = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_level();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SELinuxOptions::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.SELinuxOptions)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes user = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_user(), target);
  }

  // optional bytes role = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_role(), target);
  }

  // optional bytes type = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_type(), target);
  }

  // optional bytes level = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_level(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.SELinuxOptions)
  return target;
}

size_t SELinuxOptions::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.SELinuxOptions)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional bytes user = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_user());
    }

    // optional bytes role = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_role());
    }

    // optional bytes type = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_type());
    }

    // optional bytes level = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_level());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SELinuxOptions::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SELinuxOptions::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SELinuxOptions::GetClassData() const { return &_class_data_; }


void SELinuxOptions::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SELinuxOptions*>(&to_msg);
  auto& from = static_cast<const SELinuxOptions&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.SELinuxOptions)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_user(from._internal_user());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_role(from._internal_role());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_type(from._internal_type());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_level(from._internal_level());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SELinuxOptions::CopyFrom(const SELinuxOptions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.SELinuxOptions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SELinuxOptions::IsInitialized() const {
  return true;
}

void SELinuxOptions::InternalSwap(SELinuxOptions* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.user_, lhs_arena,
      &other->_impl_.user_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.role_, lhs_arena,
      &other->_impl_.role_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.type_, lhs_arena,
      &other->_impl_.type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.level_, lhs_arena,
      &other->_impl_.level_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata SELinuxOptions::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[203]);
}

// ===================================================================

class ScaleIOPersistentVolumeSource::_Internal {
 public:
  using HasBits = decltype(std::declval<ScaleIOPersistentVolumeSource>()._impl_._has_bits_);
  static void set_has_gateway(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_system(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::k8s::io::api::core::v1::SecretReference& secretref(const ScaleIOPersistentVolumeSource* msg);
  static void set_has_secretref(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_sslenabled(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_protectiondomain(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_storagepool(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_storagemode(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_volumename(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_fstype(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_readonly(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
};

const ::k8s::io::api::core::v1::SecretReference&
ScaleIOPersistentVolumeSource::_Internal::secretref(const ScaleIOPersistentVolumeSource* msg) {
  return *msg->_impl_.secretref_;
}
ScaleIOPersistentVolumeSource::ScaleIOPersistentVolumeSource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.ScaleIOPersistentVolumeSource)
}
ScaleIOPersistentVolumeSource::ScaleIOPersistentVolumeSource(const ScaleIOPersistentVolumeSource& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ScaleIOPersistentVolumeSource* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.gateway_){}
    , decltype(_impl_.system_){}
    , decltype(_impl_.protectiondomain_){}
    , decltype(_impl_.storagepool_){}
    , decltype(_impl_.storagemode_){}
    , decltype(_impl_.volumename_){}
    , decltype(_impl_.fstype_){}
    , decltype(_impl_.secretref_){nullptr}
    , decltype(_impl_.sslenabled_){}
    , decltype(_impl_.readonly_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.gateway_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.gateway_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_gateway()) {
    _this->_impl_.gateway_.Set(from._internal_gateway(), 
      _this->GetArenaForAllocation());
  }
  _impl_.system_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.system_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_system()) {
    _this->_impl_.system_.Set(from._internal_system(), 
      _this->GetArenaForAllocation());
  }
  _impl_.protectiondomain_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.protectiondomain_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_protectiondomain()) {
    _this->_impl_.protectiondomain_.Set(from._internal_protectiondomain(), 
      _this->GetArenaForAllocation());
  }
  _impl_.storagepool_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.storagepool_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_storagepool()) {
    _this->_impl_.storagepool_.Set(from._internal_storagepool(), 
      _this->GetArenaForAllocation());
  }
  _impl_.storagemode_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.storagemode_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_storagemode()) {
    _this->_impl_.storagemode_.Set(from._internal_storagemode(), 
      _this->GetArenaForAllocation());
  }
  _impl_.volumename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.volumename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_volumename()) {
    _this->_impl_.volumename_.Set(from._internal_volumename(), 
      _this->GetArenaForAllocation());
  }
  _impl_.fstype_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fstype_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_fstype()) {
    _this->_impl_.fstype_.Set(from._internal_fstype(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_secretref()) {
    _this->_impl_.secretref_ = new ::k8s::io::api::core::v1::SecretReference(*from._impl_.secretref_);
  }
  ::memcpy(&_impl_.sslenabled_, &from._impl_.sslenabled_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.readonly_) -
    reinterpret_cast<char*>(&_impl_.sslenabled_)) + sizeof(_impl_.readonly_));
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.ScaleIOPersistentVolumeSource)
}

inline void ScaleIOPersistentVolumeSource::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.gateway_){}
    , decltype(_impl_.system_){}
    , decltype(_impl_.protectiondomain_){}
    , decltype(_impl_.storagepool_){}
    , decltype(_impl_.storagemode_){}
    , decltype(_impl_.volumename_){}
    , decltype(_impl_.fstype_){}
    , decltype(_impl_.secretref_){nullptr}
    , decltype(_impl_.sslenabled_){false}
    , decltype(_impl_.readonly_){false}
  };
  _impl_.gateway_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.gateway_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.system_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.system_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.protectiondomain_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.protectiondomain_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.storagepool_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.storagepool_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.storagemode_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.storagemode_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.volumename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.volumename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.fstype_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fstype_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ScaleIOPersistentVolumeSource::~ScaleIOPersistentVolumeSource() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.ScaleIOPersistentVolumeSource)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ScaleIOPersistentVolumeSource::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.gateway_.Destroy();
  _impl_.system_.Destroy();
  _impl_.protectiondomain_.Destroy();
  _impl_.storagepool_.Destroy();
  _impl_.storagemode_.Destroy();
  _impl_.volumename_.Destroy();
  _impl_.fstype_.Destroy();
  if (this != internal_default_instance()) delete _impl_.secretref_;
}

void ScaleIOPersistentVolumeSource::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ScaleIOPersistentVolumeSource::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.ScaleIOPersistentVolumeSource)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.gateway_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.system_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.protectiondomain_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.storagepool_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.storagemode_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      _impl_.volumename_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000040u) {
      _impl_.fstype_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(_impl_.secretref_ != nullptr);
      _impl_.secretref_->Clear();
    }
  }
  ::memset(&_impl_.sslenabled_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.readonly_) -
      reinterpret_cast<char*>(&_impl_.sslenabled_)) + sizeof(_impl_.readonly_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ScaleIOPersistentVolumeSource::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes gateway = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_gateway();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes system = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_system();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.SecretReference secretRef = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_secretref(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool sslEnabled = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_sslenabled(&has_bits);
          _impl_.sslenabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes protectionDomain = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_protectiondomain();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes storagePool = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_storagepool();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes storageMode = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_storagemode();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes volumeName = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_volumename();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes fsType = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_fstype();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool readOnly = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_readonly(&has_bits);
          _impl_.readonly_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ScaleIOPersistentVolumeSource::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.ScaleIOPersistentVolumeSource)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes gateway = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_gateway(), target);
  }

  // optional bytes system = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_system(), target);
  }

  // optional .k8s.io.api.core.v1.SecretReference secretRef = 3;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::secretref(this),
        _Internal::secretref(this).GetCachedSize(), target, stream);
  }

  // optional bool sslEnabled = 4;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_sslenabled(), target);
  }

  // optional bytes protectionDomain = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_protectiondomain(), target);
  }

  // optional bytes storagePool = 6;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        6, this->_internal_storagepool(), target);
  }

  // optional bytes storageMode = 7;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteBytesMaybeAliased(
        7, this->_internal_storagemode(), target);
  }

  // optional bytes volumeName = 8;
  if (cached_has_bits & 0x00000020u) {
    target = stream->WriteBytesMaybeAliased(
        8, this->_internal_volumename(), target);
  }

  // optional bytes fsType = 9;
  if (cached_has_bits & 0x00000040u) {
    target = stream->WriteBytesMaybeAliased(
        9, this->_internal_fstype(), target);
  }

  // optional bool readOnly = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(10, this->_internal_readonly(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.ScaleIOPersistentVolumeSource)
  return target;
}

size_t ScaleIOPersistentVolumeSource::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.ScaleIOPersistentVolumeSource)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bytes gateway = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_gateway());
    }

    // optional bytes system = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_system());
    }

    // optional bytes protectionDomain = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_protectiondomain());
    }

    // optional bytes storagePool = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_storagepool());
    }

    // optional bytes storageMode = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_storagemode());
    }

    // optional bytes volumeName = 8;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_volumename());
    }

    // optional bytes fsType = 9;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_fstype());
    }

    // optional .k8s.io.api.core.v1.SecretReference secretRef = 3;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.secretref_);
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional bool sslEnabled = 4;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional bool readOnly = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ScaleIOPersistentVolumeSource::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ScaleIOPersistentVolumeSource::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ScaleIOPersistentVolumeSource::GetClassData() const { return &_class_data_; }


void ScaleIOPersistentVolumeSource::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ScaleIOPersistentVolumeSource*>(&to_msg);
  auto& from = static_cast<const ScaleIOPersistentVolumeSource&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.ScaleIOPersistentVolumeSource)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_gateway(from._internal_gateway());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_system(from._internal_system());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_protectiondomain(from._internal_protectiondomain());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_storagepool(from._internal_storagepool());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_storagemode(from._internal_storagemode());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_set_volumename(from._internal_volumename());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_set_fstype(from._internal_fstype());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_mutable_secretref()->::k8s::io::api::core::v1::SecretReference::MergeFrom(
          from._internal_secretref());
    }
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.sslenabled_ = from._impl_.sslenabled_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.readonly_ = from._impl_.readonly_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ScaleIOPersistentVolumeSource::CopyFrom(const ScaleIOPersistentVolumeSource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.ScaleIOPersistentVolumeSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ScaleIOPersistentVolumeSource::IsInitialized() const {
  return true;
}

void ScaleIOPersistentVolumeSource::InternalSwap(ScaleIOPersistentVolumeSource* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.gateway_, lhs_arena,
      &other->_impl_.gateway_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.system_, lhs_arena,
      &other->_impl_.system_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.protectiondomain_, lhs_arena,
      &other->_impl_.protectiondomain_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.storagepool_, lhs_arena,
      &other->_impl_.storagepool_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.storagemode_, lhs_arena,
      &other->_impl_.storagemode_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.volumename_, lhs_arena,
      &other->_impl_.volumename_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.fstype_, lhs_arena,
      &other->_impl_.fstype_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ScaleIOPersistentVolumeSource, _impl_.readonly_)
      + sizeof(ScaleIOPersistentVolumeSource::_impl_.readonly_)
      - PROTOBUF_FIELD_OFFSET(ScaleIOPersistentVolumeSource, _impl_.secretref_)>(
          reinterpret_cast<char*>(&_impl_.secretref_),
          reinterpret_cast<char*>(&other->_impl_.secretref_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ScaleIOPersistentVolumeSource::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[204]);
}

// ===================================================================

class ScaleIOVolumeSource::_Internal {
 public:
  using HasBits = decltype(std::declval<ScaleIOVolumeSource>()._impl_._has_bits_);
  static void set_has_gateway(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_system(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::k8s::io::api::core::v1::LocalObjectReference& secretref(const ScaleIOVolumeSource* msg);
  static void set_has_secretref(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_sslenabled(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_protectiondomain(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_storagepool(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_storagemode(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_volumename(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_fstype(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_readonly(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
};

const ::k8s::io::api::core::v1::LocalObjectReference&
ScaleIOVolumeSource::_Internal::secretref(const ScaleIOVolumeSource* msg) {
  return *msg->_impl_.secretref_;
}
ScaleIOVolumeSource::ScaleIOVolumeSource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.ScaleIOVolumeSource)
}
ScaleIOVolumeSource::ScaleIOVolumeSource(const ScaleIOVolumeSource& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ScaleIOVolumeSource* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.gateway_){}
    , decltype(_impl_.system_){}
    , decltype(_impl_.protectiondomain_){}
    , decltype(_impl_.storagepool_){}
    , decltype(_impl_.storagemode_){}
    , decltype(_impl_.volumename_){}
    , decltype(_impl_.fstype_){}
    , decltype(_impl_.secretref_){nullptr}
    , decltype(_impl_.sslenabled_){}
    , decltype(_impl_.readonly_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.gateway_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.gateway_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_gateway()) {
    _this->_impl_.gateway_.Set(from._internal_gateway(), 
      _this->GetArenaForAllocation());
  }
  _impl_.system_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.system_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_system()) {
    _this->_impl_.system_.Set(from._internal_system(), 
      _this->GetArenaForAllocation());
  }
  _impl_.protectiondomain_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.protectiondomain_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_protectiondomain()) {
    _this->_impl_.protectiondomain_.Set(from._internal_protectiondomain(), 
      _this->GetArenaForAllocation());
  }
  _impl_.storagepool_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.storagepool_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_storagepool()) {
    _this->_impl_.storagepool_.Set(from._internal_storagepool(), 
      _this->GetArenaForAllocation());
  }
  _impl_.storagemode_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.storagemode_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_storagemode()) {
    _this->_impl_.storagemode_.Set(from._internal_storagemode(), 
      _this->GetArenaForAllocation());
  }
  _impl_.volumename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.volumename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_volumename()) {
    _this->_impl_.volumename_.Set(from._internal_volumename(), 
      _this->GetArenaForAllocation());
  }
  _impl_.fstype_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fstype_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_fstype()) {
    _this->_impl_.fstype_.Set(from._internal_fstype(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_secretref()) {
    _this->_impl_.secretref_ = new ::k8s::io::api::core::v1::LocalObjectReference(*from._impl_.secretref_);
  }
  ::memcpy(&_impl_.sslenabled_, &from._impl_.sslenabled_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.readonly_) -
    reinterpret_cast<char*>(&_impl_.sslenabled_)) + sizeof(_impl_.readonly_));
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.ScaleIOVolumeSource)
}

inline void ScaleIOVolumeSource::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.gateway_){}
    , decltype(_impl_.system_){}
    , decltype(_impl_.protectiondomain_){}
    , decltype(_impl_.storagepool_){}
    , decltype(_impl_.storagemode_){}
    , decltype(_impl_.volumename_){}
    , decltype(_impl_.fstype_){}
    , decltype(_impl_.secretref_){nullptr}
    , decltype(_impl_.sslenabled_){false}
    , decltype(_impl_.readonly_){false}
  };
  _impl_.gateway_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.gateway_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.system_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.system_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.protectiondomain_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.protectiondomain_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.storagepool_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.storagepool_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.storagemode_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.storagemode_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.volumename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.volumename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.fstype_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fstype_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ScaleIOVolumeSource::~ScaleIOVolumeSource() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.ScaleIOVolumeSource)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ScaleIOVolumeSource::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.gateway_.Destroy();
  _impl_.system_.Destroy();
  _impl_.protectiondomain_.Destroy();
  _impl_.storagepool_.Destroy();
  _impl_.storagemode_.Destroy();
  _impl_.volumename_.Destroy();
  _impl_.fstype_.Destroy();
  if (this != internal_default_instance()) delete _impl_.secretref_;
}

void ScaleIOVolumeSource::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ScaleIOVolumeSource::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.ScaleIOVolumeSource)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.gateway_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.system_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.protectiondomain_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.storagepool_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.storagemode_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      _impl_.volumename_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000040u) {
      _impl_.fstype_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(_impl_.secretref_ != nullptr);
      _impl_.secretref_->Clear();
    }
  }
  ::memset(&_impl_.sslenabled_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.readonly_) -
      reinterpret_cast<char*>(&_impl_.sslenabled_)) + sizeof(_impl_.readonly_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ScaleIOVolumeSource::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes gateway = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_gateway();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes system = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_system();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.LocalObjectReference secretRef = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_secretref(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool sslEnabled = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_sslenabled(&has_bits);
          _impl_.sslenabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes protectionDomain = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_protectiondomain();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes storagePool = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_storagepool();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes storageMode = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_storagemode();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes volumeName = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_volumename();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes fsType = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_fstype();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool readOnly = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_readonly(&has_bits);
          _impl_.readonly_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ScaleIOVolumeSource::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.ScaleIOVolumeSource)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes gateway = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_gateway(), target);
  }

  // optional bytes system = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_system(), target);
  }

  // optional .k8s.io.api.core.v1.LocalObjectReference secretRef = 3;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::secretref(this),
        _Internal::secretref(this).GetCachedSize(), target, stream);
  }

  // optional bool sslEnabled = 4;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_sslenabled(), target);
  }

  // optional bytes protectionDomain = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_protectiondomain(), target);
  }

  // optional bytes storagePool = 6;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        6, this->_internal_storagepool(), target);
  }

  // optional bytes storageMode = 7;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteBytesMaybeAliased(
        7, this->_internal_storagemode(), target);
  }

  // optional bytes volumeName = 8;
  if (cached_has_bits & 0x00000020u) {
    target = stream->WriteBytesMaybeAliased(
        8, this->_internal_volumename(), target);
  }

  // optional bytes fsType = 9;
  if (cached_has_bits & 0x00000040u) {
    target = stream->WriteBytesMaybeAliased(
        9, this->_internal_fstype(), target);
  }

  // optional bool readOnly = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(10, this->_internal_readonly(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.ScaleIOVolumeSource)
  return target;
}

size_t ScaleIOVolumeSource::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.ScaleIOVolumeSource)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bytes gateway = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_gateway());
    }

    // optional bytes system = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_system());
    }

    // optional bytes protectionDomain = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_protectiondomain());
    }

    // optional bytes storagePool = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_storagepool());
    }

    // optional bytes storageMode = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_storagemode());
    }

    // optional bytes volumeName = 8;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_volumename());
    }

    // optional bytes fsType = 9;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_fstype());
    }

    // optional .k8s.io.api.core.v1.LocalObjectReference secretRef = 3;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.secretref_);
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional bool sslEnabled = 4;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional bool readOnly = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ScaleIOVolumeSource::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ScaleIOVolumeSource::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ScaleIOVolumeSource::GetClassData() const { return &_class_data_; }


void ScaleIOVolumeSource::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ScaleIOVolumeSource*>(&to_msg);
  auto& from = static_cast<const ScaleIOVolumeSource&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.ScaleIOVolumeSource)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_gateway(from._internal_gateway());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_system(from._internal_system());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_protectiondomain(from._internal_protectiondomain());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_storagepool(from._internal_storagepool());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_storagemode(from._internal_storagemode());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_set_volumename(from._internal_volumename());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_set_fstype(from._internal_fstype());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_mutable_secretref()->::k8s::io::api::core::v1::LocalObjectReference::MergeFrom(
          from._internal_secretref());
    }
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.sslenabled_ = from._impl_.sslenabled_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.readonly_ = from._impl_.readonly_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ScaleIOVolumeSource::CopyFrom(const ScaleIOVolumeSource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.ScaleIOVolumeSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ScaleIOVolumeSource::IsInitialized() const {
  return true;
}

void ScaleIOVolumeSource::InternalSwap(ScaleIOVolumeSource* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.gateway_, lhs_arena,
      &other->_impl_.gateway_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.system_, lhs_arena,
      &other->_impl_.system_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.protectiondomain_, lhs_arena,
      &other->_impl_.protectiondomain_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.storagepool_, lhs_arena,
      &other->_impl_.storagepool_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.storagemode_, lhs_arena,
      &other->_impl_.storagemode_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.volumename_, lhs_arena,
      &other->_impl_.volumename_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.fstype_, lhs_arena,
      &other->_impl_.fstype_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ScaleIOVolumeSource, _impl_.readonly_)
      + sizeof(ScaleIOVolumeSource::_impl_.readonly_)
      - PROTOBUF_FIELD_OFFSET(ScaleIOVolumeSource, _impl_.secretref_)>(
          reinterpret_cast<char*>(&_impl_.secretref_),
          reinterpret_cast<char*>(&other->_impl_.secretref_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ScaleIOVolumeSource::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[205]);
}

// ===================================================================

class ScopeSelector::_Internal {
 public:
};

ScopeSelector::ScopeSelector(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.ScopeSelector)
}
ScopeSelector::ScopeSelector(const ScopeSelector& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ScopeSelector* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.matchexpressions_){from._impl_.matchexpressions_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.ScopeSelector)
}

inline void ScopeSelector::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.matchexpressions_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ScopeSelector::~ScopeSelector() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.ScopeSelector)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ScopeSelector::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.matchexpressions_.~RepeatedPtrField();
}

void ScopeSelector::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ScopeSelector::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.ScopeSelector)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.matchexpressions_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ScopeSelector::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .k8s.io.api.core.v1.ScopedResourceSelectorRequirement matchExpressions = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_matchexpressions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ScopeSelector::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.ScopeSelector)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .k8s.io.api.core.v1.ScopedResourceSelectorRequirement matchExpressions = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_matchexpressions_size()); i < n; i++) {
    const auto& repfield = this->_internal_matchexpressions(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.ScopeSelector)
  return target;
}

size_t ScopeSelector::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.ScopeSelector)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .k8s.io.api.core.v1.ScopedResourceSelectorRequirement matchExpressions = 1;
  total_size += 1UL * this->_internal_matchexpressions_size();
  for (const auto& msg : this->_impl_.matchexpressions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ScopeSelector::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ScopeSelector::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ScopeSelector::GetClassData() const { return &_class_data_; }


void ScopeSelector::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ScopeSelector*>(&to_msg);
  auto& from = static_cast<const ScopeSelector&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.ScopeSelector)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.matchexpressions_.MergeFrom(from._impl_.matchexpressions_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ScopeSelector::CopyFrom(const ScopeSelector& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.ScopeSelector)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ScopeSelector::IsInitialized() const {
  return true;
}

void ScopeSelector::InternalSwap(ScopeSelector* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.matchexpressions_.InternalSwap(&other->_impl_.matchexpressions_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ScopeSelector::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[206]);
}

// ===================================================================

class ScopedResourceSelectorRequirement::_Internal {
 public:
  using HasBits = decltype(std::declval<ScopedResourceSelectorRequirement>()._impl_._has_bits_);
  static void set_has_scopename(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_operator_(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ScopedResourceSelectorRequirement::ScopedResourceSelectorRequirement(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.ScopedResourceSelectorRequirement)
}
ScopedResourceSelectorRequirement::ScopedResourceSelectorRequirement(const ScopedResourceSelectorRequirement& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ScopedResourceSelectorRequirement* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.values_){from._impl_.values_}
    , decltype(_impl_.scopename_){}
    , decltype(_impl_.operator__){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.scopename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.scopename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_scopename()) {
    _this->_impl_.scopename_.Set(from._internal_scopename(), 
      _this->GetArenaForAllocation());
  }
  _impl_.operator__.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.operator__.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_operator_()) {
    _this->_impl_.operator__.Set(from._internal_operator_(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.ScopedResourceSelectorRequirement)
}

inline void ScopedResourceSelectorRequirement::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.values_){arena}
    , decltype(_impl_.scopename_){}
    , decltype(_impl_.operator__){}
  };
  _impl_.scopename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.scopename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.operator__.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.operator__.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ScopedResourceSelectorRequirement::~ScopedResourceSelectorRequirement() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.ScopedResourceSelectorRequirement)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ScopedResourceSelectorRequirement::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.values_.~RepeatedPtrField();
  _impl_.scopename_.Destroy();
  _impl_.operator__.Destroy();
}

void ScopedResourceSelectorRequirement::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ScopedResourceSelectorRequirement::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.ScopedResourceSelectorRequirement)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.values_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.scopename_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.operator__.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ScopedResourceSelectorRequirement::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes scopeName = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_scopename();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes operator = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_operator_();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string values = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_values();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "k8s.io.api.core.v1.ScopedResourceSelectorRequirement.values");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ScopedResourceSelectorRequirement::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.ScopedResourceSelectorRequirement)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes scopeName = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_scopename(), target);
  }

  // optional bytes operator = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_operator_(), target);
  }

  // repeated string values = 3;
  for (int i = 0, n = this->_internal_values_size(); i < n; i++) {
    const auto& s = this->_internal_values(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "k8s.io.api.core.v1.ScopedResourceSelectorRequirement.values");
    target = stream->WriteString(3, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.ScopedResourceSelectorRequirement)
  return target;
}

size_t ScopedResourceSelectorRequirement::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.ScopedResourceSelectorRequirement)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string values = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.values_.size());
  for (int i = 0, n = _impl_.values_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.values_.Get(i));
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes scopeName = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_scopename());
    }

    // optional bytes operator = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_operator_());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ScopedResourceSelectorRequirement::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ScopedResourceSelectorRequirement::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ScopedResourceSelectorRequirement::GetClassData() const { return &_class_data_; }


void ScopedResourceSelectorRequirement::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ScopedResourceSelectorRequirement*>(&to_msg);
  auto& from = static_cast<const ScopedResourceSelectorRequirement&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.ScopedResourceSelectorRequirement)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.values_.MergeFrom(from._impl_.values_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_scopename(from._internal_scopename());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_operator_(from._internal_operator_());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ScopedResourceSelectorRequirement::CopyFrom(const ScopedResourceSelectorRequirement& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.ScopedResourceSelectorRequirement)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ScopedResourceSelectorRequirement::IsInitialized() const {
  return true;
}

void ScopedResourceSelectorRequirement::InternalSwap(ScopedResourceSelectorRequirement* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.values_.InternalSwap(&other->_impl_.values_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.scopename_, lhs_arena,
      &other->_impl_.scopename_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.operator__, lhs_arena,
      &other->_impl_.operator__, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ScopedResourceSelectorRequirement::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[207]);
}

// ===================================================================

class SeccompProfile::_Internal {
 public:
  using HasBits = decltype(std::declval<SeccompProfile>()._impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_localhostprofile(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

SeccompProfile::SeccompProfile(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.SeccompProfile)
}
SeccompProfile::SeccompProfile(const SeccompProfile& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SeccompProfile* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.type_){}
    , decltype(_impl_.localhostprofile_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_type()) {
    _this->_impl_.type_.Set(from._internal_type(), 
      _this->GetArenaForAllocation());
  }
  _impl_.localhostprofile_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.localhostprofile_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_localhostprofile()) {
    _this->_impl_.localhostprofile_.Set(from._internal_localhostprofile(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.SeccompProfile)
}

inline void SeccompProfile::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.type_){}
    , decltype(_impl_.localhostprofile_){}
  };
  _impl_.type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.localhostprofile_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.localhostprofile_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SeccompProfile::~SeccompProfile() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.SeccompProfile)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SeccompProfile::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.type_.Destroy();
  _impl_.localhostprofile_.Destroy();
}

void SeccompProfile::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SeccompProfile::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.SeccompProfile)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.type_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.localhostprofile_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SeccompProfile::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes localhostProfile = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_localhostprofile();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SeccompProfile::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.SeccompProfile)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_type(), target);
  }

  // optional bytes localhostProfile = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_localhostprofile(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.SeccompProfile)
  return target;
}

size_t SeccompProfile::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.SeccompProfile)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes type = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_type());
    }

    // optional bytes localhostProfile = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_localhostprofile());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SeccompProfile::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SeccompProfile::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SeccompProfile::GetClassData() const { return &_class_data_; }


void SeccompProfile::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SeccompProfile*>(&to_msg);
  auto& from = static_cast<const SeccompProfile&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.SeccompProfile)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_type(from._internal_type());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_localhostprofile(from._internal_localhostprofile());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SeccompProfile::CopyFrom(const SeccompProfile& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.SeccompProfile)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SeccompProfile::IsInitialized() const {
  return true;
}

void SeccompProfile::InternalSwap(SeccompProfile* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.type_, lhs_arena,
      &other->_impl_.type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.localhostprofile_, lhs_arena,
      &other->_impl_.localhostprofile_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata SeccompProfile::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[208]);
}

// ===================================================================

Secret_DataEntry_DoNotUse::Secret_DataEntry_DoNotUse() {}
Secret_DataEntry_DoNotUse::Secret_DataEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void Secret_DataEntry_DoNotUse::MergeFrom(const Secret_DataEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata Secret_DataEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[209]);
}

// ===================================================================

Secret_StringDataEntry_DoNotUse::Secret_StringDataEntry_DoNotUse() {}
Secret_StringDataEntry_DoNotUse::Secret_StringDataEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void Secret_StringDataEntry_DoNotUse::MergeFrom(const Secret_StringDataEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata Secret_StringDataEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[210]);
}

// ===================================================================

class Secret::_Internal {
 public:
  using HasBits = decltype(std::declval<Secret>()._impl_._has_bits_);
  static const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& metadata(const Secret* msg);
  static void set_has_metadata(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_immutable(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta&
Secret::_Internal::metadata(const Secret* msg) {
  return *msg->_impl_.metadata_;
}
void Secret::clear_metadata() {
  if (_impl_.metadata_ != nullptr) _impl_.metadata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
Secret::Secret(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &Secret::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.Secret)
}
Secret::Secret(const Secret& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Secret* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_.data_)*/{}
    , /*decltype(_impl_.stringdata_)*/{}
    , decltype(_impl_.type_){}
    , decltype(_impl_.metadata_){nullptr}
    , decltype(_impl_.immutable_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.data_.MergeFrom(from._impl_.data_);
  _this->_impl_.stringdata_.MergeFrom(from._impl_.stringdata_);
  _impl_.type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_type()) {
    _this->_impl_.type_.Set(from._internal_type(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_metadata()) {
    _this->_impl_.metadata_ = new ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta(*from._impl_.metadata_);
  }
  _this->_impl_.immutable_ = from._impl_.immutable_;
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.Secret)
}

inline void Secret::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_.data_)*/{::_pbi::ArenaInitialized(), arena}
    , /*decltype(_impl_.stringdata_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.type_){}
    , decltype(_impl_.metadata_){nullptr}
    , decltype(_impl_.immutable_){false}
  };
  _impl_.type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Secret::~Secret() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.Secret)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void Secret::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.data_.Destruct();
  _impl_.data_.~MapField();
  _impl_.stringdata_.Destruct();
  _impl_.stringdata_.~MapField();
  _impl_.type_.Destroy();
  if (this != internal_default_instance()) delete _impl_.metadata_;
}

void Secret::ArenaDtor(void* object) {
  Secret* _this = reinterpret_cast< Secret* >(object);
  _this->_impl_.data_.Destruct();
  _this->_impl_.stringdata_.Destruct();
}
void Secret::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Secret::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.Secret)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.data_.Clear();
  _impl_.stringdata_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.type_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.metadata_ != nullptr);
      _impl_.metadata_->Clear();
    }
  }
  _impl_.immutable_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Secret::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_metadata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // map<string, bytes> data = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.data_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bytes type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // map<string, string> stringData = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.stringdata_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool immutable = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_immutable(&has_bits);
          _impl_.immutable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Secret::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.Secret)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::metadata(this),
        _Internal::metadata(this).GetCachedSize(), target, stream);
  }

  // map<string, bytes> data = 2;
  if (!this->_internal_data().empty()) {
    using MapType = ::_pb::Map<std::string, std::string>;
    using WireHelper = Secret_DataEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_data();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "k8s.io.api.core.v1.Secret.DataEntry.key");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(2, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(2, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  // optional bytes type = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_type(), target);
  }

  // map<string, string> stringData = 4;
  if (!this->_internal_stringdata().empty()) {
    using MapType = ::_pb::Map<std::string, std::string>;
    using WireHelper = Secret_StringDataEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_stringdata();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "k8s.io.api.core.v1.Secret.StringDataEntry.key");
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        entry.second.data(), static_cast<int>(entry.second.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "k8s.io.api.core.v1.Secret.StringDataEntry.value");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(4, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(4, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  // optional bool immutable = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_immutable(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.Secret)
  return target;
}

size_t Secret::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.Secret)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, bytes> data = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_data_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
      it = this->_internal_data().begin();
      it != this->_internal_data().end(); ++it) {
    total_size += Secret_DataEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // map<string, string> stringData = 4;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_stringdata_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
      it = this->_internal_stringdata().begin();
      it != this->_internal_stringdata().end(); ++it) {
    total_size += Secret_StringDataEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bytes type = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_type());
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.metadata_);
    }

    // optional bool immutable = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Secret::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Secret::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Secret::GetClassData() const { return &_class_data_; }


void Secret::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Secret*>(&to_msg);
  auto& from = static_cast<const Secret&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.Secret)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.data_.MergeFrom(from._impl_.data_);
  _this->_impl_.stringdata_.MergeFrom(from._impl_.stringdata_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_type(from._internal_type());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_metadata()->::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta::MergeFrom(
          from._internal_metadata());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.immutable_ = from._impl_.immutable_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Secret::CopyFrom(const Secret& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.Secret)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Secret::IsInitialized() const {
  return true;
}

void Secret::InternalSwap(Secret* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.data_.InternalSwap(&other->_impl_.data_);
  _impl_.stringdata_.InternalSwap(&other->_impl_.stringdata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.type_, lhs_arena,
      &other->_impl_.type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Secret, _impl_.immutable_)
      + sizeof(Secret::_impl_.immutable_)
      - PROTOBUF_FIELD_OFFSET(Secret, _impl_.metadata_)>(
          reinterpret_cast<char*>(&_impl_.metadata_),
          reinterpret_cast<char*>(&other->_impl_.metadata_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Secret::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[211]);
}

// ===================================================================

class SecretEnvSource::_Internal {
 public:
  using HasBits = decltype(std::declval<SecretEnvSource>()._impl_._has_bits_);
  static const ::k8s::io::api::core::v1::LocalObjectReference& localobjectreference(const SecretEnvSource* msg);
  static void set_has_localobjectreference(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_optional(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::k8s::io::api::core::v1::LocalObjectReference&
SecretEnvSource::_Internal::localobjectreference(const SecretEnvSource* msg) {
  return *msg->_impl_.localobjectreference_;
}
SecretEnvSource::SecretEnvSource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.SecretEnvSource)
}
SecretEnvSource::SecretEnvSource(const SecretEnvSource& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SecretEnvSource* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.localobjectreference_){nullptr}
    , decltype(_impl_.optional_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_localobjectreference()) {
    _this->_impl_.localobjectreference_ = new ::k8s::io::api::core::v1::LocalObjectReference(*from._impl_.localobjectreference_);
  }
  _this->_impl_.optional_ = from._impl_.optional_;
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.SecretEnvSource)
}

inline void SecretEnvSource::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.localobjectreference_){nullptr}
    , decltype(_impl_.optional_){false}
  };
}

SecretEnvSource::~SecretEnvSource() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.SecretEnvSource)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SecretEnvSource::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.localobjectreference_;
}

void SecretEnvSource::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SecretEnvSource::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.SecretEnvSource)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.localobjectreference_ != nullptr);
    _impl_.localobjectreference_->Clear();
  }
  _impl_.optional_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SecretEnvSource::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .k8s.io.api.core.v1.LocalObjectReference localObjectReference = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_localobjectreference(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool optional = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_optional(&has_bits);
          _impl_.optional_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SecretEnvSource::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.SecretEnvSource)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .k8s.io.api.core.v1.LocalObjectReference localObjectReference = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::localobjectreference(this),
        _Internal::localobjectreference(this).GetCachedSize(), target, stream);
  }

  // optional bool optional = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_optional(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.SecretEnvSource)
  return target;
}

size_t SecretEnvSource::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.SecretEnvSource)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .k8s.io.api.core.v1.LocalObjectReference localObjectReference = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.localobjectreference_);
    }

    // optional bool optional = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SecretEnvSource::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SecretEnvSource::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SecretEnvSource::GetClassData() const { return &_class_data_; }


void SecretEnvSource::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SecretEnvSource*>(&to_msg);
  auto& from = static_cast<const SecretEnvSource&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.SecretEnvSource)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_localobjectreference()->::k8s::io::api::core::v1::LocalObjectReference::MergeFrom(
          from._internal_localobjectreference());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.optional_ = from._impl_.optional_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SecretEnvSource::CopyFrom(const SecretEnvSource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.SecretEnvSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SecretEnvSource::IsInitialized() const {
  return true;
}

void SecretEnvSource::InternalSwap(SecretEnvSource* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SecretEnvSource, _impl_.optional_)
      + sizeof(SecretEnvSource::_impl_.optional_)
      - PROTOBUF_FIELD_OFFSET(SecretEnvSource, _impl_.localobjectreference_)>(
          reinterpret_cast<char*>(&_impl_.localobjectreference_),
          reinterpret_cast<char*>(&other->_impl_.localobjectreference_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SecretEnvSource::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[212]);
}

// ===================================================================

class SecretKeySelector::_Internal {
 public:
  using HasBits = decltype(std::declval<SecretKeySelector>()._impl_._has_bits_);
  static const ::k8s::io::api::core::v1::LocalObjectReference& localobjectreference(const SecretKeySelector* msg);
  static void set_has_localobjectreference(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_optional(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::k8s::io::api::core::v1::LocalObjectReference&
SecretKeySelector::_Internal::localobjectreference(const SecretKeySelector* msg) {
  return *msg->_impl_.localobjectreference_;
}
SecretKeySelector::SecretKeySelector(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.SecretKeySelector)
}
SecretKeySelector::SecretKeySelector(const SecretKeySelector& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SecretKeySelector* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.key_){}
    , decltype(_impl_.localobjectreference_){nullptr}
    , decltype(_impl_.optional_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_key()) {
    _this->_impl_.key_.Set(from._internal_key(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_localobjectreference()) {
    _this->_impl_.localobjectreference_ = new ::k8s::io::api::core::v1::LocalObjectReference(*from._impl_.localobjectreference_);
  }
  _this->_impl_.optional_ = from._impl_.optional_;
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.SecretKeySelector)
}

inline void SecretKeySelector::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.key_){}
    , decltype(_impl_.localobjectreference_){nullptr}
    , decltype(_impl_.optional_){false}
  };
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SecretKeySelector::~SecretKeySelector() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.SecretKeySelector)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SecretKeySelector::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.key_.Destroy();
  if (this != internal_default_instance()) delete _impl_.localobjectreference_;
}

void SecretKeySelector::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SecretKeySelector::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.SecretKeySelector)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.key_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.localobjectreference_ != nullptr);
      _impl_.localobjectreference_->Clear();
    }
  }
  _impl_.optional_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SecretKeySelector::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .k8s.io.api.core.v1.LocalObjectReference localObjectReference = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_localobjectreference(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes key = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool optional = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_optional(&has_bits);
          _impl_.optional_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SecretKeySelector::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.SecretKeySelector)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .k8s.io.api.core.v1.LocalObjectReference localObjectReference = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::localobjectreference(this),
        _Internal::localobjectreference(this).GetCachedSize(), target, stream);
  }

  // optional bytes key = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_key(), target);
  }

  // optional bool optional = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_optional(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.SecretKeySelector)
  return target;
}

size_t SecretKeySelector::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.SecretKeySelector)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bytes key = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_key());
    }

    // optional .k8s.io.api.core.v1.LocalObjectReference localObjectReference = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.localobjectreference_);
    }

    // optional bool optional = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SecretKeySelector::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SecretKeySelector::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SecretKeySelector::GetClassData() const { return &_class_data_; }


void SecretKeySelector::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SecretKeySelector*>(&to_msg);
  auto& from = static_cast<const SecretKeySelector&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.SecretKeySelector)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_key(from._internal_key());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_localobjectreference()->::k8s::io::api::core::v1::LocalObjectReference::MergeFrom(
          from._internal_localobjectreference());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.optional_ = from._impl_.optional_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SecretKeySelector::CopyFrom(const SecretKeySelector& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.SecretKeySelector)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SecretKeySelector::IsInitialized() const {
  return true;
}

void SecretKeySelector::InternalSwap(SecretKeySelector* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.key_, lhs_arena,
      &other->_impl_.key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SecretKeySelector, _impl_.optional_)
      + sizeof(SecretKeySelector::_impl_.optional_)
      - PROTOBUF_FIELD_OFFSET(SecretKeySelector, _impl_.localobjectreference_)>(
          reinterpret_cast<char*>(&_impl_.localobjectreference_),
          reinterpret_cast<char*>(&other->_impl_.localobjectreference_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SecretKeySelector::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[213]);
}

// ===================================================================

class SecretList::_Internal {
 public:
  using HasBits = decltype(std::declval<SecretList>()._impl_._has_bits_);
  static const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& metadata(const SecretList* msg);
  static void set_has_metadata(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta&
SecretList::_Internal::metadata(const SecretList* msg) {
  return *msg->_impl_.metadata_;
}
void SecretList::clear_metadata() {
  if (_impl_.metadata_ != nullptr) _impl_.metadata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
SecretList::SecretList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.SecretList)
}
SecretList::SecretList(const SecretList& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SecretList* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.items_){from._impl_.items_}
    , decltype(_impl_.metadata_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_metadata()) {
    _this->_impl_.metadata_ = new ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta(*from._impl_.metadata_);
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.SecretList)
}

inline void SecretList::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.items_){arena}
    , decltype(_impl_.metadata_){nullptr}
  };
}

SecretList::~SecretList() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.SecretList)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SecretList::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.items_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.metadata_;
}

void SecretList::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SecretList::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.SecretList)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.items_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.metadata_ != nullptr);
    _impl_.metadata_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SecretList::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_metadata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .k8s.io.api.core.v1.Secret items = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_items(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SecretList::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.SecretList)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::metadata(this),
        _Internal::metadata(this).GetCachedSize(), target, stream);
  }

  // repeated .k8s.io.api.core.v1.Secret items = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_items_size()); i < n; i++) {
    const auto& repfield = this->_internal_items(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.SecretList)
  return target;
}

size_t SecretList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.SecretList)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .k8s.io.api.core.v1.Secret items = 2;
  total_size += 1UL * this->_internal_items_size();
  for (const auto& msg : this->_impl_.items_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.metadata_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SecretList::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SecretList::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SecretList::GetClassData() const { return &_class_data_; }


void SecretList::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SecretList*>(&to_msg);
  auto& from = static_cast<const SecretList&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.SecretList)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.items_.MergeFrom(from._impl_.items_);
  if (from._internal_has_metadata()) {
    _this->_internal_mutable_metadata()->::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta::MergeFrom(
        from._internal_metadata());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SecretList::CopyFrom(const SecretList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.SecretList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SecretList::IsInitialized() const {
  return true;
}

void SecretList::InternalSwap(SecretList* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.items_.InternalSwap(&other->_impl_.items_);
  swap(_impl_.metadata_, other->_impl_.metadata_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SecretList::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[214]);
}

// ===================================================================

class SecretProjection::_Internal {
 public:
  using HasBits = decltype(std::declval<SecretProjection>()._impl_._has_bits_);
  static const ::k8s::io::api::core::v1::LocalObjectReference& localobjectreference(const SecretProjection* msg);
  static void set_has_localobjectreference(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_optional(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::k8s::io::api::core::v1::LocalObjectReference&
SecretProjection::_Internal::localobjectreference(const SecretProjection* msg) {
  return *msg->_impl_.localobjectreference_;
}
SecretProjection::SecretProjection(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.SecretProjection)
}
SecretProjection::SecretProjection(const SecretProjection& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SecretProjection* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.items_){from._impl_.items_}
    , decltype(_impl_.localobjectreference_){nullptr}
    , decltype(_impl_.optional_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_localobjectreference()) {
    _this->_impl_.localobjectreference_ = new ::k8s::io::api::core::v1::LocalObjectReference(*from._impl_.localobjectreference_);
  }
  _this->_impl_.optional_ = from._impl_.optional_;
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.SecretProjection)
}

inline void SecretProjection::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.items_){arena}
    , decltype(_impl_.localobjectreference_){nullptr}
    , decltype(_impl_.optional_){false}
  };
}

SecretProjection::~SecretProjection() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.SecretProjection)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SecretProjection::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.items_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.localobjectreference_;
}

void SecretProjection::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SecretProjection::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.SecretProjection)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.items_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.localobjectreference_ != nullptr);
    _impl_.localobjectreference_->Clear();
  }
  _impl_.optional_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SecretProjection::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .k8s.io.api.core.v1.LocalObjectReference localObjectReference = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_localobjectreference(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .k8s.io.api.core.v1.KeyToPath items = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_items(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool optional = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_optional(&has_bits);
          _impl_.optional_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SecretProjection::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.SecretProjection)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .k8s.io.api.core.v1.LocalObjectReference localObjectReference = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::localobjectreference(this),
        _Internal::localobjectreference(this).GetCachedSize(), target, stream);
  }

  // repeated .k8s.io.api.core.v1.KeyToPath items = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_items_size()); i < n; i++) {
    const auto& repfield = this->_internal_items(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bool optional = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_optional(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.SecretProjection)
  return target;
}

size_t SecretProjection::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.SecretProjection)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .k8s.io.api.core.v1.KeyToPath items = 2;
  total_size += 1UL * this->_internal_items_size();
  for (const auto& msg : this->_impl_.items_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .k8s.io.api.core.v1.LocalObjectReference localObjectReference = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.localobjectreference_);
    }

    // optional bool optional = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SecretProjection::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SecretProjection::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SecretProjection::GetClassData() const { return &_class_data_; }


void SecretProjection::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SecretProjection*>(&to_msg);
  auto& from = static_cast<const SecretProjection&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.SecretProjection)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.items_.MergeFrom(from._impl_.items_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_localobjectreference()->::k8s::io::api::core::v1::LocalObjectReference::MergeFrom(
          from._internal_localobjectreference());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.optional_ = from._impl_.optional_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SecretProjection::CopyFrom(const SecretProjection& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.SecretProjection)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SecretProjection::IsInitialized() const {
  return true;
}

void SecretProjection::InternalSwap(SecretProjection* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.items_.InternalSwap(&other->_impl_.items_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SecretProjection, _impl_.optional_)
      + sizeof(SecretProjection::_impl_.optional_)
      - PROTOBUF_FIELD_OFFSET(SecretProjection, _impl_.localobjectreference_)>(
          reinterpret_cast<char*>(&_impl_.localobjectreference_),
          reinterpret_cast<char*>(&other->_impl_.localobjectreference_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SecretProjection::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[215]);
}

// ===================================================================

class SecretReference::_Internal {
 public:
  using HasBits = decltype(std::declval<SecretReference>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_namespace_(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

SecretReference::SecretReference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.SecretReference)
}
SecretReference::SecretReference(const SecretReference& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SecretReference* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.namespace__){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.namespace__.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.namespace__.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_namespace_()) {
    _this->_impl_.namespace__.Set(from._internal_namespace_(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.SecretReference)
}

inline void SecretReference::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.namespace__){}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.namespace__.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.namespace__.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SecretReference::~SecretReference() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.SecretReference)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SecretReference::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.namespace__.Destroy();
}

void SecretReference::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SecretReference::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.SecretReference)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.namespace__.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SecretReference::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes namespace = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_namespace_();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SecretReference::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.SecretReference)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional bytes namespace = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_namespace_(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.SecretReference)
  return target;
}

size_t SecretReference::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.SecretReference)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_name());
    }

    // optional bytes namespace = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_namespace_());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SecretReference::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SecretReference::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SecretReference::GetClassData() const { return &_class_data_; }


void SecretReference::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SecretReference*>(&to_msg);
  auto& from = static_cast<const SecretReference&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.SecretReference)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_namespace_(from._internal_namespace_());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SecretReference::CopyFrom(const SecretReference& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.SecretReference)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SecretReference::IsInitialized() const {
  return true;
}

void SecretReference::InternalSwap(SecretReference* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.namespace__, lhs_arena,
      &other->_impl_.namespace__, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata SecretReference::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[216]);
}

// ===================================================================

class SecretVolumeSource::_Internal {
 public:
  using HasBits = decltype(std::declval<SecretVolumeSource>()._impl_._has_bits_);
  static void set_has_secretname(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_defaultmode(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_optional(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

SecretVolumeSource::SecretVolumeSource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.SecretVolumeSource)
}
SecretVolumeSource::SecretVolumeSource(const SecretVolumeSource& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SecretVolumeSource* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.items_){from._impl_.items_}
    , decltype(_impl_.secretname_){}
    , decltype(_impl_.defaultmode_){}
    , decltype(_impl_.optional_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.secretname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.secretname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_secretname()) {
    _this->_impl_.secretname_.Set(from._internal_secretname(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.defaultmode_, &from._impl_.defaultmode_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.optional_) -
    reinterpret_cast<char*>(&_impl_.defaultmode_)) + sizeof(_impl_.optional_));
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.SecretVolumeSource)
}

inline void SecretVolumeSource::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.items_){arena}
    , decltype(_impl_.secretname_){}
    , decltype(_impl_.defaultmode_){0}
    , decltype(_impl_.optional_){false}
  };
  _impl_.secretname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.secretname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SecretVolumeSource::~SecretVolumeSource() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.SecretVolumeSource)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SecretVolumeSource::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.items_.~RepeatedPtrField();
  _impl_.secretname_.Destroy();
}

void SecretVolumeSource::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SecretVolumeSource::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.SecretVolumeSource)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.items_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.secretname_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.defaultmode_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.optional_) -
        reinterpret_cast<char*>(&_impl_.defaultmode_)) + sizeof(_impl_.optional_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SecretVolumeSource::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes secretName = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_secretname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .k8s.io.api.core.v1.KeyToPath items = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_items(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional int32 defaultMode = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_defaultmode(&has_bits);
          _impl_.defaultmode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool optional = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_optional(&has_bits);
          _impl_.optional_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SecretVolumeSource::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.SecretVolumeSource)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes secretName = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_secretname(), target);
  }

  // repeated .k8s.io.api.core.v1.KeyToPath items = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_items_size()); i < n; i++) {
    const auto& repfield = this->_internal_items(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional int32 defaultMode = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_defaultmode(), target);
  }

  // optional bool optional = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_optional(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.SecretVolumeSource)
  return target;
}

size_t SecretVolumeSource::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.SecretVolumeSource)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .k8s.io.api.core.v1.KeyToPath items = 2;
  total_size += 1UL * this->_internal_items_size();
  for (const auto& msg : this->_impl_.items_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bytes secretName = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_secretname());
    }

    // optional int32 defaultMode = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_defaultmode());
    }

    // optional bool optional = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SecretVolumeSource::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SecretVolumeSource::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SecretVolumeSource::GetClassData() const { return &_class_data_; }


void SecretVolumeSource::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SecretVolumeSource*>(&to_msg);
  auto& from = static_cast<const SecretVolumeSource&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.SecretVolumeSource)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.items_.MergeFrom(from._impl_.items_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_secretname(from._internal_secretname());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.defaultmode_ = from._impl_.defaultmode_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.optional_ = from._impl_.optional_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SecretVolumeSource::CopyFrom(const SecretVolumeSource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.SecretVolumeSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SecretVolumeSource::IsInitialized() const {
  return true;
}

void SecretVolumeSource::InternalSwap(SecretVolumeSource* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.items_.InternalSwap(&other->_impl_.items_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.secretname_, lhs_arena,
      &other->_impl_.secretname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SecretVolumeSource, _impl_.optional_)
      + sizeof(SecretVolumeSource::_impl_.optional_)
      - PROTOBUF_FIELD_OFFSET(SecretVolumeSource, _impl_.defaultmode_)>(
          reinterpret_cast<char*>(&_impl_.defaultmode_),
          reinterpret_cast<char*>(&other->_impl_.defaultmode_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SecretVolumeSource::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[217]);
}

// ===================================================================

class SecurityContext::_Internal {
 public:
  using HasBits = decltype(std::declval<SecurityContext>()._impl_._has_bits_);
  static const ::k8s::io::api::core::v1::Capabilities& capabilities(const SecurityContext* msg);
  static void set_has_capabilities(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_privileged(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::k8s::io::api::core::v1::SELinuxOptions& selinuxoptions(const SecurityContext* msg);
  static void set_has_selinuxoptions(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::k8s::io::api::core::v1::WindowsSecurityContextOptions& windowsoptions(const SecurityContext* msg);
  static void set_has_windowsoptions(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_runasuser(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_runasgroup(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_runasnonroot(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_readonlyrootfilesystem(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_allowprivilegeescalation(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_procmount(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::k8s::io::api::core::v1::SeccompProfile& seccompprofile(const SecurityContext* msg);
  static void set_has_seccompprofile(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::k8s::io::api::core::v1::Capabilities&
SecurityContext::_Internal::capabilities(const SecurityContext* msg) {
  return *msg->_impl_.capabilities_;
}
const ::k8s::io::api::core::v1::SELinuxOptions&
SecurityContext::_Internal::selinuxoptions(const SecurityContext* msg) {
  return *msg->_impl_.selinuxoptions_;
}
const ::k8s::io::api::core::v1::WindowsSecurityContextOptions&
SecurityContext::_Internal::windowsoptions(const SecurityContext* msg) {
  return *msg->_impl_.windowsoptions_;
}
const ::k8s::io::api::core::v1::SeccompProfile&
SecurityContext::_Internal::seccompprofile(const SecurityContext* msg) {
  return *msg->_impl_.seccompprofile_;
}
SecurityContext::SecurityContext(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.SecurityContext)
}
SecurityContext::SecurityContext(const SecurityContext& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SecurityContext* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.procmount_){}
    , decltype(_impl_.capabilities_){nullptr}
    , decltype(_impl_.selinuxoptions_){nullptr}
    , decltype(_impl_.windowsoptions_){nullptr}
    , decltype(_impl_.seccompprofile_){nullptr}
    , decltype(_impl_.runasuser_){}
    , decltype(_impl_.runasgroup_){}
    , decltype(_impl_.privileged_){}
    , decltype(_impl_.runasnonroot_){}
    , decltype(_impl_.readonlyrootfilesystem_){}
    , decltype(_impl_.allowprivilegeescalation_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.procmount_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.procmount_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_procmount()) {
    _this->_impl_.procmount_.Set(from._internal_procmount(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_capabilities()) {
    _this->_impl_.capabilities_ = new ::k8s::io::api::core::v1::Capabilities(*from._impl_.capabilities_);
  }
  if (from._internal_has_selinuxoptions()) {
    _this->_impl_.selinuxoptions_ = new ::k8s::io::api::core::v1::SELinuxOptions(*from._impl_.selinuxoptions_);
  }
  if (from._internal_has_windowsoptions()) {
    _this->_impl_.windowsoptions_ = new ::k8s::io::api::core::v1::WindowsSecurityContextOptions(*from._impl_.windowsoptions_);
  }
  if (from._internal_has_seccompprofile()) {
    _this->_impl_.seccompprofile_ = new ::k8s::io::api::core::v1::SeccompProfile(*from._impl_.seccompprofile_);
  }
  ::memcpy(&_impl_.runasuser_, &from._impl_.runasuser_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.allowprivilegeescalation_) -
    reinterpret_cast<char*>(&_impl_.runasuser_)) + sizeof(_impl_.allowprivilegeescalation_));
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.SecurityContext)
}

inline void SecurityContext::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.procmount_){}
    , decltype(_impl_.capabilities_){nullptr}
    , decltype(_impl_.selinuxoptions_){nullptr}
    , decltype(_impl_.windowsoptions_){nullptr}
    , decltype(_impl_.seccompprofile_){nullptr}
    , decltype(_impl_.runasuser_){int64_t{0}}
    , decltype(_impl_.runasgroup_){int64_t{0}}
    , decltype(_impl_.privileged_){false}
    , decltype(_impl_.runasnonroot_){false}
    , decltype(_impl_.readonlyrootfilesystem_){false}
    , decltype(_impl_.allowprivilegeescalation_){false}
  };
  _impl_.procmount_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.procmount_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SecurityContext::~SecurityContext() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.SecurityContext)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SecurityContext::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.procmount_.Destroy();
  if (this != internal_default_instance()) delete _impl_.capabilities_;
  if (this != internal_default_instance()) delete _impl_.selinuxoptions_;
  if (this != internal_default_instance()) delete _impl_.windowsoptions_;
  if (this != internal_default_instance()) delete _impl_.seccompprofile_;
}

void SecurityContext::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SecurityContext::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.SecurityContext)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.procmount_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.capabilities_ != nullptr);
      _impl_.capabilities_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.selinuxoptions_ != nullptr);
      _impl_.selinuxoptions_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.windowsoptions_ != nullptr);
      _impl_.windowsoptions_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.seccompprofile_ != nullptr);
      _impl_.seccompprofile_->Clear();
    }
  }
  if (cached_has_bits & 0x000000e0u) {
    ::memset(&_impl_.runasuser_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.privileged_) -
        reinterpret_cast<char*>(&_impl_.runasuser_)) + sizeof(_impl_.privileged_));
  }
  if (cached_has_bits & 0x00000700u) {
    ::memset(&_impl_.runasnonroot_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.allowprivilegeescalation_) -
        reinterpret_cast<char*>(&_impl_.runasnonroot_)) + sizeof(_impl_.allowprivilegeescalation_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SecurityContext::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .k8s.io.api.core.v1.Capabilities capabilities = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_capabilities(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool privileged = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_privileged(&has_bits);
          _impl_.privileged_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.SELinuxOptions seLinuxOptions = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_selinuxoptions(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 runAsUser = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_runasuser(&has_bits);
          _impl_.runasuser_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool runAsNonRoot = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_runasnonroot(&has_bits);
          _impl_.runasnonroot_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool readOnlyRootFilesystem = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_readonlyrootfilesystem(&has_bits);
          _impl_.readonlyrootfilesystem_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool allowPrivilegeEscalation = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_allowprivilegeescalation(&has_bits);
          _impl_.allowprivilegeescalation_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 runAsGroup = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_runasgroup(&has_bits);
          _impl_.runasgroup_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes procMount = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_procmount();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.WindowsSecurityContextOptions windowsOptions = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_windowsoptions(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.SeccompProfile seccompProfile = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_seccompprofile(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SecurityContext::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.SecurityContext)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .k8s.io.api.core.v1.Capabilities capabilities = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::capabilities(this),
        _Internal::capabilities(this).GetCachedSize(), target, stream);
  }

  // optional bool privileged = 2;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_privileged(), target);
  }

  // optional .k8s.io.api.core.v1.SELinuxOptions seLinuxOptions = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::selinuxoptions(this),
        _Internal::selinuxoptions(this).GetCachedSize(), target, stream);
  }

  // optional int64 runAsUser = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_runasuser(), target);
  }

  // optional bool runAsNonRoot = 5;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_runasnonroot(), target);
  }

  // optional bool readOnlyRootFilesystem = 6;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_readonlyrootfilesystem(), target);
  }

  // optional bool allowPrivilegeEscalation = 7;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_allowprivilegeescalation(), target);
  }

  // optional int64 runAsGroup = 8;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(8, this->_internal_runasgroup(), target);
  }

  // optional bytes procMount = 9;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        9, this->_internal_procmount(), target);
  }

  // optional .k8s.io.api.core.v1.WindowsSecurityContextOptions windowsOptions = 10;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::windowsoptions(this),
        _Internal::windowsoptions(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.SeccompProfile seccompProfile = 11;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::seccompprofile(this),
        _Internal::seccompprofile(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.SecurityContext)
  return target;
}

size_t SecurityContext::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.SecurityContext)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bytes procMount = 9;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_procmount());
    }

    // optional .k8s.io.api.core.v1.Capabilities capabilities = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.capabilities_);
    }

    // optional .k8s.io.api.core.v1.SELinuxOptions seLinuxOptions = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.selinuxoptions_);
    }

    // optional .k8s.io.api.core.v1.WindowsSecurityContextOptions windowsOptions = 10;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.windowsoptions_);
    }

    // optional .k8s.io.api.core.v1.SeccompProfile seccompProfile = 11;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.seccompprofile_);
    }

    // optional int64 runAsUser = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_runasuser());
    }

    // optional int64 runAsGroup = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_runasgroup());
    }

    // optional bool privileged = 2;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x00000700u) {
    // optional bool runAsNonRoot = 5;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional bool readOnlyRootFilesystem = 6;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

    // optional bool allowPrivilegeEscalation = 7;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SecurityContext::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SecurityContext::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SecurityContext::GetClassData() const { return &_class_data_; }


void SecurityContext::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SecurityContext*>(&to_msg);
  auto& from = static_cast<const SecurityContext&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.SecurityContext)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_procmount(from._internal_procmount());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_capabilities()->::k8s::io::api::core::v1::Capabilities::MergeFrom(
          from._internal_capabilities());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_selinuxoptions()->::k8s::io::api::core::v1::SELinuxOptions::MergeFrom(
          from._internal_selinuxoptions());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_windowsoptions()->::k8s::io::api::core::v1::WindowsSecurityContextOptions::MergeFrom(
          from._internal_windowsoptions());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_seccompprofile()->::k8s::io::api::core::v1::SeccompProfile::MergeFrom(
          from._internal_seccompprofile());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.runasuser_ = from._impl_.runasuser_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.runasgroup_ = from._impl_.runasgroup_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.privileged_ = from._impl_.privileged_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.runasnonroot_ = from._impl_.runasnonroot_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.readonlyrootfilesystem_ = from._impl_.readonlyrootfilesystem_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.allowprivilegeescalation_ = from._impl_.allowprivilegeescalation_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SecurityContext::CopyFrom(const SecurityContext& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.SecurityContext)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SecurityContext::IsInitialized() const {
  return true;
}

void SecurityContext::InternalSwap(SecurityContext* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.procmount_, lhs_arena,
      &other->_impl_.procmount_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SecurityContext, _impl_.allowprivilegeescalation_)
      + sizeof(SecurityContext::_impl_.allowprivilegeescalation_)
      - PROTOBUF_FIELD_OFFSET(SecurityContext, _impl_.capabilities_)>(
          reinterpret_cast<char*>(&_impl_.capabilities_),
          reinterpret_cast<char*>(&other->_impl_.capabilities_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SecurityContext::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[218]);
}

// ===================================================================

class SerializedReference::_Internal {
 public:
  using HasBits = decltype(std::declval<SerializedReference>()._impl_._has_bits_);
  static const ::k8s::io::api::core::v1::ObjectReference& reference(const SerializedReference* msg);
  static void set_has_reference(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::k8s::io::api::core::v1::ObjectReference&
SerializedReference::_Internal::reference(const SerializedReference* msg) {
  return *msg->_impl_.reference_;
}
SerializedReference::SerializedReference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.SerializedReference)
}
SerializedReference::SerializedReference(const SerializedReference& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SerializedReference* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.reference_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_reference()) {
    _this->_impl_.reference_ = new ::k8s::io::api::core::v1::ObjectReference(*from._impl_.reference_);
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.SerializedReference)
}

inline void SerializedReference::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.reference_){nullptr}
  };
}

SerializedReference::~SerializedReference() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.SerializedReference)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SerializedReference::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.reference_;
}

void SerializedReference::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SerializedReference::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.SerializedReference)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.reference_ != nullptr);
    _impl_.reference_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SerializedReference::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .k8s.io.api.core.v1.ObjectReference reference = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_reference(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SerializedReference::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.SerializedReference)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .k8s.io.api.core.v1.ObjectReference reference = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::reference(this),
        _Internal::reference(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.SerializedReference)
  return target;
}

size_t SerializedReference::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.SerializedReference)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .k8s.io.api.core.v1.ObjectReference reference = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.reference_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SerializedReference::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SerializedReference::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SerializedReference::GetClassData() const { return &_class_data_; }


void SerializedReference::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SerializedReference*>(&to_msg);
  auto& from = static_cast<const SerializedReference&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.SerializedReference)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_reference()) {
    _this->_internal_mutable_reference()->::k8s::io::api::core::v1::ObjectReference::MergeFrom(
        from._internal_reference());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SerializedReference::CopyFrom(const SerializedReference& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.SerializedReference)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SerializedReference::IsInitialized() const {
  return true;
}

void SerializedReference::InternalSwap(SerializedReference* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.reference_, other->_impl_.reference_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SerializedReference::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[219]);
}

// ===================================================================

class Service::_Internal {
 public:
  using HasBits = decltype(std::declval<Service>()._impl_._has_bits_);
  static const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& metadata(const Service* msg);
  static void set_has_metadata(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::k8s::io::api::core::v1::ServiceSpec& spec(const Service* msg);
  static void set_has_spec(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::k8s::io::api::core::v1::ServiceStatus& status(const Service* msg);
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta&
Service::_Internal::metadata(const Service* msg) {
  return *msg->_impl_.metadata_;
}
const ::k8s::io::api::core::v1::ServiceSpec&
Service::_Internal::spec(const Service* msg) {
  return *msg->_impl_.spec_;
}
const ::k8s::io::api::core::v1::ServiceStatus&
Service::_Internal::status(const Service* msg) {
  return *msg->_impl_.status_;
}
void Service::clear_metadata() {
  if (_impl_.metadata_ != nullptr) _impl_.metadata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
Service::Service(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.Service)
}
Service::Service(const Service& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Service* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.metadata_){nullptr}
    , decltype(_impl_.spec_){nullptr}
    , decltype(_impl_.status_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_metadata()) {
    _this->_impl_.metadata_ = new ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta(*from._impl_.metadata_);
  }
  if (from._internal_has_spec()) {
    _this->_impl_.spec_ = new ::k8s::io::api::core::v1::ServiceSpec(*from._impl_.spec_);
  }
  if (from._internal_has_status()) {
    _this->_impl_.status_ = new ::k8s::io::api::core::v1::ServiceStatus(*from._impl_.status_);
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.Service)
}

inline void Service::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.metadata_){nullptr}
    , decltype(_impl_.spec_){nullptr}
    , decltype(_impl_.status_){nullptr}
  };
}

Service::~Service() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.Service)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Service::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.metadata_;
  if (this != internal_default_instance()) delete _impl_.spec_;
  if (this != internal_default_instance()) delete _impl_.status_;
}

void Service::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Service::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.Service)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.metadata_ != nullptr);
      _impl_.metadata_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.spec_ != nullptr);
      _impl_.spec_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.status_ != nullptr);
      _impl_.status_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Service::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_metadata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.ServiceSpec spec = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_spec(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.ServiceStatus status = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_status(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Service::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.Service)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::metadata(this),
        _Internal::metadata(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.ServiceSpec spec = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::spec(this),
        _Internal::spec(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.ServiceStatus status = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::status(this),
        _Internal::status(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.Service)
  return target;
}

size_t Service::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.Service)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.metadata_);
    }

    // optional .k8s.io.api.core.v1.ServiceSpec spec = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.spec_);
    }

    // optional .k8s.io.api.core.v1.ServiceStatus status = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.status_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Service::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Service::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Service::GetClassData() const { return &_class_data_; }


void Service::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Service*>(&to_msg);
  auto& from = static_cast<const Service&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.Service)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_metadata()->::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta::MergeFrom(
          from._internal_metadata());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_spec()->::k8s::io::api::core::v1::ServiceSpec::MergeFrom(
          from._internal_spec());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_status()->::k8s::io::api::core::v1::ServiceStatus::MergeFrom(
          from._internal_status());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Service::CopyFrom(const Service& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.Service)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Service::IsInitialized() const {
  return true;
}

void Service::InternalSwap(Service* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Service, _impl_.status_)
      + sizeof(Service::_impl_.status_)
      - PROTOBUF_FIELD_OFFSET(Service, _impl_.metadata_)>(
          reinterpret_cast<char*>(&_impl_.metadata_),
          reinterpret_cast<char*>(&other->_impl_.metadata_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Service::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[220]);
}

// ===================================================================

class ServiceAccount::_Internal {
 public:
  using HasBits = decltype(std::declval<ServiceAccount>()._impl_._has_bits_);
  static const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& metadata(const ServiceAccount* msg);
  static void set_has_metadata(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_automountserviceaccounttoken(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta&
ServiceAccount::_Internal::metadata(const ServiceAccount* msg) {
  return *msg->_impl_.metadata_;
}
void ServiceAccount::clear_metadata() {
  if (_impl_.metadata_ != nullptr) _impl_.metadata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
ServiceAccount::ServiceAccount(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.ServiceAccount)
}
ServiceAccount::ServiceAccount(const ServiceAccount& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ServiceAccount* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.secrets_){from._impl_.secrets_}
    , decltype(_impl_.imagepullsecrets_){from._impl_.imagepullsecrets_}
    , decltype(_impl_.metadata_){nullptr}
    , decltype(_impl_.automountserviceaccounttoken_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_metadata()) {
    _this->_impl_.metadata_ = new ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta(*from._impl_.metadata_);
  }
  _this->_impl_.automountserviceaccounttoken_ = from._impl_.automountserviceaccounttoken_;
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.ServiceAccount)
}

inline void ServiceAccount::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.secrets_){arena}
    , decltype(_impl_.imagepullsecrets_){arena}
    , decltype(_impl_.metadata_){nullptr}
    , decltype(_impl_.automountserviceaccounttoken_){false}
  };
}

ServiceAccount::~ServiceAccount() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.ServiceAccount)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ServiceAccount::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.secrets_.~RepeatedPtrField();
  _impl_.imagepullsecrets_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.metadata_;
}

void ServiceAccount::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ServiceAccount::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.ServiceAccount)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.secrets_.Clear();
  _impl_.imagepullsecrets_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.metadata_ != nullptr);
    _impl_.metadata_->Clear();
  }
  _impl_.automountserviceaccounttoken_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ServiceAccount::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_metadata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .k8s.io.api.core.v1.ObjectReference secrets = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_secrets(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .k8s.io.api.core.v1.LocalObjectReference imagePullSecrets = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_imagepullsecrets(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool automountServiceAccountToken = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_automountserviceaccounttoken(&has_bits);
          _impl_.automountserviceaccounttoken_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ServiceAccount::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.ServiceAccount)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::metadata(this),
        _Internal::metadata(this).GetCachedSize(), target, stream);
  }

  // repeated .k8s.io.api.core.v1.ObjectReference secrets = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_secrets_size()); i < n; i++) {
    const auto& repfield = this->_internal_secrets(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .k8s.io.api.core.v1.LocalObjectReference imagePullSecrets = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_imagepullsecrets_size()); i < n; i++) {
    const auto& repfield = this->_internal_imagepullsecrets(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bool automountServiceAccountToken = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_automountserviceaccounttoken(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.ServiceAccount)
  return target;
}

size_t ServiceAccount::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.ServiceAccount)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .k8s.io.api.core.v1.ObjectReference secrets = 2;
  total_size += 1UL * this->_internal_secrets_size();
  for (const auto& msg : this->_impl_.secrets_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .k8s.io.api.core.v1.LocalObjectReference imagePullSecrets = 3;
  total_size += 1UL * this->_internal_imagepullsecrets_size();
  for (const auto& msg : this->_impl_.imagepullsecrets_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.metadata_);
    }

    // optional bool automountServiceAccountToken = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ServiceAccount::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ServiceAccount::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ServiceAccount::GetClassData() const { return &_class_data_; }


void ServiceAccount::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ServiceAccount*>(&to_msg);
  auto& from = static_cast<const ServiceAccount&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.ServiceAccount)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.secrets_.MergeFrom(from._impl_.secrets_);
  _this->_impl_.imagepullsecrets_.MergeFrom(from._impl_.imagepullsecrets_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_metadata()->::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta::MergeFrom(
          from._internal_metadata());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.automountserviceaccounttoken_ = from._impl_.automountserviceaccounttoken_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ServiceAccount::CopyFrom(const ServiceAccount& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.ServiceAccount)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ServiceAccount::IsInitialized() const {
  return true;
}

void ServiceAccount::InternalSwap(ServiceAccount* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.secrets_.InternalSwap(&other->_impl_.secrets_);
  _impl_.imagepullsecrets_.InternalSwap(&other->_impl_.imagepullsecrets_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ServiceAccount, _impl_.automountserviceaccounttoken_)
      + sizeof(ServiceAccount::_impl_.automountserviceaccounttoken_)
      - PROTOBUF_FIELD_OFFSET(ServiceAccount, _impl_.metadata_)>(
          reinterpret_cast<char*>(&_impl_.metadata_),
          reinterpret_cast<char*>(&other->_impl_.metadata_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ServiceAccount::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[221]);
}

// ===================================================================

class ServiceAccountList::_Internal {
 public:
  using HasBits = decltype(std::declval<ServiceAccountList>()._impl_._has_bits_);
  static const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& metadata(const ServiceAccountList* msg);
  static void set_has_metadata(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta&
ServiceAccountList::_Internal::metadata(const ServiceAccountList* msg) {
  return *msg->_impl_.metadata_;
}
void ServiceAccountList::clear_metadata() {
  if (_impl_.metadata_ != nullptr) _impl_.metadata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
ServiceAccountList::ServiceAccountList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.ServiceAccountList)
}
ServiceAccountList::ServiceAccountList(const ServiceAccountList& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ServiceAccountList* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.items_){from._impl_.items_}
    , decltype(_impl_.metadata_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_metadata()) {
    _this->_impl_.metadata_ = new ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta(*from._impl_.metadata_);
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.ServiceAccountList)
}

inline void ServiceAccountList::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.items_){arena}
    , decltype(_impl_.metadata_){nullptr}
  };
}

ServiceAccountList::~ServiceAccountList() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.ServiceAccountList)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ServiceAccountList::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.items_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.metadata_;
}

void ServiceAccountList::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ServiceAccountList::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.ServiceAccountList)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.items_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.metadata_ != nullptr);
    _impl_.metadata_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ServiceAccountList::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_metadata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .k8s.io.api.core.v1.ServiceAccount items = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_items(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ServiceAccountList::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.ServiceAccountList)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::metadata(this),
        _Internal::metadata(this).GetCachedSize(), target, stream);
  }

  // repeated .k8s.io.api.core.v1.ServiceAccount items = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_items_size()); i < n; i++) {
    const auto& repfield = this->_internal_items(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.ServiceAccountList)
  return target;
}

size_t ServiceAccountList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.ServiceAccountList)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .k8s.io.api.core.v1.ServiceAccount items = 2;
  total_size += 1UL * this->_internal_items_size();
  for (const auto& msg : this->_impl_.items_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.metadata_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ServiceAccountList::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ServiceAccountList::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ServiceAccountList::GetClassData() const { return &_class_data_; }


void ServiceAccountList::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ServiceAccountList*>(&to_msg);
  auto& from = static_cast<const ServiceAccountList&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.ServiceAccountList)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.items_.MergeFrom(from._impl_.items_);
  if (from._internal_has_metadata()) {
    _this->_internal_mutable_metadata()->::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta::MergeFrom(
        from._internal_metadata());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ServiceAccountList::CopyFrom(const ServiceAccountList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.ServiceAccountList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ServiceAccountList::IsInitialized() const {
  return true;
}

void ServiceAccountList::InternalSwap(ServiceAccountList* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.items_.InternalSwap(&other->_impl_.items_);
  swap(_impl_.metadata_, other->_impl_.metadata_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ServiceAccountList::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[222]);
}

// ===================================================================

class ServiceAccountTokenProjection::_Internal {
 public:
  using HasBits = decltype(std::declval<ServiceAccountTokenProjection>()._impl_._has_bits_);
  static void set_has_audience(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_expirationseconds(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_path(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ServiceAccountTokenProjection::ServiceAccountTokenProjection(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.ServiceAccountTokenProjection)
}
ServiceAccountTokenProjection::ServiceAccountTokenProjection(const ServiceAccountTokenProjection& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ServiceAccountTokenProjection* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.audience_){}
    , decltype(_impl_.path_){}
    , decltype(_impl_.expirationseconds_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.audience_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.audience_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_audience()) {
    _this->_impl_.audience_.Set(from._internal_audience(), 
      _this->GetArenaForAllocation());
  }
  _impl_.path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_path()) {
    _this->_impl_.path_.Set(from._internal_path(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.expirationseconds_ = from._impl_.expirationseconds_;
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.ServiceAccountTokenProjection)
}

inline void ServiceAccountTokenProjection::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.audience_){}
    , decltype(_impl_.path_){}
    , decltype(_impl_.expirationseconds_){int64_t{0}}
  };
  _impl_.audience_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.audience_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ServiceAccountTokenProjection::~ServiceAccountTokenProjection() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.ServiceAccountTokenProjection)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ServiceAccountTokenProjection::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.audience_.Destroy();
  _impl_.path_.Destroy();
}

void ServiceAccountTokenProjection::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ServiceAccountTokenProjection::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.ServiceAccountTokenProjection)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.audience_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.path_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.expirationseconds_ = int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ServiceAccountTokenProjection::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes audience = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_audience();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 expirationSeconds = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_expirationseconds(&has_bits);
          _impl_.expirationseconds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes path = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_path();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ServiceAccountTokenProjection::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.ServiceAccountTokenProjection)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes audience = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_audience(), target);
  }

  // optional int64 expirationSeconds = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_expirationseconds(), target);
  }

  // optional bytes path = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_path(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.ServiceAccountTokenProjection)
  return target;
}

size_t ServiceAccountTokenProjection::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.ServiceAccountTokenProjection)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bytes audience = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_audience());
    }

    // optional bytes path = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_path());
    }

    // optional int64 expirationSeconds = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_expirationseconds());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ServiceAccountTokenProjection::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ServiceAccountTokenProjection::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ServiceAccountTokenProjection::GetClassData() const { return &_class_data_; }


void ServiceAccountTokenProjection::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ServiceAccountTokenProjection*>(&to_msg);
  auto& from = static_cast<const ServiceAccountTokenProjection&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.ServiceAccountTokenProjection)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_audience(from._internal_audience());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_path(from._internal_path());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.expirationseconds_ = from._impl_.expirationseconds_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ServiceAccountTokenProjection::CopyFrom(const ServiceAccountTokenProjection& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.ServiceAccountTokenProjection)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ServiceAccountTokenProjection::IsInitialized() const {
  return true;
}

void ServiceAccountTokenProjection::InternalSwap(ServiceAccountTokenProjection* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.audience_, lhs_arena,
      &other->_impl_.audience_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.path_, lhs_arena,
      &other->_impl_.path_, rhs_arena
  );
  swap(_impl_.expirationseconds_, other->_impl_.expirationseconds_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ServiceAccountTokenProjection::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[223]);
}

// ===================================================================

class ServiceList::_Internal {
 public:
  using HasBits = decltype(std::declval<ServiceList>()._impl_._has_bits_);
  static const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& metadata(const ServiceList* msg);
  static void set_has_metadata(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta&
ServiceList::_Internal::metadata(const ServiceList* msg) {
  return *msg->_impl_.metadata_;
}
void ServiceList::clear_metadata() {
  if (_impl_.metadata_ != nullptr) _impl_.metadata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
ServiceList::ServiceList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.ServiceList)
}
ServiceList::ServiceList(const ServiceList& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ServiceList* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.items_){from._impl_.items_}
    , decltype(_impl_.metadata_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_metadata()) {
    _this->_impl_.metadata_ = new ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta(*from._impl_.metadata_);
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.ServiceList)
}

inline void ServiceList::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.items_){arena}
    , decltype(_impl_.metadata_){nullptr}
  };
}

ServiceList::~ServiceList() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.ServiceList)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ServiceList::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.items_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.metadata_;
}

void ServiceList::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ServiceList::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.ServiceList)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.items_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.metadata_ != nullptr);
    _impl_.metadata_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ServiceList::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_metadata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .k8s.io.api.core.v1.Service items = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_items(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ServiceList::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.ServiceList)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::metadata(this),
        _Internal::metadata(this).GetCachedSize(), target, stream);
  }

  // repeated .k8s.io.api.core.v1.Service items = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_items_size()); i < n; i++) {
    const auto& repfield = this->_internal_items(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.ServiceList)
  return target;
}

size_t ServiceList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.ServiceList)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .k8s.io.api.core.v1.Service items = 2;
  total_size += 1UL * this->_internal_items_size();
  for (const auto& msg : this->_impl_.items_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.metadata_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ServiceList::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ServiceList::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ServiceList::GetClassData() const { return &_class_data_; }


void ServiceList::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ServiceList*>(&to_msg);
  auto& from = static_cast<const ServiceList&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.ServiceList)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.items_.MergeFrom(from._impl_.items_);
  if (from._internal_has_metadata()) {
    _this->_internal_mutable_metadata()->::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta::MergeFrom(
        from._internal_metadata());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ServiceList::CopyFrom(const ServiceList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.ServiceList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ServiceList::IsInitialized() const {
  return true;
}

void ServiceList::InternalSwap(ServiceList* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.items_.InternalSwap(&other->_impl_.items_);
  swap(_impl_.metadata_, other->_impl_.metadata_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ServiceList::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[224]);
}

// ===================================================================

class ServicePort::_Internal {
 public:
  using HasBits = decltype(std::declval<ServicePort>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_protocol(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_appprotocol(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_port(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::k8s::io::apimachinery::pkg::util::intstr::IntOrString& targetport(const ServicePort* msg);
  static void set_has_targetport(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_nodeport(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

const ::k8s::io::apimachinery::pkg::util::intstr::IntOrString&
ServicePort::_Internal::targetport(const ServicePort* msg) {
  return *msg->_impl_.targetport_;
}
void ServicePort::clear_targetport() {
  if (_impl_.targetport_ != nullptr) _impl_.targetport_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
ServicePort::ServicePort(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.ServicePort)
}
ServicePort::ServicePort(const ServicePort& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ServicePort* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.protocol_){}
    , decltype(_impl_.appprotocol_){}
    , decltype(_impl_.targetport_){nullptr}
    , decltype(_impl_.port_){}
    , decltype(_impl_.nodeport_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.protocol_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.protocol_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_protocol()) {
    _this->_impl_.protocol_.Set(from._internal_protocol(), 
      _this->GetArenaForAllocation());
  }
  _impl_.appprotocol_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.appprotocol_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_appprotocol()) {
    _this->_impl_.appprotocol_.Set(from._internal_appprotocol(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_targetport()) {
    _this->_impl_.targetport_ = new ::k8s::io::apimachinery::pkg::util::intstr::IntOrString(*from._impl_.targetport_);
  }
  ::memcpy(&_impl_.port_, &from._impl_.port_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.nodeport_) -
    reinterpret_cast<char*>(&_impl_.port_)) + sizeof(_impl_.nodeport_));
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.ServicePort)
}

inline void ServicePort::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.protocol_){}
    , decltype(_impl_.appprotocol_){}
    , decltype(_impl_.targetport_){nullptr}
    , decltype(_impl_.port_){0}
    , decltype(_impl_.nodeport_){0}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.protocol_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.protocol_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.appprotocol_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.appprotocol_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ServicePort::~ServicePort() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.ServicePort)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ServicePort::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.protocol_.Destroy();
  _impl_.appprotocol_.Destroy();
  if (this != internal_default_instance()) delete _impl_.targetport_;
}

void ServicePort::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ServicePort::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.ServicePort)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.protocol_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.appprotocol_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.targetport_ != nullptr);
      _impl_.targetport_->Clear();
    }
  }
  if (cached_has_bits & 0x00000030u) {
    ::memset(&_impl_.port_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.nodeport_) -
        reinterpret_cast<char*>(&_impl_.port_)) + sizeof(_impl_.nodeport_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ServicePort::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes protocol = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_protocol();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 port = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_port(&has_bits);
          _impl_.port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString targetPort = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_targetport(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 nodePort = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_nodeport(&has_bits);
          _impl_.nodeport_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes appProtocol = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_appprotocol();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ServicePort::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.ServicePort)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional bytes protocol = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_protocol(), target);
  }

  // optional int32 port = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_port(), target);
  }

  // optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString targetPort = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::targetport(this),
        _Internal::targetport(this).GetCachedSize(), target, stream);
  }

  // optional int32 nodePort = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_nodeport(), target);
  }

  // optional bytes appProtocol = 6;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        6, this->_internal_appprotocol(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.ServicePort)
  return target;
}

size_t ServicePort::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.ServicePort)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional bytes name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_name());
    }

    // optional bytes protocol = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_protocol());
    }

    // optional bytes appProtocol = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_appprotocol());
    }

    // optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString targetPort = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.targetport_);
    }

    // optional int32 port = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_port());
    }

    // optional int32 nodePort = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_nodeport());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ServicePort::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ServicePort::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ServicePort::GetClassData() const { return &_class_data_; }


void ServicePort::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ServicePort*>(&to_msg);
  auto& from = static_cast<const ServicePort&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.ServicePort)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_protocol(from._internal_protocol());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_appprotocol(from._internal_appprotocol());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_targetport()->::k8s::io::apimachinery::pkg::util::intstr::IntOrString::MergeFrom(
          from._internal_targetport());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.port_ = from._impl_.port_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.nodeport_ = from._impl_.nodeport_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ServicePort::CopyFrom(const ServicePort& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.ServicePort)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ServicePort::IsInitialized() const {
  return true;
}

void ServicePort::InternalSwap(ServicePort* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.protocol_, lhs_arena,
      &other->_impl_.protocol_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.appprotocol_, lhs_arena,
      &other->_impl_.appprotocol_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ServicePort, _impl_.nodeport_)
      + sizeof(ServicePort::_impl_.nodeport_)
      - PROTOBUF_FIELD_OFFSET(ServicePort, _impl_.targetport_)>(
          reinterpret_cast<char*>(&_impl_.targetport_),
          reinterpret_cast<char*>(&other->_impl_.targetport_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ServicePort::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[225]);
}

// ===================================================================

class ServiceProxyOptions::_Internal {
 public:
  using HasBits = decltype(std::declval<ServiceProxyOptions>()._impl_._has_bits_);
  static void set_has_path(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ServiceProxyOptions::ServiceProxyOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.ServiceProxyOptions)
}
ServiceProxyOptions::ServiceProxyOptions(const ServiceProxyOptions& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ServiceProxyOptions* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.path_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_path()) {
    _this->_impl_.path_.Set(from._internal_path(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.ServiceProxyOptions)
}

inline void ServiceProxyOptions::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.path_){}
  };
  _impl_.path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ServiceProxyOptions::~ServiceProxyOptions() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.ServiceProxyOptions)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ServiceProxyOptions::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.path_.Destroy();
}

void ServiceProxyOptions::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ServiceProxyOptions::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.ServiceProxyOptions)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.path_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ServiceProxyOptions::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes path = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_path();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ServiceProxyOptions::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.ServiceProxyOptions)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes path = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_path(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.ServiceProxyOptions)
  return target;
}

size_t ServiceProxyOptions::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.ServiceProxyOptions)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes path = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_path());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ServiceProxyOptions::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ServiceProxyOptions::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ServiceProxyOptions::GetClassData() const { return &_class_data_; }


void ServiceProxyOptions::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ServiceProxyOptions*>(&to_msg);
  auto& from = static_cast<const ServiceProxyOptions&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.ServiceProxyOptions)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_path()) {
    _this->_internal_set_path(from._internal_path());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ServiceProxyOptions::CopyFrom(const ServiceProxyOptions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.ServiceProxyOptions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ServiceProxyOptions::IsInitialized() const {
  return true;
}

void ServiceProxyOptions::InternalSwap(ServiceProxyOptions* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.path_, lhs_arena,
      &other->_impl_.path_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ServiceProxyOptions::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[226]);
}

// ===================================================================

ServiceSpec_SelectorEntry_DoNotUse::ServiceSpec_SelectorEntry_DoNotUse() {}
ServiceSpec_SelectorEntry_DoNotUse::ServiceSpec_SelectorEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void ServiceSpec_SelectorEntry_DoNotUse::MergeFrom(const ServiceSpec_SelectorEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata ServiceSpec_SelectorEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[227]);
}

// ===================================================================

class ServiceSpec::_Internal {
 public:
  using HasBits = decltype(std::declval<ServiceSpec>()._impl_._has_bits_);
  static void set_has_clusterip(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_sessionaffinity(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_loadbalancerip(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_externalname(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_externaltrafficpolicy(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_healthchecknodeport(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_publishnotreadyaddresses(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static const ::k8s::io::api::core::v1::SessionAffinityConfig& sessionaffinityconfig(const ServiceSpec* msg);
  static void set_has_sessionaffinityconfig(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_ipfamilypolicy(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_allocateloadbalancernodeports(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_loadbalancerclass(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_internaltrafficpolicy(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
};

const ::k8s::io::api::core::v1::SessionAffinityConfig&
ServiceSpec::_Internal::sessionaffinityconfig(const ServiceSpec* msg) {
  return *msg->_impl_.sessionaffinityconfig_;
}
ServiceSpec::ServiceSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &ServiceSpec::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.ServiceSpec)
}
ServiceSpec::ServiceSpec(const ServiceSpec& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ServiceSpec* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ports_){from._impl_.ports_}
    , /*decltype(_impl_.selector_)*/{}
    , decltype(_impl_.externalips_){from._impl_.externalips_}
    , decltype(_impl_.loadbalancersourceranges_){from._impl_.loadbalancersourceranges_}
    , decltype(_impl_.clusterips_){from._impl_.clusterips_}
    , decltype(_impl_.ipfamilies_){from._impl_.ipfamilies_}
    , decltype(_impl_.clusterip_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.sessionaffinity_){}
    , decltype(_impl_.loadbalancerip_){}
    , decltype(_impl_.externalname_){}
    , decltype(_impl_.externaltrafficpolicy_){}
    , decltype(_impl_.ipfamilypolicy_){}
    , decltype(_impl_.loadbalancerclass_){}
    , decltype(_impl_.internaltrafficpolicy_){}
    , decltype(_impl_.sessionaffinityconfig_){nullptr}
    , decltype(_impl_.healthchecknodeport_){}
    , decltype(_impl_.publishnotreadyaddresses_){}
    , decltype(_impl_.allocateloadbalancernodeports_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.selector_.MergeFrom(from._impl_.selector_);
  _impl_.clusterip_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.clusterip_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_clusterip()) {
    _this->_impl_.clusterip_.Set(from._internal_clusterip(), 
      _this->GetArenaForAllocation());
  }
  _impl_.type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_type()) {
    _this->_impl_.type_.Set(from._internal_type(), 
      _this->GetArenaForAllocation());
  }
  _impl_.sessionaffinity_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sessionaffinity_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_sessionaffinity()) {
    _this->_impl_.sessionaffinity_.Set(from._internal_sessionaffinity(), 
      _this->GetArenaForAllocation());
  }
  _impl_.loadbalancerip_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.loadbalancerip_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_loadbalancerip()) {
    _this->_impl_.loadbalancerip_.Set(from._internal_loadbalancerip(), 
      _this->GetArenaForAllocation());
  }
  _impl_.externalname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.externalname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_externalname()) {
    _this->_impl_.externalname_.Set(from._internal_externalname(), 
      _this->GetArenaForAllocation());
  }
  _impl_.externaltrafficpolicy_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.externaltrafficpolicy_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_externaltrafficpolicy()) {
    _this->_impl_.externaltrafficpolicy_.Set(from._internal_externaltrafficpolicy(), 
      _this->GetArenaForAllocation());
  }
  _impl_.ipfamilypolicy_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ipfamilypolicy_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ipfamilypolicy()) {
    _this->_impl_.ipfamilypolicy_.Set(from._internal_ipfamilypolicy(), 
      _this->GetArenaForAllocation());
  }
  _impl_.loadbalancerclass_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.loadbalancerclass_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_loadbalancerclass()) {
    _this->_impl_.loadbalancerclass_.Set(from._internal_loadbalancerclass(), 
      _this->GetArenaForAllocation());
  }
  _impl_.internaltrafficpolicy_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.internaltrafficpolicy_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_internaltrafficpolicy()) {
    _this->_impl_.internaltrafficpolicy_.Set(from._internal_internaltrafficpolicy(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_sessionaffinityconfig()) {
    _this->_impl_.sessionaffinityconfig_ = new ::k8s::io::api::core::v1::SessionAffinityConfig(*from._impl_.sessionaffinityconfig_);
  }
  ::memcpy(&_impl_.healthchecknodeport_, &from._impl_.healthchecknodeport_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.allocateloadbalancernodeports_) -
    reinterpret_cast<char*>(&_impl_.healthchecknodeport_)) + sizeof(_impl_.allocateloadbalancernodeports_));
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.ServiceSpec)
}

inline void ServiceSpec::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ports_){arena}
    , /*decltype(_impl_.selector_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.externalips_){arena}
    , decltype(_impl_.loadbalancersourceranges_){arena}
    , decltype(_impl_.clusterips_){arena}
    , decltype(_impl_.ipfamilies_){arena}
    , decltype(_impl_.clusterip_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.sessionaffinity_){}
    , decltype(_impl_.loadbalancerip_){}
    , decltype(_impl_.externalname_){}
    , decltype(_impl_.externaltrafficpolicy_){}
    , decltype(_impl_.ipfamilypolicy_){}
    , decltype(_impl_.loadbalancerclass_){}
    , decltype(_impl_.internaltrafficpolicy_){}
    , decltype(_impl_.sessionaffinityconfig_){nullptr}
    , decltype(_impl_.healthchecknodeport_){0}
    , decltype(_impl_.publishnotreadyaddresses_){false}
    , decltype(_impl_.allocateloadbalancernodeports_){false}
  };
  _impl_.clusterip_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.clusterip_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.sessionaffinity_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sessionaffinity_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.loadbalancerip_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.loadbalancerip_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.externalname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.externalname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.externaltrafficpolicy_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.externaltrafficpolicy_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.ipfamilypolicy_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ipfamilypolicy_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.loadbalancerclass_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.loadbalancerclass_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.internaltrafficpolicy_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.internaltrafficpolicy_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ServiceSpec::~ServiceSpec() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.ServiceSpec)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void ServiceSpec::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.ports_.~RepeatedPtrField();
  _impl_.selector_.Destruct();
  _impl_.selector_.~MapField();
  _impl_.externalips_.~RepeatedPtrField();
  _impl_.loadbalancersourceranges_.~RepeatedPtrField();
  _impl_.clusterips_.~RepeatedPtrField();
  _impl_.ipfamilies_.~RepeatedPtrField();
  _impl_.clusterip_.Destroy();
  _impl_.type_.Destroy();
  _impl_.sessionaffinity_.Destroy();
  _impl_.loadbalancerip_.Destroy();
  _impl_.externalname_.Destroy();
  _impl_.externaltrafficpolicy_.Destroy();
  _impl_.ipfamilypolicy_.Destroy();
  _impl_.loadbalancerclass_.Destroy();
  _impl_.internaltrafficpolicy_.Destroy();
  if (this != internal_default_instance()) delete _impl_.sessionaffinityconfig_;
}

void ServiceSpec::ArenaDtor(void* object) {
  ServiceSpec* _this = reinterpret_cast< ServiceSpec* >(object);
  _this->_impl_.selector_.Destruct();
}
void ServiceSpec::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ServiceSpec::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.ServiceSpec)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.ports_.Clear();
  _impl_.selector_.Clear();
  _impl_.externalips_.Clear();
  _impl_.loadbalancersourceranges_.Clear();
  _impl_.clusterips_.Clear();
  _impl_.ipfamilies_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.clusterip_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.type_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.sessionaffinity_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.loadbalancerip_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.externalname_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      _impl_.externaltrafficpolicy_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000040u) {
      _impl_.ipfamilypolicy_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000080u) {
      _impl_.loadbalancerclass_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      _impl_.internaltrafficpolicy_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000200u) {
      GOOGLE_DCHECK(_impl_.sessionaffinityconfig_ != nullptr);
      _impl_.sessionaffinityconfig_->Clear();
    }
  }
  if (cached_has_bits & 0x00001c00u) {
    ::memset(&_impl_.healthchecknodeport_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.allocateloadbalancernodeports_) -
        reinterpret_cast<char*>(&_impl_.healthchecknodeport_)) + sizeof(_impl_.allocateloadbalancernodeports_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ServiceSpec::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .k8s.io.api.core.v1.ServicePort ports = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_ports(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // map<string, string> selector = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.selector_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bytes clusterIP = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_clusterip();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes type = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string externalIPs = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_externalips();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "k8s.io.api.core.v1.ServiceSpec.externalIPs");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bytes sessionAffinity = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_sessionaffinity();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes loadBalancerIP = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_loadbalancerip();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string loadBalancerSourceRanges = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_loadbalancersourceranges();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "k8s.io.api.core.v1.ServiceSpec.loadBalancerSourceRanges");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bytes externalName = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_externalname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes externalTrafficPolicy = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          auto str = _internal_mutable_externaltrafficpolicy();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 healthCheckNodePort = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_healthchecknodeport(&has_bits);
          _impl_.healthchecknodeport_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool publishNotReadyAddresses = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_publishnotreadyaddresses(&has_bits);
          _impl_.publishnotreadyaddresses_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.SessionAffinityConfig sessionAffinityConfig = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_sessionaffinityconfig(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes ipFamilyPolicy = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          auto str = _internal_mutable_ipfamilypolicy();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string clusterIPs = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          ptr -= 2;
          do {
            ptr += 2;
            auto str = _internal_add_clusterips();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "k8s.io.api.core.v1.ServiceSpec.clusterIPs");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<146>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string ipFamilies = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          ptr -= 2;
          do {
            ptr += 2;
            auto str = _internal_add_ipfamilies();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "k8s.io.api.core.v1.ServiceSpec.ipFamilies");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<154>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool allocateLoadBalancerNodePorts = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _Internal::set_has_allocateloadbalancernodeports(&has_bits);
          _impl_.allocateloadbalancernodeports_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes loadBalancerClass = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          auto str = _internal_mutable_loadbalancerclass();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes internalTrafficPolicy = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 178)) {
          auto str = _internal_mutable_internaltrafficpolicy();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ServiceSpec::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.ServiceSpec)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .k8s.io.api.core.v1.ServicePort ports = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_ports_size()); i < n; i++) {
    const auto& repfield = this->_internal_ports(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // map<string, string> selector = 2;
  if (!this->_internal_selector().empty()) {
    using MapType = ::_pb::Map<std::string, std::string>;
    using WireHelper = ServiceSpec_SelectorEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_selector();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "k8s.io.api.core.v1.ServiceSpec.SelectorEntry.key");
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        entry.second.data(), static_cast<int>(entry.second.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "k8s.io.api.core.v1.ServiceSpec.SelectorEntry.value");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(2, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(2, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes clusterIP = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_clusterip(), target);
  }

  // optional bytes type = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_type(), target);
  }

  // repeated string externalIPs = 5;
  for (int i = 0, n = this->_internal_externalips_size(); i < n; i++) {
    const auto& s = this->_internal_externalips(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "k8s.io.api.core.v1.ServiceSpec.externalIPs");
    target = stream->WriteString(5, s, target);
  }

  // optional bytes sessionAffinity = 7;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        7, this->_internal_sessionaffinity(), target);
  }

  // optional bytes loadBalancerIP = 8;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        8, this->_internal_loadbalancerip(), target);
  }

  // repeated string loadBalancerSourceRanges = 9;
  for (int i = 0, n = this->_internal_loadbalancersourceranges_size(); i < n; i++) {
    const auto& s = this->_internal_loadbalancersourceranges(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "k8s.io.api.core.v1.ServiceSpec.loadBalancerSourceRanges");
    target = stream->WriteString(9, s, target);
  }

  // optional bytes externalName = 10;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteBytesMaybeAliased(
        10, this->_internal_externalname(), target);
  }

  // optional bytes externalTrafficPolicy = 11;
  if (cached_has_bits & 0x00000020u) {
    target = stream->WriteBytesMaybeAliased(
        11, this->_internal_externaltrafficpolicy(), target);
  }

  // optional int32 healthCheckNodePort = 12;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(12, this->_internal_healthchecknodeport(), target);
  }

  // optional bool publishNotReadyAddresses = 13;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(13, this->_internal_publishnotreadyaddresses(), target);
  }

  // optional .k8s.io.api.core.v1.SessionAffinityConfig sessionAffinityConfig = 14;
  if (cached_has_bits & 0x00000200u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(14, _Internal::sessionaffinityconfig(this),
        _Internal::sessionaffinityconfig(this).GetCachedSize(), target, stream);
  }

  // optional bytes ipFamilyPolicy = 17;
  if (cached_has_bits & 0x00000040u) {
    target = stream->WriteBytesMaybeAliased(
        17, this->_internal_ipfamilypolicy(), target);
  }

  // repeated string clusterIPs = 18;
  for (int i = 0, n = this->_internal_clusterips_size(); i < n; i++) {
    const auto& s = this->_internal_clusterips(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "k8s.io.api.core.v1.ServiceSpec.clusterIPs");
    target = stream->WriteString(18, s, target);
  }

  // repeated string ipFamilies = 19;
  for (int i = 0, n = this->_internal_ipfamilies_size(); i < n; i++) {
    const auto& s = this->_internal_ipfamilies(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "k8s.io.api.core.v1.ServiceSpec.ipFamilies");
    target = stream->WriteString(19, s, target);
  }

  // optional bool allocateLoadBalancerNodePorts = 20;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(20, this->_internal_allocateloadbalancernodeports(), target);
  }

  // optional bytes loadBalancerClass = 21;
  if (cached_has_bits & 0x00000080u) {
    target = stream->WriteBytesMaybeAliased(
        21, this->_internal_loadbalancerclass(), target);
  }

  // optional bytes internalTrafficPolicy = 22;
  if (cached_has_bits & 0x00000100u) {
    target = stream->WriteBytesMaybeAliased(
        22, this->_internal_internaltrafficpolicy(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.ServiceSpec)
  return target;
}

size_t ServiceSpec::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.ServiceSpec)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .k8s.io.api.core.v1.ServicePort ports = 1;
  total_size += 1UL * this->_internal_ports_size();
  for (const auto& msg : this->_impl_.ports_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // map<string, string> selector = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_selector_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
      it = this->_internal_selector().begin();
      it != this->_internal_selector().end(); ++it) {
    total_size += ServiceSpec_SelectorEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // repeated string externalIPs = 5;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.externalips_.size());
  for (int i = 0, n = _impl_.externalips_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.externalips_.Get(i));
  }

  // repeated string loadBalancerSourceRanges = 9;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.loadbalancersourceranges_.size());
  for (int i = 0, n = _impl_.loadbalancersourceranges_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.loadbalancersourceranges_.Get(i));
  }

  // repeated string clusterIPs = 18;
  total_size += 2 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.clusterips_.size());
  for (int i = 0, n = _impl_.clusterips_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.clusterips_.Get(i));
  }

  // repeated string ipFamilies = 19;
  total_size += 2 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.ipfamilies_.size());
  for (int i = 0, n = _impl_.ipfamilies_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.ipfamilies_.Get(i));
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bytes clusterIP = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_clusterip());
    }

    // optional bytes type = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_type());
    }

    // optional bytes sessionAffinity = 7;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_sessionaffinity());
    }

    // optional bytes loadBalancerIP = 8;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_loadbalancerip());
    }

    // optional bytes externalName = 10;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_externalname());
    }

    // optional bytes externalTrafficPolicy = 11;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_externaltrafficpolicy());
    }

    // optional bytes ipFamilyPolicy = 17;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_ipfamilypolicy());
    }

    // optional bytes loadBalancerClass = 21;
    if (cached_has_bits & 0x00000080u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_loadbalancerclass());
    }

  }
  if (cached_has_bits & 0x00001f00u) {
    // optional bytes internalTrafficPolicy = 22;
    if (cached_has_bits & 0x00000100u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_internaltrafficpolicy());
    }

    // optional .k8s.io.api.core.v1.SessionAffinityConfig sessionAffinityConfig = 14;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.sessionaffinityconfig_);
    }

    // optional int32 healthCheckNodePort = 12;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_healthchecknodeport());
    }

    // optional bool publishNotReadyAddresses = 13;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 1;
    }

    // optional bool allocateLoadBalancerNodePorts = 20;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ServiceSpec::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ServiceSpec::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ServiceSpec::GetClassData() const { return &_class_data_; }


void ServiceSpec::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ServiceSpec*>(&to_msg);
  auto& from = static_cast<const ServiceSpec&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.ServiceSpec)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.ports_.MergeFrom(from._impl_.ports_);
  _this->_impl_.selector_.MergeFrom(from._impl_.selector_);
  _this->_impl_.externalips_.MergeFrom(from._impl_.externalips_);
  _this->_impl_.loadbalancersourceranges_.MergeFrom(from._impl_.loadbalancersourceranges_);
  _this->_impl_.clusterips_.MergeFrom(from._impl_.clusterips_);
  _this->_impl_.ipfamilies_.MergeFrom(from._impl_.ipfamilies_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_clusterip(from._internal_clusterip());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_type(from._internal_type());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_sessionaffinity(from._internal_sessionaffinity());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_loadbalancerip(from._internal_loadbalancerip());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_externalname(from._internal_externalname());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_set_externaltrafficpolicy(from._internal_externaltrafficpolicy());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_set_ipfamilypolicy(from._internal_ipfamilypolicy());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_set_loadbalancerclass(from._internal_loadbalancerclass());
    }
  }
  if (cached_has_bits & 0x00001f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_internal_set_internaltrafficpolicy(from._internal_internaltrafficpolicy());
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_internal_mutable_sessionaffinityconfig()->::k8s::io::api::core::v1::SessionAffinityConfig::MergeFrom(
          from._internal_sessionaffinityconfig());
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.healthchecknodeport_ = from._impl_.healthchecknodeport_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.publishnotreadyaddresses_ = from._impl_.publishnotreadyaddresses_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.allocateloadbalancernodeports_ = from._impl_.allocateloadbalancernodeports_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ServiceSpec::CopyFrom(const ServiceSpec& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.ServiceSpec)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ServiceSpec::IsInitialized() const {
  return true;
}

void ServiceSpec::InternalSwap(ServiceSpec* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.ports_.InternalSwap(&other->_impl_.ports_);
  _impl_.selector_.InternalSwap(&other->_impl_.selector_);
  _impl_.externalips_.InternalSwap(&other->_impl_.externalips_);
  _impl_.loadbalancersourceranges_.InternalSwap(&other->_impl_.loadbalancersourceranges_);
  _impl_.clusterips_.InternalSwap(&other->_impl_.clusterips_);
  _impl_.ipfamilies_.InternalSwap(&other->_impl_.ipfamilies_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.clusterip_, lhs_arena,
      &other->_impl_.clusterip_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.type_, lhs_arena,
      &other->_impl_.type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.sessionaffinity_, lhs_arena,
      &other->_impl_.sessionaffinity_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.loadbalancerip_, lhs_arena,
      &other->_impl_.loadbalancerip_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.externalname_, lhs_arena,
      &other->_impl_.externalname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.externaltrafficpolicy_, lhs_arena,
      &other->_impl_.externaltrafficpolicy_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.ipfamilypolicy_, lhs_arena,
      &other->_impl_.ipfamilypolicy_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.loadbalancerclass_, lhs_arena,
      &other->_impl_.loadbalancerclass_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.internaltrafficpolicy_, lhs_arena,
      &other->_impl_.internaltrafficpolicy_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ServiceSpec, _impl_.allocateloadbalancernodeports_)
      + sizeof(ServiceSpec::_impl_.allocateloadbalancernodeports_)
      - PROTOBUF_FIELD_OFFSET(ServiceSpec, _impl_.sessionaffinityconfig_)>(
          reinterpret_cast<char*>(&_impl_.sessionaffinityconfig_),
          reinterpret_cast<char*>(&other->_impl_.sessionaffinityconfig_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ServiceSpec::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[228]);
}

// ===================================================================

class ServiceStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<ServiceStatus>()._impl_._has_bits_);
  static const ::k8s::io::api::core::v1::LoadBalancerStatus& loadbalancer(const ServiceStatus* msg);
  static void set_has_loadbalancer(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::k8s::io::api::core::v1::LoadBalancerStatus&
ServiceStatus::_Internal::loadbalancer(const ServiceStatus* msg) {
  return *msg->_impl_.loadbalancer_;
}
void ServiceStatus::clear_conditions() {
  _impl_.conditions_.Clear();
}
ServiceStatus::ServiceStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.ServiceStatus)
}
ServiceStatus::ServiceStatus(const ServiceStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ServiceStatus* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.conditions_){from._impl_.conditions_}
    , decltype(_impl_.loadbalancer_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_loadbalancer()) {
    _this->_impl_.loadbalancer_ = new ::k8s::io::api::core::v1::LoadBalancerStatus(*from._impl_.loadbalancer_);
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.ServiceStatus)
}

inline void ServiceStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.conditions_){arena}
    , decltype(_impl_.loadbalancer_){nullptr}
  };
}

ServiceStatus::~ServiceStatus() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.ServiceStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ServiceStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.conditions_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.loadbalancer_;
}

void ServiceStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ServiceStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.ServiceStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.conditions_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.loadbalancer_ != nullptr);
    _impl_.loadbalancer_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ServiceStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .k8s.io.api.core.v1.LoadBalancerStatus loadBalancer = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_loadbalancer(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_conditions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ServiceStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.ServiceStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .k8s.io.api.core.v1.LoadBalancerStatus loadBalancer = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::loadbalancer(this),
        _Internal::loadbalancer(this).GetCachedSize(), target, stream);
  }

  // repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_conditions_size()); i < n; i++) {
    const auto& repfield = this->_internal_conditions(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.ServiceStatus)
  return target;
}

size_t ServiceStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.ServiceStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 2;
  total_size += 1UL * this->_internal_conditions_size();
  for (const auto& msg : this->_impl_.conditions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .k8s.io.api.core.v1.LoadBalancerStatus loadBalancer = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.loadbalancer_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ServiceStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ServiceStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ServiceStatus::GetClassData() const { return &_class_data_; }


void ServiceStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ServiceStatus*>(&to_msg);
  auto& from = static_cast<const ServiceStatus&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.ServiceStatus)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.conditions_.MergeFrom(from._impl_.conditions_);
  if (from._internal_has_loadbalancer()) {
    _this->_internal_mutable_loadbalancer()->::k8s::io::api::core::v1::LoadBalancerStatus::MergeFrom(
        from._internal_loadbalancer());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ServiceStatus::CopyFrom(const ServiceStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.ServiceStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ServiceStatus::IsInitialized() const {
  return true;
}

void ServiceStatus::InternalSwap(ServiceStatus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.conditions_.InternalSwap(&other->_impl_.conditions_);
  swap(_impl_.loadbalancer_, other->_impl_.loadbalancer_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ServiceStatus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[229]);
}

// ===================================================================

class SessionAffinityConfig::_Internal {
 public:
  using HasBits = decltype(std::declval<SessionAffinityConfig>()._impl_._has_bits_);
  static const ::k8s::io::api::core::v1::ClientIPConfig& clientip(const SessionAffinityConfig* msg);
  static void set_has_clientip(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::k8s::io::api::core::v1::ClientIPConfig&
SessionAffinityConfig::_Internal::clientip(const SessionAffinityConfig* msg) {
  return *msg->_impl_.clientip_;
}
SessionAffinityConfig::SessionAffinityConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.SessionAffinityConfig)
}
SessionAffinityConfig::SessionAffinityConfig(const SessionAffinityConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SessionAffinityConfig* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.clientip_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_clientip()) {
    _this->_impl_.clientip_ = new ::k8s::io::api::core::v1::ClientIPConfig(*from._impl_.clientip_);
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.SessionAffinityConfig)
}

inline void SessionAffinityConfig::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.clientip_){nullptr}
  };
}

SessionAffinityConfig::~SessionAffinityConfig() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.SessionAffinityConfig)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SessionAffinityConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.clientip_;
}

void SessionAffinityConfig::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SessionAffinityConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.SessionAffinityConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.clientip_ != nullptr);
    _impl_.clientip_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SessionAffinityConfig::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .k8s.io.api.core.v1.ClientIPConfig clientIP = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_clientip(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SessionAffinityConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.SessionAffinityConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .k8s.io.api.core.v1.ClientIPConfig clientIP = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::clientip(this),
        _Internal::clientip(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.SessionAffinityConfig)
  return target;
}

size_t SessionAffinityConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.SessionAffinityConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .k8s.io.api.core.v1.ClientIPConfig clientIP = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.clientip_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SessionAffinityConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SessionAffinityConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SessionAffinityConfig::GetClassData() const { return &_class_data_; }


void SessionAffinityConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SessionAffinityConfig*>(&to_msg);
  auto& from = static_cast<const SessionAffinityConfig&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.SessionAffinityConfig)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_clientip()) {
    _this->_internal_mutable_clientip()->::k8s::io::api::core::v1::ClientIPConfig::MergeFrom(
        from._internal_clientip());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SessionAffinityConfig::CopyFrom(const SessionAffinityConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.SessionAffinityConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SessionAffinityConfig::IsInitialized() const {
  return true;
}

void SessionAffinityConfig::InternalSwap(SessionAffinityConfig* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.clientip_, other->_impl_.clientip_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SessionAffinityConfig::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[230]);
}

// ===================================================================

class SleepAction::_Internal {
 public:
  using HasBits = decltype(std::declval<SleepAction>()._impl_._has_bits_);
  static void set_has_seconds(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

SleepAction::SleepAction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.SleepAction)
}
SleepAction::SleepAction(const SleepAction& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SleepAction* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.seconds_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.seconds_ = from._impl_.seconds_;
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.SleepAction)
}

inline void SleepAction::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.seconds_){int64_t{0}}
  };
}

SleepAction::~SleepAction() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.SleepAction)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SleepAction::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SleepAction::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SleepAction::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.SleepAction)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.seconds_ = int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SleepAction::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 seconds = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_seconds(&has_bits);
          _impl_.seconds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SleepAction::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.SleepAction)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 seconds = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_seconds(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.SleepAction)
  return target;
}

size_t SleepAction::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.SleepAction)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int64 seconds = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_seconds());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SleepAction::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SleepAction::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SleepAction::GetClassData() const { return &_class_data_; }


void SleepAction::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SleepAction*>(&to_msg);
  auto& from = static_cast<const SleepAction&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.SleepAction)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_seconds()) {
    _this->_internal_set_seconds(from._internal_seconds());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SleepAction::CopyFrom(const SleepAction& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.SleepAction)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SleepAction::IsInitialized() const {
  return true;
}

void SleepAction::InternalSwap(SleepAction* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.seconds_, other->_impl_.seconds_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SleepAction::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[231]);
}

// ===================================================================

class StorageOSPersistentVolumeSource::_Internal {
 public:
  using HasBits = decltype(std::declval<StorageOSPersistentVolumeSource>()._impl_._has_bits_);
  static void set_has_volumename(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_volumenamespace(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_fstype(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_readonly(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::k8s::io::api::core::v1::ObjectReference& secretref(const StorageOSPersistentVolumeSource* msg);
  static void set_has_secretref(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::k8s::io::api::core::v1::ObjectReference&
StorageOSPersistentVolumeSource::_Internal::secretref(const StorageOSPersistentVolumeSource* msg) {
  return *msg->_impl_.secretref_;
}
StorageOSPersistentVolumeSource::StorageOSPersistentVolumeSource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.StorageOSPersistentVolumeSource)
}
StorageOSPersistentVolumeSource::StorageOSPersistentVolumeSource(const StorageOSPersistentVolumeSource& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StorageOSPersistentVolumeSource* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.volumename_){}
    , decltype(_impl_.volumenamespace_){}
    , decltype(_impl_.fstype_){}
    , decltype(_impl_.secretref_){nullptr}
    , decltype(_impl_.readonly_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.volumename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.volumename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_volumename()) {
    _this->_impl_.volumename_.Set(from._internal_volumename(), 
      _this->GetArenaForAllocation());
  }
  _impl_.volumenamespace_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.volumenamespace_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_volumenamespace()) {
    _this->_impl_.volumenamespace_.Set(from._internal_volumenamespace(), 
      _this->GetArenaForAllocation());
  }
  _impl_.fstype_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fstype_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_fstype()) {
    _this->_impl_.fstype_.Set(from._internal_fstype(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_secretref()) {
    _this->_impl_.secretref_ = new ::k8s::io::api::core::v1::ObjectReference(*from._impl_.secretref_);
  }
  _this->_impl_.readonly_ = from._impl_.readonly_;
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.StorageOSPersistentVolumeSource)
}

inline void StorageOSPersistentVolumeSource::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.volumename_){}
    , decltype(_impl_.volumenamespace_){}
    , decltype(_impl_.fstype_){}
    , decltype(_impl_.secretref_){nullptr}
    , decltype(_impl_.readonly_){false}
  };
  _impl_.volumename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.volumename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.volumenamespace_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.volumenamespace_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.fstype_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fstype_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

StorageOSPersistentVolumeSource::~StorageOSPersistentVolumeSource() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.StorageOSPersistentVolumeSource)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StorageOSPersistentVolumeSource::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.volumename_.Destroy();
  _impl_.volumenamespace_.Destroy();
  _impl_.fstype_.Destroy();
  if (this != internal_default_instance()) delete _impl_.secretref_;
}

void StorageOSPersistentVolumeSource::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StorageOSPersistentVolumeSource::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.StorageOSPersistentVolumeSource)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.volumename_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.volumenamespace_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.fstype_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.secretref_ != nullptr);
      _impl_.secretref_->Clear();
    }
  }
  _impl_.readonly_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StorageOSPersistentVolumeSource::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes volumeName = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_volumename();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes volumeNamespace = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_volumenamespace();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes fsType = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_fstype();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool readOnly = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_readonly(&has_bits);
          _impl_.readonly_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.ObjectReference secretRef = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_secretref(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StorageOSPersistentVolumeSource::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.StorageOSPersistentVolumeSource)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes volumeName = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_volumename(), target);
  }

  // optional bytes volumeNamespace = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_volumenamespace(), target);
  }

  // optional bytes fsType = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_fstype(), target);
  }

  // optional bool readOnly = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_readonly(), target);
  }

  // optional .k8s.io.api.core.v1.ObjectReference secretRef = 5;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::secretref(this),
        _Internal::secretref(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.StorageOSPersistentVolumeSource)
  return target;
}

size_t StorageOSPersistentVolumeSource::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.StorageOSPersistentVolumeSource)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional bytes volumeName = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_volumename());
    }

    // optional bytes volumeNamespace = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_volumenamespace());
    }

    // optional bytes fsType = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_fstype());
    }

    // optional .k8s.io.api.core.v1.ObjectReference secretRef = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.secretref_);
    }

    // optional bool readOnly = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StorageOSPersistentVolumeSource::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StorageOSPersistentVolumeSource::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StorageOSPersistentVolumeSource::GetClassData() const { return &_class_data_; }


void StorageOSPersistentVolumeSource::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StorageOSPersistentVolumeSource*>(&to_msg);
  auto& from = static_cast<const StorageOSPersistentVolumeSource&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.StorageOSPersistentVolumeSource)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_volumename(from._internal_volumename());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_volumenamespace(from._internal_volumenamespace());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_fstype(from._internal_fstype());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_secretref()->::k8s::io::api::core::v1::ObjectReference::MergeFrom(
          from._internal_secretref());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.readonly_ = from._impl_.readonly_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StorageOSPersistentVolumeSource::CopyFrom(const StorageOSPersistentVolumeSource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.StorageOSPersistentVolumeSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StorageOSPersistentVolumeSource::IsInitialized() const {
  return true;
}

void StorageOSPersistentVolumeSource::InternalSwap(StorageOSPersistentVolumeSource* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.volumename_, lhs_arena,
      &other->_impl_.volumename_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.volumenamespace_, lhs_arena,
      &other->_impl_.volumenamespace_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.fstype_, lhs_arena,
      &other->_impl_.fstype_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StorageOSPersistentVolumeSource, _impl_.readonly_)
      + sizeof(StorageOSPersistentVolumeSource::_impl_.readonly_)
      - PROTOBUF_FIELD_OFFSET(StorageOSPersistentVolumeSource, _impl_.secretref_)>(
          reinterpret_cast<char*>(&_impl_.secretref_),
          reinterpret_cast<char*>(&other->_impl_.secretref_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StorageOSPersistentVolumeSource::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[232]);
}

// ===================================================================

class StorageOSVolumeSource::_Internal {
 public:
  using HasBits = decltype(std::declval<StorageOSVolumeSource>()._impl_._has_bits_);
  static void set_has_volumename(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_volumenamespace(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_fstype(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_readonly(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::k8s::io::api::core::v1::LocalObjectReference& secretref(const StorageOSVolumeSource* msg);
  static void set_has_secretref(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::k8s::io::api::core::v1::LocalObjectReference&
StorageOSVolumeSource::_Internal::secretref(const StorageOSVolumeSource* msg) {
  return *msg->_impl_.secretref_;
}
StorageOSVolumeSource::StorageOSVolumeSource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.StorageOSVolumeSource)
}
StorageOSVolumeSource::StorageOSVolumeSource(const StorageOSVolumeSource& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StorageOSVolumeSource* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.volumename_){}
    , decltype(_impl_.volumenamespace_){}
    , decltype(_impl_.fstype_){}
    , decltype(_impl_.secretref_){nullptr}
    , decltype(_impl_.readonly_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.volumename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.volumename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_volumename()) {
    _this->_impl_.volumename_.Set(from._internal_volumename(), 
      _this->GetArenaForAllocation());
  }
  _impl_.volumenamespace_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.volumenamespace_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_volumenamespace()) {
    _this->_impl_.volumenamespace_.Set(from._internal_volumenamespace(), 
      _this->GetArenaForAllocation());
  }
  _impl_.fstype_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fstype_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_fstype()) {
    _this->_impl_.fstype_.Set(from._internal_fstype(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_secretref()) {
    _this->_impl_.secretref_ = new ::k8s::io::api::core::v1::LocalObjectReference(*from._impl_.secretref_);
  }
  _this->_impl_.readonly_ = from._impl_.readonly_;
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.StorageOSVolumeSource)
}

inline void StorageOSVolumeSource::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.volumename_){}
    , decltype(_impl_.volumenamespace_){}
    , decltype(_impl_.fstype_){}
    , decltype(_impl_.secretref_){nullptr}
    , decltype(_impl_.readonly_){false}
  };
  _impl_.volumename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.volumename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.volumenamespace_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.volumenamespace_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.fstype_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fstype_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

StorageOSVolumeSource::~StorageOSVolumeSource() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.StorageOSVolumeSource)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StorageOSVolumeSource::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.volumename_.Destroy();
  _impl_.volumenamespace_.Destroy();
  _impl_.fstype_.Destroy();
  if (this != internal_default_instance()) delete _impl_.secretref_;
}

void StorageOSVolumeSource::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StorageOSVolumeSource::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.StorageOSVolumeSource)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.volumename_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.volumenamespace_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.fstype_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.secretref_ != nullptr);
      _impl_.secretref_->Clear();
    }
  }
  _impl_.readonly_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StorageOSVolumeSource::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes volumeName = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_volumename();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes volumeNamespace = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_volumenamespace();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes fsType = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_fstype();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool readOnly = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_readonly(&has_bits);
          _impl_.readonly_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.LocalObjectReference secretRef = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_secretref(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StorageOSVolumeSource::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.StorageOSVolumeSource)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes volumeName = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_volumename(), target);
  }

  // optional bytes volumeNamespace = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_volumenamespace(), target);
  }

  // optional bytes fsType = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_fstype(), target);
  }

  // optional bool readOnly = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_readonly(), target);
  }

  // optional .k8s.io.api.core.v1.LocalObjectReference secretRef = 5;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::secretref(this),
        _Internal::secretref(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.StorageOSVolumeSource)
  return target;
}

size_t StorageOSVolumeSource::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.StorageOSVolumeSource)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional bytes volumeName = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_volumename());
    }

    // optional bytes volumeNamespace = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_volumenamespace());
    }

    // optional bytes fsType = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_fstype());
    }

    // optional .k8s.io.api.core.v1.LocalObjectReference secretRef = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.secretref_);
    }

    // optional bool readOnly = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StorageOSVolumeSource::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StorageOSVolumeSource::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StorageOSVolumeSource::GetClassData() const { return &_class_data_; }


void StorageOSVolumeSource::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StorageOSVolumeSource*>(&to_msg);
  auto& from = static_cast<const StorageOSVolumeSource&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.StorageOSVolumeSource)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_volumename(from._internal_volumename());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_volumenamespace(from._internal_volumenamespace());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_fstype(from._internal_fstype());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_secretref()->::k8s::io::api::core::v1::LocalObjectReference::MergeFrom(
          from._internal_secretref());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.readonly_ = from._impl_.readonly_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StorageOSVolumeSource::CopyFrom(const StorageOSVolumeSource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.StorageOSVolumeSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StorageOSVolumeSource::IsInitialized() const {
  return true;
}

void StorageOSVolumeSource::InternalSwap(StorageOSVolumeSource* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.volumename_, lhs_arena,
      &other->_impl_.volumename_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.volumenamespace_, lhs_arena,
      &other->_impl_.volumenamespace_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.fstype_, lhs_arena,
      &other->_impl_.fstype_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StorageOSVolumeSource, _impl_.readonly_)
      + sizeof(StorageOSVolumeSource::_impl_.readonly_)
      - PROTOBUF_FIELD_OFFSET(StorageOSVolumeSource, _impl_.secretref_)>(
          reinterpret_cast<char*>(&_impl_.secretref_),
          reinterpret_cast<char*>(&other->_impl_.secretref_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StorageOSVolumeSource::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[233]);
}

// ===================================================================

class Sysctl::_Internal {
 public:
  using HasBits = decltype(std::declval<Sysctl>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

Sysctl::Sysctl(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.Sysctl)
}
Sysctl::Sysctl(const Sysctl& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Sysctl* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.value_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_value()) {
    _this->_impl_.value_.Set(from._internal_value(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.Sysctl)
}

inline void Sysctl::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.value_){}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Sysctl::~Sysctl() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.Sysctl)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Sysctl::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.value_.Destroy();
}

void Sysctl::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Sysctl::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.Sysctl)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.value_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Sysctl::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Sysctl::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.Sysctl)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional bytes value = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.Sysctl)
  return target;
}

size_t Sysctl::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.Sysctl)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_name());
    }

    // optional bytes value = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_value());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Sysctl::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Sysctl::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Sysctl::GetClassData() const { return &_class_data_; }


void Sysctl::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Sysctl*>(&to_msg);
  auto& from = static_cast<const Sysctl&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.Sysctl)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_value(from._internal_value());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Sysctl::CopyFrom(const Sysctl& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.Sysctl)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Sysctl::IsInitialized() const {
  return true;
}

void Sysctl::InternalSwap(Sysctl* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.value_, lhs_arena,
      &other->_impl_.value_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata Sysctl::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[234]);
}

// ===================================================================

class TCPSocketAction::_Internal {
 public:
  using HasBits = decltype(std::declval<TCPSocketAction>()._impl_._has_bits_);
  static const ::k8s::io::apimachinery::pkg::util::intstr::IntOrString& port(const TCPSocketAction* msg);
  static void set_has_port(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_host(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::k8s::io::apimachinery::pkg::util::intstr::IntOrString&
TCPSocketAction::_Internal::port(const TCPSocketAction* msg) {
  return *msg->_impl_.port_;
}
void TCPSocketAction::clear_port() {
  if (_impl_.port_ != nullptr) _impl_.port_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
TCPSocketAction::TCPSocketAction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.TCPSocketAction)
}
TCPSocketAction::TCPSocketAction(const TCPSocketAction& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TCPSocketAction* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.host_){}
    , decltype(_impl_.port_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.host_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.host_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_host()) {
    _this->_impl_.host_.Set(from._internal_host(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_port()) {
    _this->_impl_.port_ = new ::k8s::io::apimachinery::pkg::util::intstr::IntOrString(*from._impl_.port_);
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.TCPSocketAction)
}

inline void TCPSocketAction::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.host_){}
    , decltype(_impl_.port_){nullptr}
  };
  _impl_.host_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.host_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TCPSocketAction::~TCPSocketAction() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.TCPSocketAction)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TCPSocketAction::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.host_.Destroy();
  if (this != internal_default_instance()) delete _impl_.port_;
}

void TCPSocketAction::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TCPSocketAction::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.TCPSocketAction)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.host_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.port_ != nullptr);
      _impl_.port_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TCPSocketAction::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString port = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_port(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes host = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_host();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TCPSocketAction::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.TCPSocketAction)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString port = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::port(this),
        _Internal::port(this).GetCachedSize(), target, stream);
  }

  // optional bytes host = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_host(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.TCPSocketAction)
  return target;
}

size_t TCPSocketAction::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.TCPSocketAction)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes host = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_host());
    }

    // optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString port = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.port_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TCPSocketAction::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TCPSocketAction::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TCPSocketAction::GetClassData() const { return &_class_data_; }


void TCPSocketAction::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TCPSocketAction*>(&to_msg);
  auto& from = static_cast<const TCPSocketAction&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.TCPSocketAction)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_host(from._internal_host());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_port()->::k8s::io::apimachinery::pkg::util::intstr::IntOrString::MergeFrom(
          from._internal_port());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TCPSocketAction::CopyFrom(const TCPSocketAction& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.TCPSocketAction)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TCPSocketAction::IsInitialized() const {
  return true;
}

void TCPSocketAction::InternalSwap(TCPSocketAction* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.host_, lhs_arena,
      &other->_impl_.host_, rhs_arena
  );
  swap(_impl_.port_, other->_impl_.port_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TCPSocketAction::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[235]);
}

// ===================================================================

class Taint::_Internal {
 public:
  using HasBits = decltype(std::declval<Taint>()._impl_._has_bits_);
  static void set_has_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_effect(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::k8s::io::apimachinery::pkg::apis::meta::v1::Time& timeadded(const Taint* msg);
  static void set_has_timeadded(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::k8s::io::apimachinery::pkg::apis::meta::v1::Time&
Taint::_Internal::timeadded(const Taint* msg) {
  return *msg->_impl_.timeadded_;
}
void Taint::clear_timeadded() {
  if (_impl_.timeadded_ != nullptr) _impl_.timeadded_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
Taint::Taint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.Taint)
}
Taint::Taint(const Taint& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Taint* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.key_){}
    , decltype(_impl_.value_){}
    , decltype(_impl_.effect_){}
    , decltype(_impl_.timeadded_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_key()) {
    _this->_impl_.key_.Set(from._internal_key(), 
      _this->GetArenaForAllocation());
  }
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_value()) {
    _this->_impl_.value_.Set(from._internal_value(), 
      _this->GetArenaForAllocation());
  }
  _impl_.effect_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.effect_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_effect()) {
    _this->_impl_.effect_.Set(from._internal_effect(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_timeadded()) {
    _this->_impl_.timeadded_ = new ::k8s::io::apimachinery::pkg::apis::meta::v1::Time(*from._impl_.timeadded_);
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.Taint)
}

inline void Taint::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.key_){}
    , decltype(_impl_.value_){}
    , decltype(_impl_.effect_){}
    , decltype(_impl_.timeadded_){nullptr}
  };
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.effect_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.effect_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Taint::~Taint() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.Taint)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Taint::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.key_.Destroy();
  _impl_.value_.Destroy();
  _impl_.effect_.Destroy();
  if (this != internal_default_instance()) delete _impl_.timeadded_;
}

void Taint::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Taint::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.Taint)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.key_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.value_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.effect_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.timeadded_ != nullptr);
      _impl_.timeadded_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Taint::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes effect = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_effect();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time timeAdded = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_timeadded(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Taint::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.Taint)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes key = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_key(), target);
  }

  // optional bytes value = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_value(), target);
  }

  // optional bytes effect = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_effect(), target);
  }

  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time timeAdded = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::timeadded(this),
        _Internal::timeadded(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.Taint)
  return target;
}

size_t Taint::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.Taint)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional bytes key = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_key());
    }

    // optional bytes value = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_value());
    }

    // optional bytes effect = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_effect());
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time timeAdded = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.timeadded_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Taint::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Taint::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Taint::GetClassData() const { return &_class_data_; }


void Taint::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Taint*>(&to_msg);
  auto& from = static_cast<const Taint&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.Taint)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_key(from._internal_key());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_value(from._internal_value());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_effect(from._internal_effect());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_timeadded()->::k8s::io::apimachinery::pkg::apis::meta::v1::Time::MergeFrom(
          from._internal_timeadded());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Taint::CopyFrom(const Taint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.Taint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Taint::IsInitialized() const {
  return true;
}

void Taint::InternalSwap(Taint* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.key_, lhs_arena,
      &other->_impl_.key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.value_, lhs_arena,
      &other->_impl_.value_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.effect_, lhs_arena,
      &other->_impl_.effect_, rhs_arena
  );
  swap(_impl_.timeadded_, other->_impl_.timeadded_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Taint::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[236]);
}

// ===================================================================

class Toleration::_Internal {
 public:
  using HasBits = decltype(std::declval<Toleration>()._impl_._has_bits_);
  static void set_has_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_operator_(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_effect(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_tolerationseconds(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Toleration::Toleration(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.Toleration)
}
Toleration::Toleration(const Toleration& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Toleration* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.key_){}
    , decltype(_impl_.operator__){}
    , decltype(_impl_.value_){}
    , decltype(_impl_.effect_){}
    , decltype(_impl_.tolerationseconds_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_key()) {
    _this->_impl_.key_.Set(from._internal_key(), 
      _this->GetArenaForAllocation());
  }
  _impl_.operator__.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.operator__.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_operator_()) {
    _this->_impl_.operator__.Set(from._internal_operator_(), 
      _this->GetArenaForAllocation());
  }
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_value()) {
    _this->_impl_.value_.Set(from._internal_value(), 
      _this->GetArenaForAllocation());
  }
  _impl_.effect_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.effect_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_effect()) {
    _this->_impl_.effect_.Set(from._internal_effect(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.tolerationseconds_ = from._impl_.tolerationseconds_;
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.Toleration)
}

inline void Toleration::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.key_){}
    , decltype(_impl_.operator__){}
    , decltype(_impl_.value_){}
    , decltype(_impl_.effect_){}
    , decltype(_impl_.tolerationseconds_){int64_t{0}}
  };
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.operator__.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.operator__.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.effect_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.effect_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Toleration::~Toleration() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.Toleration)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Toleration::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.key_.Destroy();
  _impl_.operator__.Destroy();
  _impl_.value_.Destroy();
  _impl_.effect_.Destroy();
}

void Toleration::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Toleration::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.Toleration)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.key_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.operator__.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.value_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.effect_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.tolerationseconds_ = int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Toleration::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes operator = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_operator_();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes value = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes effect = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_effect();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 tolerationSeconds = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_tolerationseconds(&has_bits);
          _impl_.tolerationseconds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Toleration::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.Toleration)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes key = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_key(), target);
  }

  // optional bytes operator = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_operator_(), target);
  }

  // optional bytes value = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_value(), target);
  }

  // optional bytes effect = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_effect(), target);
  }

  // optional int64 tolerationSeconds = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(5, this->_internal_tolerationseconds(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.Toleration)
  return target;
}

size_t Toleration::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.Toleration)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional bytes key = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_key());
    }

    // optional bytes operator = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_operator_());
    }

    // optional bytes value = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_value());
    }

    // optional bytes effect = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_effect());
    }

    // optional int64 tolerationSeconds = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_tolerationseconds());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Toleration::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Toleration::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Toleration::GetClassData() const { return &_class_data_; }


void Toleration::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Toleration*>(&to_msg);
  auto& from = static_cast<const Toleration&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.Toleration)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_key(from._internal_key());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_operator_(from._internal_operator_());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_value(from._internal_value());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_effect(from._internal_effect());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.tolerationseconds_ = from._impl_.tolerationseconds_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Toleration::CopyFrom(const Toleration& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.Toleration)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Toleration::IsInitialized() const {
  return true;
}

void Toleration::InternalSwap(Toleration* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.key_, lhs_arena,
      &other->_impl_.key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.operator__, lhs_arena,
      &other->_impl_.operator__, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.value_, lhs_arena,
      &other->_impl_.value_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.effect_, lhs_arena,
      &other->_impl_.effect_, rhs_arena
  );
  swap(_impl_.tolerationseconds_, other->_impl_.tolerationseconds_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Toleration::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[237]);
}

// ===================================================================

class TopologySelectorLabelRequirement::_Internal {
 public:
  using HasBits = decltype(std::declval<TopologySelectorLabelRequirement>()._impl_._has_bits_);
  static void set_has_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

TopologySelectorLabelRequirement::TopologySelectorLabelRequirement(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.TopologySelectorLabelRequirement)
}
TopologySelectorLabelRequirement::TopologySelectorLabelRequirement(const TopologySelectorLabelRequirement& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TopologySelectorLabelRequirement* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.values_){from._impl_.values_}
    , decltype(_impl_.key_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_key()) {
    _this->_impl_.key_.Set(from._internal_key(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.TopologySelectorLabelRequirement)
}

inline void TopologySelectorLabelRequirement::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.values_){arena}
    , decltype(_impl_.key_){}
  };
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TopologySelectorLabelRequirement::~TopologySelectorLabelRequirement() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.TopologySelectorLabelRequirement)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TopologySelectorLabelRequirement::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.values_.~RepeatedPtrField();
  _impl_.key_.Destroy();
}

void TopologySelectorLabelRequirement::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TopologySelectorLabelRequirement::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.TopologySelectorLabelRequirement)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.values_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.key_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TopologySelectorLabelRequirement::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string values = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_values();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "k8s.io.api.core.v1.TopologySelectorLabelRequirement.values");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TopologySelectorLabelRequirement::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.TopologySelectorLabelRequirement)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes key = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_key(), target);
  }

  // repeated string values = 2;
  for (int i = 0, n = this->_internal_values_size(); i < n; i++) {
    const auto& s = this->_internal_values(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "k8s.io.api.core.v1.TopologySelectorLabelRequirement.values");
    target = stream->WriteString(2, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.TopologySelectorLabelRequirement)
  return target;
}

size_t TopologySelectorLabelRequirement::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.TopologySelectorLabelRequirement)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string values = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.values_.size());
  for (int i = 0, n = _impl_.values_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.values_.Get(i));
  }

  // optional bytes key = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_key());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TopologySelectorLabelRequirement::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TopologySelectorLabelRequirement::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TopologySelectorLabelRequirement::GetClassData() const { return &_class_data_; }


void TopologySelectorLabelRequirement::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TopologySelectorLabelRequirement*>(&to_msg);
  auto& from = static_cast<const TopologySelectorLabelRequirement&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.TopologySelectorLabelRequirement)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.values_.MergeFrom(from._impl_.values_);
  if (from._internal_has_key()) {
    _this->_internal_set_key(from._internal_key());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TopologySelectorLabelRequirement::CopyFrom(const TopologySelectorLabelRequirement& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.TopologySelectorLabelRequirement)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TopologySelectorLabelRequirement::IsInitialized() const {
  return true;
}

void TopologySelectorLabelRequirement::InternalSwap(TopologySelectorLabelRequirement* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.values_.InternalSwap(&other->_impl_.values_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.key_, lhs_arena,
      &other->_impl_.key_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata TopologySelectorLabelRequirement::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[238]);
}

// ===================================================================

class TopologySelectorTerm::_Internal {
 public:
};

TopologySelectorTerm::TopologySelectorTerm(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.TopologySelectorTerm)
}
TopologySelectorTerm::TopologySelectorTerm(const TopologySelectorTerm& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TopologySelectorTerm* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.matchlabelexpressions_){from._impl_.matchlabelexpressions_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.TopologySelectorTerm)
}

inline void TopologySelectorTerm::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.matchlabelexpressions_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

TopologySelectorTerm::~TopologySelectorTerm() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.TopologySelectorTerm)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TopologySelectorTerm::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.matchlabelexpressions_.~RepeatedPtrField();
}

void TopologySelectorTerm::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TopologySelectorTerm::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.TopologySelectorTerm)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.matchlabelexpressions_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TopologySelectorTerm::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .k8s.io.api.core.v1.TopologySelectorLabelRequirement matchLabelExpressions = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_matchlabelexpressions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TopologySelectorTerm::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.TopologySelectorTerm)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .k8s.io.api.core.v1.TopologySelectorLabelRequirement matchLabelExpressions = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_matchlabelexpressions_size()); i < n; i++) {
    const auto& repfield = this->_internal_matchlabelexpressions(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.TopologySelectorTerm)
  return target;
}

size_t TopologySelectorTerm::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.TopologySelectorTerm)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .k8s.io.api.core.v1.TopologySelectorLabelRequirement matchLabelExpressions = 1;
  total_size += 1UL * this->_internal_matchlabelexpressions_size();
  for (const auto& msg : this->_impl_.matchlabelexpressions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TopologySelectorTerm::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TopologySelectorTerm::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TopologySelectorTerm::GetClassData() const { return &_class_data_; }


void TopologySelectorTerm::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TopologySelectorTerm*>(&to_msg);
  auto& from = static_cast<const TopologySelectorTerm&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.TopologySelectorTerm)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.matchlabelexpressions_.MergeFrom(from._impl_.matchlabelexpressions_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TopologySelectorTerm::CopyFrom(const TopologySelectorTerm& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.TopologySelectorTerm)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TopologySelectorTerm::IsInitialized() const {
  return true;
}

void TopologySelectorTerm::InternalSwap(TopologySelectorTerm* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.matchlabelexpressions_.InternalSwap(&other->_impl_.matchlabelexpressions_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TopologySelectorTerm::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[239]);
}

// ===================================================================

class TopologySpreadConstraint::_Internal {
 public:
  using HasBits = decltype(std::declval<TopologySpreadConstraint>()._impl_._has_bits_);
  static void set_has_maxskew(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_topologykey(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_whenunsatisfiable(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector& labelselector(const TopologySpreadConstraint* msg);
  static void set_has_labelselector(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_mindomains(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_nodeaffinitypolicy(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_nodetaintspolicy(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector&
TopologySpreadConstraint::_Internal::labelselector(const TopologySpreadConstraint* msg) {
  return *msg->_impl_.labelselector_;
}
void TopologySpreadConstraint::clear_labelselector() {
  if (_impl_.labelselector_ != nullptr) _impl_.labelselector_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
TopologySpreadConstraint::TopologySpreadConstraint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.TopologySpreadConstraint)
}
TopologySpreadConstraint::TopologySpreadConstraint(const TopologySpreadConstraint& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TopologySpreadConstraint* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.matchlabelkeys_){from._impl_.matchlabelkeys_}
    , decltype(_impl_.topologykey_){}
    , decltype(_impl_.whenunsatisfiable_){}
    , decltype(_impl_.nodeaffinitypolicy_){}
    , decltype(_impl_.nodetaintspolicy_){}
    , decltype(_impl_.labelselector_){nullptr}
    , decltype(_impl_.maxskew_){}
    , decltype(_impl_.mindomains_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.topologykey_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.topologykey_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_topologykey()) {
    _this->_impl_.topologykey_.Set(from._internal_topologykey(), 
      _this->GetArenaForAllocation());
  }
  _impl_.whenunsatisfiable_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.whenunsatisfiable_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_whenunsatisfiable()) {
    _this->_impl_.whenunsatisfiable_.Set(from._internal_whenunsatisfiable(), 
      _this->GetArenaForAllocation());
  }
  _impl_.nodeaffinitypolicy_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nodeaffinitypolicy_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_nodeaffinitypolicy()) {
    _this->_impl_.nodeaffinitypolicy_.Set(from._internal_nodeaffinitypolicy(), 
      _this->GetArenaForAllocation());
  }
  _impl_.nodetaintspolicy_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nodetaintspolicy_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_nodetaintspolicy()) {
    _this->_impl_.nodetaintspolicy_.Set(from._internal_nodetaintspolicy(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_labelselector()) {
    _this->_impl_.labelselector_ = new ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector(*from._impl_.labelselector_);
  }
  ::memcpy(&_impl_.maxskew_, &from._impl_.maxskew_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.mindomains_) -
    reinterpret_cast<char*>(&_impl_.maxskew_)) + sizeof(_impl_.mindomains_));
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.TopologySpreadConstraint)
}

inline void TopologySpreadConstraint::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.matchlabelkeys_){arena}
    , decltype(_impl_.topologykey_){}
    , decltype(_impl_.whenunsatisfiable_){}
    , decltype(_impl_.nodeaffinitypolicy_){}
    , decltype(_impl_.nodetaintspolicy_){}
    , decltype(_impl_.labelselector_){nullptr}
    , decltype(_impl_.maxskew_){0}
    , decltype(_impl_.mindomains_){0}
  };
  _impl_.topologykey_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.topologykey_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.whenunsatisfiable_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.whenunsatisfiable_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.nodeaffinitypolicy_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nodeaffinitypolicy_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.nodetaintspolicy_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nodetaintspolicy_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TopologySpreadConstraint::~TopologySpreadConstraint() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.TopologySpreadConstraint)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TopologySpreadConstraint::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.matchlabelkeys_.~RepeatedPtrField();
  _impl_.topologykey_.Destroy();
  _impl_.whenunsatisfiable_.Destroy();
  _impl_.nodeaffinitypolicy_.Destroy();
  _impl_.nodetaintspolicy_.Destroy();
  if (this != internal_default_instance()) delete _impl_.labelselector_;
}

void TopologySpreadConstraint::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TopologySpreadConstraint::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.TopologySpreadConstraint)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.matchlabelkeys_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.topologykey_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.whenunsatisfiable_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.nodeaffinitypolicy_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.nodetaintspolicy_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.labelselector_ != nullptr);
      _impl_.labelselector_->Clear();
    }
  }
  if (cached_has_bits & 0x00000060u) {
    ::memset(&_impl_.maxskew_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.mindomains_) -
        reinterpret_cast<char*>(&_impl_.maxskew_)) + sizeof(_impl_.mindomains_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TopologySpreadConstraint::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 maxSkew = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_maxskew(&has_bits);
          _impl_.maxskew_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes topologyKey = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_topologykey();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes whenUnsatisfiable = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_whenunsatisfiable();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector labelSelector = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_labelselector(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 minDomains = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_mindomains(&has_bits);
          _impl_.mindomains_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes nodeAffinityPolicy = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_nodeaffinitypolicy();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes nodeTaintsPolicy = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_nodetaintspolicy();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string matchLabelKeys = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_matchlabelkeys();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "k8s.io.api.core.v1.TopologySpreadConstraint.matchLabelKeys");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TopologySpreadConstraint::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.TopologySpreadConstraint)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 maxSkew = 1;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_maxskew(), target);
  }

  // optional bytes topologyKey = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_topologykey(), target);
  }

  // optional bytes whenUnsatisfiable = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_whenunsatisfiable(), target);
  }

  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector labelSelector = 4;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::labelselector(this),
        _Internal::labelselector(this).GetCachedSize(), target, stream);
  }

  // optional int32 minDomains = 5;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_mindomains(), target);
  }

  // optional bytes nodeAffinityPolicy = 6;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        6, this->_internal_nodeaffinitypolicy(), target);
  }

  // optional bytes nodeTaintsPolicy = 7;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        7, this->_internal_nodetaintspolicy(), target);
  }

  // repeated string matchLabelKeys = 8;
  for (int i = 0, n = this->_internal_matchlabelkeys_size(); i < n; i++) {
    const auto& s = this->_internal_matchlabelkeys(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "k8s.io.api.core.v1.TopologySpreadConstraint.matchLabelKeys");
    target = stream->WriteString(8, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.TopologySpreadConstraint)
  return target;
}

size_t TopologySpreadConstraint::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.TopologySpreadConstraint)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string matchLabelKeys = 8;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.matchlabelkeys_.size());
  for (int i = 0, n = _impl_.matchlabelkeys_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.matchlabelkeys_.Get(i));
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional bytes topologyKey = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_topologykey());
    }

    // optional bytes whenUnsatisfiable = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_whenunsatisfiable());
    }

    // optional bytes nodeAffinityPolicy = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_nodeaffinitypolicy());
    }

    // optional bytes nodeTaintsPolicy = 7;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_nodetaintspolicy());
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector labelSelector = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.labelselector_);
    }

    // optional int32 maxSkew = 1;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_maxskew());
    }

    // optional int32 minDomains = 5;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_mindomains());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TopologySpreadConstraint::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TopologySpreadConstraint::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TopologySpreadConstraint::GetClassData() const { return &_class_data_; }


void TopologySpreadConstraint::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TopologySpreadConstraint*>(&to_msg);
  auto& from = static_cast<const TopologySpreadConstraint&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.TopologySpreadConstraint)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.matchlabelkeys_.MergeFrom(from._impl_.matchlabelkeys_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_topologykey(from._internal_topologykey());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_whenunsatisfiable(from._internal_whenunsatisfiable());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_nodeaffinitypolicy(from._internal_nodeaffinitypolicy());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_nodetaintspolicy(from._internal_nodetaintspolicy());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_labelselector()->::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector::MergeFrom(
          from._internal_labelselector());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.maxskew_ = from._impl_.maxskew_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.mindomains_ = from._impl_.mindomains_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TopologySpreadConstraint::CopyFrom(const TopologySpreadConstraint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.TopologySpreadConstraint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TopologySpreadConstraint::IsInitialized() const {
  return true;
}

void TopologySpreadConstraint::InternalSwap(TopologySpreadConstraint* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.matchlabelkeys_.InternalSwap(&other->_impl_.matchlabelkeys_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.topologykey_, lhs_arena,
      &other->_impl_.topologykey_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.whenunsatisfiable_, lhs_arena,
      &other->_impl_.whenunsatisfiable_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.nodeaffinitypolicy_, lhs_arena,
      &other->_impl_.nodeaffinitypolicy_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.nodetaintspolicy_, lhs_arena,
      &other->_impl_.nodetaintspolicy_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TopologySpreadConstraint, _impl_.mindomains_)
      + sizeof(TopologySpreadConstraint::_impl_.mindomains_)
      - PROTOBUF_FIELD_OFFSET(TopologySpreadConstraint, _impl_.labelselector_)>(
          reinterpret_cast<char*>(&_impl_.labelselector_),
          reinterpret_cast<char*>(&other->_impl_.labelselector_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TopologySpreadConstraint::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[240]);
}

// ===================================================================

class TypedLocalObjectReference::_Internal {
 public:
  using HasBits = decltype(std::declval<TypedLocalObjectReference>()._impl_._has_bits_);
  static void set_has_apigroup(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_kind(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

TypedLocalObjectReference::TypedLocalObjectReference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.TypedLocalObjectReference)
}
TypedLocalObjectReference::TypedLocalObjectReference(const TypedLocalObjectReference& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TypedLocalObjectReference* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.apigroup_){}
    , decltype(_impl_.kind_){}
    , decltype(_impl_.name_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.apigroup_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.apigroup_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_apigroup()) {
    _this->_impl_.apigroup_.Set(from._internal_apigroup(), 
      _this->GetArenaForAllocation());
  }
  _impl_.kind_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.kind_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_kind()) {
    _this->_impl_.kind_.Set(from._internal_kind(), 
      _this->GetArenaForAllocation());
  }
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.TypedLocalObjectReference)
}

inline void TypedLocalObjectReference::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.apigroup_){}
    , decltype(_impl_.kind_){}
    , decltype(_impl_.name_){}
  };
  _impl_.apigroup_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.apigroup_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.kind_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.kind_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TypedLocalObjectReference::~TypedLocalObjectReference() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.TypedLocalObjectReference)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TypedLocalObjectReference::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.apigroup_.Destroy();
  _impl_.kind_.Destroy();
  _impl_.name_.Destroy();
}

void TypedLocalObjectReference::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TypedLocalObjectReference::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.TypedLocalObjectReference)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.apigroup_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.kind_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TypedLocalObjectReference::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes apiGroup = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_apigroup();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes kind = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_kind();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TypedLocalObjectReference::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.TypedLocalObjectReference)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes apiGroup = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_apigroup(), target);
  }

  // optional bytes kind = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_kind(), target);
  }

  // optional bytes name = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.TypedLocalObjectReference)
  return target;
}

size_t TypedLocalObjectReference::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.TypedLocalObjectReference)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bytes apiGroup = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_apigroup());
    }

    // optional bytes kind = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_kind());
    }

    // optional bytes name = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_name());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TypedLocalObjectReference::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TypedLocalObjectReference::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TypedLocalObjectReference::GetClassData() const { return &_class_data_; }


void TypedLocalObjectReference::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TypedLocalObjectReference*>(&to_msg);
  auto& from = static_cast<const TypedLocalObjectReference&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.TypedLocalObjectReference)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_apigroup(from._internal_apigroup());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_kind(from._internal_kind());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_name(from._internal_name());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TypedLocalObjectReference::CopyFrom(const TypedLocalObjectReference& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.TypedLocalObjectReference)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TypedLocalObjectReference::IsInitialized() const {
  return true;
}

void TypedLocalObjectReference::InternalSwap(TypedLocalObjectReference* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.apigroup_, lhs_arena,
      &other->_impl_.apigroup_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.kind_, lhs_arena,
      &other->_impl_.kind_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata TypedLocalObjectReference::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[241]);
}

// ===================================================================

class TypedObjectReference::_Internal {
 public:
  using HasBits = decltype(std::declval<TypedObjectReference>()._impl_._has_bits_);
  static void set_has_apigroup(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_kind(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_namespace_(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

TypedObjectReference::TypedObjectReference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.TypedObjectReference)
}
TypedObjectReference::TypedObjectReference(const TypedObjectReference& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TypedObjectReference* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.apigroup_){}
    , decltype(_impl_.kind_){}
    , decltype(_impl_.name_){}
    , decltype(_impl_.namespace__){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.apigroup_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.apigroup_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_apigroup()) {
    _this->_impl_.apigroup_.Set(from._internal_apigroup(), 
      _this->GetArenaForAllocation());
  }
  _impl_.kind_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.kind_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_kind()) {
    _this->_impl_.kind_.Set(from._internal_kind(), 
      _this->GetArenaForAllocation());
  }
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.namespace__.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.namespace__.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_namespace_()) {
    _this->_impl_.namespace__.Set(from._internal_namespace_(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.TypedObjectReference)
}

inline void TypedObjectReference::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.apigroup_){}
    , decltype(_impl_.kind_){}
    , decltype(_impl_.name_){}
    , decltype(_impl_.namespace__){}
  };
  _impl_.apigroup_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.apigroup_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.kind_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.kind_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.namespace__.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.namespace__.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TypedObjectReference::~TypedObjectReference() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.TypedObjectReference)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TypedObjectReference::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.apigroup_.Destroy();
  _impl_.kind_.Destroy();
  _impl_.name_.Destroy();
  _impl_.namespace__.Destroy();
}

void TypedObjectReference::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TypedObjectReference::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.TypedObjectReference)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.apigroup_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.kind_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.namespace__.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TypedObjectReference::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes apiGroup = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_apigroup();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes kind = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_kind();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes namespace = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_namespace_();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TypedObjectReference::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.TypedObjectReference)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes apiGroup = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_apigroup(), target);
  }

  // optional bytes kind = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_kind(), target);
  }

  // optional bytes name = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_name(), target);
  }

  // optional bytes namespace = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_namespace_(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.TypedObjectReference)
  return target;
}

size_t TypedObjectReference::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.TypedObjectReference)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional bytes apiGroup = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_apigroup());
    }

    // optional bytes kind = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_kind());
    }

    // optional bytes name = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_name());
    }

    // optional bytes namespace = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_namespace_());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TypedObjectReference::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TypedObjectReference::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TypedObjectReference::GetClassData() const { return &_class_data_; }


void TypedObjectReference::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TypedObjectReference*>(&to_msg);
  auto& from = static_cast<const TypedObjectReference&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.TypedObjectReference)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_apigroup(from._internal_apigroup());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_kind(from._internal_kind());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_namespace_(from._internal_namespace_());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TypedObjectReference::CopyFrom(const TypedObjectReference& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.TypedObjectReference)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TypedObjectReference::IsInitialized() const {
  return true;
}

void TypedObjectReference::InternalSwap(TypedObjectReference* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.apigroup_, lhs_arena,
      &other->_impl_.apigroup_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.kind_, lhs_arena,
      &other->_impl_.kind_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.namespace__, lhs_arena,
      &other->_impl_.namespace__, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata TypedObjectReference::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[242]);
}

// ===================================================================

class Volume::_Internal {
 public:
  using HasBits = decltype(std::declval<Volume>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::k8s::io::api::core::v1::VolumeSource& volumesource(const Volume* msg);
  static void set_has_volumesource(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::k8s::io::api::core::v1::VolumeSource&
Volume::_Internal::volumesource(const Volume* msg) {
  return *msg->_impl_.volumesource_;
}
Volume::Volume(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.Volume)
}
Volume::Volume(const Volume& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Volume* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.volumesource_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_volumesource()) {
    _this->_impl_.volumesource_ = new ::k8s::io::api::core::v1::VolumeSource(*from._impl_.volumesource_);
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.Volume)
}

inline void Volume::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.volumesource_){nullptr}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Volume::~Volume() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.Volume)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Volume::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.volumesource_;
}

void Volume::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Volume::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.Volume)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.volumesource_ != nullptr);
      _impl_.volumesource_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Volume::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.VolumeSource volumeSource = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_volumesource(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Volume::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.Volume)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional .k8s.io.api.core.v1.VolumeSource volumeSource = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::volumesource(this),
        _Internal::volumesource(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.Volume)
  return target;
}

size_t Volume::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.Volume)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_name());
    }

    // optional .k8s.io.api.core.v1.VolumeSource volumeSource = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.volumesource_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Volume::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Volume::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Volume::GetClassData() const { return &_class_data_; }


void Volume::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Volume*>(&to_msg);
  auto& from = static_cast<const Volume&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.Volume)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_volumesource()->::k8s::io::api::core::v1::VolumeSource::MergeFrom(
          from._internal_volumesource());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Volume::CopyFrom(const Volume& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.Volume)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Volume::IsInitialized() const {
  return true;
}

void Volume::InternalSwap(Volume* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  swap(_impl_.volumesource_, other->_impl_.volumesource_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Volume::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[243]);
}

// ===================================================================

class VolumeDevice::_Internal {
 public:
  using HasBits = decltype(std::declval<VolumeDevice>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_devicepath(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

VolumeDevice::VolumeDevice(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.VolumeDevice)
}
VolumeDevice::VolumeDevice(const VolumeDevice& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  VolumeDevice* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.devicepath_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.devicepath_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.devicepath_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_devicepath()) {
    _this->_impl_.devicepath_.Set(from._internal_devicepath(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.VolumeDevice)
}

inline void VolumeDevice::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.devicepath_){}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.devicepath_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.devicepath_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

VolumeDevice::~VolumeDevice() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.VolumeDevice)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VolumeDevice::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.devicepath_.Destroy();
}

void VolumeDevice::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VolumeDevice::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.VolumeDevice)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.devicepath_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VolumeDevice::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes devicePath = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_devicepath();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VolumeDevice::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.VolumeDevice)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional bytes devicePath = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_devicepath(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.VolumeDevice)
  return target;
}

size_t VolumeDevice::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.VolumeDevice)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_name());
    }

    // optional bytes devicePath = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_devicepath());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VolumeDevice::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VolumeDevice::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VolumeDevice::GetClassData() const { return &_class_data_; }


void VolumeDevice::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VolumeDevice*>(&to_msg);
  auto& from = static_cast<const VolumeDevice&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.VolumeDevice)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_devicepath(from._internal_devicepath());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VolumeDevice::CopyFrom(const VolumeDevice& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.VolumeDevice)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VolumeDevice::IsInitialized() const {
  return true;
}

void VolumeDevice::InternalSwap(VolumeDevice* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.devicepath_, lhs_arena,
      &other->_impl_.devicepath_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata VolumeDevice::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[244]);
}

// ===================================================================

class VolumeMount::_Internal {
 public:
  using HasBits = decltype(std::declval<VolumeMount>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_readonly(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_mountpath(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_subpath(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_mountpropagation(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_subpathexpr(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

VolumeMount::VolumeMount(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.VolumeMount)
}
VolumeMount::VolumeMount(const VolumeMount& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  VolumeMount* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.mountpath_){}
    , decltype(_impl_.subpath_){}
    , decltype(_impl_.mountpropagation_){}
    , decltype(_impl_.subpathexpr_){}
    , decltype(_impl_.readonly_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.mountpath_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mountpath_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_mountpath()) {
    _this->_impl_.mountpath_.Set(from._internal_mountpath(), 
      _this->GetArenaForAllocation());
  }
  _impl_.subpath_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.subpath_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_subpath()) {
    _this->_impl_.subpath_.Set(from._internal_subpath(), 
      _this->GetArenaForAllocation());
  }
  _impl_.mountpropagation_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mountpropagation_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_mountpropagation()) {
    _this->_impl_.mountpropagation_.Set(from._internal_mountpropagation(), 
      _this->GetArenaForAllocation());
  }
  _impl_.subpathexpr_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.subpathexpr_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_subpathexpr()) {
    _this->_impl_.subpathexpr_.Set(from._internal_subpathexpr(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.readonly_ = from._impl_.readonly_;
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.VolumeMount)
}

inline void VolumeMount::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.mountpath_){}
    , decltype(_impl_.subpath_){}
    , decltype(_impl_.mountpropagation_){}
    , decltype(_impl_.subpathexpr_){}
    , decltype(_impl_.readonly_){false}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.mountpath_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mountpath_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.subpath_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.subpath_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.mountpropagation_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mountpropagation_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.subpathexpr_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.subpathexpr_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

VolumeMount::~VolumeMount() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.VolumeMount)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VolumeMount::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.mountpath_.Destroy();
  _impl_.subpath_.Destroy();
  _impl_.mountpropagation_.Destroy();
  _impl_.subpathexpr_.Destroy();
}

void VolumeMount::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VolumeMount::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.VolumeMount)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.mountpath_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.subpath_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.mountpropagation_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.subpathexpr_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.readonly_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VolumeMount::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool readOnly = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_readonly(&has_bits);
          _impl_.readonly_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes mountPath = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_mountpath();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes subPath = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_subpath();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes mountPropagation = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_mountpropagation();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes subPathExpr = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_subpathexpr();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VolumeMount::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.VolumeMount)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional bool readOnly = 2;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_readonly(), target);
  }

  // optional bytes mountPath = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_mountpath(), target);
  }

  // optional bytes subPath = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_subpath(), target);
  }

  // optional bytes mountPropagation = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_mountpropagation(), target);
  }

  // optional bytes subPathExpr = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteBytesMaybeAliased(
        6, this->_internal_subpathexpr(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.VolumeMount)
  return target;
}

size_t VolumeMount::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.VolumeMount)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional bytes name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_name());
    }

    // optional bytes mountPath = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_mountpath());
    }

    // optional bytes subPath = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_subpath());
    }

    // optional bytes mountPropagation = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_mountpropagation());
    }

    // optional bytes subPathExpr = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_subpathexpr());
    }

    // optional bool readOnly = 2;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VolumeMount::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VolumeMount::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VolumeMount::GetClassData() const { return &_class_data_; }


void VolumeMount::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VolumeMount*>(&to_msg);
  auto& from = static_cast<const VolumeMount&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.VolumeMount)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_mountpath(from._internal_mountpath());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_subpath(from._internal_subpath());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_mountpropagation(from._internal_mountpropagation());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_subpathexpr(from._internal_subpathexpr());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.readonly_ = from._impl_.readonly_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VolumeMount::CopyFrom(const VolumeMount& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.VolumeMount)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VolumeMount::IsInitialized() const {
  return true;
}

void VolumeMount::InternalSwap(VolumeMount* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.mountpath_, lhs_arena,
      &other->_impl_.mountpath_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.subpath_, lhs_arena,
      &other->_impl_.subpath_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.mountpropagation_, lhs_arena,
      &other->_impl_.mountpropagation_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.subpathexpr_, lhs_arena,
      &other->_impl_.subpathexpr_, rhs_arena
  );
  swap(_impl_.readonly_, other->_impl_.readonly_);
}

::PROTOBUF_NAMESPACE_ID::Metadata VolumeMount::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[245]);
}

// ===================================================================

class VolumeNodeAffinity::_Internal {
 public:
  using HasBits = decltype(std::declval<VolumeNodeAffinity>()._impl_._has_bits_);
  static const ::k8s::io::api::core::v1::NodeSelector& required(const VolumeNodeAffinity* msg);
  static void set_has_required(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::k8s::io::api::core::v1::NodeSelector&
VolumeNodeAffinity::_Internal::required(const VolumeNodeAffinity* msg) {
  return *msg->_impl_.required_;
}
VolumeNodeAffinity::VolumeNodeAffinity(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.VolumeNodeAffinity)
}
VolumeNodeAffinity::VolumeNodeAffinity(const VolumeNodeAffinity& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  VolumeNodeAffinity* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.required_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_required()) {
    _this->_impl_.required_ = new ::k8s::io::api::core::v1::NodeSelector(*from._impl_.required_);
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.VolumeNodeAffinity)
}

inline void VolumeNodeAffinity::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.required_){nullptr}
  };
}

VolumeNodeAffinity::~VolumeNodeAffinity() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.VolumeNodeAffinity)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VolumeNodeAffinity::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.required_;
}

void VolumeNodeAffinity::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VolumeNodeAffinity::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.VolumeNodeAffinity)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.required_ != nullptr);
    _impl_.required_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VolumeNodeAffinity::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .k8s.io.api.core.v1.NodeSelector required = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_required(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VolumeNodeAffinity::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.VolumeNodeAffinity)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .k8s.io.api.core.v1.NodeSelector required = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::required(this),
        _Internal::required(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.VolumeNodeAffinity)
  return target;
}

size_t VolumeNodeAffinity::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.VolumeNodeAffinity)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .k8s.io.api.core.v1.NodeSelector required = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.required_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VolumeNodeAffinity::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VolumeNodeAffinity::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VolumeNodeAffinity::GetClassData() const { return &_class_data_; }


void VolumeNodeAffinity::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VolumeNodeAffinity*>(&to_msg);
  auto& from = static_cast<const VolumeNodeAffinity&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.VolumeNodeAffinity)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_required()) {
    _this->_internal_mutable_required()->::k8s::io::api::core::v1::NodeSelector::MergeFrom(
        from._internal_required());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VolumeNodeAffinity::CopyFrom(const VolumeNodeAffinity& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.VolumeNodeAffinity)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VolumeNodeAffinity::IsInitialized() const {
  return true;
}

void VolumeNodeAffinity::InternalSwap(VolumeNodeAffinity* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.required_, other->_impl_.required_);
}

::PROTOBUF_NAMESPACE_ID::Metadata VolumeNodeAffinity::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[246]);
}

// ===================================================================

class VolumeProjection::_Internal {
 public:
  using HasBits = decltype(std::declval<VolumeProjection>()._impl_._has_bits_);
  static const ::k8s::io::api::core::v1::SecretProjection& secret(const VolumeProjection* msg);
  static void set_has_secret(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::k8s::io::api::core::v1::DownwardAPIProjection& downwardapi(const VolumeProjection* msg);
  static void set_has_downwardapi(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::k8s::io::api::core::v1::ConfigMapProjection& configmap(const VolumeProjection* msg);
  static void set_has_configmap(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::k8s::io::api::core::v1::ServiceAccountTokenProjection& serviceaccounttoken(const VolumeProjection* msg);
  static void set_has_serviceaccounttoken(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::k8s::io::api::core::v1::ClusterTrustBundleProjection& clustertrustbundle(const VolumeProjection* msg);
  static void set_has_clustertrustbundle(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::k8s::io::api::core::v1::SecretProjection&
VolumeProjection::_Internal::secret(const VolumeProjection* msg) {
  return *msg->_impl_.secret_;
}
const ::k8s::io::api::core::v1::DownwardAPIProjection&
VolumeProjection::_Internal::downwardapi(const VolumeProjection* msg) {
  return *msg->_impl_.downwardapi_;
}
const ::k8s::io::api::core::v1::ConfigMapProjection&
VolumeProjection::_Internal::configmap(const VolumeProjection* msg) {
  return *msg->_impl_.configmap_;
}
const ::k8s::io::api::core::v1::ServiceAccountTokenProjection&
VolumeProjection::_Internal::serviceaccounttoken(const VolumeProjection* msg) {
  return *msg->_impl_.serviceaccounttoken_;
}
const ::k8s::io::api::core::v1::ClusterTrustBundleProjection&
VolumeProjection::_Internal::clustertrustbundle(const VolumeProjection* msg) {
  return *msg->_impl_.clustertrustbundle_;
}
VolumeProjection::VolumeProjection(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.VolumeProjection)
}
VolumeProjection::VolumeProjection(const VolumeProjection& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  VolumeProjection* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.secret_){nullptr}
    , decltype(_impl_.downwardapi_){nullptr}
    , decltype(_impl_.configmap_){nullptr}
    , decltype(_impl_.serviceaccounttoken_){nullptr}
    , decltype(_impl_.clustertrustbundle_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_secret()) {
    _this->_impl_.secret_ = new ::k8s::io::api::core::v1::SecretProjection(*from._impl_.secret_);
  }
  if (from._internal_has_downwardapi()) {
    _this->_impl_.downwardapi_ = new ::k8s::io::api::core::v1::DownwardAPIProjection(*from._impl_.downwardapi_);
  }
  if (from._internal_has_configmap()) {
    _this->_impl_.configmap_ = new ::k8s::io::api::core::v1::ConfigMapProjection(*from._impl_.configmap_);
  }
  if (from._internal_has_serviceaccounttoken()) {
    _this->_impl_.serviceaccounttoken_ = new ::k8s::io::api::core::v1::ServiceAccountTokenProjection(*from._impl_.serviceaccounttoken_);
  }
  if (from._internal_has_clustertrustbundle()) {
    _this->_impl_.clustertrustbundle_ = new ::k8s::io::api::core::v1::ClusterTrustBundleProjection(*from._impl_.clustertrustbundle_);
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.VolumeProjection)
}

inline void VolumeProjection::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.secret_){nullptr}
    , decltype(_impl_.downwardapi_){nullptr}
    , decltype(_impl_.configmap_){nullptr}
    , decltype(_impl_.serviceaccounttoken_){nullptr}
    , decltype(_impl_.clustertrustbundle_){nullptr}
  };
}

VolumeProjection::~VolumeProjection() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.VolumeProjection)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VolumeProjection::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.secret_;
  if (this != internal_default_instance()) delete _impl_.downwardapi_;
  if (this != internal_default_instance()) delete _impl_.configmap_;
  if (this != internal_default_instance()) delete _impl_.serviceaccounttoken_;
  if (this != internal_default_instance()) delete _impl_.clustertrustbundle_;
}

void VolumeProjection::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VolumeProjection::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.VolumeProjection)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.secret_ != nullptr);
      _impl_.secret_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.downwardapi_ != nullptr);
      _impl_.downwardapi_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.configmap_ != nullptr);
      _impl_.configmap_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.serviceaccounttoken_ != nullptr);
      _impl_.serviceaccounttoken_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.clustertrustbundle_ != nullptr);
      _impl_.clustertrustbundle_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VolumeProjection::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .k8s.io.api.core.v1.SecretProjection secret = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_secret(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.DownwardAPIProjection downwardAPI = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_downwardapi(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.ConfigMapProjection configMap = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_configmap(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.ServiceAccountTokenProjection serviceAccountToken = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_serviceaccounttoken(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.ClusterTrustBundleProjection clusterTrustBundle = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_clustertrustbundle(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VolumeProjection::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.VolumeProjection)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .k8s.io.api.core.v1.SecretProjection secret = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::secret(this),
        _Internal::secret(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.DownwardAPIProjection downwardAPI = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::downwardapi(this),
        _Internal::downwardapi(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.ConfigMapProjection configMap = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::configmap(this),
        _Internal::configmap(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.ServiceAccountTokenProjection serviceAccountToken = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::serviceaccounttoken(this),
        _Internal::serviceaccounttoken(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.ClusterTrustBundleProjection clusterTrustBundle = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::clustertrustbundle(this),
        _Internal::clustertrustbundle(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.VolumeProjection)
  return target;
}

size_t VolumeProjection::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.VolumeProjection)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .k8s.io.api.core.v1.SecretProjection secret = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.secret_);
    }

    // optional .k8s.io.api.core.v1.DownwardAPIProjection downwardAPI = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.downwardapi_);
    }

    // optional .k8s.io.api.core.v1.ConfigMapProjection configMap = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.configmap_);
    }

    // optional .k8s.io.api.core.v1.ServiceAccountTokenProjection serviceAccountToken = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.serviceaccounttoken_);
    }

    // optional .k8s.io.api.core.v1.ClusterTrustBundleProjection clusterTrustBundle = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.clustertrustbundle_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VolumeProjection::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VolumeProjection::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VolumeProjection::GetClassData() const { return &_class_data_; }


void VolumeProjection::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VolumeProjection*>(&to_msg);
  auto& from = static_cast<const VolumeProjection&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.VolumeProjection)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_secret()->::k8s::io::api::core::v1::SecretProjection::MergeFrom(
          from._internal_secret());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_downwardapi()->::k8s::io::api::core::v1::DownwardAPIProjection::MergeFrom(
          from._internal_downwardapi());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_configmap()->::k8s::io::api::core::v1::ConfigMapProjection::MergeFrom(
          from._internal_configmap());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_serviceaccounttoken()->::k8s::io::api::core::v1::ServiceAccountTokenProjection::MergeFrom(
          from._internal_serviceaccounttoken());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_clustertrustbundle()->::k8s::io::api::core::v1::ClusterTrustBundleProjection::MergeFrom(
          from._internal_clustertrustbundle());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VolumeProjection::CopyFrom(const VolumeProjection& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.VolumeProjection)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VolumeProjection::IsInitialized() const {
  return true;
}

void VolumeProjection::InternalSwap(VolumeProjection* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VolumeProjection, _impl_.clustertrustbundle_)
      + sizeof(VolumeProjection::_impl_.clustertrustbundle_)
      - PROTOBUF_FIELD_OFFSET(VolumeProjection, _impl_.secret_)>(
          reinterpret_cast<char*>(&_impl_.secret_),
          reinterpret_cast<char*>(&other->_impl_.secret_));
}

::PROTOBUF_NAMESPACE_ID::Metadata VolumeProjection::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[247]);
}

// ===================================================================

VolumeResourceRequirements_LimitsEntry_DoNotUse::VolumeResourceRequirements_LimitsEntry_DoNotUse() {}
VolumeResourceRequirements_LimitsEntry_DoNotUse::VolumeResourceRequirements_LimitsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void VolumeResourceRequirements_LimitsEntry_DoNotUse::MergeFrom(const VolumeResourceRequirements_LimitsEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata VolumeResourceRequirements_LimitsEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[248]);
}

// ===================================================================

VolumeResourceRequirements_RequestsEntry_DoNotUse::VolumeResourceRequirements_RequestsEntry_DoNotUse() {}
VolumeResourceRequirements_RequestsEntry_DoNotUse::VolumeResourceRequirements_RequestsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void VolumeResourceRequirements_RequestsEntry_DoNotUse::MergeFrom(const VolumeResourceRequirements_RequestsEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata VolumeResourceRequirements_RequestsEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[249]);
}

// ===================================================================

class VolumeResourceRequirements::_Internal {
 public:
};

void VolumeResourceRequirements::clear_limits() {
  _impl_.limits_.Clear();
}
void VolumeResourceRequirements::clear_requests() {
  _impl_.requests_.Clear();
}
VolumeResourceRequirements::VolumeResourceRequirements(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &VolumeResourceRequirements::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.VolumeResourceRequirements)
}
VolumeResourceRequirements::VolumeResourceRequirements(const VolumeResourceRequirements& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  VolumeResourceRequirements* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_.limits_)*/{}
    , /*decltype(_impl_.requests_)*/{}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.limits_.MergeFrom(from._impl_.limits_);
  _this->_impl_.requests_.MergeFrom(from._impl_.requests_);
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.VolumeResourceRequirements)
}

inline void VolumeResourceRequirements::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_.limits_)*/{::_pbi::ArenaInitialized(), arena}
    , /*decltype(_impl_.requests_)*/{::_pbi::ArenaInitialized(), arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

VolumeResourceRequirements::~VolumeResourceRequirements() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.VolumeResourceRequirements)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void VolumeResourceRequirements::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.limits_.Destruct();
  _impl_.limits_.~MapField();
  _impl_.requests_.Destruct();
  _impl_.requests_.~MapField();
}

void VolumeResourceRequirements::ArenaDtor(void* object) {
  VolumeResourceRequirements* _this = reinterpret_cast< VolumeResourceRequirements* >(object);
  _this->_impl_.limits_.Destruct();
  _this->_impl_.requests_.Destruct();
}
void VolumeResourceRequirements::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VolumeResourceRequirements::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.VolumeResourceRequirements)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.limits_.Clear();
  _impl_.requests_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VolumeResourceRequirements::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // map<string, .k8s.io.apimachinery.pkg.api.resource.Quantity> limits = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.limits_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // map<string, .k8s.io.apimachinery.pkg.api.resource.Quantity> requests = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.requests_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VolumeResourceRequirements::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.VolumeResourceRequirements)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // map<string, .k8s.io.apimachinery.pkg.api.resource.Quantity> limits = 1;
  if (!this->_internal_limits().empty()) {
    using MapType = ::_pb::Map<std::string, ::k8s::io::apimachinery::pkg::api::resource::Quantity>;
    using WireHelper = VolumeResourceRequirements_LimitsEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_limits();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "k8s.io.api.core.v1.VolumeResourceRequirements.LimitsEntry.key");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(1, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(1, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  // map<string, .k8s.io.apimachinery.pkg.api.resource.Quantity> requests = 2;
  if (!this->_internal_requests().empty()) {
    using MapType = ::_pb::Map<std::string, ::k8s::io::apimachinery::pkg::api::resource::Quantity>;
    using WireHelper = VolumeResourceRequirements_RequestsEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_requests();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "k8s.io.api.core.v1.VolumeResourceRequirements.RequestsEntry.key");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(2, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(2, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.VolumeResourceRequirements)
  return target;
}

size_t VolumeResourceRequirements::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.VolumeResourceRequirements)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, .k8s.io.apimachinery.pkg.api.resource.Quantity> limits = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_limits_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::k8s::io::apimachinery::pkg::api::resource::Quantity >::const_iterator
      it = this->_internal_limits().begin();
      it != this->_internal_limits().end(); ++it) {
    total_size += VolumeResourceRequirements_LimitsEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // map<string, .k8s.io.apimachinery.pkg.api.resource.Quantity> requests = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_requests_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::k8s::io::apimachinery::pkg::api::resource::Quantity >::const_iterator
      it = this->_internal_requests().begin();
      it != this->_internal_requests().end(); ++it) {
    total_size += VolumeResourceRequirements_RequestsEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VolumeResourceRequirements::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VolumeResourceRequirements::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VolumeResourceRequirements::GetClassData() const { return &_class_data_; }


void VolumeResourceRequirements::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VolumeResourceRequirements*>(&to_msg);
  auto& from = static_cast<const VolumeResourceRequirements&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.VolumeResourceRequirements)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.limits_.MergeFrom(from._impl_.limits_);
  _this->_impl_.requests_.MergeFrom(from._impl_.requests_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VolumeResourceRequirements::CopyFrom(const VolumeResourceRequirements& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.VolumeResourceRequirements)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VolumeResourceRequirements::IsInitialized() const {
  return true;
}

void VolumeResourceRequirements::InternalSwap(VolumeResourceRequirements* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.limits_.InternalSwap(&other->_impl_.limits_);
  _impl_.requests_.InternalSwap(&other->_impl_.requests_);
}

::PROTOBUF_NAMESPACE_ID::Metadata VolumeResourceRequirements::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[250]);
}

// ===================================================================

class VolumeSource::_Internal {
 public:
  using HasBits = decltype(std::declval<VolumeSource>()._impl_._has_bits_);
  static const ::k8s::io::api::core::v1::HostPathVolumeSource& hostpath(const VolumeSource* msg);
  static void set_has_hostpath(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::k8s::io::api::core::v1::EmptyDirVolumeSource& emptydir(const VolumeSource* msg);
  static void set_has_emptydir(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::k8s::io::api::core::v1::GCEPersistentDiskVolumeSource& gcepersistentdisk(const VolumeSource* msg);
  static void set_has_gcepersistentdisk(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::k8s::io::api::core::v1::AWSElasticBlockStoreVolumeSource& awselasticblockstore(const VolumeSource* msg);
  static void set_has_awselasticblockstore(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::k8s::io::api::core::v1::GitRepoVolumeSource& gitrepo(const VolumeSource* msg);
  static void set_has_gitrepo(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::k8s::io::api::core::v1::SecretVolumeSource& secret(const VolumeSource* msg);
  static void set_has_secret(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::k8s::io::api::core::v1::NFSVolumeSource& nfs(const VolumeSource* msg);
  static void set_has_nfs(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::k8s::io::api::core::v1::ISCSIVolumeSource& iscsi(const VolumeSource* msg);
  static void set_has_iscsi(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::k8s::io::api::core::v1::GlusterfsVolumeSource& glusterfs(const VolumeSource* msg);
  static void set_has_glusterfs(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static const ::k8s::io::api::core::v1::PersistentVolumeClaimVolumeSource& persistentvolumeclaim(const VolumeSource* msg);
  static void set_has_persistentvolumeclaim(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static const ::k8s::io::api::core::v1::RBDVolumeSource& rbd(const VolumeSource* msg);
  static void set_has_rbd(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static const ::k8s::io::api::core::v1::FlexVolumeSource& flexvolume(const VolumeSource* msg);
  static void set_has_flexvolume(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static const ::k8s::io::api::core::v1::CinderVolumeSource& cinder(const VolumeSource* msg);
  static void set_has_cinder(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static const ::k8s::io::api::core::v1::CephFSVolumeSource& cephfs(const VolumeSource* msg);
  static void set_has_cephfs(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static const ::k8s::io::api::core::v1::FlockerVolumeSource& flocker(const VolumeSource* msg);
  static void set_has_flocker(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static const ::k8s::io::api::core::v1::DownwardAPIVolumeSource& downwardapi(const VolumeSource* msg);
  static void set_has_downwardapi(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static const ::k8s::io::api::core::v1::FCVolumeSource& fc(const VolumeSource* msg);
  static void set_has_fc(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static const ::k8s::io::api::core::v1::AzureFileVolumeSource& azurefile(const VolumeSource* msg);
  static void set_has_azurefile(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static const ::k8s::io::api::core::v1::ConfigMapVolumeSource& configmap(const VolumeSource* msg);
  static void set_has_configmap(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static const ::k8s::io::api::core::v1::VsphereVirtualDiskVolumeSource& vspherevolume(const VolumeSource* msg);
  static void set_has_vspherevolume(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static const ::k8s::io::api::core::v1::QuobyteVolumeSource& quobyte(const VolumeSource* msg);
  static void set_has_quobyte(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static const ::k8s::io::api::core::v1::AzureDiskVolumeSource& azuredisk(const VolumeSource* msg);
  static void set_has_azuredisk(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static const ::k8s::io::api::core::v1::PhotonPersistentDiskVolumeSource& photonpersistentdisk(const VolumeSource* msg);
  static void set_has_photonpersistentdisk(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static const ::k8s::io::api::core::v1::ProjectedVolumeSource& projected(const VolumeSource* msg);
  static void set_has_projected(HasBits* has_bits) {
    (*has_bits)[0] |= 33554432u;
  }
  static const ::k8s::io::api::core::v1::PortworxVolumeSource& portworxvolume(const VolumeSource* msg);
  static void set_has_portworxvolume(HasBits* has_bits) {
    (*has_bits)[0] |= 8388608u;
  }
  static const ::k8s::io::api::core::v1::ScaleIOVolumeSource& scaleio(const VolumeSource* msg);
  static void set_has_scaleio(HasBits* has_bits) {
    (*has_bits)[0] |= 16777216u;
  }
  static const ::k8s::io::api::core::v1::StorageOSVolumeSource& storageos(const VolumeSource* msg);
  static void set_has_storageos(HasBits* has_bits) {
    (*has_bits)[0] |= 67108864u;
  }
  static const ::k8s::io::api::core::v1::CSIVolumeSource& csi(const VolumeSource* msg);
  static void set_has_csi(HasBits* has_bits) {
    (*has_bits)[0] |= 134217728u;
  }
  static const ::k8s::io::api::core::v1::EphemeralVolumeSource& ephemeral(const VolumeSource* msg);
  static void set_has_ephemeral(HasBits* has_bits) {
    (*has_bits)[0] |= 268435456u;
  }
};

const ::k8s::io::api::core::v1::HostPathVolumeSource&
VolumeSource::_Internal::hostpath(const VolumeSource* msg) {
  return *msg->_impl_.hostpath_;
}
const ::k8s::io::api::core::v1::EmptyDirVolumeSource&
VolumeSource::_Internal::emptydir(const VolumeSource* msg) {
  return *msg->_impl_.emptydir_;
}
const ::k8s::io::api::core::v1::GCEPersistentDiskVolumeSource&
VolumeSource::_Internal::gcepersistentdisk(const VolumeSource* msg) {
  return *msg->_impl_.gcepersistentdisk_;
}
const ::k8s::io::api::core::v1::AWSElasticBlockStoreVolumeSource&
VolumeSource::_Internal::awselasticblockstore(const VolumeSource* msg) {
  return *msg->_impl_.awselasticblockstore_;
}
const ::k8s::io::api::core::v1::GitRepoVolumeSource&
VolumeSource::_Internal::gitrepo(const VolumeSource* msg) {
  return *msg->_impl_.gitrepo_;
}
const ::k8s::io::api::core::v1::SecretVolumeSource&
VolumeSource::_Internal::secret(const VolumeSource* msg) {
  return *msg->_impl_.secret_;
}
const ::k8s::io::api::core::v1::NFSVolumeSource&
VolumeSource::_Internal::nfs(const VolumeSource* msg) {
  return *msg->_impl_.nfs_;
}
const ::k8s::io::api::core::v1::ISCSIVolumeSource&
VolumeSource::_Internal::iscsi(const VolumeSource* msg) {
  return *msg->_impl_.iscsi_;
}
const ::k8s::io::api::core::v1::GlusterfsVolumeSource&
VolumeSource::_Internal::glusterfs(const VolumeSource* msg) {
  return *msg->_impl_.glusterfs_;
}
const ::k8s::io::api::core::v1::PersistentVolumeClaimVolumeSource&
VolumeSource::_Internal::persistentvolumeclaim(const VolumeSource* msg) {
  return *msg->_impl_.persistentvolumeclaim_;
}
const ::k8s::io::api::core::v1::RBDVolumeSource&
VolumeSource::_Internal::rbd(const VolumeSource* msg) {
  return *msg->_impl_.rbd_;
}
const ::k8s::io::api::core::v1::FlexVolumeSource&
VolumeSource::_Internal::flexvolume(const VolumeSource* msg) {
  return *msg->_impl_.flexvolume_;
}
const ::k8s::io::api::core::v1::CinderVolumeSource&
VolumeSource::_Internal::cinder(const VolumeSource* msg) {
  return *msg->_impl_.cinder_;
}
const ::k8s::io::api::core::v1::CephFSVolumeSource&
VolumeSource::_Internal::cephfs(const VolumeSource* msg) {
  return *msg->_impl_.cephfs_;
}
const ::k8s::io::api::core::v1::FlockerVolumeSource&
VolumeSource::_Internal::flocker(const VolumeSource* msg) {
  return *msg->_impl_.flocker_;
}
const ::k8s::io::api::core::v1::DownwardAPIVolumeSource&
VolumeSource::_Internal::downwardapi(const VolumeSource* msg) {
  return *msg->_impl_.downwardapi_;
}
const ::k8s::io::api::core::v1::FCVolumeSource&
VolumeSource::_Internal::fc(const VolumeSource* msg) {
  return *msg->_impl_.fc_;
}
const ::k8s::io::api::core::v1::AzureFileVolumeSource&
VolumeSource::_Internal::azurefile(const VolumeSource* msg) {
  return *msg->_impl_.azurefile_;
}
const ::k8s::io::api::core::v1::ConfigMapVolumeSource&
VolumeSource::_Internal::configmap(const VolumeSource* msg) {
  return *msg->_impl_.configmap_;
}
const ::k8s::io::api::core::v1::VsphereVirtualDiskVolumeSource&
VolumeSource::_Internal::vspherevolume(const VolumeSource* msg) {
  return *msg->_impl_.vspherevolume_;
}
const ::k8s::io::api::core::v1::QuobyteVolumeSource&
VolumeSource::_Internal::quobyte(const VolumeSource* msg) {
  return *msg->_impl_.quobyte_;
}
const ::k8s::io::api::core::v1::AzureDiskVolumeSource&
VolumeSource::_Internal::azuredisk(const VolumeSource* msg) {
  return *msg->_impl_.azuredisk_;
}
const ::k8s::io::api::core::v1::PhotonPersistentDiskVolumeSource&
VolumeSource::_Internal::photonpersistentdisk(const VolumeSource* msg) {
  return *msg->_impl_.photonpersistentdisk_;
}
const ::k8s::io::api::core::v1::ProjectedVolumeSource&
VolumeSource::_Internal::projected(const VolumeSource* msg) {
  return *msg->_impl_.projected_;
}
const ::k8s::io::api::core::v1::PortworxVolumeSource&
VolumeSource::_Internal::portworxvolume(const VolumeSource* msg) {
  return *msg->_impl_.portworxvolume_;
}
const ::k8s::io::api::core::v1::ScaleIOVolumeSource&
VolumeSource::_Internal::scaleio(const VolumeSource* msg) {
  return *msg->_impl_.scaleio_;
}
const ::k8s::io::api::core::v1::StorageOSVolumeSource&
VolumeSource::_Internal::storageos(const VolumeSource* msg) {
  return *msg->_impl_.storageos_;
}
const ::k8s::io::api::core::v1::CSIVolumeSource&
VolumeSource::_Internal::csi(const VolumeSource* msg) {
  return *msg->_impl_.csi_;
}
const ::k8s::io::api::core::v1::EphemeralVolumeSource&
VolumeSource::_Internal::ephemeral(const VolumeSource* msg) {
  return *msg->_impl_.ephemeral_;
}
VolumeSource::VolumeSource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.VolumeSource)
}
VolumeSource::VolumeSource(const VolumeSource& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  VolumeSource* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.hostpath_){nullptr}
    , decltype(_impl_.emptydir_){nullptr}
    , decltype(_impl_.gcepersistentdisk_){nullptr}
    , decltype(_impl_.awselasticblockstore_){nullptr}
    , decltype(_impl_.gitrepo_){nullptr}
    , decltype(_impl_.secret_){nullptr}
    , decltype(_impl_.nfs_){nullptr}
    , decltype(_impl_.iscsi_){nullptr}
    , decltype(_impl_.glusterfs_){nullptr}
    , decltype(_impl_.persistentvolumeclaim_){nullptr}
    , decltype(_impl_.rbd_){nullptr}
    , decltype(_impl_.flexvolume_){nullptr}
    , decltype(_impl_.cinder_){nullptr}
    , decltype(_impl_.cephfs_){nullptr}
    , decltype(_impl_.flocker_){nullptr}
    , decltype(_impl_.downwardapi_){nullptr}
    , decltype(_impl_.fc_){nullptr}
    , decltype(_impl_.azurefile_){nullptr}
    , decltype(_impl_.configmap_){nullptr}
    , decltype(_impl_.vspherevolume_){nullptr}
    , decltype(_impl_.quobyte_){nullptr}
    , decltype(_impl_.azuredisk_){nullptr}
    , decltype(_impl_.photonpersistentdisk_){nullptr}
    , decltype(_impl_.portworxvolume_){nullptr}
    , decltype(_impl_.scaleio_){nullptr}
    , decltype(_impl_.projected_){nullptr}
    , decltype(_impl_.storageos_){nullptr}
    , decltype(_impl_.csi_){nullptr}
    , decltype(_impl_.ephemeral_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_hostpath()) {
    _this->_impl_.hostpath_ = new ::k8s::io::api::core::v1::HostPathVolumeSource(*from._impl_.hostpath_);
  }
  if (from._internal_has_emptydir()) {
    _this->_impl_.emptydir_ = new ::k8s::io::api::core::v1::EmptyDirVolumeSource(*from._impl_.emptydir_);
  }
  if (from._internal_has_gcepersistentdisk()) {
    _this->_impl_.gcepersistentdisk_ = new ::k8s::io::api::core::v1::GCEPersistentDiskVolumeSource(*from._impl_.gcepersistentdisk_);
  }
  if (from._internal_has_awselasticblockstore()) {
    _this->_impl_.awselasticblockstore_ = new ::k8s::io::api::core::v1::AWSElasticBlockStoreVolumeSource(*from._impl_.awselasticblockstore_);
  }
  if (from._internal_has_gitrepo()) {
    _this->_impl_.gitrepo_ = new ::k8s::io::api::core::v1::GitRepoVolumeSource(*from._impl_.gitrepo_);
  }
  if (from._internal_has_secret()) {
    _this->_impl_.secret_ = new ::k8s::io::api::core::v1::SecretVolumeSource(*from._impl_.secret_);
  }
  if (from._internal_has_nfs()) {
    _this->_impl_.nfs_ = new ::k8s::io::api::core::v1::NFSVolumeSource(*from._impl_.nfs_);
  }
  if (from._internal_has_iscsi()) {
    _this->_impl_.iscsi_ = new ::k8s::io::api::core::v1::ISCSIVolumeSource(*from._impl_.iscsi_);
  }
  if (from._internal_has_glusterfs()) {
    _this->_impl_.glusterfs_ = new ::k8s::io::api::core::v1::GlusterfsVolumeSource(*from._impl_.glusterfs_);
  }
  if (from._internal_has_persistentvolumeclaim()) {
    _this->_impl_.persistentvolumeclaim_ = new ::k8s::io::api::core::v1::PersistentVolumeClaimVolumeSource(*from._impl_.persistentvolumeclaim_);
  }
  if (from._internal_has_rbd()) {
    _this->_impl_.rbd_ = new ::k8s::io::api::core::v1::RBDVolumeSource(*from._impl_.rbd_);
  }
  if (from._internal_has_flexvolume()) {
    _this->_impl_.flexvolume_ = new ::k8s::io::api::core::v1::FlexVolumeSource(*from._impl_.flexvolume_);
  }
  if (from._internal_has_cinder()) {
    _this->_impl_.cinder_ = new ::k8s::io::api::core::v1::CinderVolumeSource(*from._impl_.cinder_);
  }
  if (from._internal_has_cephfs()) {
    _this->_impl_.cephfs_ = new ::k8s::io::api::core::v1::CephFSVolumeSource(*from._impl_.cephfs_);
  }
  if (from._internal_has_flocker()) {
    _this->_impl_.flocker_ = new ::k8s::io::api::core::v1::FlockerVolumeSource(*from._impl_.flocker_);
  }
  if (from._internal_has_downwardapi()) {
    _this->_impl_.downwardapi_ = new ::k8s::io::api::core::v1::DownwardAPIVolumeSource(*from._impl_.downwardapi_);
  }
  if (from._internal_has_fc()) {
    _this->_impl_.fc_ = new ::k8s::io::api::core::v1::FCVolumeSource(*from._impl_.fc_);
  }
  if (from._internal_has_azurefile()) {
    _this->_impl_.azurefile_ = new ::k8s::io::api::core::v1::AzureFileVolumeSource(*from._impl_.azurefile_);
  }
  if (from._internal_has_configmap()) {
    _this->_impl_.configmap_ = new ::k8s::io::api::core::v1::ConfigMapVolumeSource(*from._impl_.configmap_);
  }
  if (from._internal_has_vspherevolume()) {
    _this->_impl_.vspherevolume_ = new ::k8s::io::api::core::v1::VsphereVirtualDiskVolumeSource(*from._impl_.vspherevolume_);
  }
  if (from._internal_has_quobyte()) {
    _this->_impl_.quobyte_ = new ::k8s::io::api::core::v1::QuobyteVolumeSource(*from._impl_.quobyte_);
  }
  if (from._internal_has_azuredisk()) {
    _this->_impl_.azuredisk_ = new ::k8s::io::api::core::v1::AzureDiskVolumeSource(*from._impl_.azuredisk_);
  }
  if (from._internal_has_photonpersistentdisk()) {
    _this->_impl_.photonpersistentdisk_ = new ::k8s::io::api::core::v1::PhotonPersistentDiskVolumeSource(*from._impl_.photonpersistentdisk_);
  }
  if (from._internal_has_portworxvolume()) {
    _this->_impl_.portworxvolume_ = new ::k8s::io::api::core::v1::PortworxVolumeSource(*from._impl_.portworxvolume_);
  }
  if (from._internal_has_scaleio()) {
    _this->_impl_.scaleio_ = new ::k8s::io::api::core::v1::ScaleIOVolumeSource(*from._impl_.scaleio_);
  }
  if (from._internal_has_projected()) {
    _this->_impl_.projected_ = new ::k8s::io::api::core::v1::ProjectedVolumeSource(*from._impl_.projected_);
  }
  if (from._internal_has_storageos()) {
    _this->_impl_.storageos_ = new ::k8s::io::api::core::v1::StorageOSVolumeSource(*from._impl_.storageos_);
  }
  if (from._internal_has_csi()) {
    _this->_impl_.csi_ = new ::k8s::io::api::core::v1::CSIVolumeSource(*from._impl_.csi_);
  }
  if (from._internal_has_ephemeral()) {
    _this->_impl_.ephemeral_ = new ::k8s::io::api::core::v1::EphemeralVolumeSource(*from._impl_.ephemeral_);
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.VolumeSource)
}

inline void VolumeSource::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.hostpath_){nullptr}
    , decltype(_impl_.emptydir_){nullptr}
    , decltype(_impl_.gcepersistentdisk_){nullptr}
    , decltype(_impl_.awselasticblockstore_){nullptr}
    , decltype(_impl_.gitrepo_){nullptr}
    , decltype(_impl_.secret_){nullptr}
    , decltype(_impl_.nfs_){nullptr}
    , decltype(_impl_.iscsi_){nullptr}
    , decltype(_impl_.glusterfs_){nullptr}
    , decltype(_impl_.persistentvolumeclaim_){nullptr}
    , decltype(_impl_.rbd_){nullptr}
    , decltype(_impl_.flexvolume_){nullptr}
    , decltype(_impl_.cinder_){nullptr}
    , decltype(_impl_.cephfs_){nullptr}
    , decltype(_impl_.flocker_){nullptr}
    , decltype(_impl_.downwardapi_){nullptr}
    , decltype(_impl_.fc_){nullptr}
    , decltype(_impl_.azurefile_){nullptr}
    , decltype(_impl_.configmap_){nullptr}
    , decltype(_impl_.vspherevolume_){nullptr}
    , decltype(_impl_.quobyte_){nullptr}
    , decltype(_impl_.azuredisk_){nullptr}
    , decltype(_impl_.photonpersistentdisk_){nullptr}
    , decltype(_impl_.portworxvolume_){nullptr}
    , decltype(_impl_.scaleio_){nullptr}
    , decltype(_impl_.projected_){nullptr}
    , decltype(_impl_.storageos_){nullptr}
    , decltype(_impl_.csi_){nullptr}
    , decltype(_impl_.ephemeral_){nullptr}
  };
}

VolumeSource::~VolumeSource() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.VolumeSource)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VolumeSource::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.hostpath_;
  if (this != internal_default_instance()) delete _impl_.emptydir_;
  if (this != internal_default_instance()) delete _impl_.gcepersistentdisk_;
  if (this != internal_default_instance()) delete _impl_.awselasticblockstore_;
  if (this != internal_default_instance()) delete _impl_.gitrepo_;
  if (this != internal_default_instance()) delete _impl_.secret_;
  if (this != internal_default_instance()) delete _impl_.nfs_;
  if (this != internal_default_instance()) delete _impl_.iscsi_;
  if (this != internal_default_instance()) delete _impl_.glusterfs_;
  if (this != internal_default_instance()) delete _impl_.persistentvolumeclaim_;
  if (this != internal_default_instance()) delete _impl_.rbd_;
  if (this != internal_default_instance()) delete _impl_.flexvolume_;
  if (this != internal_default_instance()) delete _impl_.cinder_;
  if (this != internal_default_instance()) delete _impl_.cephfs_;
  if (this != internal_default_instance()) delete _impl_.flocker_;
  if (this != internal_default_instance()) delete _impl_.downwardapi_;
  if (this != internal_default_instance()) delete _impl_.fc_;
  if (this != internal_default_instance()) delete _impl_.azurefile_;
  if (this != internal_default_instance()) delete _impl_.configmap_;
  if (this != internal_default_instance()) delete _impl_.vspherevolume_;
  if (this != internal_default_instance()) delete _impl_.quobyte_;
  if (this != internal_default_instance()) delete _impl_.azuredisk_;
  if (this != internal_default_instance()) delete _impl_.photonpersistentdisk_;
  if (this != internal_default_instance()) delete _impl_.portworxvolume_;
  if (this != internal_default_instance()) delete _impl_.scaleio_;
  if (this != internal_default_instance()) delete _impl_.projected_;
  if (this != internal_default_instance()) delete _impl_.storageos_;
  if (this != internal_default_instance()) delete _impl_.csi_;
  if (this != internal_default_instance()) delete _impl_.ephemeral_;
}

void VolumeSource::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VolumeSource::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.VolumeSource)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.hostpath_ != nullptr);
      _impl_.hostpath_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.emptydir_ != nullptr);
      _impl_.emptydir_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.gcepersistentdisk_ != nullptr);
      _impl_.gcepersistentdisk_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.awselasticblockstore_ != nullptr);
      _impl_.awselasticblockstore_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.gitrepo_ != nullptr);
      _impl_.gitrepo_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.secret_ != nullptr);
      _impl_.secret_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(_impl_.nfs_ != nullptr);
      _impl_.nfs_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(_impl_.iscsi_ != nullptr);
      _impl_.iscsi_->Clear();
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      GOOGLE_DCHECK(_impl_.glusterfs_ != nullptr);
      _impl_.glusterfs_->Clear();
    }
    if (cached_has_bits & 0x00000200u) {
      GOOGLE_DCHECK(_impl_.persistentvolumeclaim_ != nullptr);
      _impl_.persistentvolumeclaim_->Clear();
    }
    if (cached_has_bits & 0x00000400u) {
      GOOGLE_DCHECK(_impl_.rbd_ != nullptr);
      _impl_.rbd_->Clear();
    }
    if (cached_has_bits & 0x00000800u) {
      GOOGLE_DCHECK(_impl_.flexvolume_ != nullptr);
      _impl_.flexvolume_->Clear();
    }
    if (cached_has_bits & 0x00001000u) {
      GOOGLE_DCHECK(_impl_.cinder_ != nullptr);
      _impl_.cinder_->Clear();
    }
    if (cached_has_bits & 0x00002000u) {
      GOOGLE_DCHECK(_impl_.cephfs_ != nullptr);
      _impl_.cephfs_->Clear();
    }
    if (cached_has_bits & 0x00004000u) {
      GOOGLE_DCHECK(_impl_.flocker_ != nullptr);
      _impl_.flocker_->Clear();
    }
    if (cached_has_bits & 0x00008000u) {
      GOOGLE_DCHECK(_impl_.downwardapi_ != nullptr);
      _impl_.downwardapi_->Clear();
    }
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      GOOGLE_DCHECK(_impl_.fc_ != nullptr);
      _impl_.fc_->Clear();
    }
    if (cached_has_bits & 0x00020000u) {
      GOOGLE_DCHECK(_impl_.azurefile_ != nullptr);
      _impl_.azurefile_->Clear();
    }
    if (cached_has_bits & 0x00040000u) {
      GOOGLE_DCHECK(_impl_.configmap_ != nullptr);
      _impl_.configmap_->Clear();
    }
    if (cached_has_bits & 0x00080000u) {
      GOOGLE_DCHECK(_impl_.vspherevolume_ != nullptr);
      _impl_.vspherevolume_->Clear();
    }
    if (cached_has_bits & 0x00100000u) {
      GOOGLE_DCHECK(_impl_.quobyte_ != nullptr);
      _impl_.quobyte_->Clear();
    }
    if (cached_has_bits & 0x00200000u) {
      GOOGLE_DCHECK(_impl_.azuredisk_ != nullptr);
      _impl_.azuredisk_->Clear();
    }
    if (cached_has_bits & 0x00400000u) {
      GOOGLE_DCHECK(_impl_.photonpersistentdisk_ != nullptr);
      _impl_.photonpersistentdisk_->Clear();
    }
    if (cached_has_bits & 0x00800000u) {
      GOOGLE_DCHECK(_impl_.portworxvolume_ != nullptr);
      _impl_.portworxvolume_->Clear();
    }
  }
  if (cached_has_bits & 0x1f000000u) {
    if (cached_has_bits & 0x01000000u) {
      GOOGLE_DCHECK(_impl_.scaleio_ != nullptr);
      _impl_.scaleio_->Clear();
    }
    if (cached_has_bits & 0x02000000u) {
      GOOGLE_DCHECK(_impl_.projected_ != nullptr);
      _impl_.projected_->Clear();
    }
    if (cached_has_bits & 0x04000000u) {
      GOOGLE_DCHECK(_impl_.storageos_ != nullptr);
      _impl_.storageos_->Clear();
    }
    if (cached_has_bits & 0x08000000u) {
      GOOGLE_DCHECK(_impl_.csi_ != nullptr);
      _impl_.csi_->Clear();
    }
    if (cached_has_bits & 0x10000000u) {
      GOOGLE_DCHECK(_impl_.ephemeral_ != nullptr);
      _impl_.ephemeral_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VolumeSource::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .k8s.io.api.core.v1.HostPathVolumeSource hostPath = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_hostpath(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.EmptyDirVolumeSource emptyDir = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_emptydir(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.GCEPersistentDiskVolumeSource gcePersistentDisk = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_gcepersistentdisk(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.AWSElasticBlockStoreVolumeSource awsElasticBlockStore = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_awselasticblockstore(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.GitRepoVolumeSource gitRepo = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_gitrepo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.SecretVolumeSource secret = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_secret(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.NFSVolumeSource nfs = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_nfs(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.ISCSIVolumeSource iscsi = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_iscsi(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.GlusterfsVolumeSource glusterfs = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_glusterfs(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.PersistentVolumeClaimVolumeSource persistentVolumeClaim = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_persistentvolumeclaim(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.RBDVolumeSource rbd = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_rbd(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.FlexVolumeSource flexVolume = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_flexvolume(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.CinderVolumeSource cinder = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_cinder(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.CephFSVolumeSource cephfs = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_cephfs(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.FlockerVolumeSource flocker = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_flocker(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.DownwardAPIVolumeSource downwardAPI = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_downwardapi(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.FCVolumeSource fc = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          ptr = ctx->ParseMessage(_internal_mutable_fc(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.AzureFileVolumeSource azureFile = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          ptr = ctx->ParseMessage(_internal_mutable_azurefile(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.ConfigMapVolumeSource configMap = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          ptr = ctx->ParseMessage(_internal_mutable_configmap(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.VsphereVirtualDiskVolumeSource vsphereVolume = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_vspherevolume(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.QuobyteVolumeSource quobyte = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          ptr = ctx->ParseMessage(_internal_mutable_quobyte(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.AzureDiskVolumeSource azureDisk = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 178)) {
          ptr = ctx->ParseMessage(_internal_mutable_azuredisk(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.PhotonPersistentDiskVolumeSource photonPersistentDisk = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 186)) {
          ptr = ctx->ParseMessage(_internal_mutable_photonpersistentdisk(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.PortworxVolumeSource portworxVolume = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 194)) {
          ptr = ctx->ParseMessage(_internal_mutable_portworxvolume(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.ScaleIOVolumeSource scaleIO = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 202)) {
          ptr = ctx->ParseMessage(_internal_mutable_scaleio(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.ProjectedVolumeSource projected = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 210)) {
          ptr = ctx->ParseMessage(_internal_mutable_projected(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.StorageOSVolumeSource storageos = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 218)) {
          ptr = ctx->ParseMessage(_internal_mutable_storageos(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.CSIVolumeSource csi = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 226)) {
          ptr = ctx->ParseMessage(_internal_mutable_csi(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.EphemeralVolumeSource ephemeral = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 234)) {
          ptr = ctx->ParseMessage(_internal_mutable_ephemeral(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VolumeSource::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.VolumeSource)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .k8s.io.api.core.v1.HostPathVolumeSource hostPath = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::hostpath(this),
        _Internal::hostpath(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.EmptyDirVolumeSource emptyDir = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::emptydir(this),
        _Internal::emptydir(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.GCEPersistentDiskVolumeSource gcePersistentDisk = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::gcepersistentdisk(this),
        _Internal::gcepersistentdisk(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.AWSElasticBlockStoreVolumeSource awsElasticBlockStore = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::awselasticblockstore(this),
        _Internal::awselasticblockstore(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.GitRepoVolumeSource gitRepo = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::gitrepo(this),
        _Internal::gitrepo(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.SecretVolumeSource secret = 6;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::secret(this),
        _Internal::secret(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.NFSVolumeSource nfs = 7;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::nfs(this),
        _Internal::nfs(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.ISCSIVolumeSource iscsi = 8;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::iscsi(this),
        _Internal::iscsi(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.GlusterfsVolumeSource glusterfs = 9;
  if (cached_has_bits & 0x00000100u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::glusterfs(this),
        _Internal::glusterfs(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.PersistentVolumeClaimVolumeSource persistentVolumeClaim = 10;
  if (cached_has_bits & 0x00000200u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::persistentvolumeclaim(this),
        _Internal::persistentvolumeclaim(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.RBDVolumeSource rbd = 11;
  if (cached_has_bits & 0x00000400u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::rbd(this),
        _Internal::rbd(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.FlexVolumeSource flexVolume = 12;
  if (cached_has_bits & 0x00000800u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, _Internal::flexvolume(this),
        _Internal::flexvolume(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.CinderVolumeSource cinder = 13;
  if (cached_has_bits & 0x00001000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(13, _Internal::cinder(this),
        _Internal::cinder(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.CephFSVolumeSource cephfs = 14;
  if (cached_has_bits & 0x00002000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(14, _Internal::cephfs(this),
        _Internal::cephfs(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.FlockerVolumeSource flocker = 15;
  if (cached_has_bits & 0x00004000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(15, _Internal::flocker(this),
        _Internal::flocker(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.DownwardAPIVolumeSource downwardAPI = 16;
  if (cached_has_bits & 0x00008000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(16, _Internal::downwardapi(this),
        _Internal::downwardapi(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.FCVolumeSource fc = 17;
  if (cached_has_bits & 0x00010000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(17, _Internal::fc(this),
        _Internal::fc(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.AzureFileVolumeSource azureFile = 18;
  if (cached_has_bits & 0x00020000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(18, _Internal::azurefile(this),
        _Internal::azurefile(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.ConfigMapVolumeSource configMap = 19;
  if (cached_has_bits & 0x00040000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(19, _Internal::configmap(this),
        _Internal::configmap(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.VsphereVirtualDiskVolumeSource vsphereVolume = 20;
  if (cached_has_bits & 0x00080000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(20, _Internal::vspherevolume(this),
        _Internal::vspherevolume(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.QuobyteVolumeSource quobyte = 21;
  if (cached_has_bits & 0x00100000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(21, _Internal::quobyte(this),
        _Internal::quobyte(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.AzureDiskVolumeSource azureDisk = 22;
  if (cached_has_bits & 0x00200000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(22, _Internal::azuredisk(this),
        _Internal::azuredisk(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.PhotonPersistentDiskVolumeSource photonPersistentDisk = 23;
  if (cached_has_bits & 0x00400000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(23, _Internal::photonpersistentdisk(this),
        _Internal::photonpersistentdisk(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.PortworxVolumeSource portworxVolume = 24;
  if (cached_has_bits & 0x00800000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(24, _Internal::portworxvolume(this),
        _Internal::portworxvolume(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.ScaleIOVolumeSource scaleIO = 25;
  if (cached_has_bits & 0x01000000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(25, _Internal::scaleio(this),
        _Internal::scaleio(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.ProjectedVolumeSource projected = 26;
  if (cached_has_bits & 0x02000000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(26, _Internal::projected(this),
        _Internal::projected(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.StorageOSVolumeSource storageos = 27;
  if (cached_has_bits & 0x04000000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(27, _Internal::storageos(this),
        _Internal::storageos(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.CSIVolumeSource csi = 28;
  if (cached_has_bits & 0x08000000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(28, _Internal::csi(this),
        _Internal::csi(this).GetCachedSize(), target, stream);
  }

  // optional .k8s.io.api.core.v1.EphemeralVolumeSource ephemeral = 29;
  if (cached_has_bits & 0x10000000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(29, _Internal::ephemeral(this),
        _Internal::ephemeral(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.VolumeSource)
  return target;
}

size_t VolumeSource::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.VolumeSource)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .k8s.io.api.core.v1.HostPathVolumeSource hostPath = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.hostpath_);
    }

    // optional .k8s.io.api.core.v1.EmptyDirVolumeSource emptyDir = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.emptydir_);
    }

    // optional .k8s.io.api.core.v1.GCEPersistentDiskVolumeSource gcePersistentDisk = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.gcepersistentdisk_);
    }

    // optional .k8s.io.api.core.v1.AWSElasticBlockStoreVolumeSource awsElasticBlockStore = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.awselasticblockstore_);
    }

    // optional .k8s.io.api.core.v1.GitRepoVolumeSource gitRepo = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.gitrepo_);
    }

    // optional .k8s.io.api.core.v1.SecretVolumeSource secret = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.secret_);
    }

    // optional .k8s.io.api.core.v1.NFSVolumeSource nfs = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.nfs_);
    }

    // optional .k8s.io.api.core.v1.ISCSIVolumeSource iscsi = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.iscsi_);
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional .k8s.io.api.core.v1.GlusterfsVolumeSource glusterfs = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.glusterfs_);
    }

    // optional .k8s.io.api.core.v1.PersistentVolumeClaimVolumeSource persistentVolumeClaim = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.persistentvolumeclaim_);
    }

    // optional .k8s.io.api.core.v1.RBDVolumeSource rbd = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.rbd_);
    }

    // optional .k8s.io.api.core.v1.FlexVolumeSource flexVolume = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.flexvolume_);
    }

    // optional .k8s.io.api.core.v1.CinderVolumeSource cinder = 13;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.cinder_);
    }

    // optional .k8s.io.api.core.v1.CephFSVolumeSource cephfs = 14;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.cephfs_);
    }

    // optional .k8s.io.api.core.v1.FlockerVolumeSource flocker = 15;
    if (cached_has_bits & 0x00004000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.flocker_);
    }

    // optional .k8s.io.api.core.v1.DownwardAPIVolumeSource downwardAPI = 16;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.downwardapi_);
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional .k8s.io.api.core.v1.FCVolumeSource fc = 17;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.fc_);
    }

    // optional .k8s.io.api.core.v1.AzureFileVolumeSource azureFile = 18;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.azurefile_);
    }

    // optional .k8s.io.api.core.v1.ConfigMapVolumeSource configMap = 19;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.configmap_);
    }

    // optional .k8s.io.api.core.v1.VsphereVirtualDiskVolumeSource vsphereVolume = 20;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.vspherevolume_);
    }

    // optional .k8s.io.api.core.v1.QuobyteVolumeSource quobyte = 21;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.quobyte_);
    }

    // optional .k8s.io.api.core.v1.AzureDiskVolumeSource azureDisk = 22;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.azuredisk_);
    }

    // optional .k8s.io.api.core.v1.PhotonPersistentDiskVolumeSource photonPersistentDisk = 23;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.photonpersistentdisk_);
    }

    // optional .k8s.io.api.core.v1.PortworxVolumeSource portworxVolume = 24;
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.portworxvolume_);
    }

  }
  if (cached_has_bits & 0x1f000000u) {
    // optional .k8s.io.api.core.v1.ScaleIOVolumeSource scaleIO = 25;
    if (cached_has_bits & 0x01000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.scaleio_);
    }

    // optional .k8s.io.api.core.v1.ProjectedVolumeSource projected = 26;
    if (cached_has_bits & 0x02000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.projected_);
    }

    // optional .k8s.io.api.core.v1.StorageOSVolumeSource storageos = 27;
    if (cached_has_bits & 0x04000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.storageos_);
    }

    // optional .k8s.io.api.core.v1.CSIVolumeSource csi = 28;
    if (cached_has_bits & 0x08000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.csi_);
    }

    // optional .k8s.io.api.core.v1.EphemeralVolumeSource ephemeral = 29;
    if (cached_has_bits & 0x10000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.ephemeral_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VolumeSource::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VolumeSource::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VolumeSource::GetClassData() const { return &_class_data_; }


void VolumeSource::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VolumeSource*>(&to_msg);
  auto& from = static_cast<const VolumeSource&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.VolumeSource)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_hostpath()->::k8s::io::api::core::v1::HostPathVolumeSource::MergeFrom(
          from._internal_hostpath());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_emptydir()->::k8s::io::api::core::v1::EmptyDirVolumeSource::MergeFrom(
          from._internal_emptydir());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_gcepersistentdisk()->::k8s::io::api::core::v1::GCEPersistentDiskVolumeSource::MergeFrom(
          from._internal_gcepersistentdisk());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_awselasticblockstore()->::k8s::io::api::core::v1::AWSElasticBlockStoreVolumeSource::MergeFrom(
          from._internal_awselasticblockstore());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_gitrepo()->::k8s::io::api::core::v1::GitRepoVolumeSource::MergeFrom(
          from._internal_gitrepo());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_secret()->::k8s::io::api::core::v1::SecretVolumeSource::MergeFrom(
          from._internal_secret());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_nfs()->::k8s::io::api::core::v1::NFSVolumeSource::MergeFrom(
          from._internal_nfs());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_mutable_iscsi()->::k8s::io::api::core::v1::ISCSIVolumeSource::MergeFrom(
          from._internal_iscsi());
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_internal_mutable_glusterfs()->::k8s::io::api::core::v1::GlusterfsVolumeSource::MergeFrom(
          from._internal_glusterfs());
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_internal_mutable_persistentvolumeclaim()->::k8s::io::api::core::v1::PersistentVolumeClaimVolumeSource::MergeFrom(
          from._internal_persistentvolumeclaim());
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_internal_mutable_rbd()->::k8s::io::api::core::v1::RBDVolumeSource::MergeFrom(
          from._internal_rbd());
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_internal_mutable_flexvolume()->::k8s::io::api::core::v1::FlexVolumeSource::MergeFrom(
          from._internal_flexvolume());
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_internal_mutable_cinder()->::k8s::io::api::core::v1::CinderVolumeSource::MergeFrom(
          from._internal_cinder());
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_internal_mutable_cephfs()->::k8s::io::api::core::v1::CephFSVolumeSource::MergeFrom(
          from._internal_cephfs());
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_internal_mutable_flocker()->::k8s::io::api::core::v1::FlockerVolumeSource::MergeFrom(
          from._internal_flocker());
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_internal_mutable_downwardapi()->::k8s::io::api::core::v1::DownwardAPIVolumeSource::MergeFrom(
          from._internal_downwardapi());
    }
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_internal_mutable_fc()->::k8s::io::api::core::v1::FCVolumeSource::MergeFrom(
          from._internal_fc());
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_internal_mutable_azurefile()->::k8s::io::api::core::v1::AzureFileVolumeSource::MergeFrom(
          from._internal_azurefile());
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_internal_mutable_configmap()->::k8s::io::api::core::v1::ConfigMapVolumeSource::MergeFrom(
          from._internal_configmap());
    }
    if (cached_has_bits & 0x00080000u) {
      _this->_internal_mutable_vspherevolume()->::k8s::io::api::core::v1::VsphereVirtualDiskVolumeSource::MergeFrom(
          from._internal_vspherevolume());
    }
    if (cached_has_bits & 0x00100000u) {
      _this->_internal_mutable_quobyte()->::k8s::io::api::core::v1::QuobyteVolumeSource::MergeFrom(
          from._internal_quobyte());
    }
    if (cached_has_bits & 0x00200000u) {
      _this->_internal_mutable_azuredisk()->::k8s::io::api::core::v1::AzureDiskVolumeSource::MergeFrom(
          from._internal_azuredisk());
    }
    if (cached_has_bits & 0x00400000u) {
      _this->_internal_mutable_photonpersistentdisk()->::k8s::io::api::core::v1::PhotonPersistentDiskVolumeSource::MergeFrom(
          from._internal_photonpersistentdisk());
    }
    if (cached_has_bits & 0x00800000u) {
      _this->_internal_mutable_portworxvolume()->::k8s::io::api::core::v1::PortworxVolumeSource::MergeFrom(
          from._internal_portworxvolume());
    }
  }
  if (cached_has_bits & 0x1f000000u) {
    if (cached_has_bits & 0x01000000u) {
      _this->_internal_mutable_scaleio()->::k8s::io::api::core::v1::ScaleIOVolumeSource::MergeFrom(
          from._internal_scaleio());
    }
    if (cached_has_bits & 0x02000000u) {
      _this->_internal_mutable_projected()->::k8s::io::api::core::v1::ProjectedVolumeSource::MergeFrom(
          from._internal_projected());
    }
    if (cached_has_bits & 0x04000000u) {
      _this->_internal_mutable_storageos()->::k8s::io::api::core::v1::StorageOSVolumeSource::MergeFrom(
          from._internal_storageos());
    }
    if (cached_has_bits & 0x08000000u) {
      _this->_internal_mutable_csi()->::k8s::io::api::core::v1::CSIVolumeSource::MergeFrom(
          from._internal_csi());
    }
    if (cached_has_bits & 0x10000000u) {
      _this->_internal_mutable_ephemeral()->::k8s::io::api::core::v1::EphemeralVolumeSource::MergeFrom(
          from._internal_ephemeral());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VolumeSource::CopyFrom(const VolumeSource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.VolumeSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VolumeSource::IsInitialized() const {
  return true;
}

void VolumeSource::InternalSwap(VolumeSource* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VolumeSource, _impl_.ephemeral_)
      + sizeof(VolumeSource::_impl_.ephemeral_)
      - PROTOBUF_FIELD_OFFSET(VolumeSource, _impl_.hostpath_)>(
          reinterpret_cast<char*>(&_impl_.hostpath_),
          reinterpret_cast<char*>(&other->_impl_.hostpath_));
}

::PROTOBUF_NAMESPACE_ID::Metadata VolumeSource::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[251]);
}

// ===================================================================

class VsphereVirtualDiskVolumeSource::_Internal {
 public:
  using HasBits = decltype(std::declval<VsphereVirtualDiskVolumeSource>()._impl_._has_bits_);
  static void set_has_volumepath(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_fstype(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_storagepolicyname(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_storagepolicyid(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

VsphereVirtualDiskVolumeSource::VsphereVirtualDiskVolumeSource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.VsphereVirtualDiskVolumeSource)
}
VsphereVirtualDiskVolumeSource::VsphereVirtualDiskVolumeSource(const VsphereVirtualDiskVolumeSource& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  VsphereVirtualDiskVolumeSource* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.volumepath_){}
    , decltype(_impl_.fstype_){}
    , decltype(_impl_.storagepolicyname_){}
    , decltype(_impl_.storagepolicyid_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.volumepath_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.volumepath_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_volumepath()) {
    _this->_impl_.volumepath_.Set(from._internal_volumepath(), 
      _this->GetArenaForAllocation());
  }
  _impl_.fstype_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fstype_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_fstype()) {
    _this->_impl_.fstype_.Set(from._internal_fstype(), 
      _this->GetArenaForAllocation());
  }
  _impl_.storagepolicyname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.storagepolicyname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_storagepolicyname()) {
    _this->_impl_.storagepolicyname_.Set(from._internal_storagepolicyname(), 
      _this->GetArenaForAllocation());
  }
  _impl_.storagepolicyid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.storagepolicyid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_storagepolicyid()) {
    _this->_impl_.storagepolicyid_.Set(from._internal_storagepolicyid(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.VsphereVirtualDiskVolumeSource)
}

inline void VsphereVirtualDiskVolumeSource::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.volumepath_){}
    , decltype(_impl_.fstype_){}
    , decltype(_impl_.storagepolicyname_){}
    , decltype(_impl_.storagepolicyid_){}
  };
  _impl_.volumepath_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.volumepath_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.fstype_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fstype_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.storagepolicyname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.storagepolicyname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.storagepolicyid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.storagepolicyid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

VsphereVirtualDiskVolumeSource::~VsphereVirtualDiskVolumeSource() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.VsphereVirtualDiskVolumeSource)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VsphereVirtualDiskVolumeSource::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.volumepath_.Destroy();
  _impl_.fstype_.Destroy();
  _impl_.storagepolicyname_.Destroy();
  _impl_.storagepolicyid_.Destroy();
}

void VsphereVirtualDiskVolumeSource::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VsphereVirtualDiskVolumeSource::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.VsphereVirtualDiskVolumeSource)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.volumepath_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.fstype_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.storagepolicyname_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.storagepolicyid_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VsphereVirtualDiskVolumeSource::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes volumePath = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_volumepath();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes fsType = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_fstype();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes storagePolicyName = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_storagepolicyname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes storagePolicyID = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_storagepolicyid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VsphereVirtualDiskVolumeSource::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.VsphereVirtualDiskVolumeSource)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes volumePath = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_volumepath(), target);
  }

  // optional bytes fsType = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_fstype(), target);
  }

  // optional bytes storagePolicyName = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_storagepolicyname(), target);
  }

  // optional bytes storagePolicyID = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_storagepolicyid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.VsphereVirtualDiskVolumeSource)
  return target;
}

size_t VsphereVirtualDiskVolumeSource::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.VsphereVirtualDiskVolumeSource)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional bytes volumePath = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_volumepath());
    }

    // optional bytes fsType = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_fstype());
    }

    // optional bytes storagePolicyName = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_storagepolicyname());
    }

    // optional bytes storagePolicyID = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_storagepolicyid());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VsphereVirtualDiskVolumeSource::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VsphereVirtualDiskVolumeSource::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VsphereVirtualDiskVolumeSource::GetClassData() const { return &_class_data_; }


void VsphereVirtualDiskVolumeSource::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VsphereVirtualDiskVolumeSource*>(&to_msg);
  auto& from = static_cast<const VsphereVirtualDiskVolumeSource&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.VsphereVirtualDiskVolumeSource)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_volumepath(from._internal_volumepath());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_fstype(from._internal_fstype());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_storagepolicyname(from._internal_storagepolicyname());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_storagepolicyid(from._internal_storagepolicyid());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VsphereVirtualDiskVolumeSource::CopyFrom(const VsphereVirtualDiskVolumeSource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.VsphereVirtualDiskVolumeSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VsphereVirtualDiskVolumeSource::IsInitialized() const {
  return true;
}

void VsphereVirtualDiskVolumeSource::InternalSwap(VsphereVirtualDiskVolumeSource* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.volumepath_, lhs_arena,
      &other->_impl_.volumepath_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.fstype_, lhs_arena,
      &other->_impl_.fstype_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.storagepolicyname_, lhs_arena,
      &other->_impl_.storagepolicyname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.storagepolicyid_, lhs_arena,
      &other->_impl_.storagepolicyid_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata VsphereVirtualDiskVolumeSource::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[252]);
}

// ===================================================================

class WeightedPodAffinityTerm::_Internal {
 public:
  using HasBits = decltype(std::declval<WeightedPodAffinityTerm>()._impl_._has_bits_);
  static void set_has_weight(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::k8s::io::api::core::v1::PodAffinityTerm& podaffinityterm(const WeightedPodAffinityTerm* msg);
  static void set_has_podaffinityterm(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::k8s::io::api::core::v1::PodAffinityTerm&
WeightedPodAffinityTerm::_Internal::podaffinityterm(const WeightedPodAffinityTerm* msg) {
  return *msg->_impl_.podaffinityterm_;
}
WeightedPodAffinityTerm::WeightedPodAffinityTerm(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.WeightedPodAffinityTerm)
}
WeightedPodAffinityTerm::WeightedPodAffinityTerm(const WeightedPodAffinityTerm& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  WeightedPodAffinityTerm* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.podaffinityterm_){nullptr}
    , decltype(_impl_.weight_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_podaffinityterm()) {
    _this->_impl_.podaffinityterm_ = new ::k8s::io::api::core::v1::PodAffinityTerm(*from._impl_.podaffinityterm_);
  }
  _this->_impl_.weight_ = from._impl_.weight_;
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.WeightedPodAffinityTerm)
}

inline void WeightedPodAffinityTerm::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.podaffinityterm_){nullptr}
    , decltype(_impl_.weight_){0}
  };
}

WeightedPodAffinityTerm::~WeightedPodAffinityTerm() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.WeightedPodAffinityTerm)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void WeightedPodAffinityTerm::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.podaffinityterm_;
}

void WeightedPodAffinityTerm::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void WeightedPodAffinityTerm::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.WeightedPodAffinityTerm)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.podaffinityterm_ != nullptr);
    _impl_.podaffinityterm_->Clear();
  }
  _impl_.weight_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* WeightedPodAffinityTerm::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 weight = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_weight(&has_bits);
          _impl_.weight_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .k8s.io.api.core.v1.PodAffinityTerm podAffinityTerm = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_podaffinityterm(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* WeightedPodAffinityTerm::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.WeightedPodAffinityTerm)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 weight = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_weight(), target);
  }

  // optional .k8s.io.api.core.v1.PodAffinityTerm podAffinityTerm = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::podaffinityterm(this),
        _Internal::podaffinityterm(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.WeightedPodAffinityTerm)
  return target;
}

size_t WeightedPodAffinityTerm::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.WeightedPodAffinityTerm)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .k8s.io.api.core.v1.PodAffinityTerm podAffinityTerm = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.podaffinityterm_);
    }

    // optional int32 weight = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_weight());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData WeightedPodAffinityTerm::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    WeightedPodAffinityTerm::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*WeightedPodAffinityTerm::GetClassData() const { return &_class_data_; }


void WeightedPodAffinityTerm::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<WeightedPodAffinityTerm*>(&to_msg);
  auto& from = static_cast<const WeightedPodAffinityTerm&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.WeightedPodAffinityTerm)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_podaffinityterm()->::k8s::io::api::core::v1::PodAffinityTerm::MergeFrom(
          from._internal_podaffinityterm());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.weight_ = from._impl_.weight_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void WeightedPodAffinityTerm::CopyFrom(const WeightedPodAffinityTerm& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.WeightedPodAffinityTerm)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WeightedPodAffinityTerm::IsInitialized() const {
  return true;
}

void WeightedPodAffinityTerm::InternalSwap(WeightedPodAffinityTerm* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(WeightedPodAffinityTerm, _impl_.weight_)
      + sizeof(WeightedPodAffinityTerm::_impl_.weight_)
      - PROTOBUF_FIELD_OFFSET(WeightedPodAffinityTerm, _impl_.podaffinityterm_)>(
          reinterpret_cast<char*>(&_impl_.podaffinityterm_),
          reinterpret_cast<char*>(&other->_impl_.podaffinityterm_));
}

::PROTOBUF_NAMESPACE_ID::Metadata WeightedPodAffinityTerm::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[253]);
}

// ===================================================================

class WindowsSecurityContextOptions::_Internal {
 public:
  using HasBits = decltype(std::declval<WindowsSecurityContextOptions>()._impl_._has_bits_);
  static void set_has_gmsacredentialspecname(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_gmsacredentialspec(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_runasusername(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_hostprocess(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

WindowsSecurityContextOptions::WindowsSecurityContextOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:k8s.io.api.core.v1.WindowsSecurityContextOptions)
}
WindowsSecurityContextOptions::WindowsSecurityContextOptions(const WindowsSecurityContextOptions& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  WindowsSecurityContextOptions* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.gmsacredentialspecname_){}
    , decltype(_impl_.gmsacredentialspec_){}
    , decltype(_impl_.runasusername_){}
    , decltype(_impl_.hostprocess_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.gmsacredentialspecname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.gmsacredentialspecname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_gmsacredentialspecname()) {
    _this->_impl_.gmsacredentialspecname_.Set(from._internal_gmsacredentialspecname(), 
      _this->GetArenaForAllocation());
  }
  _impl_.gmsacredentialspec_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.gmsacredentialspec_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_gmsacredentialspec()) {
    _this->_impl_.gmsacredentialspec_.Set(from._internal_gmsacredentialspec(), 
      _this->GetArenaForAllocation());
  }
  _impl_.runasusername_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.runasusername_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_runasusername()) {
    _this->_impl_.runasusername_.Set(from._internal_runasusername(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.hostprocess_ = from._impl_.hostprocess_;
  // @@protoc_insertion_point(copy_constructor:k8s.io.api.core.v1.WindowsSecurityContextOptions)
}

inline void WindowsSecurityContextOptions::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.gmsacredentialspecname_){}
    , decltype(_impl_.gmsacredentialspec_){}
    , decltype(_impl_.runasusername_){}
    , decltype(_impl_.hostprocess_){false}
  };
  _impl_.gmsacredentialspecname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.gmsacredentialspecname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.gmsacredentialspec_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.gmsacredentialspec_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.runasusername_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.runasusername_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

WindowsSecurityContextOptions::~WindowsSecurityContextOptions() {
  // @@protoc_insertion_point(destructor:k8s.io.api.core.v1.WindowsSecurityContextOptions)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void WindowsSecurityContextOptions::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.gmsacredentialspecname_.Destroy();
  _impl_.gmsacredentialspec_.Destroy();
  _impl_.runasusername_.Destroy();
}

void WindowsSecurityContextOptions::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void WindowsSecurityContextOptions::Clear() {
// @@protoc_insertion_point(message_clear_start:k8s.io.api.core.v1.WindowsSecurityContextOptions)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.gmsacredentialspecname_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.gmsacredentialspec_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.runasusername_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.hostprocess_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* WindowsSecurityContextOptions::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes gmsaCredentialSpecName = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_gmsacredentialspecname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes gmsaCredentialSpec = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_gmsacredentialspec();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes runAsUserName = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_runasusername();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool hostProcess = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_hostprocess(&has_bits);
          _impl_.hostprocess_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* WindowsSecurityContextOptions::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:k8s.io.api.core.v1.WindowsSecurityContextOptions)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes gmsaCredentialSpecName = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_gmsacredentialspecname(), target);
  }

  // optional bytes gmsaCredentialSpec = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_gmsacredentialspec(), target);
  }

  // optional bytes runAsUserName = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_runasusername(), target);
  }

  // optional bool hostProcess = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_hostprocess(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:k8s.io.api.core.v1.WindowsSecurityContextOptions)
  return target;
}

size_t WindowsSecurityContextOptions::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:k8s.io.api.core.v1.WindowsSecurityContextOptions)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional bytes gmsaCredentialSpecName = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_gmsacredentialspecname());
    }

    // optional bytes gmsaCredentialSpec = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_gmsacredentialspec());
    }

    // optional bytes runAsUserName = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_runasusername());
    }

    // optional bool hostProcess = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData WindowsSecurityContextOptions::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    WindowsSecurityContextOptions::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*WindowsSecurityContextOptions::GetClassData() const { return &_class_data_; }


void WindowsSecurityContextOptions::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<WindowsSecurityContextOptions*>(&to_msg);
  auto& from = static_cast<const WindowsSecurityContextOptions&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:k8s.io.api.core.v1.WindowsSecurityContextOptions)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_gmsacredentialspecname(from._internal_gmsacredentialspecname());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_gmsacredentialspec(from._internal_gmsacredentialspec());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_runasusername(from._internal_runasusername());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.hostprocess_ = from._impl_.hostprocess_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void WindowsSecurityContextOptions::CopyFrom(const WindowsSecurityContextOptions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:k8s.io.api.core.v1.WindowsSecurityContextOptions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WindowsSecurityContextOptions::IsInitialized() const {
  return true;
}

void WindowsSecurityContextOptions::InternalSwap(WindowsSecurityContextOptions* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.gmsacredentialspecname_, lhs_arena,
      &other->_impl_.gmsacredentialspecname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.gmsacredentialspec_, lhs_arena,
      &other->_impl_.gmsacredentialspec_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.runasusername_, lhs_arena,
      &other->_impl_.runasusername_, rhs_arena
  );
  swap(_impl_.hostprocess_, other->_impl_.hostprocess_);
}

::PROTOBUF_NAMESPACE_ID::Metadata WindowsSecurityContextOptions::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_getter, &descriptor_table_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto_once,
      file_level_metadata_staging_5fsrc_5fk8s_2eio_5fapi_5fcore_5fv1_5fgenerated_2eproto[254]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1
}  // namespace core
}  // namespace api
}  // namespace io
}  // namespace k8s
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::PodOrNode*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::PodOrNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::PodOrNode >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::AWSElasticBlockStoreVolumeSource*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::AWSElasticBlockStoreVolumeSource >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::AWSElasticBlockStoreVolumeSource >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::Affinity*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::Affinity >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::Affinity >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::AttachedVolume*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::AttachedVolume >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::AttachedVolume >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::AvoidPods*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::AvoidPods >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::AvoidPods >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::AzureDiskVolumeSource*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::AzureDiskVolumeSource >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::AzureDiskVolumeSource >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::AzureFilePersistentVolumeSource*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::AzureFilePersistentVolumeSource >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::AzureFilePersistentVolumeSource >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::AzureFileVolumeSource*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::AzureFileVolumeSource >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::AzureFileVolumeSource >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::Binding*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::Binding >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::Binding >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::CSIPersistentVolumeSource_VolumeAttributesEntry_DoNotUse*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::CSIPersistentVolumeSource_VolumeAttributesEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::CSIPersistentVolumeSource_VolumeAttributesEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::CSIPersistentVolumeSource*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::CSIPersistentVolumeSource >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::CSIPersistentVolumeSource >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::CSIVolumeSource_VolumeAttributesEntry_DoNotUse*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::CSIVolumeSource_VolumeAttributesEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::CSIVolumeSource_VolumeAttributesEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::CSIVolumeSource*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::CSIVolumeSource >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::CSIVolumeSource >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::Capabilities*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::Capabilities >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::Capabilities >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::CephFSPersistentVolumeSource*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::CephFSPersistentVolumeSource >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::CephFSPersistentVolumeSource >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::CephFSVolumeSource*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::CephFSVolumeSource >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::CephFSVolumeSource >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::CinderPersistentVolumeSource*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::CinderPersistentVolumeSource >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::CinderPersistentVolumeSource >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::CinderVolumeSource*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::CinderVolumeSource >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::CinderVolumeSource >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::ClaimSource*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::ClaimSource >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::ClaimSource >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::ClientIPConfig*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::ClientIPConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::ClientIPConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::ClusterTrustBundleProjection*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::ClusterTrustBundleProjection >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::ClusterTrustBundleProjection >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::ComponentCondition*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::ComponentCondition >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::ComponentCondition >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::ComponentStatus*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::ComponentStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::ComponentStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::ComponentStatusList*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::ComponentStatusList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::ComponentStatusList >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::ConfigMap_DataEntry_DoNotUse*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::ConfigMap_DataEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::ConfigMap_DataEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::ConfigMap_BinaryDataEntry_DoNotUse*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::ConfigMap_BinaryDataEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::ConfigMap_BinaryDataEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::ConfigMap*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::ConfigMap >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::ConfigMap >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::ConfigMapEnvSource*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::ConfigMapEnvSource >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::ConfigMapEnvSource >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::ConfigMapKeySelector*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::ConfigMapKeySelector >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::ConfigMapKeySelector >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::ConfigMapList*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::ConfigMapList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::ConfigMapList >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::ConfigMapNodeConfigSource*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::ConfigMapNodeConfigSource >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::ConfigMapNodeConfigSource >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::ConfigMapProjection*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::ConfigMapProjection >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::ConfigMapProjection >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::ConfigMapVolumeSource*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::ConfigMapVolumeSource >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::ConfigMapVolumeSource >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::Container*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::Container >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::Container >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::ContainerImage*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::ContainerImage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::ContainerImage >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::ContainerPort*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::ContainerPort >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::ContainerPort >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::ContainerResizePolicy*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::ContainerResizePolicy >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::ContainerResizePolicy >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::ContainerState*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::ContainerState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::ContainerState >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::ContainerStateRunning*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::ContainerStateRunning >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::ContainerStateRunning >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::ContainerStateTerminated*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::ContainerStateTerminated >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::ContainerStateTerminated >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::ContainerStateWaiting*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::ContainerStateWaiting >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::ContainerStateWaiting >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::ContainerStatus_AllocatedResourcesEntry_DoNotUse*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::ContainerStatus_AllocatedResourcesEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::ContainerStatus_AllocatedResourcesEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::ContainerStatus*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::ContainerStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::ContainerStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::DaemonEndpoint*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::DaemonEndpoint >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::DaemonEndpoint >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::DownwardAPIProjection*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::DownwardAPIProjection >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::DownwardAPIProjection >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::DownwardAPIVolumeFile*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::DownwardAPIVolumeFile >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::DownwardAPIVolumeFile >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::DownwardAPIVolumeSource*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::DownwardAPIVolumeSource >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::DownwardAPIVolumeSource >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::EmptyDirVolumeSource*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::EmptyDirVolumeSource >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::EmptyDirVolumeSource >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::EndpointAddress*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::EndpointAddress >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::EndpointAddress >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::EndpointPort*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::EndpointPort >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::EndpointPort >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::EndpointSubset*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::EndpointSubset >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::EndpointSubset >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::Endpoints*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::Endpoints >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::Endpoints >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::EndpointsList*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::EndpointsList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::EndpointsList >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::EnvFromSource*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::EnvFromSource >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::EnvFromSource >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::EnvVar*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::EnvVar >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::EnvVar >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::EnvVarSource*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::EnvVarSource >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::EnvVarSource >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::EphemeralContainer*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::EphemeralContainer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::EphemeralContainer >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::EphemeralContainerCommon*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::EphemeralContainerCommon >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::EphemeralContainerCommon >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::EphemeralVolumeSource*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::EphemeralVolumeSource >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::EphemeralVolumeSource >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::Event*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::Event >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::Event >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::EventList*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::EventList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::EventList >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::EventSeries*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::EventSeries >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::EventSeries >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::EventSource*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::EventSource >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::EventSource >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::ExecAction*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::ExecAction >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::ExecAction >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::FCVolumeSource*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::FCVolumeSource >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::FCVolumeSource >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::FlexPersistentVolumeSource_OptionsEntry_DoNotUse*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::FlexPersistentVolumeSource_OptionsEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::FlexPersistentVolumeSource_OptionsEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::FlexPersistentVolumeSource*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::FlexPersistentVolumeSource >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::FlexPersistentVolumeSource >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::FlexVolumeSource_OptionsEntry_DoNotUse*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::FlexVolumeSource_OptionsEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::FlexVolumeSource_OptionsEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::FlexVolumeSource*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::FlexVolumeSource >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::FlexVolumeSource >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::FlockerVolumeSource*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::FlockerVolumeSource >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::FlockerVolumeSource >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::GCEPersistentDiskVolumeSource*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::GCEPersistentDiskVolumeSource >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::GCEPersistentDiskVolumeSource >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::GRPCAction*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::GRPCAction >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::GRPCAction >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::GitRepoVolumeSource*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::GitRepoVolumeSource >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::GitRepoVolumeSource >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::GlusterfsPersistentVolumeSource*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::GlusterfsPersistentVolumeSource >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::GlusterfsPersistentVolumeSource >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::GlusterfsVolumeSource*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::GlusterfsVolumeSource >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::GlusterfsVolumeSource >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::HTTPGetAction*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::HTTPGetAction >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::HTTPGetAction >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::HTTPHeader*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::HTTPHeader >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::HTTPHeader >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::HostAlias*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::HostAlias >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::HostAlias >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::HostIP*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::HostIP >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::HostIP >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::HostPathVolumeSource*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::HostPathVolumeSource >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::HostPathVolumeSource >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::ISCSIPersistentVolumeSource*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::ISCSIPersistentVolumeSource >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::ISCSIPersistentVolumeSource >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::ISCSIVolumeSource*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::ISCSIVolumeSource >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::ISCSIVolumeSource >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::KeyToPath*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::KeyToPath >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::KeyToPath >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::Lifecycle*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::Lifecycle >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::Lifecycle >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::LifecycleHandler*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::LifecycleHandler >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::LifecycleHandler >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::LimitRange*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::LimitRange >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::LimitRange >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::LimitRangeItem_MaxEntry_DoNotUse*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::LimitRangeItem_MaxEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::LimitRangeItem_MaxEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::LimitRangeItem_MinEntry_DoNotUse*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::LimitRangeItem_MinEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::LimitRangeItem_MinEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::LimitRangeItem_DefaultEntry_DoNotUse*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::LimitRangeItem_DefaultEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::LimitRangeItem_DefaultEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::LimitRangeItem_DefaultRequestEntry_DoNotUse*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::LimitRangeItem_DefaultRequestEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::LimitRangeItem_DefaultRequestEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::LimitRangeItem_MaxLimitRequestRatioEntry_DoNotUse*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::LimitRangeItem_MaxLimitRequestRatioEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::LimitRangeItem_MaxLimitRequestRatioEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::LimitRangeItem*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::LimitRangeItem >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::LimitRangeItem >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::LimitRangeList*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::LimitRangeList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::LimitRangeList >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::LimitRangeSpec*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::LimitRangeSpec >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::LimitRangeSpec >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::List*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::List >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::List >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::LoadBalancerIngress*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::LoadBalancerIngress >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::LoadBalancerIngress >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::LoadBalancerStatus*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::LoadBalancerStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::LoadBalancerStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::LocalObjectReference*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::LocalObjectReference >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::LocalObjectReference >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::LocalVolumeSource*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::LocalVolumeSource >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::LocalVolumeSource >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::ModifyVolumeStatus*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::ModifyVolumeStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::ModifyVolumeStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::NFSVolumeSource*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::NFSVolumeSource >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::NFSVolumeSource >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::Namespace*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::Namespace >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::Namespace >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::NamespaceCondition*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::NamespaceCondition >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::NamespaceCondition >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::NamespaceList*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::NamespaceList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::NamespaceList >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::NamespaceSpec*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::NamespaceSpec >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::NamespaceSpec >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::NamespaceStatus*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::NamespaceStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::NamespaceStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::Node*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::Node >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::Node >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::NodeAddress*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::NodeAddress >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::NodeAddress >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::NodeAffinity*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::NodeAffinity >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::NodeAffinity >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::NodeCondition*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::NodeCondition >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::NodeCondition >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::NodeConfigSource*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::NodeConfigSource >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::NodeConfigSource >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::NodeConfigStatus*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::NodeConfigStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::NodeConfigStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::NodeDaemonEndpoints*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::NodeDaemonEndpoints >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::NodeDaemonEndpoints >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::NodeList*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::NodeList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::NodeList >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::NodeProxyOptions*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::NodeProxyOptions >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::NodeProxyOptions >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::NodeResources_CapacityEntry_DoNotUse*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::NodeResources_CapacityEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::NodeResources_CapacityEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::NodeResources*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::NodeResources >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::NodeResources >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::NodeSelector*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::NodeSelector >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::NodeSelector >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::NodeSelectorRequirement*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::NodeSelectorRequirement >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::NodeSelectorRequirement >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::NodeSelectorTerm*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::NodeSelectorTerm >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::NodeSelectorTerm >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::NodeSpec*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::NodeSpec >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::NodeSpec >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::NodeStatus_CapacityEntry_DoNotUse*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::NodeStatus_CapacityEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::NodeStatus_CapacityEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::NodeStatus_AllocatableEntry_DoNotUse*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::NodeStatus_AllocatableEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::NodeStatus_AllocatableEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::NodeStatus*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::NodeStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::NodeStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::NodeSystemInfo*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::NodeSystemInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::NodeSystemInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::ObjectFieldSelector*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::ObjectFieldSelector >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::ObjectFieldSelector >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::ObjectReference*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::ObjectReference >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::ObjectReference >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::PersistentVolume*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::PersistentVolume >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::PersistentVolume >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::PersistentVolumeClaim*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::PersistentVolumeClaim >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::PersistentVolumeClaim >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::PersistentVolumeClaimCondition*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::PersistentVolumeClaimCondition >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::PersistentVolumeClaimCondition >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::PersistentVolumeClaimList*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::PersistentVolumeClaimList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::PersistentVolumeClaimList >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::PersistentVolumeClaimSpec*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::PersistentVolumeClaimSpec >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::PersistentVolumeClaimSpec >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::PersistentVolumeClaimStatus_CapacityEntry_DoNotUse*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::PersistentVolumeClaimStatus_CapacityEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::PersistentVolumeClaimStatus_CapacityEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::PersistentVolumeClaimStatus_AllocatedResourcesEntry_DoNotUse*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::PersistentVolumeClaimStatus_AllocatedResourcesEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::PersistentVolumeClaimStatus_AllocatedResourcesEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::PersistentVolumeClaimStatus_AllocatedResourceStatusesEntry_DoNotUse*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::PersistentVolumeClaimStatus_AllocatedResourceStatusesEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::PersistentVolumeClaimStatus_AllocatedResourceStatusesEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::PersistentVolumeClaimStatus*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::PersistentVolumeClaimStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::PersistentVolumeClaimStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::PersistentVolumeClaimTemplate*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::PersistentVolumeClaimTemplate >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::PersistentVolumeClaimTemplate >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::PersistentVolumeClaimVolumeSource*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::PersistentVolumeClaimVolumeSource >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::PersistentVolumeClaimVolumeSource >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::PersistentVolumeList*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::PersistentVolumeList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::PersistentVolumeList >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::PersistentVolumeSource*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::PersistentVolumeSource >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::PersistentVolumeSource >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::PersistentVolumeSpec_CapacityEntry_DoNotUse*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::PersistentVolumeSpec_CapacityEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::PersistentVolumeSpec_CapacityEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::PersistentVolumeSpec*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::PersistentVolumeSpec >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::PersistentVolumeSpec >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::PersistentVolumeStatus*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::PersistentVolumeStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::PersistentVolumeStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::PhotonPersistentDiskVolumeSource*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::PhotonPersistentDiskVolumeSource >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::PhotonPersistentDiskVolumeSource >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::Pod*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::Pod >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::Pod >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::PodAffinity*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::PodAffinity >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::PodAffinity >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::PodAffinityTerm*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::PodAffinityTerm >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::PodAffinityTerm >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::PodAntiAffinity*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::PodAntiAffinity >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::PodAntiAffinity >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::PodAttachOptions*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::PodAttachOptions >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::PodAttachOptions >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::PodCondition*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::PodCondition >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::PodCondition >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::PodDNSConfig*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::PodDNSConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::PodDNSConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::PodDNSConfigOption*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::PodDNSConfigOption >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::PodDNSConfigOption >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::PodExecOptions*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::PodExecOptions >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::PodExecOptions >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::PodIP*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::PodIP >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::PodIP >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::PodList*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::PodList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::PodList >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::PodLogOptions*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::PodLogOptions >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::PodLogOptions >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::PodOS*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::PodOS >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::PodOS >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::PodPortForwardOptions*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::PodPortForwardOptions >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::PodPortForwardOptions >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::PodProxyOptions*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::PodProxyOptions >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::PodProxyOptions >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::PodReadinessGate*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::PodReadinessGate >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::PodReadinessGate >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::PodResourceClaim*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::PodResourceClaim >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::PodResourceClaim >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::PodResourceClaimStatus*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::PodResourceClaimStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::PodResourceClaimStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::PodSchedulingGate*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::PodSchedulingGate >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::PodSchedulingGate >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::PodSecurityContext*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::PodSecurityContext >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::PodSecurityContext >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::PodSignature*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::PodSignature >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::PodSignature >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::PodSpec_NodeSelectorEntry_DoNotUse*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::PodSpec_NodeSelectorEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::PodSpec_NodeSelectorEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::PodSpec_OverheadEntry_DoNotUse*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::PodSpec_OverheadEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::PodSpec_OverheadEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::PodSpec*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::PodSpec >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::PodSpec >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::PodStatus*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::PodStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::PodStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::PodStatusResult*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::PodStatusResult >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::PodStatusResult >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::PodTemplate*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::PodTemplate >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::PodTemplate >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::PodTemplateList*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::PodTemplateList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::PodTemplateList >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::PodTemplateSpec*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::PodTemplateSpec >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::PodTemplateSpec >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::PortStatus*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::PortStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::PortStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::PortworxVolumeSource*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::PortworxVolumeSource >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::PortworxVolumeSource >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::Preconditions*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::Preconditions >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::Preconditions >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::PreferAvoidPodsEntry*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::PreferAvoidPodsEntry >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::PreferAvoidPodsEntry >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::PreferredSchedulingTerm*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::PreferredSchedulingTerm >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::PreferredSchedulingTerm >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::Probe*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::Probe >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::Probe >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::ProbeHandler*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::ProbeHandler >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::ProbeHandler >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::ProjectedVolumeSource*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::ProjectedVolumeSource >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::ProjectedVolumeSource >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::QuobyteVolumeSource*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::QuobyteVolumeSource >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::QuobyteVolumeSource >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::RBDPersistentVolumeSource*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::RBDPersistentVolumeSource >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::RBDPersistentVolumeSource >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::RBDVolumeSource*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::RBDVolumeSource >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::RBDVolumeSource >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::RangeAllocation*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::RangeAllocation >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::RangeAllocation >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::ReplicationController*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::ReplicationController >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::ReplicationController >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::ReplicationControllerCondition*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::ReplicationControllerCondition >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::ReplicationControllerCondition >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::ReplicationControllerList*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::ReplicationControllerList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::ReplicationControllerList >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::ReplicationControllerSpec_SelectorEntry_DoNotUse*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::ReplicationControllerSpec_SelectorEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::ReplicationControllerSpec_SelectorEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::ReplicationControllerSpec*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::ReplicationControllerSpec >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::ReplicationControllerSpec >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::ReplicationControllerStatus*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::ReplicationControllerStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::ReplicationControllerStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::ResourceClaim*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::ResourceClaim >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::ResourceClaim >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::ResourceFieldSelector*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::ResourceFieldSelector >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::ResourceFieldSelector >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::ResourceQuota*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::ResourceQuota >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::ResourceQuota >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::ResourceQuotaList*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::ResourceQuotaList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::ResourceQuotaList >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::ResourceQuotaSpec_HardEntry_DoNotUse*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::ResourceQuotaSpec_HardEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::ResourceQuotaSpec_HardEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::ResourceQuotaSpec*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::ResourceQuotaSpec >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::ResourceQuotaSpec >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::ResourceQuotaStatus_HardEntry_DoNotUse*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::ResourceQuotaStatus_HardEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::ResourceQuotaStatus_HardEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::ResourceQuotaStatus_UsedEntry_DoNotUse*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::ResourceQuotaStatus_UsedEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::ResourceQuotaStatus_UsedEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::ResourceQuotaStatus*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::ResourceQuotaStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::ResourceQuotaStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::ResourceRequirements_LimitsEntry_DoNotUse*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::ResourceRequirements_LimitsEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::ResourceRequirements_LimitsEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::ResourceRequirements_RequestsEntry_DoNotUse*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::ResourceRequirements_RequestsEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::ResourceRequirements_RequestsEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::ResourceRequirements*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::ResourceRequirements >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::ResourceRequirements >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::SELinuxOptions*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::SELinuxOptions >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::SELinuxOptions >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::ScaleIOPersistentVolumeSource*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::ScaleIOPersistentVolumeSource >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::ScaleIOPersistentVolumeSource >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::ScaleIOVolumeSource*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::ScaleIOVolumeSource >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::ScaleIOVolumeSource >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::ScopeSelector*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::ScopeSelector >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::ScopeSelector >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::ScopedResourceSelectorRequirement*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::ScopedResourceSelectorRequirement >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::ScopedResourceSelectorRequirement >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::SeccompProfile*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::SeccompProfile >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::SeccompProfile >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::Secret_DataEntry_DoNotUse*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::Secret_DataEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::Secret_DataEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::Secret_StringDataEntry_DoNotUse*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::Secret_StringDataEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::Secret_StringDataEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::Secret*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::Secret >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::Secret >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::SecretEnvSource*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::SecretEnvSource >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::SecretEnvSource >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::SecretKeySelector*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::SecretKeySelector >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::SecretKeySelector >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::SecretList*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::SecretList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::SecretList >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::SecretProjection*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::SecretProjection >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::SecretProjection >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::SecretReference*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::SecretReference >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::SecretReference >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::SecretVolumeSource*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::SecretVolumeSource >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::SecretVolumeSource >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::SecurityContext*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::SecurityContext >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::SecurityContext >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::SerializedReference*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::SerializedReference >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::SerializedReference >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::Service*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::Service >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::Service >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::ServiceAccount*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::ServiceAccount >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::ServiceAccount >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::ServiceAccountList*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::ServiceAccountList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::ServiceAccountList >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::ServiceAccountTokenProjection*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::ServiceAccountTokenProjection >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::ServiceAccountTokenProjection >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::ServiceList*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::ServiceList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::ServiceList >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::ServicePort*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::ServicePort >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::ServicePort >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::ServiceProxyOptions*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::ServiceProxyOptions >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::ServiceProxyOptions >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::ServiceSpec_SelectorEntry_DoNotUse*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::ServiceSpec_SelectorEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::ServiceSpec_SelectorEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::ServiceSpec*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::ServiceSpec >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::ServiceSpec >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::ServiceStatus*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::ServiceStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::ServiceStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::SessionAffinityConfig*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::SessionAffinityConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::SessionAffinityConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::SleepAction*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::SleepAction >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::SleepAction >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::StorageOSPersistentVolumeSource*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::StorageOSPersistentVolumeSource >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::StorageOSPersistentVolumeSource >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::StorageOSVolumeSource*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::StorageOSVolumeSource >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::StorageOSVolumeSource >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::Sysctl*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::Sysctl >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::Sysctl >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::TCPSocketAction*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::TCPSocketAction >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::TCPSocketAction >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::Taint*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::Taint >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::Taint >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::Toleration*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::Toleration >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::Toleration >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::TopologySelectorLabelRequirement*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::TopologySelectorLabelRequirement >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::TopologySelectorLabelRequirement >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::TopologySelectorTerm*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::TopologySelectorTerm >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::TopologySelectorTerm >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::TopologySpreadConstraint*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::TopologySpreadConstraint >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::TopologySpreadConstraint >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::TypedLocalObjectReference*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::TypedLocalObjectReference >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::TypedLocalObjectReference >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::TypedObjectReference*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::TypedObjectReference >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::TypedObjectReference >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::Volume*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::Volume >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::Volume >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::VolumeDevice*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::VolumeDevice >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::VolumeDevice >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::VolumeMount*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::VolumeMount >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::VolumeMount >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::VolumeNodeAffinity*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::VolumeNodeAffinity >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::VolumeNodeAffinity >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::VolumeProjection*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::VolumeProjection >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::VolumeProjection >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::VolumeResourceRequirements_LimitsEntry_DoNotUse*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::VolumeResourceRequirements_LimitsEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::VolumeResourceRequirements_LimitsEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::VolumeResourceRequirements_RequestsEntry_DoNotUse*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::VolumeResourceRequirements_RequestsEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::VolumeResourceRequirements_RequestsEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::VolumeResourceRequirements*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::VolumeResourceRequirements >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::VolumeResourceRequirements >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::VolumeSource*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::VolumeSource >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::VolumeSource >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::VsphereVirtualDiskVolumeSource*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::VsphereVirtualDiskVolumeSource >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::VsphereVirtualDiskVolumeSource >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::WeightedPodAffinityTerm*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::WeightedPodAffinityTerm >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::WeightedPodAffinityTerm >(arena);
}
template<> PROTOBUF_NOINLINE ::k8s::io::api::core::v1::WindowsSecurityContextOptions*
Arena::CreateMaybeMessage< ::k8s::io::api::core::v1::WindowsSecurityContextOptions >(Arena* arena) {
  return Arena::CreateMessageInternal< ::k8s::io::api::core::v1::WindowsSecurityContextOptions >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
