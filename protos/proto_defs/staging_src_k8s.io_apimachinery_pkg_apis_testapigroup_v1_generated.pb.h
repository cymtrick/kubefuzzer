// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: staging_src_k8s.io_apimachinery_pkg_apis_testapigroup_v1_generated.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_staging_5fsrc_5fk8s_2eio_5fapimachinery_5fpkg_5fapis_5ftestapigroup_5fv1_5fgenerated_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_staging_5fsrc_5fk8s_2eio_5fapimachinery_5fpkg_5fapis_5ftestapigroup_5fv1_5fgenerated_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
#include "staging_src_k8s.io_apimachinery_pkg_apis_meta_v1_generated.pb.h"
#include "staging_src_k8s.io_apimachinery_pkg_runtime_generated.pb.h"
#include "staging_src_k8s.io_apimachinery_pkg_runtime_schema_generated.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_staging_5fsrc_5fk8s_2eio_5fapimachinery_5fpkg_5fapis_5ftestapigroup_5fv1_5fgenerated_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_staging_5fsrc_5fk8s_2eio_5fapimachinery_5fpkg_5fapis_5ftestapigroup_5fv1_5fgenerated_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_staging_5fsrc_5fk8s_2eio_5fapimachinery_5fpkg_5fapis_5ftestapigroup_5fv1_5fgenerated_2eproto;
namespace k8s {
namespace io {
namespace apimachinery {
namespace pkg {
namespace apis {
namespace testapigroup {
namespace v1 {
class Carp;
struct CarpDefaultTypeInternal;
extern CarpDefaultTypeInternal _Carp_default_instance_;
class CarpCondition;
struct CarpConditionDefaultTypeInternal;
extern CarpConditionDefaultTypeInternal _CarpCondition_default_instance_;
class CarpList;
struct CarpListDefaultTypeInternal;
extern CarpListDefaultTypeInternal _CarpList_default_instance_;
class CarpSpec;
struct CarpSpecDefaultTypeInternal;
extern CarpSpecDefaultTypeInternal _CarpSpec_default_instance_;
class CarpSpec_NodeSelectorEntry_DoNotUse;
struct CarpSpec_NodeSelectorEntry_DoNotUseDefaultTypeInternal;
extern CarpSpec_NodeSelectorEntry_DoNotUseDefaultTypeInternal _CarpSpec_NodeSelectorEntry_DoNotUse_default_instance_;
class CarpStatus;
struct CarpStatusDefaultTypeInternal;
extern CarpStatusDefaultTypeInternal _CarpStatus_default_instance_;
}  // namespace v1
}  // namespace testapigroup
}  // namespace apis
}  // namespace pkg
}  // namespace apimachinery
}  // namespace io
}  // namespace k8s
PROTOBUF_NAMESPACE_OPEN
template<> ::k8s::io::apimachinery::pkg::apis::testapigroup::v1::Carp* Arena::CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::testapigroup::v1::Carp>(Arena*);
template<> ::k8s::io::apimachinery::pkg::apis::testapigroup::v1::CarpCondition* Arena::CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::testapigroup::v1::CarpCondition>(Arena*);
template<> ::k8s::io::apimachinery::pkg::apis::testapigroup::v1::CarpList* Arena::CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::testapigroup::v1::CarpList>(Arena*);
template<> ::k8s::io::apimachinery::pkg::apis::testapigroup::v1::CarpSpec* Arena::CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::testapigroup::v1::CarpSpec>(Arena*);
template<> ::k8s::io::apimachinery::pkg::apis::testapigroup::v1::CarpSpec_NodeSelectorEntry_DoNotUse* Arena::CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::testapigroup::v1::CarpSpec_NodeSelectorEntry_DoNotUse>(Arena*);
template<> ::k8s::io::apimachinery::pkg::apis::testapigroup::v1::CarpStatus* Arena::CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::testapigroup::v1::CarpStatus>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace k8s {
namespace io {
namespace apimachinery {
namespace pkg {
namespace apis {
namespace testapigroup {
namespace v1 {

// ===================================================================

class Carp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:k8s.io.apimachinery.pkg.apis.testapigroup.v1.Carp) */ {
 public:
  inline Carp() : Carp(nullptr) {}
  ~Carp() override;
  explicit PROTOBUF_CONSTEXPR Carp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Carp(const Carp& from);
  Carp(Carp&& from) noexcept
    : Carp() {
    *this = ::std::move(from);
  }

  inline Carp& operator=(const Carp& from) {
    CopyFrom(from);
    return *this;
  }
  inline Carp& operator=(Carp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Carp& default_instance() {
    return *internal_default_instance();
  }
  static inline const Carp* internal_default_instance() {
    return reinterpret_cast<const Carp*>(
               &_Carp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Carp& a, Carp& b) {
    a.Swap(&b);
  }
  inline void Swap(Carp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Carp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Carp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Carp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Carp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Carp& from) {
    Carp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Carp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "k8s.io.apimachinery.pkg.apis.testapigroup.v1.Carp";
  }
  protected:
  explicit Carp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 1,
    kSpecFieldNumber = 2,
    kStatusFieldNumber = 3,
  };
  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& metadata() const;
  PROTOBUF_NODISCARD ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* release_metadata();
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* mutable_metadata();
  void set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata);
  private:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& _internal_metadata() const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata);
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* unsafe_arena_release_metadata();

  // optional .k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpSpec spec = 2;
  bool has_spec() const;
  private:
  bool _internal_has_spec() const;
  public:
  void clear_spec();
  const ::k8s::io::apimachinery::pkg::apis::testapigroup::v1::CarpSpec& spec() const;
  PROTOBUF_NODISCARD ::k8s::io::apimachinery::pkg::apis::testapigroup::v1::CarpSpec* release_spec();
  ::k8s::io::apimachinery::pkg::apis::testapigroup::v1::CarpSpec* mutable_spec();
  void set_allocated_spec(::k8s::io::apimachinery::pkg::apis::testapigroup::v1::CarpSpec* spec);
  private:
  const ::k8s::io::apimachinery::pkg::apis::testapigroup::v1::CarpSpec& _internal_spec() const;
  ::k8s::io::apimachinery::pkg::apis::testapigroup::v1::CarpSpec* _internal_mutable_spec();
  public:
  void unsafe_arena_set_allocated_spec(
      ::k8s::io::apimachinery::pkg::apis::testapigroup::v1::CarpSpec* spec);
  ::k8s::io::apimachinery::pkg::apis::testapigroup::v1::CarpSpec* unsafe_arena_release_spec();

  // optional .k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpStatus status = 3;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::k8s::io::apimachinery::pkg::apis::testapigroup::v1::CarpStatus& status() const;
  PROTOBUF_NODISCARD ::k8s::io::apimachinery::pkg::apis::testapigroup::v1::CarpStatus* release_status();
  ::k8s::io::apimachinery::pkg::apis::testapigroup::v1::CarpStatus* mutable_status();
  void set_allocated_status(::k8s::io::apimachinery::pkg::apis::testapigroup::v1::CarpStatus* status);
  private:
  const ::k8s::io::apimachinery::pkg::apis::testapigroup::v1::CarpStatus& _internal_status() const;
  ::k8s::io::apimachinery::pkg::apis::testapigroup::v1::CarpStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::k8s::io::apimachinery::pkg::apis::testapigroup::v1::CarpStatus* status);
  ::k8s::io::apimachinery::pkg::apis::testapigroup::v1::CarpStatus* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.testapigroup.v1.Carp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata_;
    ::k8s::io::apimachinery::pkg::apis::testapigroup::v1::CarpSpec* spec_;
    ::k8s::io::apimachinery::pkg::apis::testapigroup::v1::CarpStatus* status_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_staging_5fsrc_5fk8s_2eio_5fapimachinery_5fpkg_5fapis_5ftestapigroup_5fv1_5fgenerated_2eproto;
};
// -------------------------------------------------------------------

class CarpCondition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpCondition) */ {
 public:
  inline CarpCondition() : CarpCondition(nullptr) {}
  ~CarpCondition() override;
  explicit PROTOBUF_CONSTEXPR CarpCondition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CarpCondition(const CarpCondition& from);
  CarpCondition(CarpCondition&& from) noexcept
    : CarpCondition() {
    *this = ::std::move(from);
  }

  inline CarpCondition& operator=(const CarpCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline CarpCondition& operator=(CarpCondition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CarpCondition& default_instance() {
    return *internal_default_instance();
  }
  static inline const CarpCondition* internal_default_instance() {
    return reinterpret_cast<const CarpCondition*>(
               &_CarpCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CarpCondition& a, CarpCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(CarpCondition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CarpCondition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CarpCondition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CarpCondition>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CarpCondition& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CarpCondition& from) {
    CarpCondition::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CarpCondition* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpCondition";
  }
  protected:
  explicit CarpCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kStatusFieldNumber = 2,
    kReasonFieldNumber = 5,
    kMessageFieldNumber = 6,
    kLastProbeTimeFieldNumber = 3,
    kLastTransitionTimeFieldNumber = 4,
  };
  // optional bytes type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // optional bytes status = 2;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // optional bytes reason = 5;
  bool has_reason() const;
  private:
  bool _internal_has_reason() const;
  public:
  void clear_reason();
  const std::string& reason() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reason(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reason();
  PROTOBUF_NODISCARD std::string* release_reason();
  void set_allocated_reason(std::string* reason);
  private:
  const std::string& _internal_reason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reason(const std::string& value);
  std::string* _internal_mutable_reason();
  public:

  // optional bytes message = 6;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastProbeTime = 3;
  bool has_lastprobetime() const;
  private:
  bool _internal_has_lastprobetime() const;
  public:
  void clear_lastprobetime();
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::Time& lastprobetime() const;
  PROTOBUF_NODISCARD ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* release_lastprobetime();
  ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* mutable_lastprobetime();
  void set_allocated_lastprobetime(::k8s::io::apimachinery::pkg::apis::meta::v1::Time* lastprobetime);
  private:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::Time& _internal_lastprobetime() const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* _internal_mutable_lastprobetime();
  public:
  void unsafe_arena_set_allocated_lastprobetime(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* lastprobetime);
  ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* unsafe_arena_release_lastprobetime();

  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 4;
  bool has_lasttransitiontime() const;
  private:
  bool _internal_has_lasttransitiontime() const;
  public:
  void clear_lasttransitiontime();
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::Time& lasttransitiontime() const;
  PROTOBUF_NODISCARD ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* release_lasttransitiontime();
  ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* mutable_lasttransitiontime();
  void set_allocated_lasttransitiontime(::k8s::io::apimachinery::pkg::apis::meta::v1::Time* lasttransitiontime);
  private:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::Time& _internal_lasttransitiontime() const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* _internal_mutable_lasttransitiontime();
  public:
  void unsafe_arena_set_allocated_lasttransitiontime(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* lasttransitiontime);
  ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* unsafe_arena_release_lasttransitiontime();

  // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpCondition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reason_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* lastprobetime_;
    ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* lasttransitiontime_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_staging_5fsrc_5fk8s_2eio_5fapimachinery_5fpkg_5fapis_5ftestapigroup_5fv1_5fgenerated_2eproto;
};
// -------------------------------------------------------------------

class CarpList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpList) */ {
 public:
  inline CarpList() : CarpList(nullptr) {}
  ~CarpList() override;
  explicit PROTOBUF_CONSTEXPR CarpList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CarpList(const CarpList& from);
  CarpList(CarpList&& from) noexcept
    : CarpList() {
    *this = ::std::move(from);
  }

  inline CarpList& operator=(const CarpList& from) {
    CopyFrom(from);
    return *this;
  }
  inline CarpList& operator=(CarpList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CarpList& default_instance() {
    return *internal_default_instance();
  }
  static inline const CarpList* internal_default_instance() {
    return reinterpret_cast<const CarpList*>(
               &_CarpList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CarpList& a, CarpList& b) {
    a.Swap(&b);
  }
  inline void Swap(CarpList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CarpList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CarpList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CarpList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CarpList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CarpList& from) {
    CarpList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CarpList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpList";
  }
  protected:
  explicit CarpList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 2,
    kMetadataFieldNumber = 1,
  };
  // repeated .k8s.io.apimachinery.pkg.apis.testapigroup.v1.Carp items = 2;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::k8s::io::apimachinery::pkg::apis::testapigroup::v1::Carp* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::k8s::io::apimachinery::pkg::apis::testapigroup::v1::Carp >*
      mutable_items();
  private:
  const ::k8s::io::apimachinery::pkg::apis::testapigroup::v1::Carp& _internal_items(int index) const;
  ::k8s::io::apimachinery::pkg::apis::testapigroup::v1::Carp* _internal_add_items();
  public:
  const ::k8s::io::apimachinery::pkg::apis::testapigroup::v1::Carp& items(int index) const;
  ::k8s::io::apimachinery::pkg::apis::testapigroup::v1::Carp* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::k8s::io::apimachinery::pkg::apis::testapigroup::v1::Carp >&
      items() const;

  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& metadata() const;
  PROTOBUF_NODISCARD ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* release_metadata();
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* mutable_metadata();
  void set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata);
  private:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& _internal_metadata() const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata);
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* unsafe_arena_release_metadata();

  // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::k8s::io::apimachinery::pkg::apis::testapigroup::v1::Carp > items_;
    ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_staging_5fsrc_5fk8s_2eio_5fapimachinery_5fpkg_5fapis_5ftestapigroup_5fv1_5fgenerated_2eproto;
};
// -------------------------------------------------------------------

class CarpSpec_NodeSelectorEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<CarpSpec_NodeSelectorEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<CarpSpec_NodeSelectorEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  CarpSpec_NodeSelectorEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR CarpSpec_NodeSelectorEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit CarpSpec_NodeSelectorEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const CarpSpec_NodeSelectorEntry_DoNotUse& other);
  static const CarpSpec_NodeSelectorEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const CarpSpec_NodeSelectorEntry_DoNotUse*>(&_CarpSpec_NodeSelectorEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
#ifndef NDEBUG
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
       s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpSpec.NodeSelectorEntry.key");
#else
    (void) s;
#endif
    return true;
 }
  static bool ValidateValue(std::string* s) {
#ifndef NDEBUG
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
       s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpSpec.NodeSelectorEntry.value");
#else
    (void) s;
#endif
    return true;
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_staging_5fsrc_5fk8s_2eio_5fapimachinery_5fpkg_5fapis_5ftestapigroup_5fv1_5fgenerated_2eproto;
};

// -------------------------------------------------------------------

class CarpSpec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpSpec) */ {
 public:
  inline CarpSpec() : CarpSpec(nullptr) {}
  ~CarpSpec() override;
  explicit PROTOBUF_CONSTEXPR CarpSpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CarpSpec(const CarpSpec& from);
  CarpSpec(CarpSpec&& from) noexcept
    : CarpSpec() {
    *this = ::std::move(from);
  }

  inline CarpSpec& operator=(const CarpSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline CarpSpec& operator=(CarpSpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CarpSpec& default_instance() {
    return *internal_default_instance();
  }
  static inline const CarpSpec* internal_default_instance() {
    return reinterpret_cast<const CarpSpec*>(
               &_CarpSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CarpSpec& a, CarpSpec& b) {
    a.Swap(&b);
  }
  inline void Swap(CarpSpec* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CarpSpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CarpSpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CarpSpec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CarpSpec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CarpSpec& from) {
    CarpSpec::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CarpSpec* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpSpec";
  }
  protected:
  explicit CarpSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kNodeSelectorFieldNumber = 7,
    kRestartPolicyFieldNumber = 3,
    kServiceAccountNameFieldNumber = 8,
    kServiceAccountFieldNumber = 9,
    kNodeNameFieldNumber = 10,
    kHostnameFieldNumber = 16,
    kSubdomainFieldNumber = 17,
    kSchedulernameFieldNumber = 19,
    kTerminationGracePeriodSecondsFieldNumber = 4,
    kActiveDeadlineSecondsFieldNumber = 5,
    kHostNetworkFieldNumber = 11,
    kHostPIDFieldNumber = 12,
    kHostIPCFieldNumber = 13,
  };
  // map<string, string> nodeSelector = 7;
  int nodeselector_size() const;
  private:
  int _internal_nodeselector_size() const;
  public:
  void clear_nodeselector();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_nodeselector() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_nodeselector();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      nodeselector() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_nodeselector();

  // optional bytes restartPolicy = 3;
  bool has_restartpolicy() const;
  private:
  bool _internal_has_restartpolicy() const;
  public:
  void clear_restartpolicy();
  const std::string& restartpolicy() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_restartpolicy(ArgT0&& arg0, ArgT... args);
  std::string* mutable_restartpolicy();
  PROTOBUF_NODISCARD std::string* release_restartpolicy();
  void set_allocated_restartpolicy(std::string* restartpolicy);
  private:
  const std::string& _internal_restartpolicy() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_restartpolicy(const std::string& value);
  std::string* _internal_mutable_restartpolicy();
  public:

  // optional bytes serviceAccountName = 8;
  bool has_serviceaccountname() const;
  private:
  bool _internal_has_serviceaccountname() const;
  public:
  void clear_serviceaccountname();
  const std::string& serviceaccountname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_serviceaccountname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_serviceaccountname();
  PROTOBUF_NODISCARD std::string* release_serviceaccountname();
  void set_allocated_serviceaccountname(std::string* serviceaccountname);
  private:
  const std::string& _internal_serviceaccountname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serviceaccountname(const std::string& value);
  std::string* _internal_mutable_serviceaccountname();
  public:

  // optional bytes serviceAccount = 9;
  bool has_serviceaccount() const;
  private:
  bool _internal_has_serviceaccount() const;
  public:
  void clear_serviceaccount();
  const std::string& serviceaccount() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_serviceaccount(ArgT0&& arg0, ArgT... args);
  std::string* mutable_serviceaccount();
  PROTOBUF_NODISCARD std::string* release_serviceaccount();
  void set_allocated_serviceaccount(std::string* serviceaccount);
  private:
  const std::string& _internal_serviceaccount() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serviceaccount(const std::string& value);
  std::string* _internal_mutable_serviceaccount();
  public:

  // optional bytes nodeName = 10;
  bool has_nodename() const;
  private:
  bool _internal_has_nodename() const;
  public:
  void clear_nodename();
  const std::string& nodename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nodename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nodename();
  PROTOBUF_NODISCARD std::string* release_nodename();
  void set_allocated_nodename(std::string* nodename);
  private:
  const std::string& _internal_nodename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nodename(const std::string& value);
  std::string* _internal_mutable_nodename();
  public:

  // optional bytes hostname = 16;
  bool has_hostname() const;
  private:
  bool _internal_has_hostname() const;
  public:
  void clear_hostname();
  const std::string& hostname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hostname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hostname();
  PROTOBUF_NODISCARD std::string* release_hostname();
  void set_allocated_hostname(std::string* hostname);
  private:
  const std::string& _internal_hostname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hostname(const std::string& value);
  std::string* _internal_mutable_hostname();
  public:

  // optional bytes subdomain = 17;
  bool has_subdomain() const;
  private:
  bool _internal_has_subdomain() const;
  public:
  void clear_subdomain();
  const std::string& subdomain() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_subdomain(ArgT0&& arg0, ArgT... args);
  std::string* mutable_subdomain();
  PROTOBUF_NODISCARD std::string* release_subdomain();
  void set_allocated_subdomain(std::string* subdomain);
  private:
  const std::string& _internal_subdomain() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subdomain(const std::string& value);
  std::string* _internal_mutable_subdomain();
  public:

  // optional bytes schedulername = 19;
  bool has_schedulername() const;
  private:
  bool _internal_has_schedulername() const;
  public:
  void clear_schedulername();
  const std::string& schedulername() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_schedulername(ArgT0&& arg0, ArgT... args);
  std::string* mutable_schedulername();
  PROTOBUF_NODISCARD std::string* release_schedulername();
  void set_allocated_schedulername(std::string* schedulername);
  private:
  const std::string& _internal_schedulername() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_schedulername(const std::string& value);
  std::string* _internal_mutable_schedulername();
  public:

  // optional int64 terminationGracePeriodSeconds = 4;
  bool has_terminationgraceperiodseconds() const;
  private:
  bool _internal_has_terminationgraceperiodseconds() const;
  public:
  void clear_terminationgraceperiodseconds();
  int64_t terminationgraceperiodseconds() const;
  void set_terminationgraceperiodseconds(int64_t value);
  private:
  int64_t _internal_terminationgraceperiodseconds() const;
  void _internal_set_terminationgraceperiodseconds(int64_t value);
  public:

  // optional int64 activeDeadlineSeconds = 5;
  bool has_activedeadlineseconds() const;
  private:
  bool _internal_has_activedeadlineseconds() const;
  public:
  void clear_activedeadlineseconds();
  int64_t activedeadlineseconds() const;
  void set_activedeadlineseconds(int64_t value);
  private:
  int64_t _internal_activedeadlineseconds() const;
  void _internal_set_activedeadlineseconds(int64_t value);
  public:

  // optional bool hostNetwork = 11;
  bool has_hostnetwork() const;
  private:
  bool _internal_has_hostnetwork() const;
  public:
  void clear_hostnetwork();
  bool hostnetwork() const;
  void set_hostnetwork(bool value);
  private:
  bool _internal_hostnetwork() const;
  void _internal_set_hostnetwork(bool value);
  public:

  // optional bool hostPID = 12;
  bool has_hostpid() const;
  private:
  bool _internal_has_hostpid() const;
  public:
  void clear_hostpid();
  bool hostpid() const;
  void set_hostpid(bool value);
  private:
  bool _internal_hostpid() const;
  void _internal_set_hostpid(bool value);
  public:

  // optional bool hostIPC = 13;
  bool has_hostipc() const;
  private:
  bool _internal_has_hostipc() const;
  public:
  void clear_hostipc();
  bool hostipc() const;
  void set_hostipc(bool value);
  private:
  bool _internal_hostipc() const;
  void _internal_set_hostipc(bool value);
  public:

  // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpSpec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        CarpSpec_NodeSelectorEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> nodeselector_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr restartpolicy_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serviceaccountname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serviceaccount_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nodename_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hostname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subdomain_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr schedulername_;
    int64_t terminationgraceperiodseconds_;
    int64_t activedeadlineseconds_;
    bool hostnetwork_;
    bool hostpid_;
    bool hostipc_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_staging_5fsrc_5fk8s_2eio_5fapimachinery_5fpkg_5fapis_5ftestapigroup_5fv1_5fgenerated_2eproto;
};
// -------------------------------------------------------------------

class CarpStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpStatus) */ {
 public:
  inline CarpStatus() : CarpStatus(nullptr) {}
  ~CarpStatus() override;
  explicit PROTOBUF_CONSTEXPR CarpStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CarpStatus(const CarpStatus& from);
  CarpStatus(CarpStatus&& from) noexcept
    : CarpStatus() {
    *this = ::std::move(from);
  }

  inline CarpStatus& operator=(const CarpStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline CarpStatus& operator=(CarpStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CarpStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const CarpStatus* internal_default_instance() {
    return reinterpret_cast<const CarpStatus*>(
               &_CarpStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CarpStatus& a, CarpStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(CarpStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CarpStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CarpStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CarpStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CarpStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CarpStatus& from) {
    CarpStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CarpStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpStatus";
  }
  protected:
  explicit CarpStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConditionsFieldNumber = 2,
    kPhaseFieldNumber = 1,
    kMessageFieldNumber = 3,
    kReasonFieldNumber = 4,
    kHostIPFieldNumber = 5,
    kCarpIPFieldNumber = 6,
    kStartTimeFieldNumber = 7,
  };
  // repeated .k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpCondition conditions = 2;
  int conditions_size() const;
  private:
  int _internal_conditions_size() const;
  public:
  void clear_conditions();
  ::k8s::io::apimachinery::pkg::apis::testapigroup::v1::CarpCondition* mutable_conditions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::k8s::io::apimachinery::pkg::apis::testapigroup::v1::CarpCondition >*
      mutable_conditions();
  private:
  const ::k8s::io::apimachinery::pkg::apis::testapigroup::v1::CarpCondition& _internal_conditions(int index) const;
  ::k8s::io::apimachinery::pkg::apis::testapigroup::v1::CarpCondition* _internal_add_conditions();
  public:
  const ::k8s::io::apimachinery::pkg::apis::testapigroup::v1::CarpCondition& conditions(int index) const;
  ::k8s::io::apimachinery::pkg::apis::testapigroup::v1::CarpCondition* add_conditions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::k8s::io::apimachinery::pkg::apis::testapigroup::v1::CarpCondition >&
      conditions() const;

  // optional bytes phase = 1;
  bool has_phase() const;
  private:
  bool _internal_has_phase() const;
  public:
  void clear_phase();
  const std::string& phase() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_phase(ArgT0&& arg0, ArgT... args);
  std::string* mutable_phase();
  PROTOBUF_NODISCARD std::string* release_phase();
  void set_allocated_phase(std::string* phase);
  private:
  const std::string& _internal_phase() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_phase(const std::string& value);
  std::string* _internal_mutable_phase();
  public:

  // optional bytes message = 3;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // optional bytes reason = 4;
  bool has_reason() const;
  private:
  bool _internal_has_reason() const;
  public:
  void clear_reason();
  const std::string& reason() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reason(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reason();
  PROTOBUF_NODISCARD std::string* release_reason();
  void set_allocated_reason(std::string* reason);
  private:
  const std::string& _internal_reason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reason(const std::string& value);
  std::string* _internal_mutable_reason();
  public:

  // optional bytes hostIP = 5;
  bool has_hostip() const;
  private:
  bool _internal_has_hostip() const;
  public:
  void clear_hostip();
  const std::string& hostip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hostip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hostip();
  PROTOBUF_NODISCARD std::string* release_hostip();
  void set_allocated_hostip(std::string* hostip);
  private:
  const std::string& _internal_hostip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hostip(const std::string& value);
  std::string* _internal_mutable_hostip();
  public:

  // optional bytes carpIP = 6;
  bool has_carpip() const;
  private:
  bool _internal_has_carpip() const;
  public:
  void clear_carpip();
  const std::string& carpip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_carpip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_carpip();
  PROTOBUF_NODISCARD std::string* release_carpip();
  void set_allocated_carpip(std::string* carpip);
  private:
  const std::string& _internal_carpip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_carpip(const std::string& value);
  std::string* _internal_mutable_carpip();
  public:

  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time startTime = 7;
  bool has_starttime() const;
  private:
  bool _internal_has_starttime() const;
  public:
  void clear_starttime();
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::Time& starttime() const;
  PROTOBUF_NODISCARD ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* release_starttime();
  ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* mutable_starttime();
  void set_allocated_starttime(::k8s::io::apimachinery::pkg::apis::meta::v1::Time* starttime);
  private:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::Time& _internal_starttime() const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* _internal_mutable_starttime();
  public:
  void unsafe_arena_set_allocated_starttime(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* starttime);
  ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* unsafe_arena_release_starttime();

  // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::k8s::io::apimachinery::pkg::apis::testapigroup::v1::CarpCondition > conditions_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr phase_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reason_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hostip_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr carpip_;
    ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* starttime_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_staging_5fsrc_5fk8s_2eio_5fapimachinery_5fpkg_5fapis_5ftestapigroup_5fv1_5fgenerated_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Carp

// optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
inline bool Carp::_internal_has_metadata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.metadata_ != nullptr);
  return value;
}
inline bool Carp::has_metadata() const {
  return _internal_has_metadata();
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& Carp::_internal_metadata() const {
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* p = _impl_.metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta&>(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::_ObjectMeta_default_instance_);
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& Carp::metadata() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.testapigroup.v1.Carp.metadata)
  return _internal_metadata();
}
inline void Carp::unsafe_arena_set_allocated_metadata(
    ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  _impl_.metadata_ = metadata;
  if (metadata) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:k8s.io.apimachinery.pkg.apis.testapigroup.v1.Carp.metadata)
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* Carp::release_metadata() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* Carp::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.testapigroup.v1.Carp.metadata)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* Carp::_internal_mutable_metadata() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta>(GetArenaForAllocation());
    _impl_.metadata_ = p;
  }
  return _impl_.metadata_;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* Carp::mutable_metadata() {
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.testapigroup.v1.Carp.metadata)
  return _msg;
}
inline void Carp::set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata));
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.testapigroup.v1.Carp.metadata)
}

// optional .k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpSpec spec = 2;
inline bool Carp::_internal_has_spec() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.spec_ != nullptr);
  return value;
}
inline bool Carp::has_spec() const {
  return _internal_has_spec();
}
inline void Carp::clear_spec() {
  if (_impl_.spec_ != nullptr) _impl_.spec_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::k8s::io::apimachinery::pkg::apis::testapigroup::v1::CarpSpec& Carp::_internal_spec() const {
  const ::k8s::io::apimachinery::pkg::apis::testapigroup::v1::CarpSpec* p = _impl_.spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::k8s::io::apimachinery::pkg::apis::testapigroup::v1::CarpSpec&>(
      ::k8s::io::apimachinery::pkg::apis::testapigroup::v1::_CarpSpec_default_instance_);
}
inline const ::k8s::io::apimachinery::pkg::apis::testapigroup::v1::CarpSpec& Carp::spec() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.testapigroup.v1.Carp.spec)
  return _internal_spec();
}
inline void Carp::unsafe_arena_set_allocated_spec(
    ::k8s::io::apimachinery::pkg::apis::testapigroup::v1::CarpSpec* spec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spec_);
  }
  _impl_.spec_ = spec;
  if (spec) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:k8s.io.apimachinery.pkg.apis.testapigroup.v1.Carp.spec)
}
inline ::k8s::io::apimachinery::pkg::apis::testapigroup::v1::CarpSpec* Carp::release_spec() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::k8s::io::apimachinery::pkg::apis::testapigroup::v1::CarpSpec* temp = _impl_.spec_;
  _impl_.spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::testapigroup::v1::CarpSpec* Carp::unsafe_arena_release_spec() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.testapigroup.v1.Carp.spec)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::k8s::io::apimachinery::pkg::apis::testapigroup::v1::CarpSpec* temp = _impl_.spec_;
  _impl_.spec_ = nullptr;
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::testapigroup::v1::CarpSpec* Carp::_internal_mutable_spec() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::testapigroup::v1::CarpSpec>(GetArenaForAllocation());
    _impl_.spec_ = p;
  }
  return _impl_.spec_;
}
inline ::k8s::io::apimachinery::pkg::apis::testapigroup::v1::CarpSpec* Carp::mutable_spec() {
  ::k8s::io::apimachinery::pkg::apis::testapigroup::v1::CarpSpec* _msg = _internal_mutable_spec();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.testapigroup.v1.Carp.spec)
  return _msg;
}
inline void Carp::set_allocated_spec(::k8s::io::apimachinery::pkg::apis::testapigroup::v1::CarpSpec* spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.spec_;
  }
  if (spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(spec);
    if (message_arena != submessage_arena) {
      spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spec, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.spec_ = spec;
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.testapigroup.v1.Carp.spec)
}

// optional .k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpStatus status = 3;
inline bool Carp::_internal_has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.status_ != nullptr);
  return value;
}
inline bool Carp::has_status() const {
  return _internal_has_status();
}
inline void Carp::clear_status() {
  if (_impl_.status_ != nullptr) _impl_.status_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::k8s::io::apimachinery::pkg::apis::testapigroup::v1::CarpStatus& Carp::_internal_status() const {
  const ::k8s::io::apimachinery::pkg::apis::testapigroup::v1::CarpStatus* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::k8s::io::apimachinery::pkg::apis::testapigroup::v1::CarpStatus&>(
      ::k8s::io::apimachinery::pkg::apis::testapigroup::v1::_CarpStatus_default_instance_);
}
inline const ::k8s::io::apimachinery::pkg::apis::testapigroup::v1::CarpStatus& Carp::status() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.testapigroup.v1.Carp.status)
  return _internal_status();
}
inline void Carp::unsafe_arena_set_allocated_status(
    ::k8s::io::apimachinery::pkg::apis::testapigroup::v1::CarpStatus* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = status;
  if (status) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:k8s.io.apimachinery.pkg.apis.testapigroup.v1.Carp.status)
}
inline ::k8s::io::apimachinery::pkg::apis::testapigroup::v1::CarpStatus* Carp::release_status() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::k8s::io::apimachinery::pkg::apis::testapigroup::v1::CarpStatus* temp = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::testapigroup::v1::CarpStatus* Carp::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.testapigroup.v1.Carp.status)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::k8s::io::apimachinery::pkg::apis::testapigroup::v1::CarpStatus* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::testapigroup::v1::CarpStatus* Carp::_internal_mutable_status() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::testapigroup::v1::CarpStatus>(GetArenaForAllocation());
    _impl_.status_ = p;
  }
  return _impl_.status_;
}
inline ::k8s::io::apimachinery::pkg::apis::testapigroup::v1::CarpStatus* Carp::mutable_status() {
  ::k8s::io::apimachinery::pkg::apis::testapigroup::v1::CarpStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.testapigroup.v1.Carp.status)
  return _msg;
}
inline void Carp::set_allocated_status(::k8s::io::apimachinery::pkg::apis::testapigroup::v1::CarpStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.status_ = status;
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.testapigroup.v1.Carp.status)
}

// -------------------------------------------------------------------

// CarpCondition

// optional bytes type = 1;
inline bool CarpCondition::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CarpCondition::has_type() const {
  return _internal_has_type();
}
inline void CarpCondition::clear_type() {
  _impl_.type_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CarpCondition::type() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpCondition.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CarpCondition::set_type(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.type_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpCondition.type)
}
inline std::string* CarpCondition::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpCondition.type)
  return _s;
}
inline const std::string& CarpCondition::_internal_type() const {
  return _impl_.type_.Get();
}
inline void CarpCondition::_internal_set_type(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* CarpCondition::_internal_mutable_type() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* CarpCondition::release_type() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpCondition.type)
  if (!_internal_has_type()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.type_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CarpCondition::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpCondition.type)
}

// optional bytes status = 2;
inline bool CarpCondition::_internal_has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CarpCondition::has_status() const {
  return _internal_has_status();
}
inline void CarpCondition::clear_status() {
  _impl_.status_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CarpCondition::status() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpCondition.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CarpCondition::set_status(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.status_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpCondition.status)
}
inline std::string* CarpCondition::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpCondition.status)
  return _s;
}
inline const std::string& CarpCondition::_internal_status() const {
  return _impl_.status_.Get();
}
inline void CarpCondition::_internal_set_status(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.status_.Set(value, GetArenaForAllocation());
}
inline std::string* CarpCondition::_internal_mutable_status() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.status_.Mutable(GetArenaForAllocation());
}
inline std::string* CarpCondition::release_status() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpCondition.status)
  if (!_internal_has_status()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.status_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.status_.IsDefault()) {
    _impl_.status_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CarpCondition::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.status_.SetAllocated(status, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.status_.IsDefault()) {
    _impl_.status_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpCondition.status)
}

// optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastProbeTime = 3;
inline bool CarpCondition::_internal_has_lastprobetime() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.lastprobetime_ != nullptr);
  return value;
}
inline bool CarpCondition::has_lastprobetime() const {
  return _internal_has_lastprobetime();
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::Time& CarpCondition::_internal_lastprobetime() const {
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* p = _impl_.lastprobetime_;
  return p != nullptr ? *p : reinterpret_cast<const ::k8s::io::apimachinery::pkg::apis::meta::v1::Time&>(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::_Time_default_instance_);
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::Time& CarpCondition::lastprobetime() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpCondition.lastProbeTime)
  return _internal_lastprobetime();
}
inline void CarpCondition::unsafe_arena_set_allocated_lastprobetime(
    ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* lastprobetime) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lastprobetime_);
  }
  _impl_.lastprobetime_ = lastprobetime;
  if (lastprobetime) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpCondition.lastProbeTime)
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* CarpCondition::release_lastprobetime() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* temp = _impl_.lastprobetime_;
  _impl_.lastprobetime_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* CarpCondition::unsafe_arena_release_lastprobetime() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpCondition.lastProbeTime)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* temp = _impl_.lastprobetime_;
  _impl_.lastprobetime_ = nullptr;
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* CarpCondition::_internal_mutable_lastprobetime() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.lastprobetime_ == nullptr) {
    auto* p = CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::Time>(GetArenaForAllocation());
    _impl_.lastprobetime_ = p;
  }
  return _impl_.lastprobetime_;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* CarpCondition::mutable_lastprobetime() {
  ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* _msg = _internal_mutable_lastprobetime();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpCondition.lastProbeTime)
  return _msg;
}
inline void CarpCondition::set_allocated_lastprobetime(::k8s::io::apimachinery::pkg::apis::meta::v1::Time* lastprobetime) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lastprobetime_);
  }
  if (lastprobetime) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lastprobetime));
    if (message_arena != submessage_arena) {
      lastprobetime = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lastprobetime, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.lastprobetime_ = lastprobetime;
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpCondition.lastProbeTime)
}

// optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 4;
inline bool CarpCondition::_internal_has_lasttransitiontime() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.lasttransitiontime_ != nullptr);
  return value;
}
inline bool CarpCondition::has_lasttransitiontime() const {
  return _internal_has_lasttransitiontime();
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::Time& CarpCondition::_internal_lasttransitiontime() const {
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* p = _impl_.lasttransitiontime_;
  return p != nullptr ? *p : reinterpret_cast<const ::k8s::io::apimachinery::pkg::apis::meta::v1::Time&>(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::_Time_default_instance_);
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::Time& CarpCondition::lasttransitiontime() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpCondition.lastTransitionTime)
  return _internal_lasttransitiontime();
}
inline void CarpCondition::unsafe_arena_set_allocated_lasttransitiontime(
    ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* lasttransitiontime) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lasttransitiontime_);
  }
  _impl_.lasttransitiontime_ = lasttransitiontime;
  if (lasttransitiontime) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpCondition.lastTransitionTime)
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* CarpCondition::release_lasttransitiontime() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* temp = _impl_.lasttransitiontime_;
  _impl_.lasttransitiontime_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* CarpCondition::unsafe_arena_release_lasttransitiontime() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpCondition.lastTransitionTime)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* temp = _impl_.lasttransitiontime_;
  _impl_.lasttransitiontime_ = nullptr;
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* CarpCondition::_internal_mutable_lasttransitiontime() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.lasttransitiontime_ == nullptr) {
    auto* p = CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::Time>(GetArenaForAllocation());
    _impl_.lasttransitiontime_ = p;
  }
  return _impl_.lasttransitiontime_;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* CarpCondition::mutable_lasttransitiontime() {
  ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* _msg = _internal_mutable_lasttransitiontime();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpCondition.lastTransitionTime)
  return _msg;
}
inline void CarpCondition::set_allocated_lasttransitiontime(::k8s::io::apimachinery::pkg::apis::meta::v1::Time* lasttransitiontime) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lasttransitiontime_);
  }
  if (lasttransitiontime) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lasttransitiontime));
    if (message_arena != submessage_arena) {
      lasttransitiontime = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lasttransitiontime, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.lasttransitiontime_ = lasttransitiontime;
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpCondition.lastTransitionTime)
}

// optional bytes reason = 5;
inline bool CarpCondition::_internal_has_reason() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CarpCondition::has_reason() const {
  return _internal_has_reason();
}
inline void CarpCondition::clear_reason() {
  _impl_.reason_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CarpCondition::reason() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpCondition.reason)
  return _internal_reason();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CarpCondition::set_reason(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.reason_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpCondition.reason)
}
inline std::string* CarpCondition::mutable_reason() {
  std::string* _s = _internal_mutable_reason();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpCondition.reason)
  return _s;
}
inline const std::string& CarpCondition::_internal_reason() const {
  return _impl_.reason_.Get();
}
inline void CarpCondition::_internal_set_reason(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.reason_.Set(value, GetArenaForAllocation());
}
inline std::string* CarpCondition::_internal_mutable_reason() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.reason_.Mutable(GetArenaForAllocation());
}
inline std::string* CarpCondition::release_reason() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpCondition.reason)
  if (!_internal_has_reason()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.reason_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.reason_.IsDefault()) {
    _impl_.reason_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CarpCondition::set_allocated_reason(std::string* reason) {
  if (reason != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.reason_.SetAllocated(reason, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.reason_.IsDefault()) {
    _impl_.reason_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpCondition.reason)
}

// optional bytes message = 6;
inline bool CarpCondition::_internal_has_message() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CarpCondition::has_message() const {
  return _internal_has_message();
}
inline void CarpCondition::clear_message() {
  _impl_.message_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& CarpCondition::message() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpCondition.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CarpCondition::set_message(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.message_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpCondition.message)
}
inline std::string* CarpCondition::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpCondition.message)
  return _s;
}
inline const std::string& CarpCondition::_internal_message() const {
  return _impl_.message_.Get();
}
inline void CarpCondition::_internal_set_message(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* CarpCondition::_internal_mutable_message() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* CarpCondition::release_message() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpCondition.message)
  if (!_internal_has_message()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.message_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CarpCondition::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpCondition.message)
}

// -------------------------------------------------------------------

// CarpList

// optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
inline bool CarpList::_internal_has_metadata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.metadata_ != nullptr);
  return value;
}
inline bool CarpList::has_metadata() const {
  return _internal_has_metadata();
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& CarpList::_internal_metadata() const {
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* p = _impl_.metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta&>(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::_ListMeta_default_instance_);
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& CarpList::metadata() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpList.metadata)
  return _internal_metadata();
}
inline void CarpList::unsafe_arena_set_allocated_metadata(
    ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  _impl_.metadata_ = metadata;
  if (metadata) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpList.metadata)
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* CarpList::release_metadata() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* CarpList::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpList.metadata)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* CarpList::_internal_mutable_metadata() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta>(GetArenaForAllocation());
    _impl_.metadata_ = p;
  }
  return _impl_.metadata_;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* CarpList::mutable_metadata() {
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpList.metadata)
  return _msg;
}
inline void CarpList::set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata));
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpList.metadata)
}

// repeated .k8s.io.apimachinery.pkg.apis.testapigroup.v1.Carp items = 2;
inline int CarpList::_internal_items_size() const {
  return _impl_.items_.size();
}
inline int CarpList::items_size() const {
  return _internal_items_size();
}
inline void CarpList::clear_items() {
  _impl_.items_.Clear();
}
inline ::k8s::io::apimachinery::pkg::apis::testapigroup::v1::Carp* CarpList::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpList.items)
  return _impl_.items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::k8s::io::apimachinery::pkg::apis::testapigroup::v1::Carp >*
CarpList::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpList.items)
  return &_impl_.items_;
}
inline const ::k8s::io::apimachinery::pkg::apis::testapigroup::v1::Carp& CarpList::_internal_items(int index) const {
  return _impl_.items_.Get(index);
}
inline const ::k8s::io::apimachinery::pkg::apis::testapigroup::v1::Carp& CarpList::items(int index) const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpList.items)
  return _internal_items(index);
}
inline ::k8s::io::apimachinery::pkg::apis::testapigroup::v1::Carp* CarpList::_internal_add_items() {
  return _impl_.items_.Add();
}
inline ::k8s::io::apimachinery::pkg::apis::testapigroup::v1::Carp* CarpList::add_items() {
  ::k8s::io::apimachinery::pkg::apis::testapigroup::v1::Carp* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpList.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::k8s::io::apimachinery::pkg::apis::testapigroup::v1::Carp >&
CarpList::items() const {
  // @@protoc_insertion_point(field_list:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpList.items)
  return _impl_.items_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// CarpSpec

// optional bytes restartPolicy = 3;
inline bool CarpSpec::_internal_has_restartpolicy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CarpSpec::has_restartpolicy() const {
  return _internal_has_restartpolicy();
}
inline void CarpSpec::clear_restartpolicy() {
  _impl_.restartpolicy_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CarpSpec::restartpolicy() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpSpec.restartPolicy)
  return _internal_restartpolicy();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CarpSpec::set_restartpolicy(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.restartpolicy_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpSpec.restartPolicy)
}
inline std::string* CarpSpec::mutable_restartpolicy() {
  std::string* _s = _internal_mutable_restartpolicy();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpSpec.restartPolicy)
  return _s;
}
inline const std::string& CarpSpec::_internal_restartpolicy() const {
  return _impl_.restartpolicy_.Get();
}
inline void CarpSpec::_internal_set_restartpolicy(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.restartpolicy_.Set(value, GetArenaForAllocation());
}
inline std::string* CarpSpec::_internal_mutable_restartpolicy() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.restartpolicy_.Mutable(GetArenaForAllocation());
}
inline std::string* CarpSpec::release_restartpolicy() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpSpec.restartPolicy)
  if (!_internal_has_restartpolicy()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.restartpolicy_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.restartpolicy_.IsDefault()) {
    _impl_.restartpolicy_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CarpSpec::set_allocated_restartpolicy(std::string* restartpolicy) {
  if (restartpolicy != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.restartpolicy_.SetAllocated(restartpolicy, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.restartpolicy_.IsDefault()) {
    _impl_.restartpolicy_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpSpec.restartPolicy)
}

// optional int64 terminationGracePeriodSeconds = 4;
inline bool CarpSpec::_internal_has_terminationgraceperiodseconds() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool CarpSpec::has_terminationgraceperiodseconds() const {
  return _internal_has_terminationgraceperiodseconds();
}
inline void CarpSpec::clear_terminationgraceperiodseconds() {
  _impl_.terminationgraceperiodseconds_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline int64_t CarpSpec::_internal_terminationgraceperiodseconds() const {
  return _impl_.terminationgraceperiodseconds_;
}
inline int64_t CarpSpec::terminationgraceperiodseconds() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpSpec.terminationGracePeriodSeconds)
  return _internal_terminationgraceperiodseconds();
}
inline void CarpSpec::_internal_set_terminationgraceperiodseconds(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.terminationgraceperiodseconds_ = value;
}
inline void CarpSpec::set_terminationgraceperiodseconds(int64_t value) {
  _internal_set_terminationgraceperiodseconds(value);
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpSpec.terminationGracePeriodSeconds)
}

// optional int64 activeDeadlineSeconds = 5;
inline bool CarpSpec::_internal_has_activedeadlineseconds() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool CarpSpec::has_activedeadlineseconds() const {
  return _internal_has_activedeadlineseconds();
}
inline void CarpSpec::clear_activedeadlineseconds() {
  _impl_.activedeadlineseconds_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline int64_t CarpSpec::_internal_activedeadlineseconds() const {
  return _impl_.activedeadlineseconds_;
}
inline int64_t CarpSpec::activedeadlineseconds() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpSpec.activeDeadlineSeconds)
  return _internal_activedeadlineseconds();
}
inline void CarpSpec::_internal_set_activedeadlineseconds(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.activedeadlineseconds_ = value;
}
inline void CarpSpec::set_activedeadlineseconds(int64_t value) {
  _internal_set_activedeadlineseconds(value);
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpSpec.activeDeadlineSeconds)
}

// map<string, string> nodeSelector = 7;
inline int CarpSpec::_internal_nodeselector_size() const {
  return _impl_.nodeselector_.size();
}
inline int CarpSpec::nodeselector_size() const {
  return _internal_nodeselector_size();
}
inline void CarpSpec::clear_nodeselector() {
  _impl_.nodeselector_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
CarpSpec::_internal_nodeselector() const {
  return _impl_.nodeselector_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
CarpSpec::nodeselector() const {
  // @@protoc_insertion_point(field_map:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpSpec.nodeSelector)
  return _internal_nodeselector();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
CarpSpec::_internal_mutable_nodeselector() {
  return _impl_.nodeselector_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
CarpSpec::mutable_nodeselector() {
  // @@protoc_insertion_point(field_mutable_map:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpSpec.nodeSelector)
  return _internal_mutable_nodeselector();
}

// optional bytes serviceAccountName = 8;
inline bool CarpSpec::_internal_has_serviceaccountname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CarpSpec::has_serviceaccountname() const {
  return _internal_has_serviceaccountname();
}
inline void CarpSpec::clear_serviceaccountname() {
  _impl_.serviceaccountname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CarpSpec::serviceaccountname() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpSpec.serviceAccountName)
  return _internal_serviceaccountname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CarpSpec::set_serviceaccountname(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.serviceaccountname_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpSpec.serviceAccountName)
}
inline std::string* CarpSpec::mutable_serviceaccountname() {
  std::string* _s = _internal_mutable_serviceaccountname();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpSpec.serviceAccountName)
  return _s;
}
inline const std::string& CarpSpec::_internal_serviceaccountname() const {
  return _impl_.serviceaccountname_.Get();
}
inline void CarpSpec::_internal_set_serviceaccountname(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.serviceaccountname_.Set(value, GetArenaForAllocation());
}
inline std::string* CarpSpec::_internal_mutable_serviceaccountname() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.serviceaccountname_.Mutable(GetArenaForAllocation());
}
inline std::string* CarpSpec::release_serviceaccountname() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpSpec.serviceAccountName)
  if (!_internal_has_serviceaccountname()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.serviceaccountname_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.serviceaccountname_.IsDefault()) {
    _impl_.serviceaccountname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CarpSpec::set_allocated_serviceaccountname(std::string* serviceaccountname) {
  if (serviceaccountname != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.serviceaccountname_.SetAllocated(serviceaccountname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.serviceaccountname_.IsDefault()) {
    _impl_.serviceaccountname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpSpec.serviceAccountName)
}

// optional bytes serviceAccount = 9;
inline bool CarpSpec::_internal_has_serviceaccount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CarpSpec::has_serviceaccount() const {
  return _internal_has_serviceaccount();
}
inline void CarpSpec::clear_serviceaccount() {
  _impl_.serviceaccount_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CarpSpec::serviceaccount() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpSpec.serviceAccount)
  return _internal_serviceaccount();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CarpSpec::set_serviceaccount(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.serviceaccount_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpSpec.serviceAccount)
}
inline std::string* CarpSpec::mutable_serviceaccount() {
  std::string* _s = _internal_mutable_serviceaccount();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpSpec.serviceAccount)
  return _s;
}
inline const std::string& CarpSpec::_internal_serviceaccount() const {
  return _impl_.serviceaccount_.Get();
}
inline void CarpSpec::_internal_set_serviceaccount(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.serviceaccount_.Set(value, GetArenaForAllocation());
}
inline std::string* CarpSpec::_internal_mutable_serviceaccount() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.serviceaccount_.Mutable(GetArenaForAllocation());
}
inline std::string* CarpSpec::release_serviceaccount() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpSpec.serviceAccount)
  if (!_internal_has_serviceaccount()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.serviceaccount_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.serviceaccount_.IsDefault()) {
    _impl_.serviceaccount_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CarpSpec::set_allocated_serviceaccount(std::string* serviceaccount) {
  if (serviceaccount != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.serviceaccount_.SetAllocated(serviceaccount, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.serviceaccount_.IsDefault()) {
    _impl_.serviceaccount_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpSpec.serviceAccount)
}

// optional bytes nodeName = 10;
inline bool CarpSpec::_internal_has_nodename() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CarpSpec::has_nodename() const {
  return _internal_has_nodename();
}
inline void CarpSpec::clear_nodename() {
  _impl_.nodename_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& CarpSpec::nodename() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpSpec.nodeName)
  return _internal_nodename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CarpSpec::set_nodename(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.nodename_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpSpec.nodeName)
}
inline std::string* CarpSpec::mutable_nodename() {
  std::string* _s = _internal_mutable_nodename();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpSpec.nodeName)
  return _s;
}
inline const std::string& CarpSpec::_internal_nodename() const {
  return _impl_.nodename_.Get();
}
inline void CarpSpec::_internal_set_nodename(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.nodename_.Set(value, GetArenaForAllocation());
}
inline std::string* CarpSpec::_internal_mutable_nodename() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.nodename_.Mutable(GetArenaForAllocation());
}
inline std::string* CarpSpec::release_nodename() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpSpec.nodeName)
  if (!_internal_has_nodename()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.nodename_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.nodename_.IsDefault()) {
    _impl_.nodename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CarpSpec::set_allocated_nodename(std::string* nodename) {
  if (nodename != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.nodename_.SetAllocated(nodename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.nodename_.IsDefault()) {
    _impl_.nodename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpSpec.nodeName)
}

// optional bool hostNetwork = 11;
inline bool CarpSpec::_internal_has_hostnetwork() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool CarpSpec::has_hostnetwork() const {
  return _internal_has_hostnetwork();
}
inline void CarpSpec::clear_hostnetwork() {
  _impl_.hostnetwork_ = false;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline bool CarpSpec::_internal_hostnetwork() const {
  return _impl_.hostnetwork_;
}
inline bool CarpSpec::hostnetwork() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpSpec.hostNetwork)
  return _internal_hostnetwork();
}
inline void CarpSpec::_internal_set_hostnetwork(bool value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.hostnetwork_ = value;
}
inline void CarpSpec::set_hostnetwork(bool value) {
  _internal_set_hostnetwork(value);
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpSpec.hostNetwork)
}

// optional bool hostPID = 12;
inline bool CarpSpec::_internal_has_hostpid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool CarpSpec::has_hostpid() const {
  return _internal_has_hostpid();
}
inline void CarpSpec::clear_hostpid() {
  _impl_.hostpid_ = false;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline bool CarpSpec::_internal_hostpid() const {
  return _impl_.hostpid_;
}
inline bool CarpSpec::hostpid() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpSpec.hostPID)
  return _internal_hostpid();
}
inline void CarpSpec::_internal_set_hostpid(bool value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.hostpid_ = value;
}
inline void CarpSpec::set_hostpid(bool value) {
  _internal_set_hostpid(value);
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpSpec.hostPID)
}

// optional bool hostIPC = 13;
inline bool CarpSpec::_internal_has_hostipc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool CarpSpec::has_hostipc() const {
  return _internal_has_hostipc();
}
inline void CarpSpec::clear_hostipc() {
  _impl_.hostipc_ = false;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline bool CarpSpec::_internal_hostipc() const {
  return _impl_.hostipc_;
}
inline bool CarpSpec::hostipc() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpSpec.hostIPC)
  return _internal_hostipc();
}
inline void CarpSpec::_internal_set_hostipc(bool value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.hostipc_ = value;
}
inline void CarpSpec::set_hostipc(bool value) {
  _internal_set_hostipc(value);
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpSpec.hostIPC)
}

// optional bytes hostname = 16;
inline bool CarpSpec::_internal_has_hostname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CarpSpec::has_hostname() const {
  return _internal_has_hostname();
}
inline void CarpSpec::clear_hostname() {
  _impl_.hostname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& CarpSpec::hostname() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpSpec.hostname)
  return _internal_hostname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CarpSpec::set_hostname(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.hostname_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpSpec.hostname)
}
inline std::string* CarpSpec::mutable_hostname() {
  std::string* _s = _internal_mutable_hostname();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpSpec.hostname)
  return _s;
}
inline const std::string& CarpSpec::_internal_hostname() const {
  return _impl_.hostname_.Get();
}
inline void CarpSpec::_internal_set_hostname(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.hostname_.Set(value, GetArenaForAllocation());
}
inline std::string* CarpSpec::_internal_mutable_hostname() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.hostname_.Mutable(GetArenaForAllocation());
}
inline std::string* CarpSpec::release_hostname() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpSpec.hostname)
  if (!_internal_has_hostname()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.hostname_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hostname_.IsDefault()) {
    _impl_.hostname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CarpSpec::set_allocated_hostname(std::string* hostname) {
  if (hostname != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.hostname_.SetAllocated(hostname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hostname_.IsDefault()) {
    _impl_.hostname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpSpec.hostname)
}

// optional bytes subdomain = 17;
inline bool CarpSpec::_internal_has_subdomain() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CarpSpec::has_subdomain() const {
  return _internal_has_subdomain();
}
inline void CarpSpec::clear_subdomain() {
  _impl_.subdomain_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& CarpSpec::subdomain() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpSpec.subdomain)
  return _internal_subdomain();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CarpSpec::set_subdomain(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000020u;
 _impl_.subdomain_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpSpec.subdomain)
}
inline std::string* CarpSpec::mutable_subdomain() {
  std::string* _s = _internal_mutable_subdomain();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpSpec.subdomain)
  return _s;
}
inline const std::string& CarpSpec::_internal_subdomain() const {
  return _impl_.subdomain_.Get();
}
inline void CarpSpec::_internal_set_subdomain(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.subdomain_.Set(value, GetArenaForAllocation());
}
inline std::string* CarpSpec::_internal_mutable_subdomain() {
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.subdomain_.Mutable(GetArenaForAllocation());
}
inline std::string* CarpSpec::release_subdomain() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpSpec.subdomain)
  if (!_internal_has_subdomain()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* p = _impl_.subdomain_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.subdomain_.IsDefault()) {
    _impl_.subdomain_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CarpSpec::set_allocated_subdomain(std::string* subdomain) {
  if (subdomain != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.subdomain_.SetAllocated(subdomain, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.subdomain_.IsDefault()) {
    _impl_.subdomain_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpSpec.subdomain)
}

// optional bytes schedulername = 19;
inline bool CarpSpec::_internal_has_schedulername() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CarpSpec::has_schedulername() const {
  return _internal_has_schedulername();
}
inline void CarpSpec::clear_schedulername() {
  _impl_.schedulername_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const std::string& CarpSpec::schedulername() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpSpec.schedulername)
  return _internal_schedulername();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CarpSpec::set_schedulername(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000040u;
 _impl_.schedulername_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpSpec.schedulername)
}
inline std::string* CarpSpec::mutable_schedulername() {
  std::string* _s = _internal_mutable_schedulername();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpSpec.schedulername)
  return _s;
}
inline const std::string& CarpSpec::_internal_schedulername() const {
  return _impl_.schedulername_.Get();
}
inline void CarpSpec::_internal_set_schedulername(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.schedulername_.Set(value, GetArenaForAllocation());
}
inline std::string* CarpSpec::_internal_mutable_schedulername() {
  _impl_._has_bits_[0] |= 0x00000040u;
  return _impl_.schedulername_.Mutable(GetArenaForAllocation());
}
inline std::string* CarpSpec::release_schedulername() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpSpec.schedulername)
  if (!_internal_has_schedulername()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000040u;
  auto* p = _impl_.schedulername_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.schedulername_.IsDefault()) {
    _impl_.schedulername_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CarpSpec::set_allocated_schedulername(std::string* schedulername) {
  if (schedulername != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.schedulername_.SetAllocated(schedulername, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.schedulername_.IsDefault()) {
    _impl_.schedulername_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpSpec.schedulername)
}

// -------------------------------------------------------------------

// CarpStatus

// optional bytes phase = 1;
inline bool CarpStatus::_internal_has_phase() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CarpStatus::has_phase() const {
  return _internal_has_phase();
}
inline void CarpStatus::clear_phase() {
  _impl_.phase_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CarpStatus::phase() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpStatus.phase)
  return _internal_phase();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CarpStatus::set_phase(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.phase_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpStatus.phase)
}
inline std::string* CarpStatus::mutable_phase() {
  std::string* _s = _internal_mutable_phase();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpStatus.phase)
  return _s;
}
inline const std::string& CarpStatus::_internal_phase() const {
  return _impl_.phase_.Get();
}
inline void CarpStatus::_internal_set_phase(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.phase_.Set(value, GetArenaForAllocation());
}
inline std::string* CarpStatus::_internal_mutable_phase() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.phase_.Mutable(GetArenaForAllocation());
}
inline std::string* CarpStatus::release_phase() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpStatus.phase)
  if (!_internal_has_phase()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.phase_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.phase_.IsDefault()) {
    _impl_.phase_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CarpStatus::set_allocated_phase(std::string* phase) {
  if (phase != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.phase_.SetAllocated(phase, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.phase_.IsDefault()) {
    _impl_.phase_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpStatus.phase)
}

// repeated .k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpCondition conditions = 2;
inline int CarpStatus::_internal_conditions_size() const {
  return _impl_.conditions_.size();
}
inline int CarpStatus::conditions_size() const {
  return _internal_conditions_size();
}
inline void CarpStatus::clear_conditions() {
  _impl_.conditions_.Clear();
}
inline ::k8s::io::apimachinery::pkg::apis::testapigroup::v1::CarpCondition* CarpStatus::mutable_conditions(int index) {
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpStatus.conditions)
  return _impl_.conditions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::k8s::io::apimachinery::pkg::apis::testapigroup::v1::CarpCondition >*
CarpStatus::mutable_conditions() {
  // @@protoc_insertion_point(field_mutable_list:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpStatus.conditions)
  return &_impl_.conditions_;
}
inline const ::k8s::io::apimachinery::pkg::apis::testapigroup::v1::CarpCondition& CarpStatus::_internal_conditions(int index) const {
  return _impl_.conditions_.Get(index);
}
inline const ::k8s::io::apimachinery::pkg::apis::testapigroup::v1::CarpCondition& CarpStatus::conditions(int index) const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpStatus.conditions)
  return _internal_conditions(index);
}
inline ::k8s::io::apimachinery::pkg::apis::testapigroup::v1::CarpCondition* CarpStatus::_internal_add_conditions() {
  return _impl_.conditions_.Add();
}
inline ::k8s::io::apimachinery::pkg::apis::testapigroup::v1::CarpCondition* CarpStatus::add_conditions() {
  ::k8s::io::apimachinery::pkg::apis::testapigroup::v1::CarpCondition* _add = _internal_add_conditions();
  // @@protoc_insertion_point(field_add:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpStatus.conditions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::k8s::io::apimachinery::pkg::apis::testapigroup::v1::CarpCondition >&
CarpStatus::conditions() const {
  // @@protoc_insertion_point(field_list:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpStatus.conditions)
  return _impl_.conditions_;
}

// optional bytes message = 3;
inline bool CarpStatus::_internal_has_message() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CarpStatus::has_message() const {
  return _internal_has_message();
}
inline void CarpStatus::clear_message() {
  _impl_.message_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CarpStatus::message() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpStatus.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CarpStatus::set_message(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.message_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpStatus.message)
}
inline std::string* CarpStatus::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpStatus.message)
  return _s;
}
inline const std::string& CarpStatus::_internal_message() const {
  return _impl_.message_.Get();
}
inline void CarpStatus::_internal_set_message(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* CarpStatus::_internal_mutable_message() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* CarpStatus::release_message() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpStatus.message)
  if (!_internal_has_message()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.message_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CarpStatus::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpStatus.message)
}

// optional bytes reason = 4;
inline bool CarpStatus::_internal_has_reason() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CarpStatus::has_reason() const {
  return _internal_has_reason();
}
inline void CarpStatus::clear_reason() {
  _impl_.reason_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CarpStatus::reason() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpStatus.reason)
  return _internal_reason();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CarpStatus::set_reason(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.reason_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpStatus.reason)
}
inline std::string* CarpStatus::mutable_reason() {
  std::string* _s = _internal_mutable_reason();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpStatus.reason)
  return _s;
}
inline const std::string& CarpStatus::_internal_reason() const {
  return _impl_.reason_.Get();
}
inline void CarpStatus::_internal_set_reason(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.reason_.Set(value, GetArenaForAllocation());
}
inline std::string* CarpStatus::_internal_mutable_reason() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.reason_.Mutable(GetArenaForAllocation());
}
inline std::string* CarpStatus::release_reason() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpStatus.reason)
  if (!_internal_has_reason()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.reason_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.reason_.IsDefault()) {
    _impl_.reason_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CarpStatus::set_allocated_reason(std::string* reason) {
  if (reason != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.reason_.SetAllocated(reason, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.reason_.IsDefault()) {
    _impl_.reason_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpStatus.reason)
}

// optional bytes hostIP = 5;
inline bool CarpStatus::_internal_has_hostip() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CarpStatus::has_hostip() const {
  return _internal_has_hostip();
}
inline void CarpStatus::clear_hostip() {
  _impl_.hostip_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& CarpStatus::hostip() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpStatus.hostIP)
  return _internal_hostip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CarpStatus::set_hostip(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.hostip_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpStatus.hostIP)
}
inline std::string* CarpStatus::mutable_hostip() {
  std::string* _s = _internal_mutable_hostip();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpStatus.hostIP)
  return _s;
}
inline const std::string& CarpStatus::_internal_hostip() const {
  return _impl_.hostip_.Get();
}
inline void CarpStatus::_internal_set_hostip(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.hostip_.Set(value, GetArenaForAllocation());
}
inline std::string* CarpStatus::_internal_mutable_hostip() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.hostip_.Mutable(GetArenaForAllocation());
}
inline std::string* CarpStatus::release_hostip() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpStatus.hostIP)
  if (!_internal_has_hostip()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.hostip_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hostip_.IsDefault()) {
    _impl_.hostip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CarpStatus::set_allocated_hostip(std::string* hostip) {
  if (hostip != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.hostip_.SetAllocated(hostip, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hostip_.IsDefault()) {
    _impl_.hostip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpStatus.hostIP)
}

// optional bytes carpIP = 6;
inline bool CarpStatus::_internal_has_carpip() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CarpStatus::has_carpip() const {
  return _internal_has_carpip();
}
inline void CarpStatus::clear_carpip() {
  _impl_.carpip_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& CarpStatus::carpip() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpStatus.carpIP)
  return _internal_carpip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CarpStatus::set_carpip(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.carpip_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpStatus.carpIP)
}
inline std::string* CarpStatus::mutable_carpip() {
  std::string* _s = _internal_mutable_carpip();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpStatus.carpIP)
  return _s;
}
inline const std::string& CarpStatus::_internal_carpip() const {
  return _impl_.carpip_.Get();
}
inline void CarpStatus::_internal_set_carpip(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.carpip_.Set(value, GetArenaForAllocation());
}
inline std::string* CarpStatus::_internal_mutable_carpip() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.carpip_.Mutable(GetArenaForAllocation());
}
inline std::string* CarpStatus::release_carpip() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpStatus.carpIP)
  if (!_internal_has_carpip()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.carpip_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.carpip_.IsDefault()) {
    _impl_.carpip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CarpStatus::set_allocated_carpip(std::string* carpip) {
  if (carpip != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.carpip_.SetAllocated(carpip, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.carpip_.IsDefault()) {
    _impl_.carpip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpStatus.carpIP)
}

// optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time startTime = 7;
inline bool CarpStatus::_internal_has_starttime() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.starttime_ != nullptr);
  return value;
}
inline bool CarpStatus::has_starttime() const {
  return _internal_has_starttime();
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::Time& CarpStatus::_internal_starttime() const {
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* p = _impl_.starttime_;
  return p != nullptr ? *p : reinterpret_cast<const ::k8s::io::apimachinery::pkg::apis::meta::v1::Time&>(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::_Time_default_instance_);
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::Time& CarpStatus::starttime() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpStatus.startTime)
  return _internal_starttime();
}
inline void CarpStatus::unsafe_arena_set_allocated_starttime(
    ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* starttime) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.starttime_);
  }
  _impl_.starttime_ = starttime;
  if (starttime) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpStatus.startTime)
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* CarpStatus::release_starttime() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* temp = _impl_.starttime_;
  _impl_.starttime_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* CarpStatus::unsafe_arena_release_starttime() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpStatus.startTime)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* temp = _impl_.starttime_;
  _impl_.starttime_ = nullptr;
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* CarpStatus::_internal_mutable_starttime() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.starttime_ == nullptr) {
    auto* p = CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::Time>(GetArenaForAllocation());
    _impl_.starttime_ = p;
  }
  return _impl_.starttime_;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* CarpStatus::mutable_starttime() {
  ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* _msg = _internal_mutable_starttime();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpStatus.startTime)
  return _msg;
}
inline void CarpStatus::set_allocated_starttime(::k8s::io::apimachinery::pkg::apis::meta::v1::Time* starttime) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.starttime_);
  }
  if (starttime) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(starttime));
    if (message_arena != submessage_arena) {
      starttime = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, starttime, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.starttime_ = starttime;
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.testapigroup.v1.CarpStatus.startTime)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace testapigroup
}  // namespace apis
}  // namespace pkg
}  // namespace apimachinery
}  // namespace io
}  // namespace k8s

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_staging_5fsrc_5fk8s_2eio_5fapimachinery_5fpkg_5fapis_5ftestapigroup_5fv1_5fgenerated_2eproto
