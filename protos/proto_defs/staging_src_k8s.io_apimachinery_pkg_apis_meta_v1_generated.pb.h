// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: staging_src_k8s.io_apimachinery_pkg_apis_meta_v1_generated.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_staging_5fsrc_5fk8s_2eio_5fapimachinery_5fpkg_5fapis_5fmeta_5fv1_5fgenerated_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_staging_5fsrc_5fk8s_2eio_5fapimachinery_5fpkg_5fapis_5fmeta_5fv1_5fgenerated_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
#include "staging_src_k8s.io_apimachinery_pkg_runtime_generated.pb.h"
#include "staging_src_k8s.io_apimachinery_pkg_runtime_schema_generated.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_staging_5fsrc_5fk8s_2eio_5fapimachinery_5fpkg_5fapis_5fmeta_5fv1_5fgenerated_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_staging_5fsrc_5fk8s_2eio_5fapimachinery_5fpkg_5fapis_5fmeta_5fv1_5fgenerated_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_staging_5fsrc_5fk8s_2eio_5fapimachinery_5fpkg_5fapis_5fmeta_5fv1_5fgenerated_2eproto;
namespace k8s {
namespace io {
namespace apimachinery {
namespace pkg {
namespace apis {
namespace meta {
namespace v1 {
class APIGroup;
struct APIGroupDefaultTypeInternal;
extern APIGroupDefaultTypeInternal _APIGroup_default_instance_;
class APIGroupList;
struct APIGroupListDefaultTypeInternal;
extern APIGroupListDefaultTypeInternal _APIGroupList_default_instance_;
class APIResource;
struct APIResourceDefaultTypeInternal;
extern APIResourceDefaultTypeInternal _APIResource_default_instance_;
class APIResourceList;
struct APIResourceListDefaultTypeInternal;
extern APIResourceListDefaultTypeInternal _APIResourceList_default_instance_;
class APIVersions;
struct APIVersionsDefaultTypeInternal;
extern APIVersionsDefaultTypeInternal _APIVersions_default_instance_;
class ApplyOptions;
struct ApplyOptionsDefaultTypeInternal;
extern ApplyOptionsDefaultTypeInternal _ApplyOptions_default_instance_;
class Condition;
struct ConditionDefaultTypeInternal;
extern ConditionDefaultTypeInternal _Condition_default_instance_;
class CreateOptions;
struct CreateOptionsDefaultTypeInternal;
extern CreateOptionsDefaultTypeInternal _CreateOptions_default_instance_;
class DeleteOptions;
struct DeleteOptionsDefaultTypeInternal;
extern DeleteOptionsDefaultTypeInternal _DeleteOptions_default_instance_;
class Duration;
struct DurationDefaultTypeInternal;
extern DurationDefaultTypeInternal _Duration_default_instance_;
class FieldsV1;
struct FieldsV1DefaultTypeInternal;
extern FieldsV1DefaultTypeInternal _FieldsV1_default_instance_;
class GetOptions;
struct GetOptionsDefaultTypeInternal;
extern GetOptionsDefaultTypeInternal _GetOptions_default_instance_;
class GroupKind;
struct GroupKindDefaultTypeInternal;
extern GroupKindDefaultTypeInternal _GroupKind_default_instance_;
class GroupResource;
struct GroupResourceDefaultTypeInternal;
extern GroupResourceDefaultTypeInternal _GroupResource_default_instance_;
class GroupVersion;
struct GroupVersionDefaultTypeInternal;
extern GroupVersionDefaultTypeInternal _GroupVersion_default_instance_;
class GroupVersionForDiscovery;
struct GroupVersionForDiscoveryDefaultTypeInternal;
extern GroupVersionForDiscoveryDefaultTypeInternal _GroupVersionForDiscovery_default_instance_;
class GroupVersionKind;
struct GroupVersionKindDefaultTypeInternal;
extern GroupVersionKindDefaultTypeInternal _GroupVersionKind_default_instance_;
class GroupVersionResource;
struct GroupVersionResourceDefaultTypeInternal;
extern GroupVersionResourceDefaultTypeInternal _GroupVersionResource_default_instance_;
class LabelSelector;
struct LabelSelectorDefaultTypeInternal;
extern LabelSelectorDefaultTypeInternal _LabelSelector_default_instance_;
class LabelSelectorRequirement;
struct LabelSelectorRequirementDefaultTypeInternal;
extern LabelSelectorRequirementDefaultTypeInternal _LabelSelectorRequirement_default_instance_;
class LabelSelector_MatchLabelsEntry_DoNotUse;
struct LabelSelector_MatchLabelsEntry_DoNotUseDefaultTypeInternal;
extern LabelSelector_MatchLabelsEntry_DoNotUseDefaultTypeInternal _LabelSelector_MatchLabelsEntry_DoNotUse_default_instance_;
class List;
struct ListDefaultTypeInternal;
extern ListDefaultTypeInternal _List_default_instance_;
class ListMeta;
struct ListMetaDefaultTypeInternal;
extern ListMetaDefaultTypeInternal _ListMeta_default_instance_;
class ListOptions;
struct ListOptionsDefaultTypeInternal;
extern ListOptionsDefaultTypeInternal _ListOptions_default_instance_;
class ManagedFieldsEntry;
struct ManagedFieldsEntryDefaultTypeInternal;
extern ManagedFieldsEntryDefaultTypeInternal _ManagedFieldsEntry_default_instance_;
class MicroTime;
struct MicroTimeDefaultTypeInternal;
extern MicroTimeDefaultTypeInternal _MicroTime_default_instance_;
class ObjectMeta;
struct ObjectMetaDefaultTypeInternal;
extern ObjectMetaDefaultTypeInternal _ObjectMeta_default_instance_;
class ObjectMeta_AnnotationsEntry_DoNotUse;
struct ObjectMeta_AnnotationsEntry_DoNotUseDefaultTypeInternal;
extern ObjectMeta_AnnotationsEntry_DoNotUseDefaultTypeInternal _ObjectMeta_AnnotationsEntry_DoNotUse_default_instance_;
class ObjectMeta_LabelsEntry_DoNotUse;
struct ObjectMeta_LabelsEntry_DoNotUseDefaultTypeInternal;
extern ObjectMeta_LabelsEntry_DoNotUseDefaultTypeInternal _ObjectMeta_LabelsEntry_DoNotUse_default_instance_;
class OwnerReference;
struct OwnerReferenceDefaultTypeInternal;
extern OwnerReferenceDefaultTypeInternal _OwnerReference_default_instance_;
class PartialObjectMetadata;
struct PartialObjectMetadataDefaultTypeInternal;
extern PartialObjectMetadataDefaultTypeInternal _PartialObjectMetadata_default_instance_;
class PartialObjectMetadataList;
struct PartialObjectMetadataListDefaultTypeInternal;
extern PartialObjectMetadataListDefaultTypeInternal _PartialObjectMetadataList_default_instance_;
class Patch;
struct PatchDefaultTypeInternal;
extern PatchDefaultTypeInternal _Patch_default_instance_;
class PatchOptions;
struct PatchOptionsDefaultTypeInternal;
extern PatchOptionsDefaultTypeInternal _PatchOptions_default_instance_;
class Preconditions;
struct PreconditionsDefaultTypeInternal;
extern PreconditionsDefaultTypeInternal _Preconditions_default_instance_;
class RootPaths;
struct RootPathsDefaultTypeInternal;
extern RootPathsDefaultTypeInternal _RootPaths_default_instance_;
class ServerAddressByClientCIDR;
struct ServerAddressByClientCIDRDefaultTypeInternal;
extern ServerAddressByClientCIDRDefaultTypeInternal _ServerAddressByClientCIDR_default_instance_;
class Status;
struct StatusDefaultTypeInternal;
extern StatusDefaultTypeInternal _Status_default_instance_;
class StatusCause;
struct StatusCauseDefaultTypeInternal;
extern StatusCauseDefaultTypeInternal _StatusCause_default_instance_;
class StatusDetails;
struct StatusDetailsDefaultTypeInternal;
extern StatusDetailsDefaultTypeInternal _StatusDetails_default_instance_;
class TableOptions;
struct TableOptionsDefaultTypeInternal;
extern TableOptionsDefaultTypeInternal _TableOptions_default_instance_;
class Time;
struct TimeDefaultTypeInternal;
extern TimeDefaultTypeInternal _Time_default_instance_;
class Timestamp;
struct TimestampDefaultTypeInternal;
extern TimestampDefaultTypeInternal _Timestamp_default_instance_;
class TypeMeta;
struct TypeMetaDefaultTypeInternal;
extern TypeMetaDefaultTypeInternal _TypeMeta_default_instance_;
class UpdateOptions;
struct UpdateOptionsDefaultTypeInternal;
extern UpdateOptionsDefaultTypeInternal _UpdateOptions_default_instance_;
class Verbs;
struct VerbsDefaultTypeInternal;
extern VerbsDefaultTypeInternal _Verbs_default_instance_;
class WatchEvent;
struct WatchEventDefaultTypeInternal;
extern WatchEventDefaultTypeInternal _WatchEvent_default_instance_;
}  // namespace v1
}  // namespace meta
}  // namespace apis
}  // namespace pkg
}  // namespace apimachinery
}  // namespace io
}  // namespace k8s
PROTOBUF_NAMESPACE_OPEN
template<> ::k8s::io::apimachinery::pkg::apis::meta::v1::APIGroup* Arena::CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::APIGroup>(Arena*);
template<> ::k8s::io::apimachinery::pkg::apis::meta::v1::APIGroupList* Arena::CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::APIGroupList>(Arena*);
template<> ::k8s::io::apimachinery::pkg::apis::meta::v1::APIResource* Arena::CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::APIResource>(Arena*);
template<> ::k8s::io::apimachinery::pkg::apis::meta::v1::APIResourceList* Arena::CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::APIResourceList>(Arena*);
template<> ::k8s::io::apimachinery::pkg::apis::meta::v1::APIVersions* Arena::CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::APIVersions>(Arena*);
template<> ::k8s::io::apimachinery::pkg::apis::meta::v1::ApplyOptions* Arena::CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::ApplyOptions>(Arena*);
template<> ::k8s::io::apimachinery::pkg::apis::meta::v1::Condition* Arena::CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::Condition>(Arena*);
template<> ::k8s::io::apimachinery::pkg::apis::meta::v1::CreateOptions* Arena::CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::CreateOptions>(Arena*);
template<> ::k8s::io::apimachinery::pkg::apis::meta::v1::DeleteOptions* Arena::CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::DeleteOptions>(Arena*);
template<> ::k8s::io::apimachinery::pkg::apis::meta::v1::Duration* Arena::CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::Duration>(Arena*);
template<> ::k8s::io::apimachinery::pkg::apis::meta::v1::FieldsV1* Arena::CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::FieldsV1>(Arena*);
template<> ::k8s::io::apimachinery::pkg::apis::meta::v1::GetOptions* Arena::CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::GetOptions>(Arena*);
template<> ::k8s::io::apimachinery::pkg::apis::meta::v1::GroupKind* Arena::CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::GroupKind>(Arena*);
template<> ::k8s::io::apimachinery::pkg::apis::meta::v1::GroupResource* Arena::CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::GroupResource>(Arena*);
template<> ::k8s::io::apimachinery::pkg::apis::meta::v1::GroupVersion* Arena::CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::GroupVersion>(Arena*);
template<> ::k8s::io::apimachinery::pkg::apis::meta::v1::GroupVersionForDiscovery* Arena::CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::GroupVersionForDiscovery>(Arena*);
template<> ::k8s::io::apimachinery::pkg::apis::meta::v1::GroupVersionKind* Arena::CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::GroupVersionKind>(Arena*);
template<> ::k8s::io::apimachinery::pkg::apis::meta::v1::GroupVersionResource* Arena::CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::GroupVersionResource>(Arena*);
template<> ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector* Arena::CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector>(Arena*);
template<> ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelectorRequirement* Arena::CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelectorRequirement>(Arena*);
template<> ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector_MatchLabelsEntry_DoNotUse* Arena::CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelector_MatchLabelsEntry_DoNotUse>(Arena*);
template<> ::k8s::io::apimachinery::pkg::apis::meta::v1::List* Arena::CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::List>(Arena*);
template<> ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* Arena::CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta>(Arena*);
template<> ::k8s::io::apimachinery::pkg::apis::meta::v1::ListOptions* Arena::CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::ListOptions>(Arena*);
template<> ::k8s::io::apimachinery::pkg::apis::meta::v1::ManagedFieldsEntry* Arena::CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::ManagedFieldsEntry>(Arena*);
template<> ::k8s::io::apimachinery::pkg::apis::meta::v1::MicroTime* Arena::CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::MicroTime>(Arena*);
template<> ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* Arena::CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta>(Arena*);
template<> ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta_AnnotationsEntry_DoNotUse* Arena::CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta_AnnotationsEntry_DoNotUse>(Arena*);
template<> ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta_LabelsEntry_DoNotUse* Arena::CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta_LabelsEntry_DoNotUse>(Arena*);
template<> ::k8s::io::apimachinery::pkg::apis::meta::v1::OwnerReference* Arena::CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::OwnerReference>(Arena*);
template<> ::k8s::io::apimachinery::pkg::apis::meta::v1::PartialObjectMetadata* Arena::CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::PartialObjectMetadata>(Arena*);
template<> ::k8s::io::apimachinery::pkg::apis::meta::v1::PartialObjectMetadataList* Arena::CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::PartialObjectMetadataList>(Arena*);
template<> ::k8s::io::apimachinery::pkg::apis::meta::v1::Patch* Arena::CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::Patch>(Arena*);
template<> ::k8s::io::apimachinery::pkg::apis::meta::v1::PatchOptions* Arena::CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::PatchOptions>(Arena*);
template<> ::k8s::io::apimachinery::pkg::apis::meta::v1::Preconditions* Arena::CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::Preconditions>(Arena*);
template<> ::k8s::io::apimachinery::pkg::apis::meta::v1::RootPaths* Arena::CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::RootPaths>(Arena*);
template<> ::k8s::io::apimachinery::pkg::apis::meta::v1::ServerAddressByClientCIDR* Arena::CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::ServerAddressByClientCIDR>(Arena*);
template<> ::k8s::io::apimachinery::pkg::apis::meta::v1::Status* Arena::CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::Status>(Arena*);
template<> ::k8s::io::apimachinery::pkg::apis::meta::v1::StatusCause* Arena::CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::StatusCause>(Arena*);
template<> ::k8s::io::apimachinery::pkg::apis::meta::v1::StatusDetails* Arena::CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::StatusDetails>(Arena*);
template<> ::k8s::io::apimachinery::pkg::apis::meta::v1::TableOptions* Arena::CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::TableOptions>(Arena*);
template<> ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* Arena::CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::Time>(Arena*);
template<> ::k8s::io::apimachinery::pkg::apis::meta::v1::Timestamp* Arena::CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::Timestamp>(Arena*);
template<> ::k8s::io::apimachinery::pkg::apis::meta::v1::TypeMeta* Arena::CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::TypeMeta>(Arena*);
template<> ::k8s::io::apimachinery::pkg::apis::meta::v1::UpdateOptions* Arena::CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::UpdateOptions>(Arena*);
template<> ::k8s::io::apimachinery::pkg::apis::meta::v1::Verbs* Arena::CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::Verbs>(Arena*);
template<> ::k8s::io::apimachinery::pkg::apis::meta::v1::WatchEvent* Arena::CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::WatchEvent>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace k8s {
namespace io {
namespace apimachinery {
namespace pkg {
namespace apis {
namespace meta {
namespace v1 {

// ===================================================================

class APIGroup final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:k8s.io.apimachinery.pkg.apis.meta.v1.APIGroup) */ {
 public:
  inline APIGroup() : APIGroup(nullptr) {}
  ~APIGroup() override;
  explicit PROTOBUF_CONSTEXPR APIGroup(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  APIGroup(const APIGroup& from);
  APIGroup(APIGroup&& from) noexcept
    : APIGroup() {
    *this = ::std::move(from);
  }

  inline APIGroup& operator=(const APIGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline APIGroup& operator=(APIGroup&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const APIGroup& default_instance() {
    return *internal_default_instance();
  }
  static inline const APIGroup* internal_default_instance() {
    return reinterpret_cast<const APIGroup*>(
               &_APIGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(APIGroup& a, APIGroup& b) {
    a.Swap(&b);
  }
  inline void Swap(APIGroup* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(APIGroup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  APIGroup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<APIGroup>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const APIGroup& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const APIGroup& from) {
    APIGroup::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(APIGroup* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "k8s.io.apimachinery.pkg.apis.meta.v1.APIGroup";
  }
  protected:
  explicit APIGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionsFieldNumber = 2,
    kServerAddressByClientCIDRsFieldNumber = 4,
    kNameFieldNumber = 1,
    kPreferredVersionFieldNumber = 3,
  };
  // repeated .k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery versions = 2;
  int versions_size() const;
  private:
  int _internal_versions_size() const;
  public:
  void clear_versions();
  ::k8s::io::apimachinery::pkg::apis::meta::v1::GroupVersionForDiscovery* mutable_versions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::k8s::io::apimachinery::pkg::apis::meta::v1::GroupVersionForDiscovery >*
      mutable_versions();
  private:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::GroupVersionForDiscovery& _internal_versions(int index) const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::GroupVersionForDiscovery* _internal_add_versions();
  public:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::GroupVersionForDiscovery& versions(int index) const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::GroupVersionForDiscovery* add_versions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::k8s::io::apimachinery::pkg::apis::meta::v1::GroupVersionForDiscovery >&
      versions() const;

  // repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR serverAddressByClientCIDRs = 4;
  int serveraddressbyclientcidrs_size() const;
  private:
  int _internal_serveraddressbyclientcidrs_size() const;
  public:
  void clear_serveraddressbyclientcidrs();
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ServerAddressByClientCIDR* mutable_serveraddressbyclientcidrs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::k8s::io::apimachinery::pkg::apis::meta::v1::ServerAddressByClientCIDR >*
      mutable_serveraddressbyclientcidrs();
  private:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ServerAddressByClientCIDR& _internal_serveraddressbyclientcidrs(int index) const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ServerAddressByClientCIDR* _internal_add_serveraddressbyclientcidrs();
  public:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ServerAddressByClientCIDR& serveraddressbyclientcidrs(int index) const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ServerAddressByClientCIDR* add_serveraddressbyclientcidrs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::k8s::io::apimachinery::pkg::apis::meta::v1::ServerAddressByClientCIDR >&
      serveraddressbyclientcidrs() const;

  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery preferredVersion = 3;
  bool has_preferredversion() const;
  private:
  bool _internal_has_preferredversion() const;
  public:
  void clear_preferredversion();
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::GroupVersionForDiscovery& preferredversion() const;
  PROTOBUF_NODISCARD ::k8s::io::apimachinery::pkg::apis::meta::v1::GroupVersionForDiscovery* release_preferredversion();
  ::k8s::io::apimachinery::pkg::apis::meta::v1::GroupVersionForDiscovery* mutable_preferredversion();
  void set_allocated_preferredversion(::k8s::io::apimachinery::pkg::apis::meta::v1::GroupVersionForDiscovery* preferredversion);
  private:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::GroupVersionForDiscovery& _internal_preferredversion() const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::GroupVersionForDiscovery* _internal_mutable_preferredversion();
  public:
  void unsafe_arena_set_allocated_preferredversion(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::GroupVersionForDiscovery* preferredversion);
  ::k8s::io::apimachinery::pkg::apis::meta::v1::GroupVersionForDiscovery* unsafe_arena_release_preferredversion();

  // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.APIGroup)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::k8s::io::apimachinery::pkg::apis::meta::v1::GroupVersionForDiscovery > versions_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::k8s::io::apimachinery::pkg::apis::meta::v1::ServerAddressByClientCIDR > serveraddressbyclientcidrs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::k8s::io::apimachinery::pkg::apis::meta::v1::GroupVersionForDiscovery* preferredversion_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_staging_5fsrc_5fk8s_2eio_5fapimachinery_5fpkg_5fapis_5fmeta_5fv1_5fgenerated_2eproto;
};
// -------------------------------------------------------------------

class APIGroupList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:k8s.io.apimachinery.pkg.apis.meta.v1.APIGroupList) */ {
 public:
  inline APIGroupList() : APIGroupList(nullptr) {}
  ~APIGroupList() override;
  explicit PROTOBUF_CONSTEXPR APIGroupList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  APIGroupList(const APIGroupList& from);
  APIGroupList(APIGroupList&& from) noexcept
    : APIGroupList() {
    *this = ::std::move(from);
  }

  inline APIGroupList& operator=(const APIGroupList& from) {
    CopyFrom(from);
    return *this;
  }
  inline APIGroupList& operator=(APIGroupList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const APIGroupList& default_instance() {
    return *internal_default_instance();
  }
  static inline const APIGroupList* internal_default_instance() {
    return reinterpret_cast<const APIGroupList*>(
               &_APIGroupList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(APIGroupList& a, APIGroupList& b) {
    a.Swap(&b);
  }
  inline void Swap(APIGroupList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(APIGroupList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  APIGroupList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<APIGroupList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const APIGroupList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const APIGroupList& from) {
    APIGroupList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(APIGroupList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "k8s.io.apimachinery.pkg.apis.meta.v1.APIGroupList";
  }
  protected:
  explicit APIGroupList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupsFieldNumber = 1,
  };
  // repeated .k8s.io.apimachinery.pkg.apis.meta.v1.APIGroup groups = 1;
  int groups_size() const;
  private:
  int _internal_groups_size() const;
  public:
  void clear_groups();
  ::k8s::io::apimachinery::pkg::apis::meta::v1::APIGroup* mutable_groups(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::k8s::io::apimachinery::pkg::apis::meta::v1::APIGroup >*
      mutable_groups();
  private:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::APIGroup& _internal_groups(int index) const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::APIGroup* _internal_add_groups();
  public:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::APIGroup& groups(int index) const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::APIGroup* add_groups();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::k8s::io::apimachinery::pkg::apis::meta::v1::APIGroup >&
      groups() const;

  // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.APIGroupList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::k8s::io::apimachinery::pkg::apis::meta::v1::APIGroup > groups_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_staging_5fsrc_5fk8s_2eio_5fapimachinery_5fpkg_5fapis_5fmeta_5fv1_5fgenerated_2eproto;
};
// -------------------------------------------------------------------

class APIResource final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:k8s.io.apimachinery.pkg.apis.meta.v1.APIResource) */ {
 public:
  inline APIResource() : APIResource(nullptr) {}
  ~APIResource() override;
  explicit PROTOBUF_CONSTEXPR APIResource(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  APIResource(const APIResource& from);
  APIResource(APIResource&& from) noexcept
    : APIResource() {
    *this = ::std::move(from);
  }

  inline APIResource& operator=(const APIResource& from) {
    CopyFrom(from);
    return *this;
  }
  inline APIResource& operator=(APIResource&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const APIResource& default_instance() {
    return *internal_default_instance();
  }
  static inline const APIResource* internal_default_instance() {
    return reinterpret_cast<const APIResource*>(
               &_APIResource_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(APIResource& a, APIResource& b) {
    a.Swap(&b);
  }
  inline void Swap(APIResource* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(APIResource* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  APIResource* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<APIResource>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const APIResource& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const APIResource& from) {
    APIResource::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(APIResource* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "k8s.io.apimachinery.pkg.apis.meta.v1.APIResource";
  }
  protected:
  explicit APIResource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShortNamesFieldNumber = 5,
    kCategoriesFieldNumber = 7,
    kNameFieldNumber = 1,
    kKindFieldNumber = 3,
    kSingularNameFieldNumber = 6,
    kGroupFieldNumber = 8,
    kVersionFieldNumber = 9,
    kStorageVersionHashFieldNumber = 10,
    kVerbsFieldNumber = 4,
    kNamespacedFieldNumber = 2,
  };
  // repeated string shortNames = 5;
  int shortnames_size() const;
  private:
  int _internal_shortnames_size() const;
  public:
  void clear_shortnames();
  const std::string& shortnames(int index) const;
  std::string* mutable_shortnames(int index);
  void set_shortnames(int index, const std::string& value);
  void set_shortnames(int index, std::string&& value);
  void set_shortnames(int index, const char* value);
  void set_shortnames(int index, const char* value, size_t size);
  std::string* add_shortnames();
  void add_shortnames(const std::string& value);
  void add_shortnames(std::string&& value);
  void add_shortnames(const char* value);
  void add_shortnames(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& shortnames() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_shortnames();
  private:
  const std::string& _internal_shortnames(int index) const;
  std::string* _internal_add_shortnames();
  public:

  // repeated string categories = 7;
  int categories_size() const;
  private:
  int _internal_categories_size() const;
  public:
  void clear_categories();
  const std::string& categories(int index) const;
  std::string* mutable_categories(int index);
  void set_categories(int index, const std::string& value);
  void set_categories(int index, std::string&& value);
  void set_categories(int index, const char* value);
  void set_categories(int index, const char* value, size_t size);
  std::string* add_categories();
  void add_categories(const std::string& value);
  void add_categories(std::string&& value);
  void add_categories(const char* value);
  void add_categories(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& categories() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_categories();
  private:
  const std::string& _internal_categories(int index) const;
  std::string* _internal_add_categories();
  public:

  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string kind = 3;
  bool has_kind() const;
  private:
  bool _internal_has_kind() const;
  public:
  void clear_kind();
  const std::string& kind() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_kind(ArgT0&& arg0, ArgT... args);
  std::string* mutable_kind();
  PROTOBUF_NODISCARD std::string* release_kind();
  void set_allocated_kind(std::string* kind);
  private:
  const std::string& _internal_kind() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_kind(const std::string& value);
  std::string* _internal_mutable_kind();
  public:

  // optional string singularName = 6;
  bool has_singularname() const;
  private:
  bool _internal_has_singularname() const;
  public:
  void clear_singularname();
  const std::string& singularname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_singularname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_singularname();
  PROTOBUF_NODISCARD std::string* release_singularname();
  void set_allocated_singularname(std::string* singularname);
  private:
  const std::string& _internal_singularname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_singularname(const std::string& value);
  std::string* _internal_mutable_singularname();
  public:

  // optional string group = 8;
  bool has_group() const;
  private:
  bool _internal_has_group() const;
  public:
  void clear_group();
  const std::string& group() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_group(ArgT0&& arg0, ArgT... args);
  std::string* mutable_group();
  PROTOBUF_NODISCARD std::string* release_group();
  void set_allocated_group(std::string* group);
  private:
  const std::string& _internal_group() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_group(const std::string& value);
  std::string* _internal_mutable_group();
  public:

  // optional string version = 9;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // optional string storageVersionHash = 10;
  bool has_storageversionhash() const;
  private:
  bool _internal_has_storageversionhash() const;
  public:
  void clear_storageversionhash();
  const std::string& storageversionhash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_storageversionhash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_storageversionhash();
  PROTOBUF_NODISCARD std::string* release_storageversionhash();
  void set_allocated_storageversionhash(std::string* storageversionhash);
  private:
  const std::string& _internal_storageversionhash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_storageversionhash(const std::string& value);
  std::string* _internal_mutable_storageversionhash();
  public:

  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Verbs verbs = 4;
  bool has_verbs() const;
  private:
  bool _internal_has_verbs() const;
  public:
  void clear_verbs();
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::Verbs& verbs() const;
  PROTOBUF_NODISCARD ::k8s::io::apimachinery::pkg::apis::meta::v1::Verbs* release_verbs();
  ::k8s::io::apimachinery::pkg::apis::meta::v1::Verbs* mutable_verbs();
  void set_allocated_verbs(::k8s::io::apimachinery::pkg::apis::meta::v1::Verbs* verbs);
  private:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::Verbs& _internal_verbs() const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::Verbs* _internal_mutable_verbs();
  public:
  void unsafe_arena_set_allocated_verbs(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::Verbs* verbs);
  ::k8s::io::apimachinery::pkg::apis::meta::v1::Verbs* unsafe_arena_release_verbs();

  // optional bool namespaced = 2;
  bool has_namespaced() const;
  private:
  bool _internal_has_namespaced() const;
  public:
  void clear_namespaced();
  bool namespaced() const;
  void set_namespaced(bool value);
  private:
  bool _internal_namespaced() const;
  void _internal_set_namespaced(bool value);
  public:

  // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.APIResource)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> shortnames_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> categories_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr kind_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr singularname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr group_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr storageversionhash_;
    ::k8s::io::apimachinery::pkg::apis::meta::v1::Verbs* verbs_;
    bool namespaced_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_staging_5fsrc_5fk8s_2eio_5fapimachinery_5fpkg_5fapis_5fmeta_5fv1_5fgenerated_2eproto;
};
// -------------------------------------------------------------------

class APIResourceList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:k8s.io.apimachinery.pkg.apis.meta.v1.APIResourceList) */ {
 public:
  inline APIResourceList() : APIResourceList(nullptr) {}
  ~APIResourceList() override;
  explicit PROTOBUF_CONSTEXPR APIResourceList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  APIResourceList(const APIResourceList& from);
  APIResourceList(APIResourceList&& from) noexcept
    : APIResourceList() {
    *this = ::std::move(from);
  }

  inline APIResourceList& operator=(const APIResourceList& from) {
    CopyFrom(from);
    return *this;
  }
  inline APIResourceList& operator=(APIResourceList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const APIResourceList& default_instance() {
    return *internal_default_instance();
  }
  static inline const APIResourceList* internal_default_instance() {
    return reinterpret_cast<const APIResourceList*>(
               &_APIResourceList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(APIResourceList& a, APIResourceList& b) {
    a.Swap(&b);
  }
  inline void Swap(APIResourceList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(APIResourceList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  APIResourceList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<APIResourceList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const APIResourceList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const APIResourceList& from) {
    APIResourceList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(APIResourceList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "k8s.io.apimachinery.pkg.apis.meta.v1.APIResourceList";
  }
  protected:
  explicit APIResourceList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResourcesFieldNumber = 2,
    kGroupVersionFieldNumber = 1,
  };
  // repeated .k8s.io.apimachinery.pkg.apis.meta.v1.APIResource resources = 2;
  int resources_size() const;
  private:
  int _internal_resources_size() const;
  public:
  void clear_resources();
  ::k8s::io::apimachinery::pkg::apis::meta::v1::APIResource* mutable_resources(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::k8s::io::apimachinery::pkg::apis::meta::v1::APIResource >*
      mutable_resources();
  private:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::APIResource& _internal_resources(int index) const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::APIResource* _internal_add_resources();
  public:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::APIResource& resources(int index) const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::APIResource* add_resources();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::k8s::io::apimachinery::pkg::apis::meta::v1::APIResource >&
      resources() const;

  // optional string groupVersion = 1;
  bool has_groupversion() const;
  private:
  bool _internal_has_groupversion() const;
  public:
  void clear_groupversion();
  const std::string& groupversion() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_groupversion(ArgT0&& arg0, ArgT... args);
  std::string* mutable_groupversion();
  PROTOBUF_NODISCARD std::string* release_groupversion();
  void set_allocated_groupversion(std::string* groupversion);
  private:
  const std::string& _internal_groupversion() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_groupversion(const std::string& value);
  std::string* _internal_mutable_groupversion();
  public:

  // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.APIResourceList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::k8s::io::apimachinery::pkg::apis::meta::v1::APIResource > resources_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr groupversion_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_staging_5fsrc_5fk8s_2eio_5fapimachinery_5fpkg_5fapis_5fmeta_5fv1_5fgenerated_2eproto;
};
// -------------------------------------------------------------------

class APIVersions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:k8s.io.apimachinery.pkg.apis.meta.v1.APIVersions) */ {
 public:
  inline APIVersions() : APIVersions(nullptr) {}
  ~APIVersions() override;
  explicit PROTOBUF_CONSTEXPR APIVersions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  APIVersions(const APIVersions& from);
  APIVersions(APIVersions&& from) noexcept
    : APIVersions() {
    *this = ::std::move(from);
  }

  inline APIVersions& operator=(const APIVersions& from) {
    CopyFrom(from);
    return *this;
  }
  inline APIVersions& operator=(APIVersions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const APIVersions& default_instance() {
    return *internal_default_instance();
  }
  static inline const APIVersions* internal_default_instance() {
    return reinterpret_cast<const APIVersions*>(
               &_APIVersions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(APIVersions& a, APIVersions& b) {
    a.Swap(&b);
  }
  inline void Swap(APIVersions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(APIVersions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  APIVersions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<APIVersions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const APIVersions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const APIVersions& from) {
    APIVersions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(APIVersions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "k8s.io.apimachinery.pkg.apis.meta.v1.APIVersions";
  }
  protected:
  explicit APIVersions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionsFieldNumber = 1,
    kServerAddressByClientCIDRsFieldNumber = 2,
  };
  // repeated string versions = 1;
  int versions_size() const;
  private:
  int _internal_versions_size() const;
  public:
  void clear_versions();
  const std::string& versions(int index) const;
  std::string* mutable_versions(int index);
  void set_versions(int index, const std::string& value);
  void set_versions(int index, std::string&& value);
  void set_versions(int index, const char* value);
  void set_versions(int index, const char* value, size_t size);
  std::string* add_versions();
  void add_versions(const std::string& value);
  void add_versions(std::string&& value);
  void add_versions(const char* value);
  void add_versions(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& versions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_versions();
  private:
  const std::string& _internal_versions(int index) const;
  std::string* _internal_add_versions();
  public:

  // repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR serverAddressByClientCIDRs = 2;
  int serveraddressbyclientcidrs_size() const;
  private:
  int _internal_serveraddressbyclientcidrs_size() const;
  public:
  void clear_serveraddressbyclientcidrs();
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ServerAddressByClientCIDR* mutable_serveraddressbyclientcidrs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::k8s::io::apimachinery::pkg::apis::meta::v1::ServerAddressByClientCIDR >*
      mutable_serveraddressbyclientcidrs();
  private:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ServerAddressByClientCIDR& _internal_serveraddressbyclientcidrs(int index) const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ServerAddressByClientCIDR* _internal_add_serveraddressbyclientcidrs();
  public:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ServerAddressByClientCIDR& serveraddressbyclientcidrs(int index) const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ServerAddressByClientCIDR* add_serveraddressbyclientcidrs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::k8s::io::apimachinery::pkg::apis::meta::v1::ServerAddressByClientCIDR >&
      serveraddressbyclientcidrs() const;

  // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.APIVersions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> versions_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::k8s::io::apimachinery::pkg::apis::meta::v1::ServerAddressByClientCIDR > serveraddressbyclientcidrs_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_staging_5fsrc_5fk8s_2eio_5fapimachinery_5fpkg_5fapis_5fmeta_5fv1_5fgenerated_2eproto;
};
// -------------------------------------------------------------------

class ApplyOptions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:k8s.io.apimachinery.pkg.apis.meta.v1.ApplyOptions) */ {
 public:
  inline ApplyOptions() : ApplyOptions(nullptr) {}
  ~ApplyOptions() override;
  explicit PROTOBUF_CONSTEXPR ApplyOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ApplyOptions(const ApplyOptions& from);
  ApplyOptions(ApplyOptions&& from) noexcept
    : ApplyOptions() {
    *this = ::std::move(from);
  }

  inline ApplyOptions& operator=(const ApplyOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline ApplyOptions& operator=(ApplyOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ApplyOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const ApplyOptions* internal_default_instance() {
    return reinterpret_cast<const ApplyOptions*>(
               &_ApplyOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ApplyOptions& a, ApplyOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(ApplyOptions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ApplyOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ApplyOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ApplyOptions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ApplyOptions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ApplyOptions& from) {
    ApplyOptions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ApplyOptions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "k8s.io.apimachinery.pkg.apis.meta.v1.ApplyOptions";
  }
  protected:
  explicit ApplyOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDryRunFieldNumber = 1,
    kFieldManagerFieldNumber = 3,
    kForceFieldNumber = 2,
  };
  // repeated string dryRun = 1;
  int dryrun_size() const;
  private:
  int _internal_dryrun_size() const;
  public:
  void clear_dryrun();
  const std::string& dryrun(int index) const;
  std::string* mutable_dryrun(int index);
  void set_dryrun(int index, const std::string& value);
  void set_dryrun(int index, std::string&& value);
  void set_dryrun(int index, const char* value);
  void set_dryrun(int index, const char* value, size_t size);
  std::string* add_dryrun();
  void add_dryrun(const std::string& value);
  void add_dryrun(std::string&& value);
  void add_dryrun(const char* value);
  void add_dryrun(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& dryrun() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_dryrun();
  private:
  const std::string& _internal_dryrun(int index) const;
  std::string* _internal_add_dryrun();
  public:

  // optional string fieldManager = 3;
  bool has_fieldmanager() const;
  private:
  bool _internal_has_fieldmanager() const;
  public:
  void clear_fieldmanager();
  const std::string& fieldmanager() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fieldmanager(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fieldmanager();
  PROTOBUF_NODISCARD std::string* release_fieldmanager();
  void set_allocated_fieldmanager(std::string* fieldmanager);
  private:
  const std::string& _internal_fieldmanager() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fieldmanager(const std::string& value);
  std::string* _internal_mutable_fieldmanager();
  public:

  // optional bool force = 2;
  bool has_force() const;
  private:
  bool _internal_has_force() const;
  public:
  void clear_force();
  bool force() const;
  void set_force(bool value);
  private:
  bool _internal_force() const;
  void _internal_set_force(bool value);
  public:

  // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.ApplyOptions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> dryrun_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fieldmanager_;
    bool force_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_staging_5fsrc_5fk8s_2eio_5fapimachinery_5fpkg_5fapis_5fmeta_5fv1_5fgenerated_2eproto;
};
// -------------------------------------------------------------------

class Condition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:k8s.io.apimachinery.pkg.apis.meta.v1.Condition) */ {
 public:
  inline Condition() : Condition(nullptr) {}
  ~Condition() override;
  explicit PROTOBUF_CONSTEXPR Condition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Condition(const Condition& from);
  Condition(Condition&& from) noexcept
    : Condition() {
    *this = ::std::move(from);
  }

  inline Condition& operator=(const Condition& from) {
    CopyFrom(from);
    return *this;
  }
  inline Condition& operator=(Condition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Condition& default_instance() {
    return *internal_default_instance();
  }
  static inline const Condition* internal_default_instance() {
    return reinterpret_cast<const Condition*>(
               &_Condition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Condition& a, Condition& b) {
    a.Swap(&b);
  }
  inline void Swap(Condition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Condition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Condition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Condition>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Condition& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Condition& from) {
    Condition::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Condition* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "k8s.io.apimachinery.pkg.apis.meta.v1.Condition";
  }
  protected:
  explicit Condition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kStatusFieldNumber = 2,
    kReasonFieldNumber = 5,
    kMessageFieldNumber = 6,
    kLastTransitionTimeFieldNumber = 4,
    kObservedGenerationFieldNumber = 3,
  };
  // optional string type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // optional string status = 2;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // optional string reason = 5;
  bool has_reason() const;
  private:
  bool _internal_has_reason() const;
  public:
  void clear_reason();
  const std::string& reason() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reason(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reason();
  PROTOBUF_NODISCARD std::string* release_reason();
  void set_allocated_reason(std::string* reason);
  private:
  const std::string& _internal_reason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reason(const std::string& value);
  std::string* _internal_mutable_reason();
  public:

  // optional string message = 6;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 4;
  bool has_lasttransitiontime() const;
  private:
  bool _internal_has_lasttransitiontime() const;
  public:
  void clear_lasttransitiontime();
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::Time& lasttransitiontime() const;
  PROTOBUF_NODISCARD ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* release_lasttransitiontime();
  ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* mutable_lasttransitiontime();
  void set_allocated_lasttransitiontime(::k8s::io::apimachinery::pkg::apis::meta::v1::Time* lasttransitiontime);
  private:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::Time& _internal_lasttransitiontime() const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* _internal_mutable_lasttransitiontime();
  public:
  void unsafe_arena_set_allocated_lasttransitiontime(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* lasttransitiontime);
  ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* unsafe_arena_release_lasttransitiontime();

  // optional int64 observedGeneration = 3;
  bool has_observedgeneration() const;
  private:
  bool _internal_has_observedgeneration() const;
  public:
  void clear_observedgeneration();
  int64_t observedgeneration() const;
  void set_observedgeneration(int64_t value);
  private:
  int64_t _internal_observedgeneration() const;
  void _internal_set_observedgeneration(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.Condition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reason_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* lasttransitiontime_;
    int64_t observedgeneration_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_staging_5fsrc_5fk8s_2eio_5fapimachinery_5fpkg_5fapis_5fmeta_5fv1_5fgenerated_2eproto;
};
// -------------------------------------------------------------------

class CreateOptions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:k8s.io.apimachinery.pkg.apis.meta.v1.CreateOptions) */ {
 public:
  inline CreateOptions() : CreateOptions(nullptr) {}
  ~CreateOptions() override;
  explicit PROTOBUF_CONSTEXPR CreateOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateOptions(const CreateOptions& from);
  CreateOptions(CreateOptions&& from) noexcept
    : CreateOptions() {
    *this = ::std::move(from);
  }

  inline CreateOptions& operator=(const CreateOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateOptions& operator=(CreateOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateOptions* internal_default_instance() {
    return reinterpret_cast<const CreateOptions*>(
               &_CreateOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(CreateOptions& a, CreateOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateOptions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateOptions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateOptions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateOptions& from) {
    CreateOptions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateOptions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "k8s.io.apimachinery.pkg.apis.meta.v1.CreateOptions";
  }
  protected:
  explicit CreateOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDryRunFieldNumber = 1,
    kFieldManagerFieldNumber = 3,
    kFieldValidationFieldNumber = 4,
  };
  // repeated string dryRun = 1;
  int dryrun_size() const;
  private:
  int _internal_dryrun_size() const;
  public:
  void clear_dryrun();
  const std::string& dryrun(int index) const;
  std::string* mutable_dryrun(int index);
  void set_dryrun(int index, const std::string& value);
  void set_dryrun(int index, std::string&& value);
  void set_dryrun(int index, const char* value);
  void set_dryrun(int index, const char* value, size_t size);
  std::string* add_dryrun();
  void add_dryrun(const std::string& value);
  void add_dryrun(std::string&& value);
  void add_dryrun(const char* value);
  void add_dryrun(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& dryrun() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_dryrun();
  private:
  const std::string& _internal_dryrun(int index) const;
  std::string* _internal_add_dryrun();
  public:

  // optional string fieldManager = 3;
  bool has_fieldmanager() const;
  private:
  bool _internal_has_fieldmanager() const;
  public:
  void clear_fieldmanager();
  const std::string& fieldmanager() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fieldmanager(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fieldmanager();
  PROTOBUF_NODISCARD std::string* release_fieldmanager();
  void set_allocated_fieldmanager(std::string* fieldmanager);
  private:
  const std::string& _internal_fieldmanager() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fieldmanager(const std::string& value);
  std::string* _internal_mutable_fieldmanager();
  public:

  // optional string fieldValidation = 4;
  bool has_fieldvalidation() const;
  private:
  bool _internal_has_fieldvalidation() const;
  public:
  void clear_fieldvalidation();
  const std::string& fieldvalidation() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fieldvalidation(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fieldvalidation();
  PROTOBUF_NODISCARD std::string* release_fieldvalidation();
  void set_allocated_fieldvalidation(std::string* fieldvalidation);
  private:
  const std::string& _internal_fieldvalidation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fieldvalidation(const std::string& value);
  std::string* _internal_mutable_fieldvalidation();
  public:

  // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.CreateOptions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> dryrun_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fieldmanager_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fieldvalidation_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_staging_5fsrc_5fk8s_2eio_5fapimachinery_5fpkg_5fapis_5fmeta_5fv1_5fgenerated_2eproto;
};
// -------------------------------------------------------------------

class DeleteOptions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:k8s.io.apimachinery.pkg.apis.meta.v1.DeleteOptions) */ {
 public:
  inline DeleteOptions() : DeleteOptions(nullptr) {}
  ~DeleteOptions() override;
  explicit PROTOBUF_CONSTEXPR DeleteOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteOptions(const DeleteOptions& from);
  DeleteOptions(DeleteOptions&& from) noexcept
    : DeleteOptions() {
    *this = ::std::move(from);
  }

  inline DeleteOptions& operator=(const DeleteOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteOptions& operator=(DeleteOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteOptions* internal_default_instance() {
    return reinterpret_cast<const DeleteOptions*>(
               &_DeleteOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(DeleteOptions& a, DeleteOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteOptions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteOptions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteOptions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteOptions& from) {
    DeleteOptions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteOptions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "k8s.io.apimachinery.pkg.apis.meta.v1.DeleteOptions";
  }
  protected:
  explicit DeleteOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDryRunFieldNumber = 5,
    kPropagationPolicyFieldNumber = 4,
    kPreconditionsFieldNumber = 2,
    kGracePeriodSecondsFieldNumber = 1,
    kOrphanDependentsFieldNumber = 3,
  };
  // repeated string dryRun = 5;
  int dryrun_size() const;
  private:
  int _internal_dryrun_size() const;
  public:
  void clear_dryrun();
  const std::string& dryrun(int index) const;
  std::string* mutable_dryrun(int index);
  void set_dryrun(int index, const std::string& value);
  void set_dryrun(int index, std::string&& value);
  void set_dryrun(int index, const char* value);
  void set_dryrun(int index, const char* value, size_t size);
  std::string* add_dryrun();
  void add_dryrun(const std::string& value);
  void add_dryrun(std::string&& value);
  void add_dryrun(const char* value);
  void add_dryrun(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& dryrun() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_dryrun();
  private:
  const std::string& _internal_dryrun(int index) const;
  std::string* _internal_add_dryrun();
  public:

  // optional string propagationPolicy = 4;
  bool has_propagationpolicy() const;
  private:
  bool _internal_has_propagationpolicy() const;
  public:
  void clear_propagationpolicy();
  const std::string& propagationpolicy() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_propagationpolicy(ArgT0&& arg0, ArgT... args);
  std::string* mutable_propagationpolicy();
  PROTOBUF_NODISCARD std::string* release_propagationpolicy();
  void set_allocated_propagationpolicy(std::string* propagationpolicy);
  private:
  const std::string& _internal_propagationpolicy() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_propagationpolicy(const std::string& value);
  std::string* _internal_mutable_propagationpolicy();
  public:

  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Preconditions preconditions = 2;
  bool has_preconditions() const;
  private:
  bool _internal_has_preconditions() const;
  public:
  void clear_preconditions();
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::Preconditions& preconditions() const;
  PROTOBUF_NODISCARD ::k8s::io::apimachinery::pkg::apis::meta::v1::Preconditions* release_preconditions();
  ::k8s::io::apimachinery::pkg::apis::meta::v1::Preconditions* mutable_preconditions();
  void set_allocated_preconditions(::k8s::io::apimachinery::pkg::apis::meta::v1::Preconditions* preconditions);
  private:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::Preconditions& _internal_preconditions() const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::Preconditions* _internal_mutable_preconditions();
  public:
  void unsafe_arena_set_allocated_preconditions(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::Preconditions* preconditions);
  ::k8s::io::apimachinery::pkg::apis::meta::v1::Preconditions* unsafe_arena_release_preconditions();

  // optional int64 gracePeriodSeconds = 1;
  bool has_graceperiodseconds() const;
  private:
  bool _internal_has_graceperiodseconds() const;
  public:
  void clear_graceperiodseconds();
  int64_t graceperiodseconds() const;
  void set_graceperiodseconds(int64_t value);
  private:
  int64_t _internal_graceperiodseconds() const;
  void _internal_set_graceperiodseconds(int64_t value);
  public:

  // optional bool orphanDependents = 3;
  bool has_orphandependents() const;
  private:
  bool _internal_has_orphandependents() const;
  public:
  void clear_orphandependents();
  bool orphandependents() const;
  void set_orphandependents(bool value);
  private:
  bool _internal_orphandependents() const;
  void _internal_set_orphandependents(bool value);
  public:

  // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.DeleteOptions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> dryrun_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr propagationpolicy_;
    ::k8s::io::apimachinery::pkg::apis::meta::v1::Preconditions* preconditions_;
    int64_t graceperiodseconds_;
    bool orphandependents_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_staging_5fsrc_5fk8s_2eio_5fapimachinery_5fpkg_5fapis_5fmeta_5fv1_5fgenerated_2eproto;
};
// -------------------------------------------------------------------

class Duration final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:k8s.io.apimachinery.pkg.apis.meta.v1.Duration) */ {
 public:
  inline Duration() : Duration(nullptr) {}
  ~Duration() override;
  explicit PROTOBUF_CONSTEXPR Duration(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Duration(const Duration& from);
  Duration(Duration&& from) noexcept
    : Duration() {
    *this = ::std::move(from);
  }

  inline Duration& operator=(const Duration& from) {
    CopyFrom(from);
    return *this;
  }
  inline Duration& operator=(Duration&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Duration& default_instance() {
    return *internal_default_instance();
  }
  static inline const Duration* internal_default_instance() {
    return reinterpret_cast<const Duration*>(
               &_Duration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Duration& a, Duration& b) {
    a.Swap(&b);
  }
  inline void Swap(Duration* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Duration* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Duration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Duration>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Duration& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Duration& from) {
    Duration::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Duration* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "k8s.io.apimachinery.pkg.apis.meta.v1.Duration";
  }
  protected:
  explicit Duration(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDurationFieldNumber = 1,
  };
  // optional int64 duration = 1;
  bool has_duration() const;
  private:
  bool _internal_has_duration() const;
  public:
  void clear_duration();
  int64_t duration() const;
  void set_duration(int64_t value);
  private:
  int64_t _internal_duration() const;
  void _internal_set_duration(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.Duration)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int64_t duration_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_staging_5fsrc_5fk8s_2eio_5fapimachinery_5fpkg_5fapis_5fmeta_5fv1_5fgenerated_2eproto;
};
// -------------------------------------------------------------------

class FieldsV1 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:k8s.io.apimachinery.pkg.apis.meta.v1.FieldsV1) */ {
 public:
  inline FieldsV1() : FieldsV1(nullptr) {}
  ~FieldsV1() override;
  explicit PROTOBUF_CONSTEXPR FieldsV1(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FieldsV1(const FieldsV1& from);
  FieldsV1(FieldsV1&& from) noexcept
    : FieldsV1() {
    *this = ::std::move(from);
  }

  inline FieldsV1& operator=(const FieldsV1& from) {
    CopyFrom(from);
    return *this;
  }
  inline FieldsV1& operator=(FieldsV1&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FieldsV1& default_instance() {
    return *internal_default_instance();
  }
  static inline const FieldsV1* internal_default_instance() {
    return reinterpret_cast<const FieldsV1*>(
               &_FieldsV1_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(FieldsV1& a, FieldsV1& b) {
    a.Swap(&b);
  }
  inline void Swap(FieldsV1* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FieldsV1* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FieldsV1* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FieldsV1>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FieldsV1& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FieldsV1& from) {
    FieldsV1::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FieldsV1* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "k8s.io.apimachinery.pkg.apis.meta.v1.FieldsV1";
  }
  protected:
  explicit FieldsV1(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRawFieldNumber = 1,
  };
  // optional bytes Raw = 1;
  bool has_raw() const;
  private:
  bool _internal_has_raw() const;
  public:
  void clear_raw();
  const std::string& raw() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_raw(ArgT0&& arg0, ArgT... args);
  std::string* mutable_raw();
  PROTOBUF_NODISCARD std::string* release_raw();
  void set_allocated_raw(std::string* raw);
  private:
  const std::string& _internal_raw() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_raw(const std::string& value);
  std::string* _internal_mutable_raw();
  public:

  // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.FieldsV1)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr raw_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_staging_5fsrc_5fk8s_2eio_5fapimachinery_5fpkg_5fapis_5fmeta_5fv1_5fgenerated_2eproto;
};
// -------------------------------------------------------------------

class GetOptions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:k8s.io.apimachinery.pkg.apis.meta.v1.GetOptions) */ {
 public:
  inline GetOptions() : GetOptions(nullptr) {}
  ~GetOptions() override;
  explicit PROTOBUF_CONSTEXPR GetOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetOptions(const GetOptions& from);
  GetOptions(GetOptions&& from) noexcept
    : GetOptions() {
    *this = ::std::move(from);
  }

  inline GetOptions& operator=(const GetOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetOptions& operator=(GetOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetOptions* internal_default_instance() {
    return reinterpret_cast<const GetOptions*>(
               &_GetOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(GetOptions& a, GetOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(GetOptions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetOptions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetOptions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetOptions& from) {
    GetOptions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetOptions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "k8s.io.apimachinery.pkg.apis.meta.v1.GetOptions";
  }
  protected:
  explicit GetOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResourceVersionFieldNumber = 1,
  };
  // optional string resourceVersion = 1;
  bool has_resourceversion() const;
  private:
  bool _internal_has_resourceversion() const;
  public:
  void clear_resourceversion();
  const std::string& resourceversion() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_resourceversion(ArgT0&& arg0, ArgT... args);
  std::string* mutable_resourceversion();
  PROTOBUF_NODISCARD std::string* release_resourceversion();
  void set_allocated_resourceversion(std::string* resourceversion);
  private:
  const std::string& _internal_resourceversion() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resourceversion(const std::string& value);
  std::string* _internal_mutable_resourceversion();
  public:

  // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.GetOptions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resourceversion_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_staging_5fsrc_5fk8s_2eio_5fapimachinery_5fpkg_5fapis_5fmeta_5fv1_5fgenerated_2eproto;
};
// -------------------------------------------------------------------

class GroupKind final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:k8s.io.apimachinery.pkg.apis.meta.v1.GroupKind) */ {
 public:
  inline GroupKind() : GroupKind(nullptr) {}
  ~GroupKind() override;
  explicit PROTOBUF_CONSTEXPR GroupKind(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GroupKind(const GroupKind& from);
  GroupKind(GroupKind&& from) noexcept
    : GroupKind() {
    *this = ::std::move(from);
  }

  inline GroupKind& operator=(const GroupKind& from) {
    CopyFrom(from);
    return *this;
  }
  inline GroupKind& operator=(GroupKind&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GroupKind& default_instance() {
    return *internal_default_instance();
  }
  static inline const GroupKind* internal_default_instance() {
    return reinterpret_cast<const GroupKind*>(
               &_GroupKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(GroupKind& a, GroupKind& b) {
    a.Swap(&b);
  }
  inline void Swap(GroupKind* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GroupKind* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GroupKind* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GroupKind>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GroupKind& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GroupKind& from) {
    GroupKind::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GroupKind* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "k8s.io.apimachinery.pkg.apis.meta.v1.GroupKind";
  }
  protected:
  explicit GroupKind(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupFieldNumber = 1,
    kKindFieldNumber = 2,
  };
  // optional string group = 1;
  bool has_group() const;
  private:
  bool _internal_has_group() const;
  public:
  void clear_group();
  const std::string& group() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_group(ArgT0&& arg0, ArgT... args);
  std::string* mutable_group();
  PROTOBUF_NODISCARD std::string* release_group();
  void set_allocated_group(std::string* group);
  private:
  const std::string& _internal_group() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_group(const std::string& value);
  std::string* _internal_mutable_group();
  public:

  // optional string kind = 2;
  bool has_kind() const;
  private:
  bool _internal_has_kind() const;
  public:
  void clear_kind();
  const std::string& kind() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_kind(ArgT0&& arg0, ArgT... args);
  std::string* mutable_kind();
  PROTOBUF_NODISCARD std::string* release_kind();
  void set_allocated_kind(std::string* kind);
  private:
  const std::string& _internal_kind() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_kind(const std::string& value);
  std::string* _internal_mutable_kind();
  public:

  // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.GroupKind)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr group_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr kind_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_staging_5fsrc_5fk8s_2eio_5fapimachinery_5fpkg_5fapis_5fmeta_5fv1_5fgenerated_2eproto;
};
// -------------------------------------------------------------------

class GroupResource final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:k8s.io.apimachinery.pkg.apis.meta.v1.GroupResource) */ {
 public:
  inline GroupResource() : GroupResource(nullptr) {}
  ~GroupResource() override;
  explicit PROTOBUF_CONSTEXPR GroupResource(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GroupResource(const GroupResource& from);
  GroupResource(GroupResource&& from) noexcept
    : GroupResource() {
    *this = ::std::move(from);
  }

  inline GroupResource& operator=(const GroupResource& from) {
    CopyFrom(from);
    return *this;
  }
  inline GroupResource& operator=(GroupResource&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GroupResource& default_instance() {
    return *internal_default_instance();
  }
  static inline const GroupResource* internal_default_instance() {
    return reinterpret_cast<const GroupResource*>(
               &_GroupResource_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(GroupResource& a, GroupResource& b) {
    a.Swap(&b);
  }
  inline void Swap(GroupResource* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GroupResource* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GroupResource* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GroupResource>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GroupResource& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GroupResource& from) {
    GroupResource::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GroupResource* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "k8s.io.apimachinery.pkg.apis.meta.v1.GroupResource";
  }
  protected:
  explicit GroupResource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupFieldNumber = 1,
    kResourceFieldNumber = 2,
  };
  // optional string group = 1;
  bool has_group() const;
  private:
  bool _internal_has_group() const;
  public:
  void clear_group();
  const std::string& group() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_group(ArgT0&& arg0, ArgT... args);
  std::string* mutable_group();
  PROTOBUF_NODISCARD std::string* release_group();
  void set_allocated_group(std::string* group);
  private:
  const std::string& _internal_group() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_group(const std::string& value);
  std::string* _internal_mutable_group();
  public:

  // optional string resource = 2;
  bool has_resource() const;
  private:
  bool _internal_has_resource() const;
  public:
  void clear_resource();
  const std::string& resource() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_resource(ArgT0&& arg0, ArgT... args);
  std::string* mutable_resource();
  PROTOBUF_NODISCARD std::string* release_resource();
  void set_allocated_resource(std::string* resource);
  private:
  const std::string& _internal_resource() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resource(const std::string& value);
  std::string* _internal_mutable_resource();
  public:

  // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.GroupResource)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr group_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resource_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_staging_5fsrc_5fk8s_2eio_5fapimachinery_5fpkg_5fapis_5fmeta_5fv1_5fgenerated_2eproto;
};
// -------------------------------------------------------------------

class GroupVersion final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersion) */ {
 public:
  inline GroupVersion() : GroupVersion(nullptr) {}
  ~GroupVersion() override;
  explicit PROTOBUF_CONSTEXPR GroupVersion(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GroupVersion(const GroupVersion& from);
  GroupVersion(GroupVersion&& from) noexcept
    : GroupVersion() {
    *this = ::std::move(from);
  }

  inline GroupVersion& operator=(const GroupVersion& from) {
    CopyFrom(from);
    return *this;
  }
  inline GroupVersion& operator=(GroupVersion&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GroupVersion& default_instance() {
    return *internal_default_instance();
  }
  static inline const GroupVersion* internal_default_instance() {
    return reinterpret_cast<const GroupVersion*>(
               &_GroupVersion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(GroupVersion& a, GroupVersion& b) {
    a.Swap(&b);
  }
  inline void Swap(GroupVersion* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GroupVersion* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GroupVersion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GroupVersion>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GroupVersion& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GroupVersion& from) {
    GroupVersion::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GroupVersion* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersion";
  }
  protected:
  explicit GroupVersion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupFieldNumber = 1,
    kVersionFieldNumber = 2,
  };
  // optional string group = 1;
  bool has_group() const;
  private:
  bool _internal_has_group() const;
  public:
  void clear_group();
  const std::string& group() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_group(ArgT0&& arg0, ArgT... args);
  std::string* mutable_group();
  PROTOBUF_NODISCARD std::string* release_group();
  void set_allocated_group(std::string* group);
  private:
  const std::string& _internal_group() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_group(const std::string& value);
  std::string* _internal_mutable_group();
  public:

  // optional string version = 2;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersion)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr group_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_staging_5fsrc_5fk8s_2eio_5fapimachinery_5fpkg_5fapis_5fmeta_5fv1_5fgenerated_2eproto;
};
// -------------------------------------------------------------------

class GroupVersionForDiscovery final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery) */ {
 public:
  inline GroupVersionForDiscovery() : GroupVersionForDiscovery(nullptr) {}
  ~GroupVersionForDiscovery() override;
  explicit PROTOBUF_CONSTEXPR GroupVersionForDiscovery(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GroupVersionForDiscovery(const GroupVersionForDiscovery& from);
  GroupVersionForDiscovery(GroupVersionForDiscovery&& from) noexcept
    : GroupVersionForDiscovery() {
    *this = ::std::move(from);
  }

  inline GroupVersionForDiscovery& operator=(const GroupVersionForDiscovery& from) {
    CopyFrom(from);
    return *this;
  }
  inline GroupVersionForDiscovery& operator=(GroupVersionForDiscovery&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GroupVersionForDiscovery& default_instance() {
    return *internal_default_instance();
  }
  static inline const GroupVersionForDiscovery* internal_default_instance() {
    return reinterpret_cast<const GroupVersionForDiscovery*>(
               &_GroupVersionForDiscovery_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(GroupVersionForDiscovery& a, GroupVersionForDiscovery& b) {
    a.Swap(&b);
  }
  inline void Swap(GroupVersionForDiscovery* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GroupVersionForDiscovery* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GroupVersionForDiscovery* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GroupVersionForDiscovery>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GroupVersionForDiscovery& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GroupVersionForDiscovery& from) {
    GroupVersionForDiscovery::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GroupVersionForDiscovery* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery";
  }
  protected:
  explicit GroupVersionForDiscovery(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupVersionFieldNumber = 1,
    kVersionFieldNumber = 2,
  };
  // optional string groupVersion = 1;
  bool has_groupversion() const;
  private:
  bool _internal_has_groupversion() const;
  public:
  void clear_groupversion();
  const std::string& groupversion() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_groupversion(ArgT0&& arg0, ArgT... args);
  std::string* mutable_groupversion();
  PROTOBUF_NODISCARD std::string* release_groupversion();
  void set_allocated_groupversion(std::string* groupversion);
  private:
  const std::string& _internal_groupversion() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_groupversion(const std::string& value);
  std::string* _internal_mutable_groupversion();
  public:

  // optional string version = 2;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr groupversion_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_staging_5fsrc_5fk8s_2eio_5fapimachinery_5fpkg_5fapis_5fmeta_5fv1_5fgenerated_2eproto;
};
// -------------------------------------------------------------------

class GroupVersionKind final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionKind) */ {
 public:
  inline GroupVersionKind() : GroupVersionKind(nullptr) {}
  ~GroupVersionKind() override;
  explicit PROTOBUF_CONSTEXPR GroupVersionKind(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GroupVersionKind(const GroupVersionKind& from);
  GroupVersionKind(GroupVersionKind&& from) noexcept
    : GroupVersionKind() {
    *this = ::std::move(from);
  }

  inline GroupVersionKind& operator=(const GroupVersionKind& from) {
    CopyFrom(from);
    return *this;
  }
  inline GroupVersionKind& operator=(GroupVersionKind&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GroupVersionKind& default_instance() {
    return *internal_default_instance();
  }
  static inline const GroupVersionKind* internal_default_instance() {
    return reinterpret_cast<const GroupVersionKind*>(
               &_GroupVersionKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(GroupVersionKind& a, GroupVersionKind& b) {
    a.Swap(&b);
  }
  inline void Swap(GroupVersionKind* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GroupVersionKind* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GroupVersionKind* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GroupVersionKind>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GroupVersionKind& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GroupVersionKind& from) {
    GroupVersionKind::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GroupVersionKind* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionKind";
  }
  protected:
  explicit GroupVersionKind(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupFieldNumber = 1,
    kVersionFieldNumber = 2,
    kKindFieldNumber = 3,
  };
  // optional string group = 1;
  bool has_group() const;
  private:
  bool _internal_has_group() const;
  public:
  void clear_group();
  const std::string& group() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_group(ArgT0&& arg0, ArgT... args);
  std::string* mutable_group();
  PROTOBUF_NODISCARD std::string* release_group();
  void set_allocated_group(std::string* group);
  private:
  const std::string& _internal_group() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_group(const std::string& value);
  std::string* _internal_mutable_group();
  public:

  // optional string version = 2;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // optional string kind = 3;
  bool has_kind() const;
  private:
  bool _internal_has_kind() const;
  public:
  void clear_kind();
  const std::string& kind() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_kind(ArgT0&& arg0, ArgT... args);
  std::string* mutable_kind();
  PROTOBUF_NODISCARD std::string* release_kind();
  void set_allocated_kind(std::string* kind);
  private:
  const std::string& _internal_kind() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_kind(const std::string& value);
  std::string* _internal_mutable_kind();
  public:

  // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionKind)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr group_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr kind_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_staging_5fsrc_5fk8s_2eio_5fapimachinery_5fpkg_5fapis_5fmeta_5fv1_5fgenerated_2eproto;
};
// -------------------------------------------------------------------

class GroupVersionResource final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionResource) */ {
 public:
  inline GroupVersionResource() : GroupVersionResource(nullptr) {}
  ~GroupVersionResource() override;
  explicit PROTOBUF_CONSTEXPR GroupVersionResource(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GroupVersionResource(const GroupVersionResource& from);
  GroupVersionResource(GroupVersionResource&& from) noexcept
    : GroupVersionResource() {
    *this = ::std::move(from);
  }

  inline GroupVersionResource& operator=(const GroupVersionResource& from) {
    CopyFrom(from);
    return *this;
  }
  inline GroupVersionResource& operator=(GroupVersionResource&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GroupVersionResource& default_instance() {
    return *internal_default_instance();
  }
  static inline const GroupVersionResource* internal_default_instance() {
    return reinterpret_cast<const GroupVersionResource*>(
               &_GroupVersionResource_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(GroupVersionResource& a, GroupVersionResource& b) {
    a.Swap(&b);
  }
  inline void Swap(GroupVersionResource* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GroupVersionResource* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GroupVersionResource* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GroupVersionResource>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GroupVersionResource& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GroupVersionResource& from) {
    GroupVersionResource::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GroupVersionResource* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionResource";
  }
  protected:
  explicit GroupVersionResource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupFieldNumber = 1,
    kVersionFieldNumber = 2,
    kResourceFieldNumber = 3,
  };
  // optional string group = 1;
  bool has_group() const;
  private:
  bool _internal_has_group() const;
  public:
  void clear_group();
  const std::string& group() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_group(ArgT0&& arg0, ArgT... args);
  std::string* mutable_group();
  PROTOBUF_NODISCARD std::string* release_group();
  void set_allocated_group(std::string* group);
  private:
  const std::string& _internal_group() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_group(const std::string& value);
  std::string* _internal_mutable_group();
  public:

  // optional string version = 2;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // optional string resource = 3;
  bool has_resource() const;
  private:
  bool _internal_has_resource() const;
  public:
  void clear_resource();
  const std::string& resource() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_resource(ArgT0&& arg0, ArgT... args);
  std::string* mutable_resource();
  PROTOBUF_NODISCARD std::string* release_resource();
  void set_allocated_resource(std::string* resource);
  private:
  const std::string& _internal_resource() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resource(const std::string& value);
  std::string* _internal_mutable_resource();
  public:

  // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionResource)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr group_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resource_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_staging_5fsrc_5fk8s_2eio_5fapimachinery_5fpkg_5fapis_5fmeta_5fv1_5fgenerated_2eproto;
};
// -------------------------------------------------------------------

class LabelSelector_MatchLabelsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<LabelSelector_MatchLabelsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<LabelSelector_MatchLabelsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  LabelSelector_MatchLabelsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR LabelSelector_MatchLabelsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit LabelSelector_MatchLabelsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const LabelSelector_MatchLabelsEntry_DoNotUse& other);
  static const LabelSelector_MatchLabelsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const LabelSelector_MatchLabelsEntry_DoNotUse*>(&_LabelSelector_MatchLabelsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
#ifndef NDEBUG
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
       s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector.MatchLabelsEntry.key");
#else
    (void) s;
#endif
    return true;
 }
  static bool ValidateValue(std::string* s) {
#ifndef NDEBUG
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
       s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector.MatchLabelsEntry.value");
#else
    (void) s;
#endif
    return true;
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_staging_5fsrc_5fk8s_2eio_5fapimachinery_5fpkg_5fapis_5fmeta_5fv1_5fgenerated_2eproto;
};

// -------------------------------------------------------------------

class LabelSelector final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector) */ {
 public:
  inline LabelSelector() : LabelSelector(nullptr) {}
  ~LabelSelector() override;
  explicit PROTOBUF_CONSTEXPR LabelSelector(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LabelSelector(const LabelSelector& from);
  LabelSelector(LabelSelector&& from) noexcept
    : LabelSelector() {
    *this = ::std::move(from);
  }

  inline LabelSelector& operator=(const LabelSelector& from) {
    CopyFrom(from);
    return *this;
  }
  inline LabelSelector& operator=(LabelSelector&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LabelSelector& default_instance() {
    return *internal_default_instance();
  }
  static inline const LabelSelector* internal_default_instance() {
    return reinterpret_cast<const LabelSelector*>(
               &_LabelSelector_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(LabelSelector& a, LabelSelector& b) {
    a.Swap(&b);
  }
  inline void Swap(LabelSelector* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LabelSelector* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LabelSelector* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LabelSelector>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LabelSelector& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LabelSelector& from) {
    LabelSelector::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LabelSelector* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector";
  }
  protected:
  explicit LabelSelector(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kMatchLabelsFieldNumber = 1,
    kMatchExpressionsFieldNumber = 2,
  };
  // map<string, string> matchLabels = 1;
  int matchlabels_size() const;
  private:
  int _internal_matchlabels_size() const;
  public:
  void clear_matchlabels();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_matchlabels() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_matchlabels();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      matchlabels() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_matchlabels();

  // repeated .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement matchExpressions = 2;
  int matchexpressions_size() const;
  private:
  int _internal_matchexpressions_size() const;
  public:
  void clear_matchexpressions();
  ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelectorRequirement* mutable_matchexpressions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelectorRequirement >*
      mutable_matchexpressions();
  private:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelectorRequirement& _internal_matchexpressions(int index) const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelectorRequirement* _internal_add_matchexpressions();
  public:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelectorRequirement& matchexpressions(int index) const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelectorRequirement* add_matchexpressions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelectorRequirement >&
      matchexpressions() const;

  // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        LabelSelector_MatchLabelsEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> matchlabels_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelectorRequirement > matchexpressions_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_staging_5fsrc_5fk8s_2eio_5fapimachinery_5fpkg_5fapis_5fmeta_5fv1_5fgenerated_2eproto;
};
// -------------------------------------------------------------------

class LabelSelectorRequirement final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement) */ {
 public:
  inline LabelSelectorRequirement() : LabelSelectorRequirement(nullptr) {}
  ~LabelSelectorRequirement() override;
  explicit PROTOBUF_CONSTEXPR LabelSelectorRequirement(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LabelSelectorRequirement(const LabelSelectorRequirement& from);
  LabelSelectorRequirement(LabelSelectorRequirement&& from) noexcept
    : LabelSelectorRequirement() {
    *this = ::std::move(from);
  }

  inline LabelSelectorRequirement& operator=(const LabelSelectorRequirement& from) {
    CopyFrom(from);
    return *this;
  }
  inline LabelSelectorRequirement& operator=(LabelSelectorRequirement&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LabelSelectorRequirement& default_instance() {
    return *internal_default_instance();
  }
  static inline const LabelSelectorRequirement* internal_default_instance() {
    return reinterpret_cast<const LabelSelectorRequirement*>(
               &_LabelSelectorRequirement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(LabelSelectorRequirement& a, LabelSelectorRequirement& b) {
    a.Swap(&b);
  }
  inline void Swap(LabelSelectorRequirement* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LabelSelectorRequirement* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LabelSelectorRequirement* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LabelSelectorRequirement>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LabelSelectorRequirement& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LabelSelectorRequirement& from) {
    LabelSelectorRequirement::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LabelSelectorRequirement* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement";
  }
  protected:
  explicit LabelSelectorRequirement(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 3,
    kKeyFieldNumber = 1,
    kOperatorFieldNumber = 2,
  };
  // repeated string values = 3;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  const std::string& values(int index) const;
  std::string* mutable_values(int index);
  void set_values(int index, const std::string& value);
  void set_values(int index, std::string&& value);
  void set_values(int index, const char* value);
  void set_values(int index, const char* value, size_t size);
  std::string* add_values();
  void add_values(const std::string& value);
  void add_values(std::string&& value);
  void add_values(const char* value);
  void add_values(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_values();
  private:
  const std::string& _internal_values(int index) const;
  std::string* _internal_add_values();
  public:

  // optional string key = 1;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // optional string operator = 2;
  bool has_operator_() const;
  private:
  bool _internal_has_operator_() const;
  public:
  void clear_operator_();
  const std::string& operator_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_operator_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_operator_();
  PROTOBUF_NODISCARD std::string* release_operator_();
  void set_allocated_operator_(std::string* operator_);
  private:
  const std::string& _internal_operator_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_operator_(const std::string& value);
  std::string* _internal_mutable_operator_();
  public:

  // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> values_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr operator__;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_staging_5fsrc_5fk8s_2eio_5fapimachinery_5fpkg_5fapis_5fmeta_5fv1_5fgenerated_2eproto;
};
// -------------------------------------------------------------------

class List final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:k8s.io.apimachinery.pkg.apis.meta.v1.List) */ {
 public:
  inline List() : List(nullptr) {}
  ~List() override;
  explicit PROTOBUF_CONSTEXPR List(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  List(const List& from);
  List(List&& from) noexcept
    : List() {
    *this = ::std::move(from);
  }

  inline List& operator=(const List& from) {
    CopyFrom(from);
    return *this;
  }
  inline List& operator=(List&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const List& default_instance() {
    return *internal_default_instance();
  }
  static inline const List* internal_default_instance() {
    return reinterpret_cast<const List*>(
               &_List_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(List& a, List& b) {
    a.Swap(&b);
  }
  inline void Swap(List* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(List* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  List* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<List>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const List& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const List& from) {
    List::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(List* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "k8s.io.apimachinery.pkg.apis.meta.v1.List";
  }
  protected:
  explicit List(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 2,
    kMetadataFieldNumber = 1,
  };
  // repeated .k8s.io.apimachinery.pkg.runtime.RawExtension items = 2;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::k8s::io::apimachinery::pkg::runtime::RawExtension* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::k8s::io::apimachinery::pkg::runtime::RawExtension >*
      mutable_items();
  private:
  const ::k8s::io::apimachinery::pkg::runtime::RawExtension& _internal_items(int index) const;
  ::k8s::io::apimachinery::pkg::runtime::RawExtension* _internal_add_items();
  public:
  const ::k8s::io::apimachinery::pkg::runtime::RawExtension& items(int index) const;
  ::k8s::io::apimachinery::pkg::runtime::RawExtension* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::k8s::io::apimachinery::pkg::runtime::RawExtension >&
      items() const;

  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& metadata() const;
  PROTOBUF_NODISCARD ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* release_metadata();
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* mutable_metadata();
  void set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata);
  private:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& _internal_metadata() const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata);
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* unsafe_arena_release_metadata();

  // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.List)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::k8s::io::apimachinery::pkg::runtime::RawExtension > items_;
    ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_staging_5fsrc_5fk8s_2eio_5fapimachinery_5fpkg_5fapis_5fmeta_5fv1_5fgenerated_2eproto;
};
// -------------------------------------------------------------------

class ListMeta final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta) */ {
 public:
  inline ListMeta() : ListMeta(nullptr) {}
  ~ListMeta() override;
  explicit PROTOBUF_CONSTEXPR ListMeta(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListMeta(const ListMeta& from);
  ListMeta(ListMeta&& from) noexcept
    : ListMeta() {
    *this = ::std::move(from);
  }

  inline ListMeta& operator=(const ListMeta& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListMeta& operator=(ListMeta&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListMeta& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListMeta* internal_default_instance() {
    return reinterpret_cast<const ListMeta*>(
               &_ListMeta_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(ListMeta& a, ListMeta& b) {
    a.Swap(&b);
  }
  inline void Swap(ListMeta* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListMeta* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListMeta* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListMeta>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListMeta& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListMeta& from) {
    ListMeta::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListMeta* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta";
  }
  protected:
  explicit ListMeta(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSelfLinkFieldNumber = 1,
    kResourceVersionFieldNumber = 2,
    kContinueFieldNumber = 3,
    kRemainingItemCountFieldNumber = 4,
  };
  // optional string selfLink = 1;
  bool has_selflink() const;
  private:
  bool _internal_has_selflink() const;
  public:
  void clear_selflink();
  const std::string& selflink() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_selflink(ArgT0&& arg0, ArgT... args);
  std::string* mutable_selflink();
  PROTOBUF_NODISCARD std::string* release_selflink();
  void set_allocated_selflink(std::string* selflink);
  private:
  const std::string& _internal_selflink() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_selflink(const std::string& value);
  std::string* _internal_mutable_selflink();
  public:

  // optional string resourceVersion = 2;
  bool has_resourceversion() const;
  private:
  bool _internal_has_resourceversion() const;
  public:
  void clear_resourceversion();
  const std::string& resourceversion() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_resourceversion(ArgT0&& arg0, ArgT... args);
  std::string* mutable_resourceversion();
  PROTOBUF_NODISCARD std::string* release_resourceversion();
  void set_allocated_resourceversion(std::string* resourceversion);
  private:
  const std::string& _internal_resourceversion() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resourceversion(const std::string& value);
  std::string* _internal_mutable_resourceversion();
  public:

  // optional string continue = 3;
  bool has_continue_() const;
  private:
  bool _internal_has_continue_() const;
  public:
  void clear_continue_();
  const std::string& continue_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_continue_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_continue_();
  PROTOBUF_NODISCARD std::string* release_continue_();
  void set_allocated_continue_(std::string* continue_);
  private:
  const std::string& _internal_continue_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_continue_(const std::string& value);
  std::string* _internal_mutable_continue_();
  public:

  // optional int64 remainingItemCount = 4;
  bool has_remainingitemcount() const;
  private:
  bool _internal_has_remainingitemcount() const;
  public:
  void clear_remainingitemcount();
  int64_t remainingitemcount() const;
  void set_remainingitemcount(int64_t value);
  private:
  int64_t _internal_remainingitemcount() const;
  void _internal_set_remainingitemcount(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr selflink_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resourceversion_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr continue__;
    int64_t remainingitemcount_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_staging_5fsrc_5fk8s_2eio_5fapimachinery_5fpkg_5fapis_5fmeta_5fv1_5fgenerated_2eproto;
};
// -------------------------------------------------------------------

class ListOptions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:k8s.io.apimachinery.pkg.apis.meta.v1.ListOptions) */ {
 public:
  inline ListOptions() : ListOptions(nullptr) {}
  ~ListOptions() override;
  explicit PROTOBUF_CONSTEXPR ListOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListOptions(const ListOptions& from);
  ListOptions(ListOptions&& from) noexcept
    : ListOptions() {
    *this = ::std::move(from);
  }

  inline ListOptions& operator=(const ListOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListOptions& operator=(ListOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListOptions* internal_default_instance() {
    return reinterpret_cast<const ListOptions*>(
               &_ListOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(ListOptions& a, ListOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(ListOptions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListOptions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListOptions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListOptions& from) {
    ListOptions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListOptions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "k8s.io.apimachinery.pkg.apis.meta.v1.ListOptions";
  }
  protected:
  explicit ListOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLabelSelectorFieldNumber = 1,
    kFieldSelectorFieldNumber = 2,
    kResourceVersionFieldNumber = 4,
    kContinueFieldNumber = 8,
    kResourceVersionMatchFieldNumber = 10,
    kTimeoutSecondsFieldNumber = 5,
    kLimitFieldNumber = 7,
    kWatchFieldNumber = 3,
    kAllowWatchBookmarksFieldNumber = 9,
    kSendInitialEventsFieldNumber = 11,
  };
  // optional string labelSelector = 1;
  bool has_labelselector() const;
  private:
  bool _internal_has_labelselector() const;
  public:
  void clear_labelselector();
  const std::string& labelselector() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_labelselector(ArgT0&& arg0, ArgT... args);
  std::string* mutable_labelselector();
  PROTOBUF_NODISCARD std::string* release_labelselector();
  void set_allocated_labelselector(std::string* labelselector);
  private:
  const std::string& _internal_labelselector() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_labelselector(const std::string& value);
  std::string* _internal_mutable_labelselector();
  public:

  // optional string fieldSelector = 2;
  bool has_fieldselector() const;
  private:
  bool _internal_has_fieldselector() const;
  public:
  void clear_fieldselector();
  const std::string& fieldselector() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fieldselector(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fieldselector();
  PROTOBUF_NODISCARD std::string* release_fieldselector();
  void set_allocated_fieldselector(std::string* fieldselector);
  private:
  const std::string& _internal_fieldselector() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fieldselector(const std::string& value);
  std::string* _internal_mutable_fieldselector();
  public:

  // optional string resourceVersion = 4;
  bool has_resourceversion() const;
  private:
  bool _internal_has_resourceversion() const;
  public:
  void clear_resourceversion();
  const std::string& resourceversion() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_resourceversion(ArgT0&& arg0, ArgT... args);
  std::string* mutable_resourceversion();
  PROTOBUF_NODISCARD std::string* release_resourceversion();
  void set_allocated_resourceversion(std::string* resourceversion);
  private:
  const std::string& _internal_resourceversion() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resourceversion(const std::string& value);
  std::string* _internal_mutable_resourceversion();
  public:

  // optional string continue = 8;
  bool has_continue_() const;
  private:
  bool _internal_has_continue_() const;
  public:
  void clear_continue_();
  const std::string& continue_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_continue_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_continue_();
  PROTOBUF_NODISCARD std::string* release_continue_();
  void set_allocated_continue_(std::string* continue_);
  private:
  const std::string& _internal_continue_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_continue_(const std::string& value);
  std::string* _internal_mutable_continue_();
  public:

  // optional string resourceVersionMatch = 10;
  bool has_resourceversionmatch() const;
  private:
  bool _internal_has_resourceversionmatch() const;
  public:
  void clear_resourceversionmatch();
  const std::string& resourceversionmatch() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_resourceversionmatch(ArgT0&& arg0, ArgT... args);
  std::string* mutable_resourceversionmatch();
  PROTOBUF_NODISCARD std::string* release_resourceversionmatch();
  void set_allocated_resourceversionmatch(std::string* resourceversionmatch);
  private:
  const std::string& _internal_resourceversionmatch() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resourceversionmatch(const std::string& value);
  std::string* _internal_mutable_resourceversionmatch();
  public:

  // optional int64 timeoutSeconds = 5;
  bool has_timeoutseconds() const;
  private:
  bool _internal_has_timeoutseconds() const;
  public:
  void clear_timeoutseconds();
  int64_t timeoutseconds() const;
  void set_timeoutseconds(int64_t value);
  private:
  int64_t _internal_timeoutseconds() const;
  void _internal_set_timeoutseconds(int64_t value);
  public:

  // optional int64 limit = 7;
  bool has_limit() const;
  private:
  bool _internal_has_limit() const;
  public:
  void clear_limit();
  int64_t limit() const;
  void set_limit(int64_t value);
  private:
  int64_t _internal_limit() const;
  void _internal_set_limit(int64_t value);
  public:

  // optional bool watch = 3;
  bool has_watch() const;
  private:
  bool _internal_has_watch() const;
  public:
  void clear_watch();
  bool watch() const;
  void set_watch(bool value);
  private:
  bool _internal_watch() const;
  void _internal_set_watch(bool value);
  public:

  // optional bool allowWatchBookmarks = 9;
  bool has_allowwatchbookmarks() const;
  private:
  bool _internal_has_allowwatchbookmarks() const;
  public:
  void clear_allowwatchbookmarks();
  bool allowwatchbookmarks() const;
  void set_allowwatchbookmarks(bool value);
  private:
  bool _internal_allowwatchbookmarks() const;
  void _internal_set_allowwatchbookmarks(bool value);
  public:

  // optional bool sendInitialEvents = 11;
  bool has_sendinitialevents() const;
  private:
  bool _internal_has_sendinitialevents() const;
  public:
  void clear_sendinitialevents();
  bool sendinitialevents() const;
  void set_sendinitialevents(bool value);
  private:
  bool _internal_sendinitialevents() const;
  void _internal_set_sendinitialevents(bool value);
  public:

  // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.ListOptions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr labelselector_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fieldselector_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resourceversion_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr continue__;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resourceversionmatch_;
    int64_t timeoutseconds_;
    int64_t limit_;
    bool watch_;
    bool allowwatchbookmarks_;
    bool sendinitialevents_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_staging_5fsrc_5fk8s_2eio_5fapimachinery_5fpkg_5fapis_5fmeta_5fv1_5fgenerated_2eproto;
};
// -------------------------------------------------------------------

class ManagedFieldsEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:k8s.io.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry) */ {
 public:
  inline ManagedFieldsEntry() : ManagedFieldsEntry(nullptr) {}
  ~ManagedFieldsEntry() override;
  explicit PROTOBUF_CONSTEXPR ManagedFieldsEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ManagedFieldsEntry(const ManagedFieldsEntry& from);
  ManagedFieldsEntry(ManagedFieldsEntry&& from) noexcept
    : ManagedFieldsEntry() {
    *this = ::std::move(from);
  }

  inline ManagedFieldsEntry& operator=(const ManagedFieldsEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline ManagedFieldsEntry& operator=(ManagedFieldsEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ManagedFieldsEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const ManagedFieldsEntry* internal_default_instance() {
    return reinterpret_cast<const ManagedFieldsEntry*>(
               &_ManagedFieldsEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(ManagedFieldsEntry& a, ManagedFieldsEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(ManagedFieldsEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ManagedFieldsEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ManagedFieldsEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ManagedFieldsEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ManagedFieldsEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ManagedFieldsEntry& from) {
    ManagedFieldsEntry::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ManagedFieldsEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "k8s.io.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry";
  }
  protected:
  explicit ManagedFieldsEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kManagerFieldNumber = 1,
    kOperationFieldNumber = 2,
    kApiVersionFieldNumber = 3,
    kFieldsTypeFieldNumber = 6,
    kSubresourceFieldNumber = 8,
    kTimeFieldNumber = 4,
    kFieldsV1FieldNumber = 7,
  };
  // optional string manager = 1;
  bool has_manager() const;
  private:
  bool _internal_has_manager() const;
  public:
  void clear_manager();
  const std::string& manager() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_manager(ArgT0&& arg0, ArgT... args);
  std::string* mutable_manager();
  PROTOBUF_NODISCARD std::string* release_manager();
  void set_allocated_manager(std::string* manager);
  private:
  const std::string& _internal_manager() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_manager(const std::string& value);
  std::string* _internal_mutable_manager();
  public:

  // optional string operation = 2;
  bool has_operation() const;
  private:
  bool _internal_has_operation() const;
  public:
  void clear_operation();
  const std::string& operation() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_operation(ArgT0&& arg0, ArgT... args);
  std::string* mutable_operation();
  PROTOBUF_NODISCARD std::string* release_operation();
  void set_allocated_operation(std::string* operation);
  private:
  const std::string& _internal_operation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_operation(const std::string& value);
  std::string* _internal_mutable_operation();
  public:

  // optional string apiVersion = 3;
  bool has_apiversion() const;
  private:
  bool _internal_has_apiversion() const;
  public:
  void clear_apiversion();
  const std::string& apiversion() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_apiversion(ArgT0&& arg0, ArgT... args);
  std::string* mutable_apiversion();
  PROTOBUF_NODISCARD std::string* release_apiversion();
  void set_allocated_apiversion(std::string* apiversion);
  private:
  const std::string& _internal_apiversion() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_apiversion(const std::string& value);
  std::string* _internal_mutable_apiversion();
  public:

  // optional string fieldsType = 6;
  bool has_fieldstype() const;
  private:
  bool _internal_has_fieldstype() const;
  public:
  void clear_fieldstype();
  const std::string& fieldstype() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fieldstype(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fieldstype();
  PROTOBUF_NODISCARD std::string* release_fieldstype();
  void set_allocated_fieldstype(std::string* fieldstype);
  private:
  const std::string& _internal_fieldstype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fieldstype(const std::string& value);
  std::string* _internal_mutable_fieldstype();
  public:

  // optional string subresource = 8;
  bool has_subresource() const;
  private:
  bool _internal_has_subresource() const;
  public:
  void clear_subresource();
  const std::string& subresource() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_subresource(ArgT0&& arg0, ArgT... args);
  std::string* mutable_subresource();
  PROTOBUF_NODISCARD std::string* release_subresource();
  void set_allocated_subresource(std::string* subresource);
  private:
  const std::string& _internal_subresource() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subresource(const std::string& value);
  std::string* _internal_mutable_subresource();
  public:

  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time time = 4;
  bool has_time() const;
  private:
  bool _internal_has_time() const;
  public:
  void clear_time();
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::Time& time() const;
  PROTOBUF_NODISCARD ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* release_time();
  ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* mutable_time();
  void set_allocated_time(::k8s::io::apimachinery::pkg::apis::meta::v1::Time* time);
  private:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::Time& _internal_time() const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* _internal_mutable_time();
  public:
  void unsafe_arena_set_allocated_time(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* time);
  ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* unsafe_arena_release_time();

  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.FieldsV1 fieldsV1 = 7;
  bool has_fieldsv1() const;
  private:
  bool _internal_has_fieldsv1() const;
  public:
  void clear_fieldsv1();
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::FieldsV1& fieldsv1() const;
  PROTOBUF_NODISCARD ::k8s::io::apimachinery::pkg::apis::meta::v1::FieldsV1* release_fieldsv1();
  ::k8s::io::apimachinery::pkg::apis::meta::v1::FieldsV1* mutable_fieldsv1();
  void set_allocated_fieldsv1(::k8s::io::apimachinery::pkg::apis::meta::v1::FieldsV1* fieldsv1);
  private:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::FieldsV1& _internal_fieldsv1() const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::FieldsV1* _internal_mutable_fieldsv1();
  public:
  void unsafe_arena_set_allocated_fieldsv1(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::FieldsV1* fieldsv1);
  ::k8s::io::apimachinery::pkg::apis::meta::v1::FieldsV1* unsafe_arena_release_fieldsv1();

  // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr manager_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr operation_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr apiversion_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fieldstype_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subresource_;
    ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* time_;
    ::k8s::io::apimachinery::pkg::apis::meta::v1::FieldsV1* fieldsv1_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_staging_5fsrc_5fk8s_2eio_5fapimachinery_5fpkg_5fapis_5fmeta_5fv1_5fgenerated_2eproto;
};
// -------------------------------------------------------------------

class MicroTime final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime) */ {
 public:
  inline MicroTime() : MicroTime(nullptr) {}
  ~MicroTime() override;
  explicit PROTOBUF_CONSTEXPR MicroTime(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MicroTime(const MicroTime& from);
  MicroTime(MicroTime&& from) noexcept
    : MicroTime() {
    *this = ::std::move(from);
  }

  inline MicroTime& operator=(const MicroTime& from) {
    CopyFrom(from);
    return *this;
  }
  inline MicroTime& operator=(MicroTime&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MicroTime& default_instance() {
    return *internal_default_instance();
  }
  static inline const MicroTime* internal_default_instance() {
    return reinterpret_cast<const MicroTime*>(
               &_MicroTime_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(MicroTime& a, MicroTime& b) {
    a.Swap(&b);
  }
  inline void Swap(MicroTime* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MicroTime* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MicroTime* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MicroTime>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MicroTime& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MicroTime& from) {
    MicroTime::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MicroTime* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime";
  }
  protected:
  explicit MicroTime(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSecondsFieldNumber = 1,
    kNanosFieldNumber = 2,
  };
  // optional int64 seconds = 1;
  bool has_seconds() const;
  private:
  bool _internal_has_seconds() const;
  public:
  void clear_seconds();
  int64_t seconds() const;
  void set_seconds(int64_t value);
  private:
  int64_t _internal_seconds() const;
  void _internal_set_seconds(int64_t value);
  public:

  // optional int32 nanos = 2;
  bool has_nanos() const;
  private:
  bool _internal_has_nanos() const;
  public:
  void clear_nanos();
  int32_t nanos() const;
  void set_nanos(int32_t value);
  private:
  int32_t _internal_nanos() const;
  void _internal_set_nanos(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int64_t seconds_;
    int32_t nanos_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_staging_5fsrc_5fk8s_2eio_5fapimachinery_5fpkg_5fapis_5fmeta_5fv1_5fgenerated_2eproto;
};
// -------------------------------------------------------------------

class ObjectMeta_LabelsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ObjectMeta_LabelsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ObjectMeta_LabelsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  ObjectMeta_LabelsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR ObjectMeta_LabelsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ObjectMeta_LabelsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ObjectMeta_LabelsEntry_DoNotUse& other);
  static const ObjectMeta_LabelsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ObjectMeta_LabelsEntry_DoNotUse*>(&_ObjectMeta_LabelsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
#ifndef NDEBUG
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
       s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta.LabelsEntry.key");
#else
    (void) s;
#endif
    return true;
 }
  static bool ValidateValue(std::string* s) {
#ifndef NDEBUG
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
       s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta.LabelsEntry.value");
#else
    (void) s;
#endif
    return true;
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_staging_5fsrc_5fk8s_2eio_5fapimachinery_5fpkg_5fapis_5fmeta_5fv1_5fgenerated_2eproto;
};

// -------------------------------------------------------------------

class ObjectMeta_AnnotationsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ObjectMeta_AnnotationsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ObjectMeta_AnnotationsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  ObjectMeta_AnnotationsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR ObjectMeta_AnnotationsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ObjectMeta_AnnotationsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ObjectMeta_AnnotationsEntry_DoNotUse& other);
  static const ObjectMeta_AnnotationsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ObjectMeta_AnnotationsEntry_DoNotUse*>(&_ObjectMeta_AnnotationsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
#ifndef NDEBUG
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
       s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta.AnnotationsEntry.key");
#else
    (void) s;
#endif
    return true;
 }
  static bool ValidateValue(std::string* s) {
#ifndef NDEBUG
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
       s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta.AnnotationsEntry.value");
#else
    (void) s;
#endif
    return true;
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_staging_5fsrc_5fk8s_2eio_5fapimachinery_5fpkg_5fapis_5fmeta_5fv1_5fgenerated_2eproto;
};

// -------------------------------------------------------------------

class ObjectMeta final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta) */ {
 public:
  inline ObjectMeta() : ObjectMeta(nullptr) {}
  ~ObjectMeta() override;
  explicit PROTOBUF_CONSTEXPR ObjectMeta(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ObjectMeta(const ObjectMeta& from);
  ObjectMeta(ObjectMeta&& from) noexcept
    : ObjectMeta() {
    *this = ::std::move(from);
  }

  inline ObjectMeta& operator=(const ObjectMeta& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectMeta& operator=(ObjectMeta&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObjectMeta& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObjectMeta* internal_default_instance() {
    return reinterpret_cast<const ObjectMeta*>(
               &_ObjectMeta_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(ObjectMeta& a, ObjectMeta& b) {
    a.Swap(&b);
  }
  inline void Swap(ObjectMeta* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectMeta* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObjectMeta* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ObjectMeta>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ObjectMeta& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ObjectMeta& from) {
    ObjectMeta::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectMeta* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta";
  }
  protected:
  explicit ObjectMeta(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kLabelsFieldNumber = 11,
    kAnnotationsFieldNumber = 12,
    kOwnerReferencesFieldNumber = 13,
    kFinalizersFieldNumber = 14,
    kManagedFieldsFieldNumber = 17,
    kNameFieldNumber = 1,
    kGenerateNameFieldNumber = 2,
    kNamespaceFieldNumber = 3,
    kSelfLinkFieldNumber = 4,
    kUidFieldNumber = 5,
    kResourceVersionFieldNumber = 6,
    kCreationTimestampFieldNumber = 8,
    kDeletionTimestampFieldNumber = 9,
    kGenerationFieldNumber = 7,
    kDeletionGracePeriodSecondsFieldNumber = 10,
  };
  // map<string, string> labels = 11;
  int labels_size() const;
  private:
  int _internal_labels_size() const;
  public:
  void clear_labels();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_labels() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_labels();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      labels() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_labels();

  // map<string, string> annotations = 12;
  int annotations_size() const;
  private:
  int _internal_annotations_size() const;
  public:
  void clear_annotations();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_annotations() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_annotations();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      annotations() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_annotations();

  // repeated .k8s.io.apimachinery.pkg.apis.meta.v1.OwnerReference ownerReferences = 13;
  int ownerreferences_size() const;
  private:
  int _internal_ownerreferences_size() const;
  public:
  void clear_ownerreferences();
  ::k8s::io::apimachinery::pkg::apis::meta::v1::OwnerReference* mutable_ownerreferences(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::k8s::io::apimachinery::pkg::apis::meta::v1::OwnerReference >*
      mutable_ownerreferences();
  private:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::OwnerReference& _internal_ownerreferences(int index) const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::OwnerReference* _internal_add_ownerreferences();
  public:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::OwnerReference& ownerreferences(int index) const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::OwnerReference* add_ownerreferences();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::k8s::io::apimachinery::pkg::apis::meta::v1::OwnerReference >&
      ownerreferences() const;

  // repeated string finalizers = 14;
  int finalizers_size() const;
  private:
  int _internal_finalizers_size() const;
  public:
  void clear_finalizers();
  const std::string& finalizers(int index) const;
  std::string* mutable_finalizers(int index);
  void set_finalizers(int index, const std::string& value);
  void set_finalizers(int index, std::string&& value);
  void set_finalizers(int index, const char* value);
  void set_finalizers(int index, const char* value, size_t size);
  std::string* add_finalizers();
  void add_finalizers(const std::string& value);
  void add_finalizers(std::string&& value);
  void add_finalizers(const char* value);
  void add_finalizers(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& finalizers() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_finalizers();
  private:
  const std::string& _internal_finalizers(int index) const;
  std::string* _internal_add_finalizers();
  public:

  // repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry managedFields = 17;
  int managedfields_size() const;
  private:
  int _internal_managedfields_size() const;
  public:
  void clear_managedfields();
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ManagedFieldsEntry* mutable_managedfields(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::k8s::io::apimachinery::pkg::apis::meta::v1::ManagedFieldsEntry >*
      mutable_managedfields();
  private:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ManagedFieldsEntry& _internal_managedfields(int index) const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ManagedFieldsEntry* _internal_add_managedfields();
  public:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ManagedFieldsEntry& managedfields(int index) const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ManagedFieldsEntry* add_managedfields();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::k8s::io::apimachinery::pkg::apis::meta::v1::ManagedFieldsEntry >&
      managedfields() const;

  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string generateName = 2;
  bool has_generatename() const;
  private:
  bool _internal_has_generatename() const;
  public:
  void clear_generatename();
  const std::string& generatename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_generatename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_generatename();
  PROTOBUF_NODISCARD std::string* release_generatename();
  void set_allocated_generatename(std::string* generatename);
  private:
  const std::string& _internal_generatename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_generatename(const std::string& value);
  std::string* _internal_mutable_generatename();
  public:

  // optional string namespace = 3;
  bool has_namespace_() const;
  private:
  bool _internal_has_namespace_() const;
  public:
  void clear_namespace_();
  const std::string& namespace_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_namespace_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_namespace_();
  PROTOBUF_NODISCARD std::string* release_namespace_();
  void set_allocated_namespace_(std::string* namespace_);
  private:
  const std::string& _internal_namespace_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_namespace_(const std::string& value);
  std::string* _internal_mutable_namespace_();
  public:

  // optional string selfLink = 4;
  bool has_selflink() const;
  private:
  bool _internal_has_selflink() const;
  public:
  void clear_selflink();
  const std::string& selflink() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_selflink(ArgT0&& arg0, ArgT... args);
  std::string* mutable_selflink();
  PROTOBUF_NODISCARD std::string* release_selflink();
  void set_allocated_selflink(std::string* selflink);
  private:
  const std::string& _internal_selflink() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_selflink(const std::string& value);
  std::string* _internal_mutable_selflink();
  public:

  // optional string uid = 5;
  bool has_uid() const;
  private:
  bool _internal_has_uid() const;
  public:
  void clear_uid();
  const std::string& uid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uid();
  PROTOBUF_NODISCARD std::string* release_uid();
  void set_allocated_uid(std::string* uid);
  private:
  const std::string& _internal_uid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uid(const std::string& value);
  std::string* _internal_mutable_uid();
  public:

  // optional string resourceVersion = 6;
  bool has_resourceversion() const;
  private:
  bool _internal_has_resourceversion() const;
  public:
  void clear_resourceversion();
  const std::string& resourceversion() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_resourceversion(ArgT0&& arg0, ArgT... args);
  std::string* mutable_resourceversion();
  PROTOBUF_NODISCARD std::string* release_resourceversion();
  void set_allocated_resourceversion(std::string* resourceversion);
  private:
  const std::string& _internal_resourceversion() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resourceversion(const std::string& value);
  std::string* _internal_mutable_resourceversion();
  public:

  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time creationTimestamp = 8;
  bool has_creationtimestamp() const;
  private:
  bool _internal_has_creationtimestamp() const;
  public:
  void clear_creationtimestamp();
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::Time& creationtimestamp() const;
  PROTOBUF_NODISCARD ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* release_creationtimestamp();
  ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* mutable_creationtimestamp();
  void set_allocated_creationtimestamp(::k8s::io::apimachinery::pkg::apis::meta::v1::Time* creationtimestamp);
  private:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::Time& _internal_creationtimestamp() const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* _internal_mutable_creationtimestamp();
  public:
  void unsafe_arena_set_allocated_creationtimestamp(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* creationtimestamp);
  ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* unsafe_arena_release_creationtimestamp();

  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time deletionTimestamp = 9;
  bool has_deletiontimestamp() const;
  private:
  bool _internal_has_deletiontimestamp() const;
  public:
  void clear_deletiontimestamp();
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::Time& deletiontimestamp() const;
  PROTOBUF_NODISCARD ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* release_deletiontimestamp();
  ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* mutable_deletiontimestamp();
  void set_allocated_deletiontimestamp(::k8s::io::apimachinery::pkg::apis::meta::v1::Time* deletiontimestamp);
  private:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::Time& _internal_deletiontimestamp() const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* _internal_mutable_deletiontimestamp();
  public:
  void unsafe_arena_set_allocated_deletiontimestamp(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* deletiontimestamp);
  ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* unsafe_arena_release_deletiontimestamp();

  // optional int64 generation = 7;
  bool has_generation() const;
  private:
  bool _internal_has_generation() const;
  public:
  void clear_generation();
  int64_t generation() const;
  void set_generation(int64_t value);
  private:
  int64_t _internal_generation() const;
  void _internal_set_generation(int64_t value);
  public:

  // optional int64 deletionGracePeriodSeconds = 10;
  bool has_deletiongraceperiodseconds() const;
  private:
  bool _internal_has_deletiongraceperiodseconds() const;
  public:
  void clear_deletiongraceperiodseconds();
  int64_t deletiongraceperiodseconds() const;
  void set_deletiongraceperiodseconds(int64_t value);
  private:
  int64_t _internal_deletiongraceperiodseconds() const;
  void _internal_set_deletiongraceperiodseconds(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        ObjectMeta_LabelsEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> labels_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        ObjectMeta_AnnotationsEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> annotations_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::k8s::io::apimachinery::pkg::apis::meta::v1::OwnerReference > ownerreferences_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> finalizers_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::k8s::io::apimachinery::pkg::apis::meta::v1::ManagedFieldsEntry > managedfields_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr generatename_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr namespace__;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr selflink_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resourceversion_;
    ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* creationtimestamp_;
    ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* deletiontimestamp_;
    int64_t generation_;
    int64_t deletiongraceperiodseconds_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_staging_5fsrc_5fk8s_2eio_5fapimachinery_5fpkg_5fapis_5fmeta_5fv1_5fgenerated_2eproto;
};
// -------------------------------------------------------------------

class OwnerReference final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:k8s.io.apimachinery.pkg.apis.meta.v1.OwnerReference) */ {
 public:
  inline OwnerReference() : OwnerReference(nullptr) {}
  ~OwnerReference() override;
  explicit PROTOBUF_CONSTEXPR OwnerReference(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OwnerReference(const OwnerReference& from);
  OwnerReference(OwnerReference&& from) noexcept
    : OwnerReference() {
    *this = ::std::move(from);
  }

  inline OwnerReference& operator=(const OwnerReference& from) {
    CopyFrom(from);
    return *this;
  }
  inline OwnerReference& operator=(OwnerReference&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OwnerReference& default_instance() {
    return *internal_default_instance();
  }
  static inline const OwnerReference* internal_default_instance() {
    return reinterpret_cast<const OwnerReference*>(
               &_OwnerReference_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(OwnerReference& a, OwnerReference& b) {
    a.Swap(&b);
  }
  inline void Swap(OwnerReference* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OwnerReference* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OwnerReference* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OwnerReference>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OwnerReference& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OwnerReference& from) {
    OwnerReference::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OwnerReference* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "k8s.io.apimachinery.pkg.apis.meta.v1.OwnerReference";
  }
  protected:
  explicit OwnerReference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKindFieldNumber = 1,
    kNameFieldNumber = 3,
    kUidFieldNumber = 4,
    kApiVersionFieldNumber = 5,
    kControllerFieldNumber = 6,
    kBlockOwnerDeletionFieldNumber = 7,
  };
  // optional string kind = 1;
  bool has_kind() const;
  private:
  bool _internal_has_kind() const;
  public:
  void clear_kind();
  const std::string& kind() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_kind(ArgT0&& arg0, ArgT... args);
  std::string* mutable_kind();
  PROTOBUF_NODISCARD std::string* release_kind();
  void set_allocated_kind(std::string* kind);
  private:
  const std::string& _internal_kind() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_kind(const std::string& value);
  std::string* _internal_mutable_kind();
  public:

  // optional string name = 3;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string uid = 4;
  bool has_uid() const;
  private:
  bool _internal_has_uid() const;
  public:
  void clear_uid();
  const std::string& uid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uid();
  PROTOBUF_NODISCARD std::string* release_uid();
  void set_allocated_uid(std::string* uid);
  private:
  const std::string& _internal_uid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uid(const std::string& value);
  std::string* _internal_mutable_uid();
  public:

  // optional string apiVersion = 5;
  bool has_apiversion() const;
  private:
  bool _internal_has_apiversion() const;
  public:
  void clear_apiversion();
  const std::string& apiversion() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_apiversion(ArgT0&& arg0, ArgT... args);
  std::string* mutable_apiversion();
  PROTOBUF_NODISCARD std::string* release_apiversion();
  void set_allocated_apiversion(std::string* apiversion);
  private:
  const std::string& _internal_apiversion() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_apiversion(const std::string& value);
  std::string* _internal_mutable_apiversion();
  public:

  // optional bool controller = 6;
  bool has_controller() const;
  private:
  bool _internal_has_controller() const;
  public:
  void clear_controller();
  bool controller() const;
  void set_controller(bool value);
  private:
  bool _internal_controller() const;
  void _internal_set_controller(bool value);
  public:

  // optional bool blockOwnerDeletion = 7;
  bool has_blockownerdeletion() const;
  private:
  bool _internal_has_blockownerdeletion() const;
  public:
  void clear_blockownerdeletion();
  bool blockownerdeletion() const;
  void set_blockownerdeletion(bool value);
  private:
  bool _internal_blockownerdeletion() const;
  void _internal_set_blockownerdeletion(bool value);
  public:

  // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.OwnerReference)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr kind_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr apiversion_;
    bool controller_;
    bool blockownerdeletion_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_staging_5fsrc_5fk8s_2eio_5fapimachinery_5fpkg_5fapis_5fmeta_5fv1_5fgenerated_2eproto;
};
// -------------------------------------------------------------------

class PartialObjectMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:k8s.io.apimachinery.pkg.apis.meta.v1.PartialObjectMetadata) */ {
 public:
  inline PartialObjectMetadata() : PartialObjectMetadata(nullptr) {}
  ~PartialObjectMetadata() override;
  explicit PROTOBUF_CONSTEXPR PartialObjectMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PartialObjectMetadata(const PartialObjectMetadata& from);
  PartialObjectMetadata(PartialObjectMetadata&& from) noexcept
    : PartialObjectMetadata() {
    *this = ::std::move(from);
  }

  inline PartialObjectMetadata& operator=(const PartialObjectMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline PartialObjectMetadata& operator=(PartialObjectMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PartialObjectMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const PartialObjectMetadata* internal_default_instance() {
    return reinterpret_cast<const PartialObjectMetadata*>(
               &_PartialObjectMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(PartialObjectMetadata& a, PartialObjectMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(PartialObjectMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PartialObjectMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PartialObjectMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PartialObjectMetadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PartialObjectMetadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PartialObjectMetadata& from) {
    PartialObjectMetadata::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PartialObjectMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "k8s.io.apimachinery.pkg.apis.meta.v1.PartialObjectMetadata";
  }
  protected:
  explicit PartialObjectMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 1,
  };
  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& metadata() const;
  PROTOBUF_NODISCARD ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* release_metadata();
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* mutable_metadata();
  void set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata);
  private:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& _internal_metadata() const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata);
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* unsafe_arena_release_metadata();

  // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.PartialObjectMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_staging_5fsrc_5fk8s_2eio_5fapimachinery_5fpkg_5fapis_5fmeta_5fv1_5fgenerated_2eproto;
};
// -------------------------------------------------------------------

class PartialObjectMetadataList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:k8s.io.apimachinery.pkg.apis.meta.v1.PartialObjectMetadataList) */ {
 public:
  inline PartialObjectMetadataList() : PartialObjectMetadataList(nullptr) {}
  ~PartialObjectMetadataList() override;
  explicit PROTOBUF_CONSTEXPR PartialObjectMetadataList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PartialObjectMetadataList(const PartialObjectMetadataList& from);
  PartialObjectMetadataList(PartialObjectMetadataList&& from) noexcept
    : PartialObjectMetadataList() {
    *this = ::std::move(from);
  }

  inline PartialObjectMetadataList& operator=(const PartialObjectMetadataList& from) {
    CopyFrom(from);
    return *this;
  }
  inline PartialObjectMetadataList& operator=(PartialObjectMetadataList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PartialObjectMetadataList& default_instance() {
    return *internal_default_instance();
  }
  static inline const PartialObjectMetadataList* internal_default_instance() {
    return reinterpret_cast<const PartialObjectMetadataList*>(
               &_PartialObjectMetadataList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(PartialObjectMetadataList& a, PartialObjectMetadataList& b) {
    a.Swap(&b);
  }
  inline void Swap(PartialObjectMetadataList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PartialObjectMetadataList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PartialObjectMetadataList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PartialObjectMetadataList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PartialObjectMetadataList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PartialObjectMetadataList& from) {
    PartialObjectMetadataList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PartialObjectMetadataList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "k8s.io.apimachinery.pkg.apis.meta.v1.PartialObjectMetadataList";
  }
  protected:
  explicit PartialObjectMetadataList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 2,
    kMetadataFieldNumber = 1,
  };
  // repeated .k8s.io.apimachinery.pkg.apis.meta.v1.PartialObjectMetadata items = 2;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::k8s::io::apimachinery::pkg::apis::meta::v1::PartialObjectMetadata* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::k8s::io::apimachinery::pkg::apis::meta::v1::PartialObjectMetadata >*
      mutable_items();
  private:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::PartialObjectMetadata& _internal_items(int index) const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::PartialObjectMetadata* _internal_add_items();
  public:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::PartialObjectMetadata& items(int index) const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::PartialObjectMetadata* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::k8s::io::apimachinery::pkg::apis::meta::v1::PartialObjectMetadata >&
      items() const;

  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& metadata() const;
  PROTOBUF_NODISCARD ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* release_metadata();
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* mutable_metadata();
  void set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata);
  private:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& _internal_metadata() const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata);
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* unsafe_arena_release_metadata();

  // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.PartialObjectMetadataList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::k8s::io::apimachinery::pkg::apis::meta::v1::PartialObjectMetadata > items_;
    ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_staging_5fsrc_5fk8s_2eio_5fapimachinery_5fpkg_5fapis_5fmeta_5fv1_5fgenerated_2eproto;
};
// -------------------------------------------------------------------

class Patch final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:k8s.io.apimachinery.pkg.apis.meta.v1.Patch) */ {
 public:
  inline Patch() : Patch(nullptr) {}
  explicit PROTOBUF_CONSTEXPR Patch(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Patch(const Patch& from);
  Patch(Patch&& from) noexcept
    : Patch() {
    *this = ::std::move(from);
  }

  inline Patch& operator=(const Patch& from) {
    CopyFrom(from);
    return *this;
  }
  inline Patch& operator=(Patch&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Patch& default_instance() {
    return *internal_default_instance();
  }
  static inline const Patch* internal_default_instance() {
    return reinterpret_cast<const Patch*>(
               &_Patch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(Patch& a, Patch& b) {
    a.Swap(&b);
  }
  inline void Swap(Patch* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Patch* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Patch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Patch>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Patch& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Patch& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "k8s.io.apimachinery.pkg.apis.meta.v1.Patch";
  }
  protected:
  explicit Patch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.Patch)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_staging_5fsrc_5fk8s_2eio_5fapimachinery_5fpkg_5fapis_5fmeta_5fv1_5fgenerated_2eproto;
};
// -------------------------------------------------------------------

class PatchOptions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:k8s.io.apimachinery.pkg.apis.meta.v1.PatchOptions) */ {
 public:
  inline PatchOptions() : PatchOptions(nullptr) {}
  ~PatchOptions() override;
  explicit PROTOBUF_CONSTEXPR PatchOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PatchOptions(const PatchOptions& from);
  PatchOptions(PatchOptions&& from) noexcept
    : PatchOptions() {
    *this = ::std::move(from);
  }

  inline PatchOptions& operator=(const PatchOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline PatchOptions& operator=(PatchOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PatchOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const PatchOptions* internal_default_instance() {
    return reinterpret_cast<const PatchOptions*>(
               &_PatchOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(PatchOptions& a, PatchOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(PatchOptions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PatchOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PatchOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PatchOptions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PatchOptions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PatchOptions& from) {
    PatchOptions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PatchOptions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "k8s.io.apimachinery.pkg.apis.meta.v1.PatchOptions";
  }
  protected:
  explicit PatchOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDryRunFieldNumber = 1,
    kFieldManagerFieldNumber = 3,
    kFieldValidationFieldNumber = 4,
    kForceFieldNumber = 2,
  };
  // repeated string dryRun = 1;
  int dryrun_size() const;
  private:
  int _internal_dryrun_size() const;
  public:
  void clear_dryrun();
  const std::string& dryrun(int index) const;
  std::string* mutable_dryrun(int index);
  void set_dryrun(int index, const std::string& value);
  void set_dryrun(int index, std::string&& value);
  void set_dryrun(int index, const char* value);
  void set_dryrun(int index, const char* value, size_t size);
  std::string* add_dryrun();
  void add_dryrun(const std::string& value);
  void add_dryrun(std::string&& value);
  void add_dryrun(const char* value);
  void add_dryrun(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& dryrun() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_dryrun();
  private:
  const std::string& _internal_dryrun(int index) const;
  std::string* _internal_add_dryrun();
  public:

  // optional string fieldManager = 3;
  bool has_fieldmanager() const;
  private:
  bool _internal_has_fieldmanager() const;
  public:
  void clear_fieldmanager();
  const std::string& fieldmanager() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fieldmanager(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fieldmanager();
  PROTOBUF_NODISCARD std::string* release_fieldmanager();
  void set_allocated_fieldmanager(std::string* fieldmanager);
  private:
  const std::string& _internal_fieldmanager() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fieldmanager(const std::string& value);
  std::string* _internal_mutable_fieldmanager();
  public:

  // optional string fieldValidation = 4;
  bool has_fieldvalidation() const;
  private:
  bool _internal_has_fieldvalidation() const;
  public:
  void clear_fieldvalidation();
  const std::string& fieldvalidation() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fieldvalidation(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fieldvalidation();
  PROTOBUF_NODISCARD std::string* release_fieldvalidation();
  void set_allocated_fieldvalidation(std::string* fieldvalidation);
  private:
  const std::string& _internal_fieldvalidation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fieldvalidation(const std::string& value);
  std::string* _internal_mutable_fieldvalidation();
  public:

  // optional bool force = 2;
  bool has_force() const;
  private:
  bool _internal_has_force() const;
  public:
  void clear_force();
  bool force() const;
  void set_force(bool value);
  private:
  bool _internal_force() const;
  void _internal_set_force(bool value);
  public:

  // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.PatchOptions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> dryrun_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fieldmanager_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fieldvalidation_;
    bool force_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_staging_5fsrc_5fk8s_2eio_5fapimachinery_5fpkg_5fapis_5fmeta_5fv1_5fgenerated_2eproto;
};
// -------------------------------------------------------------------

class Preconditions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:k8s.io.apimachinery.pkg.apis.meta.v1.Preconditions) */ {
 public:
  inline Preconditions() : Preconditions(nullptr) {}
  ~Preconditions() override;
  explicit PROTOBUF_CONSTEXPR Preconditions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Preconditions(const Preconditions& from);
  Preconditions(Preconditions&& from) noexcept
    : Preconditions() {
    *this = ::std::move(from);
  }

  inline Preconditions& operator=(const Preconditions& from) {
    CopyFrom(from);
    return *this;
  }
  inline Preconditions& operator=(Preconditions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Preconditions& default_instance() {
    return *internal_default_instance();
  }
  static inline const Preconditions* internal_default_instance() {
    return reinterpret_cast<const Preconditions*>(
               &_Preconditions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(Preconditions& a, Preconditions& b) {
    a.Swap(&b);
  }
  inline void Swap(Preconditions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Preconditions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Preconditions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Preconditions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Preconditions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Preconditions& from) {
    Preconditions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Preconditions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "k8s.io.apimachinery.pkg.apis.meta.v1.Preconditions";
  }
  protected:
  explicit Preconditions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUidFieldNumber = 1,
    kResourceVersionFieldNumber = 2,
  };
  // optional string uid = 1;
  bool has_uid() const;
  private:
  bool _internal_has_uid() const;
  public:
  void clear_uid();
  const std::string& uid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uid();
  PROTOBUF_NODISCARD std::string* release_uid();
  void set_allocated_uid(std::string* uid);
  private:
  const std::string& _internal_uid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uid(const std::string& value);
  std::string* _internal_mutable_uid();
  public:

  // optional string resourceVersion = 2;
  bool has_resourceversion() const;
  private:
  bool _internal_has_resourceversion() const;
  public:
  void clear_resourceversion();
  const std::string& resourceversion() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_resourceversion(ArgT0&& arg0, ArgT... args);
  std::string* mutable_resourceversion();
  PROTOBUF_NODISCARD std::string* release_resourceversion();
  void set_allocated_resourceversion(std::string* resourceversion);
  private:
  const std::string& _internal_resourceversion() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resourceversion(const std::string& value);
  std::string* _internal_mutable_resourceversion();
  public:

  // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.Preconditions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resourceversion_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_staging_5fsrc_5fk8s_2eio_5fapimachinery_5fpkg_5fapis_5fmeta_5fv1_5fgenerated_2eproto;
};
// -------------------------------------------------------------------

class RootPaths final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:k8s.io.apimachinery.pkg.apis.meta.v1.RootPaths) */ {
 public:
  inline RootPaths() : RootPaths(nullptr) {}
  ~RootPaths() override;
  explicit PROTOBUF_CONSTEXPR RootPaths(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RootPaths(const RootPaths& from);
  RootPaths(RootPaths&& from) noexcept
    : RootPaths() {
    *this = ::std::move(from);
  }

  inline RootPaths& operator=(const RootPaths& from) {
    CopyFrom(from);
    return *this;
  }
  inline RootPaths& operator=(RootPaths&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RootPaths& default_instance() {
    return *internal_default_instance();
  }
  static inline const RootPaths* internal_default_instance() {
    return reinterpret_cast<const RootPaths*>(
               &_RootPaths_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(RootPaths& a, RootPaths& b) {
    a.Swap(&b);
  }
  inline void Swap(RootPaths* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RootPaths* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RootPaths* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RootPaths>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RootPaths& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RootPaths& from) {
    RootPaths::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RootPaths* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "k8s.io.apimachinery.pkg.apis.meta.v1.RootPaths";
  }
  protected:
  explicit RootPaths(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathsFieldNumber = 1,
  };
  // repeated string paths = 1;
  int paths_size() const;
  private:
  int _internal_paths_size() const;
  public:
  void clear_paths();
  const std::string& paths(int index) const;
  std::string* mutable_paths(int index);
  void set_paths(int index, const std::string& value);
  void set_paths(int index, std::string&& value);
  void set_paths(int index, const char* value);
  void set_paths(int index, const char* value, size_t size);
  std::string* add_paths();
  void add_paths(const std::string& value);
  void add_paths(std::string&& value);
  void add_paths(const char* value);
  void add_paths(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& paths() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_paths();
  private:
  const std::string& _internal_paths(int index) const;
  std::string* _internal_add_paths();
  public:

  // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.RootPaths)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> paths_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_staging_5fsrc_5fk8s_2eio_5fapimachinery_5fpkg_5fapis_5fmeta_5fv1_5fgenerated_2eproto;
};
// -------------------------------------------------------------------

class ServerAddressByClientCIDR final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:k8s.io.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR) */ {
 public:
  inline ServerAddressByClientCIDR() : ServerAddressByClientCIDR(nullptr) {}
  ~ServerAddressByClientCIDR() override;
  explicit PROTOBUF_CONSTEXPR ServerAddressByClientCIDR(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServerAddressByClientCIDR(const ServerAddressByClientCIDR& from);
  ServerAddressByClientCIDR(ServerAddressByClientCIDR&& from) noexcept
    : ServerAddressByClientCIDR() {
    *this = ::std::move(from);
  }

  inline ServerAddressByClientCIDR& operator=(const ServerAddressByClientCIDR& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerAddressByClientCIDR& operator=(ServerAddressByClientCIDR&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServerAddressByClientCIDR& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServerAddressByClientCIDR* internal_default_instance() {
    return reinterpret_cast<const ServerAddressByClientCIDR*>(
               &_ServerAddressByClientCIDR_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(ServerAddressByClientCIDR& a, ServerAddressByClientCIDR& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerAddressByClientCIDR* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerAddressByClientCIDR* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServerAddressByClientCIDR* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServerAddressByClientCIDR>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServerAddressByClientCIDR& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ServerAddressByClientCIDR& from) {
    ServerAddressByClientCIDR::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerAddressByClientCIDR* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "k8s.io.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR";
  }
  protected:
  explicit ServerAddressByClientCIDR(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientCIDRFieldNumber = 1,
    kServerAddressFieldNumber = 2,
  };
  // optional string clientCIDR = 1;
  bool has_clientcidr() const;
  private:
  bool _internal_has_clientcidr() const;
  public:
  void clear_clientcidr();
  const std::string& clientcidr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_clientcidr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_clientcidr();
  PROTOBUF_NODISCARD std::string* release_clientcidr();
  void set_allocated_clientcidr(std::string* clientcidr);
  private:
  const std::string& _internal_clientcidr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clientcidr(const std::string& value);
  std::string* _internal_mutable_clientcidr();
  public:

  // optional string serverAddress = 2;
  bool has_serveraddress() const;
  private:
  bool _internal_has_serveraddress() const;
  public:
  void clear_serveraddress();
  const std::string& serveraddress() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_serveraddress(ArgT0&& arg0, ArgT... args);
  std::string* mutable_serveraddress();
  PROTOBUF_NODISCARD std::string* release_serveraddress();
  void set_allocated_serveraddress(std::string* serveraddress);
  private:
  const std::string& _internal_serveraddress() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serveraddress(const std::string& value);
  std::string* _internal_mutable_serveraddress();
  public:

  // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clientcidr_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serveraddress_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_staging_5fsrc_5fk8s_2eio_5fapimachinery_5fpkg_5fapis_5fmeta_5fv1_5fgenerated_2eproto;
};
// -------------------------------------------------------------------

class Status final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:k8s.io.apimachinery.pkg.apis.meta.v1.Status) */ {
 public:
  inline Status() : Status(nullptr) {}
  ~Status() override;
  explicit PROTOBUF_CONSTEXPR Status(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Status(const Status& from);
  Status(Status&& from) noexcept
    : Status() {
    *this = ::std::move(from);
  }

  inline Status& operator=(const Status& from) {
    CopyFrom(from);
    return *this;
  }
  inline Status& operator=(Status&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Status& default_instance() {
    return *internal_default_instance();
  }
  static inline const Status* internal_default_instance() {
    return reinterpret_cast<const Status*>(
               &_Status_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(Status& a, Status& b) {
    a.Swap(&b);
  }
  inline void Swap(Status* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Status* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Status* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Status>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Status& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Status& from) {
    Status::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Status* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "k8s.io.apimachinery.pkg.apis.meta.v1.Status";
  }
  protected:
  explicit Status(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 2,
    kMessageFieldNumber = 3,
    kReasonFieldNumber = 4,
    kMetadataFieldNumber = 1,
    kDetailsFieldNumber = 5,
    kCodeFieldNumber = 6,
  };
  // optional string status = 2;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // optional string message = 3;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // optional string reason = 4;
  bool has_reason() const;
  private:
  bool _internal_has_reason() const;
  public:
  void clear_reason();
  const std::string& reason() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reason(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reason();
  PROTOBUF_NODISCARD std::string* release_reason();
  void set_allocated_reason(std::string* reason);
  private:
  const std::string& _internal_reason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reason(const std::string& value);
  std::string* _internal_mutable_reason();
  public:

  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& metadata() const;
  PROTOBUF_NODISCARD ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* release_metadata();
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* mutable_metadata();
  void set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata);
  private:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& _internal_metadata() const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata);
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* unsafe_arena_release_metadata();

  // optional .k8s.io.apimachinery.pkg.apis.meta.v1.StatusDetails details = 5;
  bool has_details() const;
  private:
  bool _internal_has_details() const;
  public:
  void clear_details();
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::StatusDetails& details() const;
  PROTOBUF_NODISCARD ::k8s::io::apimachinery::pkg::apis::meta::v1::StatusDetails* release_details();
  ::k8s::io::apimachinery::pkg::apis::meta::v1::StatusDetails* mutable_details();
  void set_allocated_details(::k8s::io::apimachinery::pkg::apis::meta::v1::StatusDetails* details);
  private:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::StatusDetails& _internal_details() const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::StatusDetails* _internal_mutable_details();
  public:
  void unsafe_arena_set_allocated_details(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::StatusDetails* details);
  ::k8s::io::apimachinery::pkg::apis::meta::v1::StatusDetails* unsafe_arena_release_details();

  // optional int32 code = 6;
  bool has_code() const;
  private:
  bool _internal_has_code() const;
  public:
  void clear_code();
  int32_t code() const;
  void set_code(int32_t value);
  private:
  int32_t _internal_code() const;
  void _internal_set_code(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.Status)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reason_;
    ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata_;
    ::k8s::io::apimachinery::pkg::apis::meta::v1::StatusDetails* details_;
    int32_t code_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_staging_5fsrc_5fk8s_2eio_5fapimachinery_5fpkg_5fapis_5fmeta_5fv1_5fgenerated_2eproto;
};
// -------------------------------------------------------------------

class StatusCause final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:k8s.io.apimachinery.pkg.apis.meta.v1.StatusCause) */ {
 public:
  inline StatusCause() : StatusCause(nullptr) {}
  ~StatusCause() override;
  explicit PROTOBUF_CONSTEXPR StatusCause(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StatusCause(const StatusCause& from);
  StatusCause(StatusCause&& from) noexcept
    : StatusCause() {
    *this = ::std::move(from);
  }

  inline StatusCause& operator=(const StatusCause& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatusCause& operator=(StatusCause&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StatusCause& default_instance() {
    return *internal_default_instance();
  }
  static inline const StatusCause* internal_default_instance() {
    return reinterpret_cast<const StatusCause*>(
               &_StatusCause_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(StatusCause& a, StatusCause& b) {
    a.Swap(&b);
  }
  inline void Swap(StatusCause* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatusCause* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StatusCause* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StatusCause>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StatusCause& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StatusCause& from) {
    StatusCause::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatusCause* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "k8s.io.apimachinery.pkg.apis.meta.v1.StatusCause";
  }
  protected:
  explicit StatusCause(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReasonFieldNumber = 1,
    kMessageFieldNumber = 2,
    kFieldFieldNumber = 3,
  };
  // optional string reason = 1;
  bool has_reason() const;
  private:
  bool _internal_has_reason() const;
  public:
  void clear_reason();
  const std::string& reason() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reason(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reason();
  PROTOBUF_NODISCARD std::string* release_reason();
  void set_allocated_reason(std::string* reason);
  private:
  const std::string& _internal_reason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reason(const std::string& value);
  std::string* _internal_mutable_reason();
  public:

  // optional string message = 2;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // optional string field = 3;
  bool has_field() const;
  private:
  bool _internal_has_field() const;
  public:
  void clear_field();
  const std::string& field() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field();
  PROTOBUF_NODISCARD std::string* release_field();
  void set_allocated_field(std::string* field);
  private:
  const std::string& _internal_field() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field(const std::string& value);
  std::string* _internal_mutable_field();
  public:

  // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.StatusCause)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reason_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_staging_5fsrc_5fk8s_2eio_5fapimachinery_5fpkg_5fapis_5fmeta_5fv1_5fgenerated_2eproto;
};
// -------------------------------------------------------------------

class StatusDetails final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:k8s.io.apimachinery.pkg.apis.meta.v1.StatusDetails) */ {
 public:
  inline StatusDetails() : StatusDetails(nullptr) {}
  ~StatusDetails() override;
  explicit PROTOBUF_CONSTEXPR StatusDetails(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StatusDetails(const StatusDetails& from);
  StatusDetails(StatusDetails&& from) noexcept
    : StatusDetails() {
    *this = ::std::move(from);
  }

  inline StatusDetails& operator=(const StatusDetails& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatusDetails& operator=(StatusDetails&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StatusDetails& default_instance() {
    return *internal_default_instance();
  }
  static inline const StatusDetails* internal_default_instance() {
    return reinterpret_cast<const StatusDetails*>(
               &_StatusDetails_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(StatusDetails& a, StatusDetails& b) {
    a.Swap(&b);
  }
  inline void Swap(StatusDetails* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatusDetails* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StatusDetails* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StatusDetails>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StatusDetails& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StatusDetails& from) {
    StatusDetails::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatusDetails* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "k8s.io.apimachinery.pkg.apis.meta.v1.StatusDetails";
  }
  protected:
  explicit StatusDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCausesFieldNumber = 4,
    kNameFieldNumber = 1,
    kGroupFieldNumber = 2,
    kKindFieldNumber = 3,
    kUidFieldNumber = 6,
    kRetryAfterSecondsFieldNumber = 5,
  };
  // repeated .k8s.io.apimachinery.pkg.apis.meta.v1.StatusCause causes = 4;
  int causes_size() const;
  private:
  int _internal_causes_size() const;
  public:
  void clear_causes();
  ::k8s::io::apimachinery::pkg::apis::meta::v1::StatusCause* mutable_causes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::k8s::io::apimachinery::pkg::apis::meta::v1::StatusCause >*
      mutable_causes();
  private:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::StatusCause& _internal_causes(int index) const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::StatusCause* _internal_add_causes();
  public:
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::StatusCause& causes(int index) const;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::StatusCause* add_causes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::k8s::io::apimachinery::pkg::apis::meta::v1::StatusCause >&
      causes() const;

  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string group = 2;
  bool has_group() const;
  private:
  bool _internal_has_group() const;
  public:
  void clear_group();
  const std::string& group() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_group(ArgT0&& arg0, ArgT... args);
  std::string* mutable_group();
  PROTOBUF_NODISCARD std::string* release_group();
  void set_allocated_group(std::string* group);
  private:
  const std::string& _internal_group() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_group(const std::string& value);
  std::string* _internal_mutable_group();
  public:

  // optional string kind = 3;
  bool has_kind() const;
  private:
  bool _internal_has_kind() const;
  public:
  void clear_kind();
  const std::string& kind() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_kind(ArgT0&& arg0, ArgT... args);
  std::string* mutable_kind();
  PROTOBUF_NODISCARD std::string* release_kind();
  void set_allocated_kind(std::string* kind);
  private:
  const std::string& _internal_kind() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_kind(const std::string& value);
  std::string* _internal_mutable_kind();
  public:

  // optional string uid = 6;
  bool has_uid() const;
  private:
  bool _internal_has_uid() const;
  public:
  void clear_uid();
  const std::string& uid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uid();
  PROTOBUF_NODISCARD std::string* release_uid();
  void set_allocated_uid(std::string* uid);
  private:
  const std::string& _internal_uid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uid(const std::string& value);
  std::string* _internal_mutable_uid();
  public:

  // optional int32 retryAfterSeconds = 5;
  bool has_retryafterseconds() const;
  private:
  bool _internal_has_retryafterseconds() const;
  public:
  void clear_retryafterseconds();
  int32_t retryafterseconds() const;
  void set_retryafterseconds(int32_t value);
  private:
  int32_t _internal_retryafterseconds() const;
  void _internal_set_retryafterseconds(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.StatusDetails)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::k8s::io::apimachinery::pkg::apis::meta::v1::StatusCause > causes_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr group_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr kind_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uid_;
    int32_t retryafterseconds_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_staging_5fsrc_5fk8s_2eio_5fapimachinery_5fpkg_5fapis_5fmeta_5fv1_5fgenerated_2eproto;
};
// -------------------------------------------------------------------

class TableOptions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:k8s.io.apimachinery.pkg.apis.meta.v1.TableOptions) */ {
 public:
  inline TableOptions() : TableOptions(nullptr) {}
  ~TableOptions() override;
  explicit PROTOBUF_CONSTEXPR TableOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TableOptions(const TableOptions& from);
  TableOptions(TableOptions&& from) noexcept
    : TableOptions() {
    *this = ::std::move(from);
  }

  inline TableOptions& operator=(const TableOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline TableOptions& operator=(TableOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TableOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const TableOptions* internal_default_instance() {
    return reinterpret_cast<const TableOptions*>(
               &_TableOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(TableOptions& a, TableOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(TableOptions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TableOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TableOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TableOptions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TableOptions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TableOptions& from) {
    TableOptions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TableOptions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "k8s.io.apimachinery.pkg.apis.meta.v1.TableOptions";
  }
  protected:
  explicit TableOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIncludeObjectFieldNumber = 1,
  };
  // optional string includeObject = 1;
  bool has_includeobject() const;
  private:
  bool _internal_has_includeobject() const;
  public:
  void clear_includeobject();
  const std::string& includeobject() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_includeobject(ArgT0&& arg0, ArgT... args);
  std::string* mutable_includeobject();
  PROTOBUF_NODISCARD std::string* release_includeobject();
  void set_allocated_includeobject(std::string* includeobject);
  private:
  const std::string& _internal_includeobject() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_includeobject(const std::string& value);
  std::string* _internal_mutable_includeobject();
  public:

  // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.TableOptions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr includeobject_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_staging_5fsrc_5fk8s_2eio_5fapimachinery_5fpkg_5fapis_5fmeta_5fv1_5fgenerated_2eproto;
};
// -------------------------------------------------------------------

class Time final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:k8s.io.apimachinery.pkg.apis.meta.v1.Time) */ {
 public:
  inline Time() : Time(nullptr) {}
  ~Time() override;
  explicit PROTOBUF_CONSTEXPR Time(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Time(const Time& from);
  Time(Time&& from) noexcept
    : Time() {
    *this = ::std::move(from);
  }

  inline Time& operator=(const Time& from) {
    CopyFrom(from);
    return *this;
  }
  inline Time& operator=(Time&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Time& default_instance() {
    return *internal_default_instance();
  }
  static inline const Time* internal_default_instance() {
    return reinterpret_cast<const Time*>(
               &_Time_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(Time& a, Time& b) {
    a.Swap(&b);
  }
  inline void Swap(Time* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Time* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Time* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Time>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Time& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Time& from) {
    Time::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Time* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "k8s.io.apimachinery.pkg.apis.meta.v1.Time";
  }
  protected:
  explicit Time(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSecondsFieldNumber = 1,
    kNanosFieldNumber = 2,
  };
  // optional int64 seconds = 1;
  bool has_seconds() const;
  private:
  bool _internal_has_seconds() const;
  public:
  void clear_seconds();
  int64_t seconds() const;
  void set_seconds(int64_t value);
  private:
  int64_t _internal_seconds() const;
  void _internal_set_seconds(int64_t value);
  public:

  // optional int32 nanos = 2;
  bool has_nanos() const;
  private:
  bool _internal_has_nanos() const;
  public:
  void clear_nanos();
  int32_t nanos() const;
  void set_nanos(int32_t value);
  private:
  int32_t _internal_nanos() const;
  void _internal_set_nanos(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.Time)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int64_t seconds_;
    int32_t nanos_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_staging_5fsrc_5fk8s_2eio_5fapimachinery_5fpkg_5fapis_5fmeta_5fv1_5fgenerated_2eproto;
};
// -------------------------------------------------------------------

class Timestamp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:k8s.io.apimachinery.pkg.apis.meta.v1.Timestamp) */ {
 public:
  inline Timestamp() : Timestamp(nullptr) {}
  ~Timestamp() override;
  explicit PROTOBUF_CONSTEXPR Timestamp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Timestamp(const Timestamp& from);
  Timestamp(Timestamp&& from) noexcept
    : Timestamp() {
    *this = ::std::move(from);
  }

  inline Timestamp& operator=(const Timestamp& from) {
    CopyFrom(from);
    return *this;
  }
  inline Timestamp& operator=(Timestamp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Timestamp& default_instance() {
    return *internal_default_instance();
  }
  static inline const Timestamp* internal_default_instance() {
    return reinterpret_cast<const Timestamp*>(
               &_Timestamp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(Timestamp& a, Timestamp& b) {
    a.Swap(&b);
  }
  inline void Swap(Timestamp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Timestamp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Timestamp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Timestamp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Timestamp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Timestamp& from) {
    Timestamp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Timestamp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "k8s.io.apimachinery.pkg.apis.meta.v1.Timestamp";
  }
  protected:
  explicit Timestamp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSecondsFieldNumber = 1,
    kNanosFieldNumber = 2,
  };
  // optional int64 seconds = 1;
  bool has_seconds() const;
  private:
  bool _internal_has_seconds() const;
  public:
  void clear_seconds();
  int64_t seconds() const;
  void set_seconds(int64_t value);
  private:
  int64_t _internal_seconds() const;
  void _internal_set_seconds(int64_t value);
  public:

  // optional int32 nanos = 2;
  bool has_nanos() const;
  private:
  bool _internal_has_nanos() const;
  public:
  void clear_nanos();
  int32_t nanos() const;
  void set_nanos(int32_t value);
  private:
  int32_t _internal_nanos() const;
  void _internal_set_nanos(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.Timestamp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int64_t seconds_;
    int32_t nanos_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_staging_5fsrc_5fk8s_2eio_5fapimachinery_5fpkg_5fapis_5fmeta_5fv1_5fgenerated_2eproto;
};
// -------------------------------------------------------------------

class TypeMeta final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta) */ {
 public:
  inline TypeMeta() : TypeMeta(nullptr) {}
  ~TypeMeta() override;
  explicit PROTOBUF_CONSTEXPR TypeMeta(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TypeMeta(const TypeMeta& from);
  TypeMeta(TypeMeta&& from) noexcept
    : TypeMeta() {
    *this = ::std::move(from);
  }

  inline TypeMeta& operator=(const TypeMeta& from) {
    CopyFrom(from);
    return *this;
  }
  inline TypeMeta& operator=(TypeMeta&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TypeMeta& default_instance() {
    return *internal_default_instance();
  }
  static inline const TypeMeta* internal_default_instance() {
    return reinterpret_cast<const TypeMeta*>(
               &_TypeMeta_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(TypeMeta& a, TypeMeta& b) {
    a.Swap(&b);
  }
  inline void Swap(TypeMeta* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TypeMeta* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TypeMeta* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TypeMeta>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TypeMeta& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TypeMeta& from) {
    TypeMeta::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TypeMeta* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta";
  }
  protected:
  explicit TypeMeta(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKindFieldNumber = 1,
    kApiVersionFieldNumber = 2,
  };
  // optional string kind = 1;
  bool has_kind() const;
  private:
  bool _internal_has_kind() const;
  public:
  void clear_kind();
  const std::string& kind() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_kind(ArgT0&& arg0, ArgT... args);
  std::string* mutable_kind();
  PROTOBUF_NODISCARD std::string* release_kind();
  void set_allocated_kind(std::string* kind);
  private:
  const std::string& _internal_kind() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_kind(const std::string& value);
  std::string* _internal_mutable_kind();
  public:

  // optional string apiVersion = 2;
  bool has_apiversion() const;
  private:
  bool _internal_has_apiversion() const;
  public:
  void clear_apiversion();
  const std::string& apiversion() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_apiversion(ArgT0&& arg0, ArgT... args);
  std::string* mutable_apiversion();
  PROTOBUF_NODISCARD std::string* release_apiversion();
  void set_allocated_apiversion(std::string* apiversion);
  private:
  const std::string& _internal_apiversion() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_apiversion(const std::string& value);
  std::string* _internal_mutable_apiversion();
  public:

  // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr kind_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr apiversion_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_staging_5fsrc_5fk8s_2eio_5fapimachinery_5fpkg_5fapis_5fmeta_5fv1_5fgenerated_2eproto;
};
// -------------------------------------------------------------------

class UpdateOptions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:k8s.io.apimachinery.pkg.apis.meta.v1.UpdateOptions) */ {
 public:
  inline UpdateOptions() : UpdateOptions(nullptr) {}
  ~UpdateOptions() override;
  explicit PROTOBUF_CONSTEXPR UpdateOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateOptions(const UpdateOptions& from);
  UpdateOptions(UpdateOptions&& from) noexcept
    : UpdateOptions() {
    *this = ::std::move(from);
  }

  inline UpdateOptions& operator=(const UpdateOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateOptions& operator=(UpdateOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateOptions* internal_default_instance() {
    return reinterpret_cast<const UpdateOptions*>(
               &_UpdateOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(UpdateOptions& a, UpdateOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateOptions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateOptions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateOptions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateOptions& from) {
    UpdateOptions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateOptions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "k8s.io.apimachinery.pkg.apis.meta.v1.UpdateOptions";
  }
  protected:
  explicit UpdateOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDryRunFieldNumber = 1,
    kFieldManagerFieldNumber = 2,
    kFieldValidationFieldNumber = 3,
  };
  // repeated string dryRun = 1;
  int dryrun_size() const;
  private:
  int _internal_dryrun_size() const;
  public:
  void clear_dryrun();
  const std::string& dryrun(int index) const;
  std::string* mutable_dryrun(int index);
  void set_dryrun(int index, const std::string& value);
  void set_dryrun(int index, std::string&& value);
  void set_dryrun(int index, const char* value);
  void set_dryrun(int index, const char* value, size_t size);
  std::string* add_dryrun();
  void add_dryrun(const std::string& value);
  void add_dryrun(std::string&& value);
  void add_dryrun(const char* value);
  void add_dryrun(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& dryrun() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_dryrun();
  private:
  const std::string& _internal_dryrun(int index) const;
  std::string* _internal_add_dryrun();
  public:

  // optional string fieldManager = 2;
  bool has_fieldmanager() const;
  private:
  bool _internal_has_fieldmanager() const;
  public:
  void clear_fieldmanager();
  const std::string& fieldmanager() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fieldmanager(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fieldmanager();
  PROTOBUF_NODISCARD std::string* release_fieldmanager();
  void set_allocated_fieldmanager(std::string* fieldmanager);
  private:
  const std::string& _internal_fieldmanager() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fieldmanager(const std::string& value);
  std::string* _internal_mutable_fieldmanager();
  public:

  // optional string fieldValidation = 3;
  bool has_fieldvalidation() const;
  private:
  bool _internal_has_fieldvalidation() const;
  public:
  void clear_fieldvalidation();
  const std::string& fieldvalidation() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fieldvalidation(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fieldvalidation();
  PROTOBUF_NODISCARD std::string* release_fieldvalidation();
  void set_allocated_fieldvalidation(std::string* fieldvalidation);
  private:
  const std::string& _internal_fieldvalidation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fieldvalidation(const std::string& value);
  std::string* _internal_mutable_fieldvalidation();
  public:

  // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.UpdateOptions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> dryrun_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fieldmanager_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fieldvalidation_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_staging_5fsrc_5fk8s_2eio_5fapimachinery_5fpkg_5fapis_5fmeta_5fv1_5fgenerated_2eproto;
};
// -------------------------------------------------------------------

class Verbs final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:k8s.io.apimachinery.pkg.apis.meta.v1.Verbs) */ {
 public:
  inline Verbs() : Verbs(nullptr) {}
  ~Verbs() override;
  explicit PROTOBUF_CONSTEXPR Verbs(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Verbs(const Verbs& from);
  Verbs(Verbs&& from) noexcept
    : Verbs() {
    *this = ::std::move(from);
  }

  inline Verbs& operator=(const Verbs& from) {
    CopyFrom(from);
    return *this;
  }
  inline Verbs& operator=(Verbs&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Verbs& default_instance() {
    return *internal_default_instance();
  }
  static inline const Verbs* internal_default_instance() {
    return reinterpret_cast<const Verbs*>(
               &_Verbs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(Verbs& a, Verbs& b) {
    a.Swap(&b);
  }
  inline void Swap(Verbs* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Verbs* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Verbs* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Verbs>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Verbs& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Verbs& from) {
    Verbs::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Verbs* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "k8s.io.apimachinery.pkg.apis.meta.v1.Verbs";
  }
  protected:
  explicit Verbs(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated string items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  const std::string& items(int index) const;
  std::string* mutable_items(int index);
  void set_items(int index, const std::string& value);
  void set_items(int index, std::string&& value);
  void set_items(int index, const char* value);
  void set_items(int index, const char* value, size_t size);
  std::string* add_items();
  void add_items(const std::string& value);
  void add_items(std::string&& value);
  void add_items(const char* value);
  void add_items(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& items() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_items();
  private:
  const std::string& _internal_items(int index) const;
  std::string* _internal_add_items();
  public:

  // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.Verbs)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> items_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_staging_5fsrc_5fk8s_2eio_5fapimachinery_5fpkg_5fapis_5fmeta_5fv1_5fgenerated_2eproto;
};
// -------------------------------------------------------------------

class WatchEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:k8s.io.apimachinery.pkg.apis.meta.v1.WatchEvent) */ {
 public:
  inline WatchEvent() : WatchEvent(nullptr) {}
  ~WatchEvent() override;
  explicit PROTOBUF_CONSTEXPR WatchEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WatchEvent(const WatchEvent& from);
  WatchEvent(WatchEvent&& from) noexcept
    : WatchEvent() {
    *this = ::std::move(from);
  }

  inline WatchEvent& operator=(const WatchEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline WatchEvent& operator=(WatchEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WatchEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const WatchEvent* internal_default_instance() {
    return reinterpret_cast<const WatchEvent*>(
               &_WatchEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(WatchEvent& a, WatchEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(WatchEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WatchEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WatchEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WatchEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WatchEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WatchEvent& from) {
    WatchEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WatchEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "k8s.io.apimachinery.pkg.apis.meta.v1.WatchEvent";
  }
  protected:
  explicit WatchEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kObjectFieldNumber = 2,
  };
  // optional string type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // optional .k8s.io.apimachinery.pkg.runtime.RawExtension object = 2;
  bool has_object() const;
  private:
  bool _internal_has_object() const;
  public:
  void clear_object();
  const ::k8s::io::apimachinery::pkg::runtime::RawExtension& object() const;
  PROTOBUF_NODISCARD ::k8s::io::apimachinery::pkg::runtime::RawExtension* release_object();
  ::k8s::io::apimachinery::pkg::runtime::RawExtension* mutable_object();
  void set_allocated_object(::k8s::io::apimachinery::pkg::runtime::RawExtension* object);
  private:
  const ::k8s::io::apimachinery::pkg::runtime::RawExtension& _internal_object() const;
  ::k8s::io::apimachinery::pkg::runtime::RawExtension* _internal_mutable_object();
  public:
  void unsafe_arena_set_allocated_object(
      ::k8s::io::apimachinery::pkg::runtime::RawExtension* object);
  ::k8s::io::apimachinery::pkg::runtime::RawExtension* unsafe_arena_release_object();

  // @@protoc_insertion_point(class_scope:k8s.io.apimachinery.pkg.apis.meta.v1.WatchEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    ::k8s::io::apimachinery::pkg::runtime::RawExtension* object_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_staging_5fsrc_5fk8s_2eio_5fapimachinery_5fpkg_5fapis_5fmeta_5fv1_5fgenerated_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// APIGroup

// optional string name = 1;
inline bool APIGroup::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool APIGroup::has_name() const {
  return _internal_has_name();
}
inline void APIGroup::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& APIGroup::name() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.APIGroup.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void APIGroup::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.APIGroup.name)
}
inline std::string* APIGroup::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.APIGroup.name)
  return _s;
}
inline const std::string& APIGroup::_internal_name() const {
  return _impl_.name_.Get();
}
inline void APIGroup::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* APIGroup::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* APIGroup::release_name() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.APIGroup.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void APIGroup::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.APIGroup.name)
}

// repeated .k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery versions = 2;
inline int APIGroup::_internal_versions_size() const {
  return _impl_.versions_.size();
}
inline int APIGroup::versions_size() const {
  return _internal_versions_size();
}
inline void APIGroup::clear_versions() {
  _impl_.versions_.Clear();
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::GroupVersionForDiscovery* APIGroup::mutable_versions(int index) {
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.APIGroup.versions)
  return _impl_.versions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::k8s::io::apimachinery::pkg::apis::meta::v1::GroupVersionForDiscovery >*
APIGroup::mutable_versions() {
  // @@protoc_insertion_point(field_mutable_list:k8s.io.apimachinery.pkg.apis.meta.v1.APIGroup.versions)
  return &_impl_.versions_;
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::GroupVersionForDiscovery& APIGroup::_internal_versions(int index) const {
  return _impl_.versions_.Get(index);
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::GroupVersionForDiscovery& APIGroup::versions(int index) const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.APIGroup.versions)
  return _internal_versions(index);
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::GroupVersionForDiscovery* APIGroup::_internal_add_versions() {
  return _impl_.versions_.Add();
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::GroupVersionForDiscovery* APIGroup::add_versions() {
  ::k8s::io::apimachinery::pkg::apis::meta::v1::GroupVersionForDiscovery* _add = _internal_add_versions();
  // @@protoc_insertion_point(field_add:k8s.io.apimachinery.pkg.apis.meta.v1.APIGroup.versions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::k8s::io::apimachinery::pkg::apis::meta::v1::GroupVersionForDiscovery >&
APIGroup::versions() const {
  // @@protoc_insertion_point(field_list:k8s.io.apimachinery.pkg.apis.meta.v1.APIGroup.versions)
  return _impl_.versions_;
}

// optional .k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery preferredVersion = 3;
inline bool APIGroup::_internal_has_preferredversion() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.preferredversion_ != nullptr);
  return value;
}
inline bool APIGroup::has_preferredversion() const {
  return _internal_has_preferredversion();
}
inline void APIGroup::clear_preferredversion() {
  if (_impl_.preferredversion_ != nullptr) _impl_.preferredversion_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::GroupVersionForDiscovery& APIGroup::_internal_preferredversion() const {
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::GroupVersionForDiscovery* p = _impl_.preferredversion_;
  return p != nullptr ? *p : reinterpret_cast<const ::k8s::io::apimachinery::pkg::apis::meta::v1::GroupVersionForDiscovery&>(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::_GroupVersionForDiscovery_default_instance_);
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::GroupVersionForDiscovery& APIGroup::preferredversion() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.APIGroup.preferredVersion)
  return _internal_preferredversion();
}
inline void APIGroup::unsafe_arena_set_allocated_preferredversion(
    ::k8s::io::apimachinery::pkg::apis::meta::v1::GroupVersionForDiscovery* preferredversion) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.preferredversion_);
  }
  _impl_.preferredversion_ = preferredversion;
  if (preferredversion) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.APIGroup.preferredVersion)
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::GroupVersionForDiscovery* APIGroup::release_preferredversion() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::GroupVersionForDiscovery* temp = _impl_.preferredversion_;
  _impl_.preferredversion_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::GroupVersionForDiscovery* APIGroup::unsafe_arena_release_preferredversion() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.APIGroup.preferredVersion)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::GroupVersionForDiscovery* temp = _impl_.preferredversion_;
  _impl_.preferredversion_ = nullptr;
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::GroupVersionForDiscovery* APIGroup::_internal_mutable_preferredversion() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.preferredversion_ == nullptr) {
    auto* p = CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::GroupVersionForDiscovery>(GetArenaForAllocation());
    _impl_.preferredversion_ = p;
  }
  return _impl_.preferredversion_;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::GroupVersionForDiscovery* APIGroup::mutable_preferredversion() {
  ::k8s::io::apimachinery::pkg::apis::meta::v1::GroupVersionForDiscovery* _msg = _internal_mutable_preferredversion();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.APIGroup.preferredVersion)
  return _msg;
}
inline void APIGroup::set_allocated_preferredversion(::k8s::io::apimachinery::pkg::apis::meta::v1::GroupVersionForDiscovery* preferredversion) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.preferredversion_;
  }
  if (preferredversion) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(preferredversion);
    if (message_arena != submessage_arena) {
      preferredversion = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, preferredversion, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.preferredversion_ = preferredversion;
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.APIGroup.preferredVersion)
}

// repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR serverAddressByClientCIDRs = 4;
inline int APIGroup::_internal_serveraddressbyclientcidrs_size() const {
  return _impl_.serveraddressbyclientcidrs_.size();
}
inline int APIGroup::serveraddressbyclientcidrs_size() const {
  return _internal_serveraddressbyclientcidrs_size();
}
inline void APIGroup::clear_serveraddressbyclientcidrs() {
  _impl_.serveraddressbyclientcidrs_.Clear();
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ServerAddressByClientCIDR* APIGroup::mutable_serveraddressbyclientcidrs(int index) {
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.APIGroup.serverAddressByClientCIDRs)
  return _impl_.serveraddressbyclientcidrs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::k8s::io::apimachinery::pkg::apis::meta::v1::ServerAddressByClientCIDR >*
APIGroup::mutable_serveraddressbyclientcidrs() {
  // @@protoc_insertion_point(field_mutable_list:k8s.io.apimachinery.pkg.apis.meta.v1.APIGroup.serverAddressByClientCIDRs)
  return &_impl_.serveraddressbyclientcidrs_;
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ServerAddressByClientCIDR& APIGroup::_internal_serveraddressbyclientcidrs(int index) const {
  return _impl_.serveraddressbyclientcidrs_.Get(index);
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ServerAddressByClientCIDR& APIGroup::serveraddressbyclientcidrs(int index) const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.APIGroup.serverAddressByClientCIDRs)
  return _internal_serveraddressbyclientcidrs(index);
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ServerAddressByClientCIDR* APIGroup::_internal_add_serveraddressbyclientcidrs() {
  return _impl_.serveraddressbyclientcidrs_.Add();
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ServerAddressByClientCIDR* APIGroup::add_serveraddressbyclientcidrs() {
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ServerAddressByClientCIDR* _add = _internal_add_serveraddressbyclientcidrs();
  // @@protoc_insertion_point(field_add:k8s.io.apimachinery.pkg.apis.meta.v1.APIGroup.serverAddressByClientCIDRs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::k8s::io::apimachinery::pkg::apis::meta::v1::ServerAddressByClientCIDR >&
APIGroup::serveraddressbyclientcidrs() const {
  // @@protoc_insertion_point(field_list:k8s.io.apimachinery.pkg.apis.meta.v1.APIGroup.serverAddressByClientCIDRs)
  return _impl_.serveraddressbyclientcidrs_;
}

// -------------------------------------------------------------------

// APIGroupList

// repeated .k8s.io.apimachinery.pkg.apis.meta.v1.APIGroup groups = 1;
inline int APIGroupList::_internal_groups_size() const {
  return _impl_.groups_.size();
}
inline int APIGroupList::groups_size() const {
  return _internal_groups_size();
}
inline void APIGroupList::clear_groups() {
  _impl_.groups_.Clear();
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::APIGroup* APIGroupList::mutable_groups(int index) {
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.APIGroupList.groups)
  return _impl_.groups_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::k8s::io::apimachinery::pkg::apis::meta::v1::APIGroup >*
APIGroupList::mutable_groups() {
  // @@protoc_insertion_point(field_mutable_list:k8s.io.apimachinery.pkg.apis.meta.v1.APIGroupList.groups)
  return &_impl_.groups_;
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::APIGroup& APIGroupList::_internal_groups(int index) const {
  return _impl_.groups_.Get(index);
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::APIGroup& APIGroupList::groups(int index) const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.APIGroupList.groups)
  return _internal_groups(index);
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::APIGroup* APIGroupList::_internal_add_groups() {
  return _impl_.groups_.Add();
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::APIGroup* APIGroupList::add_groups() {
  ::k8s::io::apimachinery::pkg::apis::meta::v1::APIGroup* _add = _internal_add_groups();
  // @@protoc_insertion_point(field_add:k8s.io.apimachinery.pkg.apis.meta.v1.APIGroupList.groups)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::k8s::io::apimachinery::pkg::apis::meta::v1::APIGroup >&
APIGroupList::groups() const {
  // @@protoc_insertion_point(field_list:k8s.io.apimachinery.pkg.apis.meta.v1.APIGroupList.groups)
  return _impl_.groups_;
}

// -------------------------------------------------------------------

// APIResource

// optional string name = 1;
inline bool APIResource::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool APIResource::has_name() const {
  return _internal_has_name();
}
inline void APIResource::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& APIResource::name() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.APIResource.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void APIResource::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.APIResource.name)
}
inline std::string* APIResource::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.APIResource.name)
  return _s;
}
inline const std::string& APIResource::_internal_name() const {
  return _impl_.name_.Get();
}
inline void APIResource::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* APIResource::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* APIResource::release_name() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.APIResource.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void APIResource::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.APIResource.name)
}

// optional string singularName = 6;
inline bool APIResource::_internal_has_singularname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool APIResource::has_singularname() const {
  return _internal_has_singularname();
}
inline void APIResource::clear_singularname() {
  _impl_.singularname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& APIResource::singularname() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.APIResource.singularName)
  return _internal_singularname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void APIResource::set_singularname(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.singularname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.APIResource.singularName)
}
inline std::string* APIResource::mutable_singularname() {
  std::string* _s = _internal_mutable_singularname();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.APIResource.singularName)
  return _s;
}
inline const std::string& APIResource::_internal_singularname() const {
  return _impl_.singularname_.Get();
}
inline void APIResource::_internal_set_singularname(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.singularname_.Set(value, GetArenaForAllocation());
}
inline std::string* APIResource::_internal_mutable_singularname() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.singularname_.Mutable(GetArenaForAllocation());
}
inline std::string* APIResource::release_singularname() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.APIResource.singularName)
  if (!_internal_has_singularname()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.singularname_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.singularname_.IsDefault()) {
    _impl_.singularname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void APIResource::set_allocated_singularname(std::string* singularname) {
  if (singularname != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.singularname_.SetAllocated(singularname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.singularname_.IsDefault()) {
    _impl_.singularname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.APIResource.singularName)
}

// optional bool namespaced = 2;
inline bool APIResource::_internal_has_namespaced() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool APIResource::has_namespaced() const {
  return _internal_has_namespaced();
}
inline void APIResource::clear_namespaced() {
  _impl_.namespaced_ = false;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline bool APIResource::_internal_namespaced() const {
  return _impl_.namespaced_;
}
inline bool APIResource::namespaced() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.APIResource.namespaced)
  return _internal_namespaced();
}
inline void APIResource::_internal_set_namespaced(bool value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.namespaced_ = value;
}
inline void APIResource::set_namespaced(bool value) {
  _internal_set_namespaced(value);
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.APIResource.namespaced)
}

// optional string group = 8;
inline bool APIResource::_internal_has_group() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool APIResource::has_group() const {
  return _internal_has_group();
}
inline void APIResource::clear_group() {
  _impl_.group_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& APIResource::group() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.APIResource.group)
  return _internal_group();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void APIResource::set_group(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.group_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.APIResource.group)
}
inline std::string* APIResource::mutable_group() {
  std::string* _s = _internal_mutable_group();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.APIResource.group)
  return _s;
}
inline const std::string& APIResource::_internal_group() const {
  return _impl_.group_.Get();
}
inline void APIResource::_internal_set_group(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.group_.Set(value, GetArenaForAllocation());
}
inline std::string* APIResource::_internal_mutable_group() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.group_.Mutable(GetArenaForAllocation());
}
inline std::string* APIResource::release_group() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.APIResource.group)
  if (!_internal_has_group()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.group_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.group_.IsDefault()) {
    _impl_.group_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void APIResource::set_allocated_group(std::string* group) {
  if (group != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.group_.SetAllocated(group, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.group_.IsDefault()) {
    _impl_.group_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.APIResource.group)
}

// optional string version = 9;
inline bool APIResource::_internal_has_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool APIResource::has_version() const {
  return _internal_has_version();
}
inline void APIResource::clear_version() {
  _impl_.version_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& APIResource::version() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.APIResource.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void APIResource::set_version(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.APIResource.version)
}
inline std::string* APIResource::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.APIResource.version)
  return _s;
}
inline const std::string& APIResource::_internal_version() const {
  return _impl_.version_.Get();
}
inline void APIResource::_internal_set_version(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* APIResource::_internal_mutable_version() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* APIResource::release_version() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.APIResource.version)
  if (!_internal_has_version()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.version_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void APIResource::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.APIResource.version)
}

// optional string kind = 3;
inline bool APIResource::_internal_has_kind() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool APIResource::has_kind() const {
  return _internal_has_kind();
}
inline void APIResource::clear_kind() {
  _impl_.kind_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& APIResource::kind() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.APIResource.kind)
  return _internal_kind();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void APIResource::set_kind(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.kind_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.APIResource.kind)
}
inline std::string* APIResource::mutable_kind() {
  std::string* _s = _internal_mutable_kind();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.APIResource.kind)
  return _s;
}
inline const std::string& APIResource::_internal_kind() const {
  return _impl_.kind_.Get();
}
inline void APIResource::_internal_set_kind(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.kind_.Set(value, GetArenaForAllocation());
}
inline std::string* APIResource::_internal_mutable_kind() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.kind_.Mutable(GetArenaForAllocation());
}
inline std::string* APIResource::release_kind() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.APIResource.kind)
  if (!_internal_has_kind()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.kind_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.kind_.IsDefault()) {
    _impl_.kind_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void APIResource::set_allocated_kind(std::string* kind) {
  if (kind != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.kind_.SetAllocated(kind, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.kind_.IsDefault()) {
    _impl_.kind_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.APIResource.kind)
}

// optional .k8s.io.apimachinery.pkg.apis.meta.v1.Verbs verbs = 4;
inline bool APIResource::_internal_has_verbs() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.verbs_ != nullptr);
  return value;
}
inline bool APIResource::has_verbs() const {
  return _internal_has_verbs();
}
inline void APIResource::clear_verbs() {
  if (_impl_.verbs_ != nullptr) _impl_.verbs_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::Verbs& APIResource::_internal_verbs() const {
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::Verbs* p = _impl_.verbs_;
  return p != nullptr ? *p : reinterpret_cast<const ::k8s::io::apimachinery::pkg::apis::meta::v1::Verbs&>(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::_Verbs_default_instance_);
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::Verbs& APIResource::verbs() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.APIResource.verbs)
  return _internal_verbs();
}
inline void APIResource::unsafe_arena_set_allocated_verbs(
    ::k8s::io::apimachinery::pkg::apis::meta::v1::Verbs* verbs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.verbs_);
  }
  _impl_.verbs_ = verbs;
  if (verbs) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.APIResource.verbs)
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::Verbs* APIResource::release_verbs() {
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::Verbs* temp = _impl_.verbs_;
  _impl_.verbs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::Verbs* APIResource::unsafe_arena_release_verbs() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.APIResource.verbs)
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::Verbs* temp = _impl_.verbs_;
  _impl_.verbs_ = nullptr;
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::Verbs* APIResource::_internal_mutable_verbs() {
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.verbs_ == nullptr) {
    auto* p = CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::Verbs>(GetArenaForAllocation());
    _impl_.verbs_ = p;
  }
  return _impl_.verbs_;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::Verbs* APIResource::mutable_verbs() {
  ::k8s::io::apimachinery::pkg::apis::meta::v1::Verbs* _msg = _internal_mutable_verbs();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.APIResource.verbs)
  return _msg;
}
inline void APIResource::set_allocated_verbs(::k8s::io::apimachinery::pkg::apis::meta::v1::Verbs* verbs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.verbs_;
  }
  if (verbs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(verbs);
    if (message_arena != submessage_arena) {
      verbs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, verbs, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.verbs_ = verbs;
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.APIResource.verbs)
}

// repeated string shortNames = 5;
inline int APIResource::_internal_shortnames_size() const {
  return _impl_.shortnames_.size();
}
inline int APIResource::shortnames_size() const {
  return _internal_shortnames_size();
}
inline void APIResource::clear_shortnames() {
  _impl_.shortnames_.Clear();
}
inline std::string* APIResource::add_shortnames() {
  std::string* _s = _internal_add_shortnames();
  // @@protoc_insertion_point(field_add_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.APIResource.shortNames)
  return _s;
}
inline const std::string& APIResource::_internal_shortnames(int index) const {
  return _impl_.shortnames_.Get(index);
}
inline const std::string& APIResource::shortnames(int index) const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.APIResource.shortNames)
  return _internal_shortnames(index);
}
inline std::string* APIResource::mutable_shortnames(int index) {
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.APIResource.shortNames)
  return _impl_.shortnames_.Mutable(index);
}
inline void APIResource::set_shortnames(int index, const std::string& value) {
  _impl_.shortnames_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.APIResource.shortNames)
}
inline void APIResource::set_shortnames(int index, std::string&& value) {
  _impl_.shortnames_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.APIResource.shortNames)
}
inline void APIResource::set_shortnames(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.shortnames_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:k8s.io.apimachinery.pkg.apis.meta.v1.APIResource.shortNames)
}
inline void APIResource::set_shortnames(int index, const char* value, size_t size) {
  _impl_.shortnames_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:k8s.io.apimachinery.pkg.apis.meta.v1.APIResource.shortNames)
}
inline std::string* APIResource::_internal_add_shortnames() {
  return _impl_.shortnames_.Add();
}
inline void APIResource::add_shortnames(const std::string& value) {
  _impl_.shortnames_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:k8s.io.apimachinery.pkg.apis.meta.v1.APIResource.shortNames)
}
inline void APIResource::add_shortnames(std::string&& value) {
  _impl_.shortnames_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:k8s.io.apimachinery.pkg.apis.meta.v1.APIResource.shortNames)
}
inline void APIResource::add_shortnames(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.shortnames_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:k8s.io.apimachinery.pkg.apis.meta.v1.APIResource.shortNames)
}
inline void APIResource::add_shortnames(const char* value, size_t size) {
  _impl_.shortnames_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:k8s.io.apimachinery.pkg.apis.meta.v1.APIResource.shortNames)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
APIResource::shortnames() const {
  // @@protoc_insertion_point(field_list:k8s.io.apimachinery.pkg.apis.meta.v1.APIResource.shortNames)
  return _impl_.shortnames_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
APIResource::mutable_shortnames() {
  // @@protoc_insertion_point(field_mutable_list:k8s.io.apimachinery.pkg.apis.meta.v1.APIResource.shortNames)
  return &_impl_.shortnames_;
}

// repeated string categories = 7;
inline int APIResource::_internal_categories_size() const {
  return _impl_.categories_.size();
}
inline int APIResource::categories_size() const {
  return _internal_categories_size();
}
inline void APIResource::clear_categories() {
  _impl_.categories_.Clear();
}
inline std::string* APIResource::add_categories() {
  std::string* _s = _internal_add_categories();
  // @@protoc_insertion_point(field_add_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.APIResource.categories)
  return _s;
}
inline const std::string& APIResource::_internal_categories(int index) const {
  return _impl_.categories_.Get(index);
}
inline const std::string& APIResource::categories(int index) const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.APIResource.categories)
  return _internal_categories(index);
}
inline std::string* APIResource::mutable_categories(int index) {
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.APIResource.categories)
  return _impl_.categories_.Mutable(index);
}
inline void APIResource::set_categories(int index, const std::string& value) {
  _impl_.categories_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.APIResource.categories)
}
inline void APIResource::set_categories(int index, std::string&& value) {
  _impl_.categories_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.APIResource.categories)
}
inline void APIResource::set_categories(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.categories_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:k8s.io.apimachinery.pkg.apis.meta.v1.APIResource.categories)
}
inline void APIResource::set_categories(int index, const char* value, size_t size) {
  _impl_.categories_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:k8s.io.apimachinery.pkg.apis.meta.v1.APIResource.categories)
}
inline std::string* APIResource::_internal_add_categories() {
  return _impl_.categories_.Add();
}
inline void APIResource::add_categories(const std::string& value) {
  _impl_.categories_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:k8s.io.apimachinery.pkg.apis.meta.v1.APIResource.categories)
}
inline void APIResource::add_categories(std::string&& value) {
  _impl_.categories_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:k8s.io.apimachinery.pkg.apis.meta.v1.APIResource.categories)
}
inline void APIResource::add_categories(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.categories_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:k8s.io.apimachinery.pkg.apis.meta.v1.APIResource.categories)
}
inline void APIResource::add_categories(const char* value, size_t size) {
  _impl_.categories_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:k8s.io.apimachinery.pkg.apis.meta.v1.APIResource.categories)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
APIResource::categories() const {
  // @@protoc_insertion_point(field_list:k8s.io.apimachinery.pkg.apis.meta.v1.APIResource.categories)
  return _impl_.categories_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
APIResource::mutable_categories() {
  // @@protoc_insertion_point(field_mutable_list:k8s.io.apimachinery.pkg.apis.meta.v1.APIResource.categories)
  return &_impl_.categories_;
}

// optional string storageVersionHash = 10;
inline bool APIResource::_internal_has_storageversionhash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool APIResource::has_storageversionhash() const {
  return _internal_has_storageversionhash();
}
inline void APIResource::clear_storageversionhash() {
  _impl_.storageversionhash_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& APIResource::storageversionhash() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.APIResource.storageVersionHash)
  return _internal_storageversionhash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void APIResource::set_storageversionhash(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000020u;
 _impl_.storageversionhash_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.APIResource.storageVersionHash)
}
inline std::string* APIResource::mutable_storageversionhash() {
  std::string* _s = _internal_mutable_storageversionhash();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.APIResource.storageVersionHash)
  return _s;
}
inline const std::string& APIResource::_internal_storageversionhash() const {
  return _impl_.storageversionhash_.Get();
}
inline void APIResource::_internal_set_storageversionhash(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.storageversionhash_.Set(value, GetArenaForAllocation());
}
inline std::string* APIResource::_internal_mutable_storageversionhash() {
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.storageversionhash_.Mutable(GetArenaForAllocation());
}
inline std::string* APIResource::release_storageversionhash() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.APIResource.storageVersionHash)
  if (!_internal_has_storageversionhash()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* p = _impl_.storageversionhash_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.storageversionhash_.IsDefault()) {
    _impl_.storageversionhash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void APIResource::set_allocated_storageversionhash(std::string* storageversionhash) {
  if (storageversionhash != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.storageversionhash_.SetAllocated(storageversionhash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.storageversionhash_.IsDefault()) {
    _impl_.storageversionhash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.APIResource.storageVersionHash)
}

// -------------------------------------------------------------------

// APIResourceList

// optional string groupVersion = 1;
inline bool APIResourceList::_internal_has_groupversion() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool APIResourceList::has_groupversion() const {
  return _internal_has_groupversion();
}
inline void APIResourceList::clear_groupversion() {
  _impl_.groupversion_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& APIResourceList::groupversion() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.APIResourceList.groupVersion)
  return _internal_groupversion();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void APIResourceList::set_groupversion(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.groupversion_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.APIResourceList.groupVersion)
}
inline std::string* APIResourceList::mutable_groupversion() {
  std::string* _s = _internal_mutable_groupversion();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.APIResourceList.groupVersion)
  return _s;
}
inline const std::string& APIResourceList::_internal_groupversion() const {
  return _impl_.groupversion_.Get();
}
inline void APIResourceList::_internal_set_groupversion(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.groupversion_.Set(value, GetArenaForAllocation());
}
inline std::string* APIResourceList::_internal_mutable_groupversion() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.groupversion_.Mutable(GetArenaForAllocation());
}
inline std::string* APIResourceList::release_groupversion() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.APIResourceList.groupVersion)
  if (!_internal_has_groupversion()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.groupversion_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.groupversion_.IsDefault()) {
    _impl_.groupversion_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void APIResourceList::set_allocated_groupversion(std::string* groupversion) {
  if (groupversion != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.groupversion_.SetAllocated(groupversion, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.groupversion_.IsDefault()) {
    _impl_.groupversion_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.APIResourceList.groupVersion)
}

// repeated .k8s.io.apimachinery.pkg.apis.meta.v1.APIResource resources = 2;
inline int APIResourceList::_internal_resources_size() const {
  return _impl_.resources_.size();
}
inline int APIResourceList::resources_size() const {
  return _internal_resources_size();
}
inline void APIResourceList::clear_resources() {
  _impl_.resources_.Clear();
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::APIResource* APIResourceList::mutable_resources(int index) {
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.APIResourceList.resources)
  return _impl_.resources_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::k8s::io::apimachinery::pkg::apis::meta::v1::APIResource >*
APIResourceList::mutable_resources() {
  // @@protoc_insertion_point(field_mutable_list:k8s.io.apimachinery.pkg.apis.meta.v1.APIResourceList.resources)
  return &_impl_.resources_;
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::APIResource& APIResourceList::_internal_resources(int index) const {
  return _impl_.resources_.Get(index);
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::APIResource& APIResourceList::resources(int index) const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.APIResourceList.resources)
  return _internal_resources(index);
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::APIResource* APIResourceList::_internal_add_resources() {
  return _impl_.resources_.Add();
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::APIResource* APIResourceList::add_resources() {
  ::k8s::io::apimachinery::pkg::apis::meta::v1::APIResource* _add = _internal_add_resources();
  // @@protoc_insertion_point(field_add:k8s.io.apimachinery.pkg.apis.meta.v1.APIResourceList.resources)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::k8s::io::apimachinery::pkg::apis::meta::v1::APIResource >&
APIResourceList::resources() const {
  // @@protoc_insertion_point(field_list:k8s.io.apimachinery.pkg.apis.meta.v1.APIResourceList.resources)
  return _impl_.resources_;
}

// -------------------------------------------------------------------

// APIVersions

// repeated string versions = 1;
inline int APIVersions::_internal_versions_size() const {
  return _impl_.versions_.size();
}
inline int APIVersions::versions_size() const {
  return _internal_versions_size();
}
inline void APIVersions::clear_versions() {
  _impl_.versions_.Clear();
}
inline std::string* APIVersions::add_versions() {
  std::string* _s = _internal_add_versions();
  // @@protoc_insertion_point(field_add_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.APIVersions.versions)
  return _s;
}
inline const std::string& APIVersions::_internal_versions(int index) const {
  return _impl_.versions_.Get(index);
}
inline const std::string& APIVersions::versions(int index) const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.APIVersions.versions)
  return _internal_versions(index);
}
inline std::string* APIVersions::mutable_versions(int index) {
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.APIVersions.versions)
  return _impl_.versions_.Mutable(index);
}
inline void APIVersions::set_versions(int index, const std::string& value) {
  _impl_.versions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.APIVersions.versions)
}
inline void APIVersions::set_versions(int index, std::string&& value) {
  _impl_.versions_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.APIVersions.versions)
}
inline void APIVersions::set_versions(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.versions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:k8s.io.apimachinery.pkg.apis.meta.v1.APIVersions.versions)
}
inline void APIVersions::set_versions(int index, const char* value, size_t size) {
  _impl_.versions_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:k8s.io.apimachinery.pkg.apis.meta.v1.APIVersions.versions)
}
inline std::string* APIVersions::_internal_add_versions() {
  return _impl_.versions_.Add();
}
inline void APIVersions::add_versions(const std::string& value) {
  _impl_.versions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:k8s.io.apimachinery.pkg.apis.meta.v1.APIVersions.versions)
}
inline void APIVersions::add_versions(std::string&& value) {
  _impl_.versions_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:k8s.io.apimachinery.pkg.apis.meta.v1.APIVersions.versions)
}
inline void APIVersions::add_versions(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.versions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:k8s.io.apimachinery.pkg.apis.meta.v1.APIVersions.versions)
}
inline void APIVersions::add_versions(const char* value, size_t size) {
  _impl_.versions_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:k8s.io.apimachinery.pkg.apis.meta.v1.APIVersions.versions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
APIVersions::versions() const {
  // @@protoc_insertion_point(field_list:k8s.io.apimachinery.pkg.apis.meta.v1.APIVersions.versions)
  return _impl_.versions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
APIVersions::mutable_versions() {
  // @@protoc_insertion_point(field_mutable_list:k8s.io.apimachinery.pkg.apis.meta.v1.APIVersions.versions)
  return &_impl_.versions_;
}

// repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR serverAddressByClientCIDRs = 2;
inline int APIVersions::_internal_serveraddressbyclientcidrs_size() const {
  return _impl_.serveraddressbyclientcidrs_.size();
}
inline int APIVersions::serveraddressbyclientcidrs_size() const {
  return _internal_serveraddressbyclientcidrs_size();
}
inline void APIVersions::clear_serveraddressbyclientcidrs() {
  _impl_.serveraddressbyclientcidrs_.Clear();
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ServerAddressByClientCIDR* APIVersions::mutable_serveraddressbyclientcidrs(int index) {
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.APIVersions.serverAddressByClientCIDRs)
  return _impl_.serveraddressbyclientcidrs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::k8s::io::apimachinery::pkg::apis::meta::v1::ServerAddressByClientCIDR >*
APIVersions::mutable_serveraddressbyclientcidrs() {
  // @@protoc_insertion_point(field_mutable_list:k8s.io.apimachinery.pkg.apis.meta.v1.APIVersions.serverAddressByClientCIDRs)
  return &_impl_.serveraddressbyclientcidrs_;
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ServerAddressByClientCIDR& APIVersions::_internal_serveraddressbyclientcidrs(int index) const {
  return _impl_.serveraddressbyclientcidrs_.Get(index);
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ServerAddressByClientCIDR& APIVersions::serveraddressbyclientcidrs(int index) const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.APIVersions.serverAddressByClientCIDRs)
  return _internal_serveraddressbyclientcidrs(index);
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ServerAddressByClientCIDR* APIVersions::_internal_add_serveraddressbyclientcidrs() {
  return _impl_.serveraddressbyclientcidrs_.Add();
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ServerAddressByClientCIDR* APIVersions::add_serveraddressbyclientcidrs() {
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ServerAddressByClientCIDR* _add = _internal_add_serveraddressbyclientcidrs();
  // @@protoc_insertion_point(field_add:k8s.io.apimachinery.pkg.apis.meta.v1.APIVersions.serverAddressByClientCIDRs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::k8s::io::apimachinery::pkg::apis::meta::v1::ServerAddressByClientCIDR >&
APIVersions::serveraddressbyclientcidrs() const {
  // @@protoc_insertion_point(field_list:k8s.io.apimachinery.pkg.apis.meta.v1.APIVersions.serverAddressByClientCIDRs)
  return _impl_.serveraddressbyclientcidrs_;
}

// -------------------------------------------------------------------

// ApplyOptions

// repeated string dryRun = 1;
inline int ApplyOptions::_internal_dryrun_size() const {
  return _impl_.dryrun_.size();
}
inline int ApplyOptions::dryrun_size() const {
  return _internal_dryrun_size();
}
inline void ApplyOptions::clear_dryrun() {
  _impl_.dryrun_.Clear();
}
inline std::string* ApplyOptions::add_dryrun() {
  std::string* _s = _internal_add_dryrun();
  // @@protoc_insertion_point(field_add_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.ApplyOptions.dryRun)
  return _s;
}
inline const std::string& ApplyOptions::_internal_dryrun(int index) const {
  return _impl_.dryrun_.Get(index);
}
inline const std::string& ApplyOptions::dryrun(int index) const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.ApplyOptions.dryRun)
  return _internal_dryrun(index);
}
inline std::string* ApplyOptions::mutable_dryrun(int index) {
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.ApplyOptions.dryRun)
  return _impl_.dryrun_.Mutable(index);
}
inline void ApplyOptions::set_dryrun(int index, const std::string& value) {
  _impl_.dryrun_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.ApplyOptions.dryRun)
}
inline void ApplyOptions::set_dryrun(int index, std::string&& value) {
  _impl_.dryrun_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.ApplyOptions.dryRun)
}
inline void ApplyOptions::set_dryrun(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.dryrun_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:k8s.io.apimachinery.pkg.apis.meta.v1.ApplyOptions.dryRun)
}
inline void ApplyOptions::set_dryrun(int index, const char* value, size_t size) {
  _impl_.dryrun_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:k8s.io.apimachinery.pkg.apis.meta.v1.ApplyOptions.dryRun)
}
inline std::string* ApplyOptions::_internal_add_dryrun() {
  return _impl_.dryrun_.Add();
}
inline void ApplyOptions::add_dryrun(const std::string& value) {
  _impl_.dryrun_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:k8s.io.apimachinery.pkg.apis.meta.v1.ApplyOptions.dryRun)
}
inline void ApplyOptions::add_dryrun(std::string&& value) {
  _impl_.dryrun_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:k8s.io.apimachinery.pkg.apis.meta.v1.ApplyOptions.dryRun)
}
inline void ApplyOptions::add_dryrun(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.dryrun_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:k8s.io.apimachinery.pkg.apis.meta.v1.ApplyOptions.dryRun)
}
inline void ApplyOptions::add_dryrun(const char* value, size_t size) {
  _impl_.dryrun_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:k8s.io.apimachinery.pkg.apis.meta.v1.ApplyOptions.dryRun)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ApplyOptions::dryrun() const {
  // @@protoc_insertion_point(field_list:k8s.io.apimachinery.pkg.apis.meta.v1.ApplyOptions.dryRun)
  return _impl_.dryrun_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ApplyOptions::mutable_dryrun() {
  // @@protoc_insertion_point(field_mutable_list:k8s.io.apimachinery.pkg.apis.meta.v1.ApplyOptions.dryRun)
  return &_impl_.dryrun_;
}

// optional bool force = 2;
inline bool ApplyOptions::_internal_has_force() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ApplyOptions::has_force() const {
  return _internal_has_force();
}
inline void ApplyOptions::clear_force() {
  _impl_.force_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool ApplyOptions::_internal_force() const {
  return _impl_.force_;
}
inline bool ApplyOptions::force() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.ApplyOptions.force)
  return _internal_force();
}
inline void ApplyOptions::_internal_set_force(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.force_ = value;
}
inline void ApplyOptions::set_force(bool value) {
  _internal_set_force(value);
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.ApplyOptions.force)
}

// optional string fieldManager = 3;
inline bool ApplyOptions::_internal_has_fieldmanager() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ApplyOptions::has_fieldmanager() const {
  return _internal_has_fieldmanager();
}
inline void ApplyOptions::clear_fieldmanager() {
  _impl_.fieldmanager_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ApplyOptions::fieldmanager() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.ApplyOptions.fieldManager)
  return _internal_fieldmanager();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ApplyOptions::set_fieldmanager(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.fieldmanager_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.ApplyOptions.fieldManager)
}
inline std::string* ApplyOptions::mutable_fieldmanager() {
  std::string* _s = _internal_mutable_fieldmanager();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.ApplyOptions.fieldManager)
  return _s;
}
inline const std::string& ApplyOptions::_internal_fieldmanager() const {
  return _impl_.fieldmanager_.Get();
}
inline void ApplyOptions::_internal_set_fieldmanager(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.fieldmanager_.Set(value, GetArenaForAllocation());
}
inline std::string* ApplyOptions::_internal_mutable_fieldmanager() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.fieldmanager_.Mutable(GetArenaForAllocation());
}
inline std::string* ApplyOptions::release_fieldmanager() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.ApplyOptions.fieldManager)
  if (!_internal_has_fieldmanager()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.fieldmanager_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fieldmanager_.IsDefault()) {
    _impl_.fieldmanager_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ApplyOptions::set_allocated_fieldmanager(std::string* fieldmanager) {
  if (fieldmanager != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.fieldmanager_.SetAllocated(fieldmanager, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fieldmanager_.IsDefault()) {
    _impl_.fieldmanager_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.ApplyOptions.fieldManager)
}

// -------------------------------------------------------------------

// Condition

// optional string type = 1;
inline bool Condition::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Condition::has_type() const {
  return _internal_has_type();
}
inline void Condition::clear_type() {
  _impl_.type_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Condition::type() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.Condition.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Condition::set_type(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.Condition.type)
}
inline std::string* Condition::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.Condition.type)
  return _s;
}
inline const std::string& Condition::_internal_type() const {
  return _impl_.type_.Get();
}
inline void Condition::_internal_set_type(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* Condition::_internal_mutable_type() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* Condition::release_type() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.Condition.type)
  if (!_internal_has_type()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.type_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Condition::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.Condition.type)
}

// optional string status = 2;
inline bool Condition::_internal_has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Condition::has_status() const {
  return _internal_has_status();
}
inline void Condition::clear_status() {
  _impl_.status_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Condition::status() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.Condition.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Condition::set_status(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.status_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.Condition.status)
}
inline std::string* Condition::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.Condition.status)
  return _s;
}
inline const std::string& Condition::_internal_status() const {
  return _impl_.status_.Get();
}
inline void Condition::_internal_set_status(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.status_.Set(value, GetArenaForAllocation());
}
inline std::string* Condition::_internal_mutable_status() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.status_.Mutable(GetArenaForAllocation());
}
inline std::string* Condition::release_status() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.Condition.status)
  if (!_internal_has_status()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.status_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.status_.IsDefault()) {
    _impl_.status_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Condition::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.status_.SetAllocated(status, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.status_.IsDefault()) {
    _impl_.status_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.Condition.status)
}

// optional int64 observedGeneration = 3;
inline bool Condition::_internal_has_observedgeneration() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Condition::has_observedgeneration() const {
  return _internal_has_observedgeneration();
}
inline void Condition::clear_observedgeneration() {
  _impl_.observedgeneration_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline int64_t Condition::_internal_observedgeneration() const {
  return _impl_.observedgeneration_;
}
inline int64_t Condition::observedgeneration() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.Condition.observedGeneration)
  return _internal_observedgeneration();
}
inline void Condition::_internal_set_observedgeneration(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.observedgeneration_ = value;
}
inline void Condition::set_observedgeneration(int64_t value) {
  _internal_set_observedgeneration(value);
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.Condition.observedGeneration)
}

// optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 4;
inline bool Condition::_internal_has_lasttransitiontime() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.lasttransitiontime_ != nullptr);
  return value;
}
inline bool Condition::has_lasttransitiontime() const {
  return _internal_has_lasttransitiontime();
}
inline void Condition::clear_lasttransitiontime() {
  if (_impl_.lasttransitiontime_ != nullptr) _impl_.lasttransitiontime_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::Time& Condition::_internal_lasttransitiontime() const {
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* p = _impl_.lasttransitiontime_;
  return p != nullptr ? *p : reinterpret_cast<const ::k8s::io::apimachinery::pkg::apis::meta::v1::Time&>(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::_Time_default_instance_);
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::Time& Condition::lasttransitiontime() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.Condition.lastTransitionTime)
  return _internal_lasttransitiontime();
}
inline void Condition::unsafe_arena_set_allocated_lasttransitiontime(
    ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* lasttransitiontime) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lasttransitiontime_);
  }
  _impl_.lasttransitiontime_ = lasttransitiontime;
  if (lasttransitiontime) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.Condition.lastTransitionTime)
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* Condition::release_lasttransitiontime() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* temp = _impl_.lasttransitiontime_;
  _impl_.lasttransitiontime_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* Condition::unsafe_arena_release_lasttransitiontime() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.Condition.lastTransitionTime)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* temp = _impl_.lasttransitiontime_;
  _impl_.lasttransitiontime_ = nullptr;
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* Condition::_internal_mutable_lasttransitiontime() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.lasttransitiontime_ == nullptr) {
    auto* p = CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::Time>(GetArenaForAllocation());
    _impl_.lasttransitiontime_ = p;
  }
  return _impl_.lasttransitiontime_;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* Condition::mutable_lasttransitiontime() {
  ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* _msg = _internal_mutable_lasttransitiontime();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.Condition.lastTransitionTime)
  return _msg;
}
inline void Condition::set_allocated_lasttransitiontime(::k8s::io::apimachinery::pkg::apis::meta::v1::Time* lasttransitiontime) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.lasttransitiontime_;
  }
  if (lasttransitiontime) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(lasttransitiontime);
    if (message_arena != submessage_arena) {
      lasttransitiontime = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lasttransitiontime, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.lasttransitiontime_ = lasttransitiontime;
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.Condition.lastTransitionTime)
}

// optional string reason = 5;
inline bool Condition::_internal_has_reason() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Condition::has_reason() const {
  return _internal_has_reason();
}
inline void Condition::clear_reason() {
  _impl_.reason_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Condition::reason() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.Condition.reason)
  return _internal_reason();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Condition::set_reason(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.reason_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.Condition.reason)
}
inline std::string* Condition::mutable_reason() {
  std::string* _s = _internal_mutable_reason();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.Condition.reason)
  return _s;
}
inline const std::string& Condition::_internal_reason() const {
  return _impl_.reason_.Get();
}
inline void Condition::_internal_set_reason(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.reason_.Set(value, GetArenaForAllocation());
}
inline std::string* Condition::_internal_mutable_reason() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.reason_.Mutable(GetArenaForAllocation());
}
inline std::string* Condition::release_reason() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.Condition.reason)
  if (!_internal_has_reason()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.reason_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.reason_.IsDefault()) {
    _impl_.reason_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Condition::set_allocated_reason(std::string* reason) {
  if (reason != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.reason_.SetAllocated(reason, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.reason_.IsDefault()) {
    _impl_.reason_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.Condition.reason)
}

// optional string message = 6;
inline bool Condition::_internal_has_message() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Condition::has_message() const {
  return _internal_has_message();
}
inline void Condition::clear_message() {
  _impl_.message_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& Condition::message() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.Condition.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Condition::set_message(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.Condition.message)
}
inline std::string* Condition::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.Condition.message)
  return _s;
}
inline const std::string& Condition::_internal_message() const {
  return _impl_.message_.Get();
}
inline void Condition::_internal_set_message(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* Condition::_internal_mutable_message() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* Condition::release_message() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.Condition.message)
  if (!_internal_has_message()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.message_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Condition::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.Condition.message)
}

// -------------------------------------------------------------------

// CreateOptions

// repeated string dryRun = 1;
inline int CreateOptions::_internal_dryrun_size() const {
  return _impl_.dryrun_.size();
}
inline int CreateOptions::dryrun_size() const {
  return _internal_dryrun_size();
}
inline void CreateOptions::clear_dryrun() {
  _impl_.dryrun_.Clear();
}
inline std::string* CreateOptions::add_dryrun() {
  std::string* _s = _internal_add_dryrun();
  // @@protoc_insertion_point(field_add_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.CreateOptions.dryRun)
  return _s;
}
inline const std::string& CreateOptions::_internal_dryrun(int index) const {
  return _impl_.dryrun_.Get(index);
}
inline const std::string& CreateOptions::dryrun(int index) const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.CreateOptions.dryRun)
  return _internal_dryrun(index);
}
inline std::string* CreateOptions::mutable_dryrun(int index) {
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.CreateOptions.dryRun)
  return _impl_.dryrun_.Mutable(index);
}
inline void CreateOptions::set_dryrun(int index, const std::string& value) {
  _impl_.dryrun_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.CreateOptions.dryRun)
}
inline void CreateOptions::set_dryrun(int index, std::string&& value) {
  _impl_.dryrun_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.CreateOptions.dryRun)
}
inline void CreateOptions::set_dryrun(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.dryrun_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:k8s.io.apimachinery.pkg.apis.meta.v1.CreateOptions.dryRun)
}
inline void CreateOptions::set_dryrun(int index, const char* value, size_t size) {
  _impl_.dryrun_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:k8s.io.apimachinery.pkg.apis.meta.v1.CreateOptions.dryRun)
}
inline std::string* CreateOptions::_internal_add_dryrun() {
  return _impl_.dryrun_.Add();
}
inline void CreateOptions::add_dryrun(const std::string& value) {
  _impl_.dryrun_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:k8s.io.apimachinery.pkg.apis.meta.v1.CreateOptions.dryRun)
}
inline void CreateOptions::add_dryrun(std::string&& value) {
  _impl_.dryrun_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:k8s.io.apimachinery.pkg.apis.meta.v1.CreateOptions.dryRun)
}
inline void CreateOptions::add_dryrun(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.dryrun_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:k8s.io.apimachinery.pkg.apis.meta.v1.CreateOptions.dryRun)
}
inline void CreateOptions::add_dryrun(const char* value, size_t size) {
  _impl_.dryrun_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:k8s.io.apimachinery.pkg.apis.meta.v1.CreateOptions.dryRun)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CreateOptions::dryrun() const {
  // @@protoc_insertion_point(field_list:k8s.io.apimachinery.pkg.apis.meta.v1.CreateOptions.dryRun)
  return _impl_.dryrun_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CreateOptions::mutable_dryrun() {
  // @@protoc_insertion_point(field_mutable_list:k8s.io.apimachinery.pkg.apis.meta.v1.CreateOptions.dryRun)
  return &_impl_.dryrun_;
}

// optional string fieldManager = 3;
inline bool CreateOptions::_internal_has_fieldmanager() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CreateOptions::has_fieldmanager() const {
  return _internal_has_fieldmanager();
}
inline void CreateOptions::clear_fieldmanager() {
  _impl_.fieldmanager_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CreateOptions::fieldmanager() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.CreateOptions.fieldManager)
  return _internal_fieldmanager();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateOptions::set_fieldmanager(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.fieldmanager_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.CreateOptions.fieldManager)
}
inline std::string* CreateOptions::mutable_fieldmanager() {
  std::string* _s = _internal_mutable_fieldmanager();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.CreateOptions.fieldManager)
  return _s;
}
inline const std::string& CreateOptions::_internal_fieldmanager() const {
  return _impl_.fieldmanager_.Get();
}
inline void CreateOptions::_internal_set_fieldmanager(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.fieldmanager_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateOptions::_internal_mutable_fieldmanager() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.fieldmanager_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateOptions::release_fieldmanager() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.CreateOptions.fieldManager)
  if (!_internal_has_fieldmanager()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.fieldmanager_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fieldmanager_.IsDefault()) {
    _impl_.fieldmanager_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CreateOptions::set_allocated_fieldmanager(std::string* fieldmanager) {
  if (fieldmanager != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.fieldmanager_.SetAllocated(fieldmanager, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fieldmanager_.IsDefault()) {
    _impl_.fieldmanager_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.CreateOptions.fieldManager)
}

// optional string fieldValidation = 4;
inline bool CreateOptions::_internal_has_fieldvalidation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CreateOptions::has_fieldvalidation() const {
  return _internal_has_fieldvalidation();
}
inline void CreateOptions::clear_fieldvalidation() {
  _impl_.fieldvalidation_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CreateOptions::fieldvalidation() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.CreateOptions.fieldValidation)
  return _internal_fieldvalidation();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateOptions::set_fieldvalidation(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.fieldvalidation_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.CreateOptions.fieldValidation)
}
inline std::string* CreateOptions::mutable_fieldvalidation() {
  std::string* _s = _internal_mutable_fieldvalidation();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.CreateOptions.fieldValidation)
  return _s;
}
inline const std::string& CreateOptions::_internal_fieldvalidation() const {
  return _impl_.fieldvalidation_.Get();
}
inline void CreateOptions::_internal_set_fieldvalidation(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.fieldvalidation_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateOptions::_internal_mutable_fieldvalidation() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.fieldvalidation_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateOptions::release_fieldvalidation() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.CreateOptions.fieldValidation)
  if (!_internal_has_fieldvalidation()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.fieldvalidation_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fieldvalidation_.IsDefault()) {
    _impl_.fieldvalidation_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CreateOptions::set_allocated_fieldvalidation(std::string* fieldvalidation) {
  if (fieldvalidation != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.fieldvalidation_.SetAllocated(fieldvalidation, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fieldvalidation_.IsDefault()) {
    _impl_.fieldvalidation_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.CreateOptions.fieldValidation)
}

// -------------------------------------------------------------------

// DeleteOptions

// optional int64 gracePeriodSeconds = 1;
inline bool DeleteOptions::_internal_has_graceperiodseconds() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DeleteOptions::has_graceperiodseconds() const {
  return _internal_has_graceperiodseconds();
}
inline void DeleteOptions::clear_graceperiodseconds() {
  _impl_.graceperiodseconds_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int64_t DeleteOptions::_internal_graceperiodseconds() const {
  return _impl_.graceperiodseconds_;
}
inline int64_t DeleteOptions::graceperiodseconds() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.DeleteOptions.gracePeriodSeconds)
  return _internal_graceperiodseconds();
}
inline void DeleteOptions::_internal_set_graceperiodseconds(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.graceperiodseconds_ = value;
}
inline void DeleteOptions::set_graceperiodseconds(int64_t value) {
  _internal_set_graceperiodseconds(value);
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.DeleteOptions.gracePeriodSeconds)
}

// optional .k8s.io.apimachinery.pkg.apis.meta.v1.Preconditions preconditions = 2;
inline bool DeleteOptions::_internal_has_preconditions() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.preconditions_ != nullptr);
  return value;
}
inline bool DeleteOptions::has_preconditions() const {
  return _internal_has_preconditions();
}
inline void DeleteOptions::clear_preconditions() {
  if (_impl_.preconditions_ != nullptr) _impl_.preconditions_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::Preconditions& DeleteOptions::_internal_preconditions() const {
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::Preconditions* p = _impl_.preconditions_;
  return p != nullptr ? *p : reinterpret_cast<const ::k8s::io::apimachinery::pkg::apis::meta::v1::Preconditions&>(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::_Preconditions_default_instance_);
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::Preconditions& DeleteOptions::preconditions() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.DeleteOptions.preconditions)
  return _internal_preconditions();
}
inline void DeleteOptions::unsafe_arena_set_allocated_preconditions(
    ::k8s::io::apimachinery::pkg::apis::meta::v1::Preconditions* preconditions) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.preconditions_);
  }
  _impl_.preconditions_ = preconditions;
  if (preconditions) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.DeleteOptions.preconditions)
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::Preconditions* DeleteOptions::release_preconditions() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::Preconditions* temp = _impl_.preconditions_;
  _impl_.preconditions_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::Preconditions* DeleteOptions::unsafe_arena_release_preconditions() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.DeleteOptions.preconditions)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::Preconditions* temp = _impl_.preconditions_;
  _impl_.preconditions_ = nullptr;
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::Preconditions* DeleteOptions::_internal_mutable_preconditions() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.preconditions_ == nullptr) {
    auto* p = CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::Preconditions>(GetArenaForAllocation());
    _impl_.preconditions_ = p;
  }
  return _impl_.preconditions_;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::Preconditions* DeleteOptions::mutable_preconditions() {
  ::k8s::io::apimachinery::pkg::apis::meta::v1::Preconditions* _msg = _internal_mutable_preconditions();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.DeleteOptions.preconditions)
  return _msg;
}
inline void DeleteOptions::set_allocated_preconditions(::k8s::io::apimachinery::pkg::apis::meta::v1::Preconditions* preconditions) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.preconditions_;
  }
  if (preconditions) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(preconditions);
    if (message_arena != submessage_arena) {
      preconditions = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, preconditions, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.preconditions_ = preconditions;
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.DeleteOptions.preconditions)
}

// optional bool orphanDependents = 3;
inline bool DeleteOptions::_internal_has_orphandependents() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DeleteOptions::has_orphandependents() const {
  return _internal_has_orphandependents();
}
inline void DeleteOptions::clear_orphandependents() {
  _impl_.orphandependents_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool DeleteOptions::_internal_orphandependents() const {
  return _impl_.orphandependents_;
}
inline bool DeleteOptions::orphandependents() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.DeleteOptions.orphanDependents)
  return _internal_orphandependents();
}
inline void DeleteOptions::_internal_set_orphandependents(bool value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.orphandependents_ = value;
}
inline void DeleteOptions::set_orphandependents(bool value) {
  _internal_set_orphandependents(value);
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.DeleteOptions.orphanDependents)
}

// optional string propagationPolicy = 4;
inline bool DeleteOptions::_internal_has_propagationpolicy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeleteOptions::has_propagationpolicy() const {
  return _internal_has_propagationpolicy();
}
inline void DeleteOptions::clear_propagationpolicy() {
  _impl_.propagationpolicy_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DeleteOptions::propagationpolicy() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.DeleteOptions.propagationPolicy)
  return _internal_propagationpolicy();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteOptions::set_propagationpolicy(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.propagationpolicy_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.DeleteOptions.propagationPolicy)
}
inline std::string* DeleteOptions::mutable_propagationpolicy() {
  std::string* _s = _internal_mutable_propagationpolicy();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.DeleteOptions.propagationPolicy)
  return _s;
}
inline const std::string& DeleteOptions::_internal_propagationpolicy() const {
  return _impl_.propagationpolicy_.Get();
}
inline void DeleteOptions::_internal_set_propagationpolicy(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.propagationpolicy_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteOptions::_internal_mutable_propagationpolicy() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.propagationpolicy_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteOptions::release_propagationpolicy() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.DeleteOptions.propagationPolicy)
  if (!_internal_has_propagationpolicy()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.propagationpolicy_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.propagationpolicy_.IsDefault()) {
    _impl_.propagationpolicy_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeleteOptions::set_allocated_propagationpolicy(std::string* propagationpolicy) {
  if (propagationpolicy != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.propagationpolicy_.SetAllocated(propagationpolicy, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.propagationpolicy_.IsDefault()) {
    _impl_.propagationpolicy_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.DeleteOptions.propagationPolicy)
}

// repeated string dryRun = 5;
inline int DeleteOptions::_internal_dryrun_size() const {
  return _impl_.dryrun_.size();
}
inline int DeleteOptions::dryrun_size() const {
  return _internal_dryrun_size();
}
inline void DeleteOptions::clear_dryrun() {
  _impl_.dryrun_.Clear();
}
inline std::string* DeleteOptions::add_dryrun() {
  std::string* _s = _internal_add_dryrun();
  // @@protoc_insertion_point(field_add_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.DeleteOptions.dryRun)
  return _s;
}
inline const std::string& DeleteOptions::_internal_dryrun(int index) const {
  return _impl_.dryrun_.Get(index);
}
inline const std::string& DeleteOptions::dryrun(int index) const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.DeleteOptions.dryRun)
  return _internal_dryrun(index);
}
inline std::string* DeleteOptions::mutable_dryrun(int index) {
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.DeleteOptions.dryRun)
  return _impl_.dryrun_.Mutable(index);
}
inline void DeleteOptions::set_dryrun(int index, const std::string& value) {
  _impl_.dryrun_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.DeleteOptions.dryRun)
}
inline void DeleteOptions::set_dryrun(int index, std::string&& value) {
  _impl_.dryrun_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.DeleteOptions.dryRun)
}
inline void DeleteOptions::set_dryrun(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.dryrun_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:k8s.io.apimachinery.pkg.apis.meta.v1.DeleteOptions.dryRun)
}
inline void DeleteOptions::set_dryrun(int index, const char* value, size_t size) {
  _impl_.dryrun_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:k8s.io.apimachinery.pkg.apis.meta.v1.DeleteOptions.dryRun)
}
inline std::string* DeleteOptions::_internal_add_dryrun() {
  return _impl_.dryrun_.Add();
}
inline void DeleteOptions::add_dryrun(const std::string& value) {
  _impl_.dryrun_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:k8s.io.apimachinery.pkg.apis.meta.v1.DeleteOptions.dryRun)
}
inline void DeleteOptions::add_dryrun(std::string&& value) {
  _impl_.dryrun_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:k8s.io.apimachinery.pkg.apis.meta.v1.DeleteOptions.dryRun)
}
inline void DeleteOptions::add_dryrun(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.dryrun_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:k8s.io.apimachinery.pkg.apis.meta.v1.DeleteOptions.dryRun)
}
inline void DeleteOptions::add_dryrun(const char* value, size_t size) {
  _impl_.dryrun_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:k8s.io.apimachinery.pkg.apis.meta.v1.DeleteOptions.dryRun)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
DeleteOptions::dryrun() const {
  // @@protoc_insertion_point(field_list:k8s.io.apimachinery.pkg.apis.meta.v1.DeleteOptions.dryRun)
  return _impl_.dryrun_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
DeleteOptions::mutable_dryrun() {
  // @@protoc_insertion_point(field_mutable_list:k8s.io.apimachinery.pkg.apis.meta.v1.DeleteOptions.dryRun)
  return &_impl_.dryrun_;
}

// -------------------------------------------------------------------

// Duration

// optional int64 duration = 1;
inline bool Duration::_internal_has_duration() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Duration::has_duration() const {
  return _internal_has_duration();
}
inline void Duration::clear_duration() {
  _impl_.duration_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t Duration::_internal_duration() const {
  return _impl_.duration_;
}
inline int64_t Duration::duration() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.Duration.duration)
  return _internal_duration();
}
inline void Duration::_internal_set_duration(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.duration_ = value;
}
inline void Duration::set_duration(int64_t value) {
  _internal_set_duration(value);
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.Duration.duration)
}

// -------------------------------------------------------------------

// FieldsV1

// optional bytes Raw = 1;
inline bool FieldsV1::_internal_has_raw() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FieldsV1::has_raw() const {
  return _internal_has_raw();
}
inline void FieldsV1::clear_raw() {
  _impl_.raw_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FieldsV1::raw() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.FieldsV1.Raw)
  return _internal_raw();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FieldsV1::set_raw(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.raw_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.FieldsV1.Raw)
}
inline std::string* FieldsV1::mutable_raw() {
  std::string* _s = _internal_mutable_raw();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.FieldsV1.Raw)
  return _s;
}
inline const std::string& FieldsV1::_internal_raw() const {
  return _impl_.raw_.Get();
}
inline void FieldsV1::_internal_set_raw(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.raw_.Set(value, GetArenaForAllocation());
}
inline std::string* FieldsV1::_internal_mutable_raw() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.raw_.Mutable(GetArenaForAllocation());
}
inline std::string* FieldsV1::release_raw() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.FieldsV1.Raw)
  if (!_internal_has_raw()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.raw_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.raw_.IsDefault()) {
    _impl_.raw_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FieldsV1::set_allocated_raw(std::string* raw) {
  if (raw != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.raw_.SetAllocated(raw, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.raw_.IsDefault()) {
    _impl_.raw_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.FieldsV1.Raw)
}

// -------------------------------------------------------------------

// GetOptions

// optional string resourceVersion = 1;
inline bool GetOptions::_internal_has_resourceversion() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GetOptions::has_resourceversion() const {
  return _internal_has_resourceversion();
}
inline void GetOptions::clear_resourceversion() {
  _impl_.resourceversion_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GetOptions::resourceversion() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.GetOptions.resourceVersion)
  return _internal_resourceversion();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetOptions::set_resourceversion(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.resourceversion_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.GetOptions.resourceVersion)
}
inline std::string* GetOptions::mutable_resourceversion() {
  std::string* _s = _internal_mutable_resourceversion();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.GetOptions.resourceVersion)
  return _s;
}
inline const std::string& GetOptions::_internal_resourceversion() const {
  return _impl_.resourceversion_.Get();
}
inline void GetOptions::_internal_set_resourceversion(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.resourceversion_.Set(value, GetArenaForAllocation());
}
inline std::string* GetOptions::_internal_mutable_resourceversion() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.resourceversion_.Mutable(GetArenaForAllocation());
}
inline std::string* GetOptions::release_resourceversion() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.GetOptions.resourceVersion)
  if (!_internal_has_resourceversion()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.resourceversion_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.resourceversion_.IsDefault()) {
    _impl_.resourceversion_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GetOptions::set_allocated_resourceversion(std::string* resourceversion) {
  if (resourceversion != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.resourceversion_.SetAllocated(resourceversion, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.resourceversion_.IsDefault()) {
    _impl_.resourceversion_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.GetOptions.resourceVersion)
}

// -------------------------------------------------------------------

// GroupKind

// optional string group = 1;
inline bool GroupKind::_internal_has_group() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GroupKind::has_group() const {
  return _internal_has_group();
}
inline void GroupKind::clear_group() {
  _impl_.group_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GroupKind::group() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.GroupKind.group)
  return _internal_group();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GroupKind::set_group(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.group_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.GroupKind.group)
}
inline std::string* GroupKind::mutable_group() {
  std::string* _s = _internal_mutable_group();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.GroupKind.group)
  return _s;
}
inline const std::string& GroupKind::_internal_group() const {
  return _impl_.group_.Get();
}
inline void GroupKind::_internal_set_group(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.group_.Set(value, GetArenaForAllocation());
}
inline std::string* GroupKind::_internal_mutable_group() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.group_.Mutable(GetArenaForAllocation());
}
inline std::string* GroupKind::release_group() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.GroupKind.group)
  if (!_internal_has_group()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.group_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.group_.IsDefault()) {
    _impl_.group_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GroupKind::set_allocated_group(std::string* group) {
  if (group != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.group_.SetAllocated(group, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.group_.IsDefault()) {
    _impl_.group_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.GroupKind.group)
}

// optional string kind = 2;
inline bool GroupKind::_internal_has_kind() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GroupKind::has_kind() const {
  return _internal_has_kind();
}
inline void GroupKind::clear_kind() {
  _impl_.kind_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& GroupKind::kind() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.GroupKind.kind)
  return _internal_kind();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GroupKind::set_kind(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.kind_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.GroupKind.kind)
}
inline std::string* GroupKind::mutable_kind() {
  std::string* _s = _internal_mutable_kind();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.GroupKind.kind)
  return _s;
}
inline const std::string& GroupKind::_internal_kind() const {
  return _impl_.kind_.Get();
}
inline void GroupKind::_internal_set_kind(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.kind_.Set(value, GetArenaForAllocation());
}
inline std::string* GroupKind::_internal_mutable_kind() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.kind_.Mutable(GetArenaForAllocation());
}
inline std::string* GroupKind::release_kind() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.GroupKind.kind)
  if (!_internal_has_kind()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.kind_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.kind_.IsDefault()) {
    _impl_.kind_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GroupKind::set_allocated_kind(std::string* kind) {
  if (kind != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.kind_.SetAllocated(kind, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.kind_.IsDefault()) {
    _impl_.kind_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.GroupKind.kind)
}

// -------------------------------------------------------------------

// GroupResource

// optional string group = 1;
inline bool GroupResource::_internal_has_group() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GroupResource::has_group() const {
  return _internal_has_group();
}
inline void GroupResource::clear_group() {
  _impl_.group_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GroupResource::group() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.GroupResource.group)
  return _internal_group();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GroupResource::set_group(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.group_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.GroupResource.group)
}
inline std::string* GroupResource::mutable_group() {
  std::string* _s = _internal_mutable_group();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.GroupResource.group)
  return _s;
}
inline const std::string& GroupResource::_internal_group() const {
  return _impl_.group_.Get();
}
inline void GroupResource::_internal_set_group(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.group_.Set(value, GetArenaForAllocation());
}
inline std::string* GroupResource::_internal_mutable_group() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.group_.Mutable(GetArenaForAllocation());
}
inline std::string* GroupResource::release_group() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.GroupResource.group)
  if (!_internal_has_group()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.group_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.group_.IsDefault()) {
    _impl_.group_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GroupResource::set_allocated_group(std::string* group) {
  if (group != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.group_.SetAllocated(group, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.group_.IsDefault()) {
    _impl_.group_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.GroupResource.group)
}

// optional string resource = 2;
inline bool GroupResource::_internal_has_resource() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GroupResource::has_resource() const {
  return _internal_has_resource();
}
inline void GroupResource::clear_resource() {
  _impl_.resource_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& GroupResource::resource() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.GroupResource.resource)
  return _internal_resource();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GroupResource::set_resource(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.resource_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.GroupResource.resource)
}
inline std::string* GroupResource::mutable_resource() {
  std::string* _s = _internal_mutable_resource();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.GroupResource.resource)
  return _s;
}
inline const std::string& GroupResource::_internal_resource() const {
  return _impl_.resource_.Get();
}
inline void GroupResource::_internal_set_resource(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.resource_.Set(value, GetArenaForAllocation());
}
inline std::string* GroupResource::_internal_mutable_resource() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.resource_.Mutable(GetArenaForAllocation());
}
inline std::string* GroupResource::release_resource() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.GroupResource.resource)
  if (!_internal_has_resource()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.resource_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.resource_.IsDefault()) {
    _impl_.resource_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GroupResource::set_allocated_resource(std::string* resource) {
  if (resource != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.resource_.SetAllocated(resource, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.resource_.IsDefault()) {
    _impl_.resource_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.GroupResource.resource)
}

// -------------------------------------------------------------------

// GroupVersion

// optional string group = 1;
inline bool GroupVersion::_internal_has_group() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GroupVersion::has_group() const {
  return _internal_has_group();
}
inline void GroupVersion::clear_group() {
  _impl_.group_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GroupVersion::group() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersion.group)
  return _internal_group();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GroupVersion::set_group(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.group_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersion.group)
}
inline std::string* GroupVersion::mutable_group() {
  std::string* _s = _internal_mutable_group();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersion.group)
  return _s;
}
inline const std::string& GroupVersion::_internal_group() const {
  return _impl_.group_.Get();
}
inline void GroupVersion::_internal_set_group(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.group_.Set(value, GetArenaForAllocation());
}
inline std::string* GroupVersion::_internal_mutable_group() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.group_.Mutable(GetArenaForAllocation());
}
inline std::string* GroupVersion::release_group() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersion.group)
  if (!_internal_has_group()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.group_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.group_.IsDefault()) {
    _impl_.group_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GroupVersion::set_allocated_group(std::string* group) {
  if (group != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.group_.SetAllocated(group, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.group_.IsDefault()) {
    _impl_.group_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersion.group)
}

// optional string version = 2;
inline bool GroupVersion::_internal_has_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GroupVersion::has_version() const {
  return _internal_has_version();
}
inline void GroupVersion::clear_version() {
  _impl_.version_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& GroupVersion::version() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersion.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GroupVersion::set_version(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersion.version)
}
inline std::string* GroupVersion::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersion.version)
  return _s;
}
inline const std::string& GroupVersion::_internal_version() const {
  return _impl_.version_.Get();
}
inline void GroupVersion::_internal_set_version(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* GroupVersion::_internal_mutable_version() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* GroupVersion::release_version() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersion.version)
  if (!_internal_has_version()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.version_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GroupVersion::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersion.version)
}

// -------------------------------------------------------------------

// GroupVersionForDiscovery

// optional string groupVersion = 1;
inline bool GroupVersionForDiscovery::_internal_has_groupversion() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GroupVersionForDiscovery::has_groupversion() const {
  return _internal_has_groupversion();
}
inline void GroupVersionForDiscovery::clear_groupversion() {
  _impl_.groupversion_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GroupVersionForDiscovery::groupversion() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery.groupVersion)
  return _internal_groupversion();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GroupVersionForDiscovery::set_groupversion(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.groupversion_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery.groupVersion)
}
inline std::string* GroupVersionForDiscovery::mutable_groupversion() {
  std::string* _s = _internal_mutable_groupversion();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery.groupVersion)
  return _s;
}
inline const std::string& GroupVersionForDiscovery::_internal_groupversion() const {
  return _impl_.groupversion_.Get();
}
inline void GroupVersionForDiscovery::_internal_set_groupversion(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.groupversion_.Set(value, GetArenaForAllocation());
}
inline std::string* GroupVersionForDiscovery::_internal_mutable_groupversion() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.groupversion_.Mutable(GetArenaForAllocation());
}
inline std::string* GroupVersionForDiscovery::release_groupversion() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery.groupVersion)
  if (!_internal_has_groupversion()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.groupversion_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.groupversion_.IsDefault()) {
    _impl_.groupversion_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GroupVersionForDiscovery::set_allocated_groupversion(std::string* groupversion) {
  if (groupversion != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.groupversion_.SetAllocated(groupversion, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.groupversion_.IsDefault()) {
    _impl_.groupversion_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery.groupVersion)
}

// optional string version = 2;
inline bool GroupVersionForDiscovery::_internal_has_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GroupVersionForDiscovery::has_version() const {
  return _internal_has_version();
}
inline void GroupVersionForDiscovery::clear_version() {
  _impl_.version_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& GroupVersionForDiscovery::version() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GroupVersionForDiscovery::set_version(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery.version)
}
inline std::string* GroupVersionForDiscovery::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery.version)
  return _s;
}
inline const std::string& GroupVersionForDiscovery::_internal_version() const {
  return _impl_.version_.Get();
}
inline void GroupVersionForDiscovery::_internal_set_version(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* GroupVersionForDiscovery::_internal_mutable_version() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* GroupVersionForDiscovery::release_version() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery.version)
  if (!_internal_has_version()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.version_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GroupVersionForDiscovery::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery.version)
}

// -------------------------------------------------------------------

// GroupVersionKind

// optional string group = 1;
inline bool GroupVersionKind::_internal_has_group() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GroupVersionKind::has_group() const {
  return _internal_has_group();
}
inline void GroupVersionKind::clear_group() {
  _impl_.group_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GroupVersionKind::group() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionKind.group)
  return _internal_group();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GroupVersionKind::set_group(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.group_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionKind.group)
}
inline std::string* GroupVersionKind::mutable_group() {
  std::string* _s = _internal_mutable_group();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionKind.group)
  return _s;
}
inline const std::string& GroupVersionKind::_internal_group() const {
  return _impl_.group_.Get();
}
inline void GroupVersionKind::_internal_set_group(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.group_.Set(value, GetArenaForAllocation());
}
inline std::string* GroupVersionKind::_internal_mutable_group() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.group_.Mutable(GetArenaForAllocation());
}
inline std::string* GroupVersionKind::release_group() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionKind.group)
  if (!_internal_has_group()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.group_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.group_.IsDefault()) {
    _impl_.group_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GroupVersionKind::set_allocated_group(std::string* group) {
  if (group != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.group_.SetAllocated(group, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.group_.IsDefault()) {
    _impl_.group_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionKind.group)
}

// optional string version = 2;
inline bool GroupVersionKind::_internal_has_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GroupVersionKind::has_version() const {
  return _internal_has_version();
}
inline void GroupVersionKind::clear_version() {
  _impl_.version_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& GroupVersionKind::version() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionKind.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GroupVersionKind::set_version(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionKind.version)
}
inline std::string* GroupVersionKind::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionKind.version)
  return _s;
}
inline const std::string& GroupVersionKind::_internal_version() const {
  return _impl_.version_.Get();
}
inline void GroupVersionKind::_internal_set_version(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* GroupVersionKind::_internal_mutable_version() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* GroupVersionKind::release_version() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionKind.version)
  if (!_internal_has_version()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.version_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GroupVersionKind::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionKind.version)
}

// optional string kind = 3;
inline bool GroupVersionKind::_internal_has_kind() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool GroupVersionKind::has_kind() const {
  return _internal_has_kind();
}
inline void GroupVersionKind::clear_kind() {
  _impl_.kind_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& GroupVersionKind::kind() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionKind.kind)
  return _internal_kind();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GroupVersionKind::set_kind(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.kind_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionKind.kind)
}
inline std::string* GroupVersionKind::mutable_kind() {
  std::string* _s = _internal_mutable_kind();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionKind.kind)
  return _s;
}
inline const std::string& GroupVersionKind::_internal_kind() const {
  return _impl_.kind_.Get();
}
inline void GroupVersionKind::_internal_set_kind(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.kind_.Set(value, GetArenaForAllocation());
}
inline std::string* GroupVersionKind::_internal_mutable_kind() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.kind_.Mutable(GetArenaForAllocation());
}
inline std::string* GroupVersionKind::release_kind() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionKind.kind)
  if (!_internal_has_kind()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.kind_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.kind_.IsDefault()) {
    _impl_.kind_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GroupVersionKind::set_allocated_kind(std::string* kind) {
  if (kind != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.kind_.SetAllocated(kind, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.kind_.IsDefault()) {
    _impl_.kind_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionKind.kind)
}

// -------------------------------------------------------------------

// GroupVersionResource

// optional string group = 1;
inline bool GroupVersionResource::_internal_has_group() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GroupVersionResource::has_group() const {
  return _internal_has_group();
}
inline void GroupVersionResource::clear_group() {
  _impl_.group_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GroupVersionResource::group() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionResource.group)
  return _internal_group();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GroupVersionResource::set_group(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.group_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionResource.group)
}
inline std::string* GroupVersionResource::mutable_group() {
  std::string* _s = _internal_mutable_group();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionResource.group)
  return _s;
}
inline const std::string& GroupVersionResource::_internal_group() const {
  return _impl_.group_.Get();
}
inline void GroupVersionResource::_internal_set_group(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.group_.Set(value, GetArenaForAllocation());
}
inline std::string* GroupVersionResource::_internal_mutable_group() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.group_.Mutable(GetArenaForAllocation());
}
inline std::string* GroupVersionResource::release_group() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionResource.group)
  if (!_internal_has_group()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.group_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.group_.IsDefault()) {
    _impl_.group_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GroupVersionResource::set_allocated_group(std::string* group) {
  if (group != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.group_.SetAllocated(group, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.group_.IsDefault()) {
    _impl_.group_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionResource.group)
}

// optional string version = 2;
inline bool GroupVersionResource::_internal_has_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GroupVersionResource::has_version() const {
  return _internal_has_version();
}
inline void GroupVersionResource::clear_version() {
  _impl_.version_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& GroupVersionResource::version() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionResource.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GroupVersionResource::set_version(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionResource.version)
}
inline std::string* GroupVersionResource::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionResource.version)
  return _s;
}
inline const std::string& GroupVersionResource::_internal_version() const {
  return _impl_.version_.Get();
}
inline void GroupVersionResource::_internal_set_version(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* GroupVersionResource::_internal_mutable_version() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* GroupVersionResource::release_version() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionResource.version)
  if (!_internal_has_version()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.version_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GroupVersionResource::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionResource.version)
}

// optional string resource = 3;
inline bool GroupVersionResource::_internal_has_resource() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool GroupVersionResource::has_resource() const {
  return _internal_has_resource();
}
inline void GroupVersionResource::clear_resource() {
  _impl_.resource_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& GroupVersionResource::resource() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionResource.resource)
  return _internal_resource();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GroupVersionResource::set_resource(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.resource_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionResource.resource)
}
inline std::string* GroupVersionResource::mutable_resource() {
  std::string* _s = _internal_mutable_resource();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionResource.resource)
  return _s;
}
inline const std::string& GroupVersionResource::_internal_resource() const {
  return _impl_.resource_.Get();
}
inline void GroupVersionResource::_internal_set_resource(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.resource_.Set(value, GetArenaForAllocation());
}
inline std::string* GroupVersionResource::_internal_mutable_resource() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.resource_.Mutable(GetArenaForAllocation());
}
inline std::string* GroupVersionResource::release_resource() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionResource.resource)
  if (!_internal_has_resource()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.resource_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.resource_.IsDefault()) {
    _impl_.resource_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GroupVersionResource::set_allocated_resource(std::string* resource) {
  if (resource != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.resource_.SetAllocated(resource, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.resource_.IsDefault()) {
    _impl_.resource_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionResource.resource)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// LabelSelector

// map<string, string> matchLabels = 1;
inline int LabelSelector::_internal_matchlabels_size() const {
  return _impl_.matchlabels_.size();
}
inline int LabelSelector::matchlabels_size() const {
  return _internal_matchlabels_size();
}
inline void LabelSelector::clear_matchlabels() {
  _impl_.matchlabels_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
LabelSelector::_internal_matchlabels() const {
  return _impl_.matchlabels_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
LabelSelector::matchlabels() const {
  // @@protoc_insertion_point(field_map:k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector.matchLabels)
  return _internal_matchlabels();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
LabelSelector::_internal_mutable_matchlabels() {
  return _impl_.matchlabels_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
LabelSelector::mutable_matchlabels() {
  // @@protoc_insertion_point(field_mutable_map:k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector.matchLabels)
  return _internal_mutable_matchlabels();
}

// repeated .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement matchExpressions = 2;
inline int LabelSelector::_internal_matchexpressions_size() const {
  return _impl_.matchexpressions_.size();
}
inline int LabelSelector::matchexpressions_size() const {
  return _internal_matchexpressions_size();
}
inline void LabelSelector::clear_matchexpressions() {
  _impl_.matchexpressions_.Clear();
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelectorRequirement* LabelSelector::mutable_matchexpressions(int index) {
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector.matchExpressions)
  return _impl_.matchexpressions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelectorRequirement >*
LabelSelector::mutable_matchexpressions() {
  // @@protoc_insertion_point(field_mutable_list:k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector.matchExpressions)
  return &_impl_.matchexpressions_;
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelectorRequirement& LabelSelector::_internal_matchexpressions(int index) const {
  return _impl_.matchexpressions_.Get(index);
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelectorRequirement& LabelSelector::matchexpressions(int index) const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector.matchExpressions)
  return _internal_matchexpressions(index);
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelectorRequirement* LabelSelector::_internal_add_matchexpressions() {
  return _impl_.matchexpressions_.Add();
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelectorRequirement* LabelSelector::add_matchexpressions() {
  ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelectorRequirement* _add = _internal_add_matchexpressions();
  // @@protoc_insertion_point(field_add:k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector.matchExpressions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::k8s::io::apimachinery::pkg::apis::meta::v1::LabelSelectorRequirement >&
LabelSelector::matchexpressions() const {
  // @@protoc_insertion_point(field_list:k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector.matchExpressions)
  return _impl_.matchexpressions_;
}

// -------------------------------------------------------------------

// LabelSelectorRequirement

// optional string key = 1;
inline bool LabelSelectorRequirement::_internal_has_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LabelSelectorRequirement::has_key() const {
  return _internal_has_key();
}
inline void LabelSelectorRequirement::clear_key() {
  _impl_.key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LabelSelectorRequirement::key() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LabelSelectorRequirement::set_key(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement.key)
}
inline std::string* LabelSelectorRequirement::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement.key)
  return _s;
}
inline const std::string& LabelSelectorRequirement::_internal_key() const {
  return _impl_.key_.Get();
}
inline void LabelSelectorRequirement::_internal_set_key(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* LabelSelectorRequirement::_internal_mutable_key() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* LabelSelectorRequirement::release_key() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement.key)
  if (!_internal_has_key()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.key_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LabelSelectorRequirement::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement.key)
}

// optional string operator = 2;
inline bool LabelSelectorRequirement::_internal_has_operator_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LabelSelectorRequirement::has_operator_() const {
  return _internal_has_operator_();
}
inline void LabelSelectorRequirement::clear_operator_() {
  _impl_.operator__.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& LabelSelectorRequirement::operator_() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement.operator)
  return _internal_operator_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LabelSelectorRequirement::set_operator_(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.operator__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement.operator)
}
inline std::string* LabelSelectorRequirement::mutable_operator_() {
  std::string* _s = _internal_mutable_operator_();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement.operator)
  return _s;
}
inline const std::string& LabelSelectorRequirement::_internal_operator_() const {
  return _impl_.operator__.Get();
}
inline void LabelSelectorRequirement::_internal_set_operator_(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.operator__.Set(value, GetArenaForAllocation());
}
inline std::string* LabelSelectorRequirement::_internal_mutable_operator_() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.operator__.Mutable(GetArenaForAllocation());
}
inline std::string* LabelSelectorRequirement::release_operator_() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement.operator)
  if (!_internal_has_operator_()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.operator__.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.operator__.IsDefault()) {
    _impl_.operator__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LabelSelectorRequirement::set_allocated_operator_(std::string* operator_) {
  if (operator_ != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.operator__.SetAllocated(operator_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.operator__.IsDefault()) {
    _impl_.operator__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement.operator)
}

// repeated string values = 3;
inline int LabelSelectorRequirement::_internal_values_size() const {
  return _impl_.values_.size();
}
inline int LabelSelectorRequirement::values_size() const {
  return _internal_values_size();
}
inline void LabelSelectorRequirement::clear_values() {
  _impl_.values_.Clear();
}
inline std::string* LabelSelectorRequirement::add_values() {
  std::string* _s = _internal_add_values();
  // @@protoc_insertion_point(field_add_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement.values)
  return _s;
}
inline const std::string& LabelSelectorRequirement::_internal_values(int index) const {
  return _impl_.values_.Get(index);
}
inline const std::string& LabelSelectorRequirement::values(int index) const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement.values)
  return _internal_values(index);
}
inline std::string* LabelSelectorRequirement::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement.values)
  return _impl_.values_.Mutable(index);
}
inline void LabelSelectorRequirement::set_values(int index, const std::string& value) {
  _impl_.values_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement.values)
}
inline void LabelSelectorRequirement::set_values(int index, std::string&& value) {
  _impl_.values_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement.values)
}
inline void LabelSelectorRequirement::set_values(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.values_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement.values)
}
inline void LabelSelectorRequirement::set_values(int index, const char* value, size_t size) {
  _impl_.values_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement.values)
}
inline std::string* LabelSelectorRequirement::_internal_add_values() {
  return _impl_.values_.Add();
}
inline void LabelSelectorRequirement::add_values(const std::string& value) {
  _impl_.values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement.values)
}
inline void LabelSelectorRequirement::add_values(std::string&& value) {
  _impl_.values_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement.values)
}
inline void LabelSelectorRequirement::add_values(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement.values)
}
inline void LabelSelectorRequirement::add_values(const char* value, size_t size) {
  _impl_.values_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement.values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
LabelSelectorRequirement::values() const {
  // @@protoc_insertion_point(field_list:k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement.values)
  return _impl_.values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
LabelSelectorRequirement::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement.values)
  return &_impl_.values_;
}

// -------------------------------------------------------------------

// List

// optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
inline bool List::_internal_has_metadata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.metadata_ != nullptr);
  return value;
}
inline bool List::has_metadata() const {
  return _internal_has_metadata();
}
inline void List::clear_metadata() {
  if (_impl_.metadata_ != nullptr) _impl_.metadata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& List::_internal_metadata() const {
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* p = _impl_.metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta&>(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::_ListMeta_default_instance_);
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& List::metadata() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.List.metadata)
  return _internal_metadata();
}
inline void List::unsafe_arena_set_allocated_metadata(
    ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  _impl_.metadata_ = metadata;
  if (metadata) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.List.metadata)
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* List::release_metadata() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* List::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.List.metadata)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* List::_internal_mutable_metadata() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta>(GetArenaForAllocation());
    _impl_.metadata_ = p;
  }
  return _impl_.metadata_;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* List::mutable_metadata() {
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.List.metadata)
  return _msg;
}
inline void List::set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.metadata_;
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(metadata);
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.List.metadata)
}

// repeated .k8s.io.apimachinery.pkg.runtime.RawExtension items = 2;
inline int List::_internal_items_size() const {
  return _impl_.items_.size();
}
inline int List::items_size() const {
  return _internal_items_size();
}
inline ::k8s::io::apimachinery::pkg::runtime::RawExtension* List::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.List.items)
  return _impl_.items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::k8s::io::apimachinery::pkg::runtime::RawExtension >*
List::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:k8s.io.apimachinery.pkg.apis.meta.v1.List.items)
  return &_impl_.items_;
}
inline const ::k8s::io::apimachinery::pkg::runtime::RawExtension& List::_internal_items(int index) const {
  return _impl_.items_.Get(index);
}
inline const ::k8s::io::apimachinery::pkg::runtime::RawExtension& List::items(int index) const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.List.items)
  return _internal_items(index);
}
inline ::k8s::io::apimachinery::pkg::runtime::RawExtension* List::_internal_add_items() {
  return _impl_.items_.Add();
}
inline ::k8s::io::apimachinery::pkg::runtime::RawExtension* List::add_items() {
  ::k8s::io::apimachinery::pkg::runtime::RawExtension* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:k8s.io.apimachinery.pkg.apis.meta.v1.List.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::k8s::io::apimachinery::pkg::runtime::RawExtension >&
List::items() const {
  // @@protoc_insertion_point(field_list:k8s.io.apimachinery.pkg.apis.meta.v1.List.items)
  return _impl_.items_;
}

// -------------------------------------------------------------------

// ListMeta

// optional string selfLink = 1;
inline bool ListMeta::_internal_has_selflink() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ListMeta::has_selflink() const {
  return _internal_has_selflink();
}
inline void ListMeta::clear_selflink() {
  _impl_.selflink_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ListMeta::selflink() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta.selfLink)
  return _internal_selflink();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListMeta::set_selflink(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.selflink_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta.selfLink)
}
inline std::string* ListMeta::mutable_selflink() {
  std::string* _s = _internal_mutable_selflink();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta.selfLink)
  return _s;
}
inline const std::string& ListMeta::_internal_selflink() const {
  return _impl_.selflink_.Get();
}
inline void ListMeta::_internal_set_selflink(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.selflink_.Set(value, GetArenaForAllocation());
}
inline std::string* ListMeta::_internal_mutable_selflink() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.selflink_.Mutable(GetArenaForAllocation());
}
inline std::string* ListMeta::release_selflink() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta.selfLink)
  if (!_internal_has_selflink()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.selflink_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.selflink_.IsDefault()) {
    _impl_.selflink_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ListMeta::set_allocated_selflink(std::string* selflink) {
  if (selflink != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.selflink_.SetAllocated(selflink, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.selflink_.IsDefault()) {
    _impl_.selflink_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta.selfLink)
}

// optional string resourceVersion = 2;
inline bool ListMeta::_internal_has_resourceversion() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ListMeta::has_resourceversion() const {
  return _internal_has_resourceversion();
}
inline void ListMeta::clear_resourceversion() {
  _impl_.resourceversion_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ListMeta::resourceversion() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta.resourceVersion)
  return _internal_resourceversion();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListMeta::set_resourceversion(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.resourceversion_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta.resourceVersion)
}
inline std::string* ListMeta::mutable_resourceversion() {
  std::string* _s = _internal_mutable_resourceversion();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta.resourceVersion)
  return _s;
}
inline const std::string& ListMeta::_internal_resourceversion() const {
  return _impl_.resourceversion_.Get();
}
inline void ListMeta::_internal_set_resourceversion(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.resourceversion_.Set(value, GetArenaForAllocation());
}
inline std::string* ListMeta::_internal_mutable_resourceversion() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.resourceversion_.Mutable(GetArenaForAllocation());
}
inline std::string* ListMeta::release_resourceversion() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta.resourceVersion)
  if (!_internal_has_resourceversion()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.resourceversion_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.resourceversion_.IsDefault()) {
    _impl_.resourceversion_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ListMeta::set_allocated_resourceversion(std::string* resourceversion) {
  if (resourceversion != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.resourceversion_.SetAllocated(resourceversion, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.resourceversion_.IsDefault()) {
    _impl_.resourceversion_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta.resourceVersion)
}

// optional string continue = 3;
inline bool ListMeta::_internal_has_continue_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ListMeta::has_continue_() const {
  return _internal_has_continue_();
}
inline void ListMeta::clear_continue_() {
  _impl_.continue__.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ListMeta::continue_() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta.continue)
  return _internal_continue_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListMeta::set_continue_(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.continue__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta.continue)
}
inline std::string* ListMeta::mutable_continue_() {
  std::string* _s = _internal_mutable_continue_();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta.continue)
  return _s;
}
inline const std::string& ListMeta::_internal_continue_() const {
  return _impl_.continue__.Get();
}
inline void ListMeta::_internal_set_continue_(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.continue__.Set(value, GetArenaForAllocation());
}
inline std::string* ListMeta::_internal_mutable_continue_() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.continue__.Mutable(GetArenaForAllocation());
}
inline std::string* ListMeta::release_continue_() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta.continue)
  if (!_internal_has_continue_()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.continue__.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.continue__.IsDefault()) {
    _impl_.continue__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ListMeta::set_allocated_continue_(std::string* continue_) {
  if (continue_ != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.continue__.SetAllocated(continue_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.continue__.IsDefault()) {
    _impl_.continue__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta.continue)
}

// optional int64 remainingItemCount = 4;
inline bool ListMeta::_internal_has_remainingitemcount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ListMeta::has_remainingitemcount() const {
  return _internal_has_remainingitemcount();
}
inline void ListMeta::clear_remainingitemcount() {
  _impl_.remainingitemcount_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int64_t ListMeta::_internal_remainingitemcount() const {
  return _impl_.remainingitemcount_;
}
inline int64_t ListMeta::remainingitemcount() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta.remainingItemCount)
  return _internal_remainingitemcount();
}
inline void ListMeta::_internal_set_remainingitemcount(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.remainingitemcount_ = value;
}
inline void ListMeta::set_remainingitemcount(int64_t value) {
  _internal_set_remainingitemcount(value);
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta.remainingItemCount)
}

// -------------------------------------------------------------------

// ListOptions

// optional string labelSelector = 1;
inline bool ListOptions::_internal_has_labelselector() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ListOptions::has_labelselector() const {
  return _internal_has_labelselector();
}
inline void ListOptions::clear_labelselector() {
  _impl_.labelselector_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ListOptions::labelselector() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.ListOptions.labelSelector)
  return _internal_labelselector();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListOptions::set_labelselector(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.labelselector_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.ListOptions.labelSelector)
}
inline std::string* ListOptions::mutable_labelselector() {
  std::string* _s = _internal_mutable_labelselector();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.ListOptions.labelSelector)
  return _s;
}
inline const std::string& ListOptions::_internal_labelselector() const {
  return _impl_.labelselector_.Get();
}
inline void ListOptions::_internal_set_labelselector(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.labelselector_.Set(value, GetArenaForAllocation());
}
inline std::string* ListOptions::_internal_mutable_labelselector() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.labelselector_.Mutable(GetArenaForAllocation());
}
inline std::string* ListOptions::release_labelselector() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.ListOptions.labelSelector)
  if (!_internal_has_labelselector()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.labelselector_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.labelselector_.IsDefault()) {
    _impl_.labelselector_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ListOptions::set_allocated_labelselector(std::string* labelselector) {
  if (labelselector != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.labelselector_.SetAllocated(labelselector, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.labelselector_.IsDefault()) {
    _impl_.labelselector_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.ListOptions.labelSelector)
}

// optional string fieldSelector = 2;
inline bool ListOptions::_internal_has_fieldselector() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ListOptions::has_fieldselector() const {
  return _internal_has_fieldselector();
}
inline void ListOptions::clear_fieldselector() {
  _impl_.fieldselector_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ListOptions::fieldselector() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.ListOptions.fieldSelector)
  return _internal_fieldselector();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListOptions::set_fieldselector(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.fieldselector_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.ListOptions.fieldSelector)
}
inline std::string* ListOptions::mutable_fieldselector() {
  std::string* _s = _internal_mutable_fieldselector();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.ListOptions.fieldSelector)
  return _s;
}
inline const std::string& ListOptions::_internal_fieldselector() const {
  return _impl_.fieldselector_.Get();
}
inline void ListOptions::_internal_set_fieldselector(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.fieldselector_.Set(value, GetArenaForAllocation());
}
inline std::string* ListOptions::_internal_mutable_fieldselector() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.fieldselector_.Mutable(GetArenaForAllocation());
}
inline std::string* ListOptions::release_fieldselector() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.ListOptions.fieldSelector)
  if (!_internal_has_fieldselector()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.fieldselector_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fieldselector_.IsDefault()) {
    _impl_.fieldselector_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ListOptions::set_allocated_fieldselector(std::string* fieldselector) {
  if (fieldselector != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.fieldselector_.SetAllocated(fieldselector, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fieldselector_.IsDefault()) {
    _impl_.fieldselector_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.ListOptions.fieldSelector)
}

// optional bool watch = 3;
inline bool ListOptions::_internal_has_watch() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ListOptions::has_watch() const {
  return _internal_has_watch();
}
inline void ListOptions::clear_watch() {
  _impl_.watch_ = false;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline bool ListOptions::_internal_watch() const {
  return _impl_.watch_;
}
inline bool ListOptions::watch() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.ListOptions.watch)
  return _internal_watch();
}
inline void ListOptions::_internal_set_watch(bool value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.watch_ = value;
}
inline void ListOptions::set_watch(bool value) {
  _internal_set_watch(value);
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.ListOptions.watch)
}

// optional bool allowWatchBookmarks = 9;
inline bool ListOptions::_internal_has_allowwatchbookmarks() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool ListOptions::has_allowwatchbookmarks() const {
  return _internal_has_allowwatchbookmarks();
}
inline void ListOptions::clear_allowwatchbookmarks() {
  _impl_.allowwatchbookmarks_ = false;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline bool ListOptions::_internal_allowwatchbookmarks() const {
  return _impl_.allowwatchbookmarks_;
}
inline bool ListOptions::allowwatchbookmarks() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.ListOptions.allowWatchBookmarks)
  return _internal_allowwatchbookmarks();
}
inline void ListOptions::_internal_set_allowwatchbookmarks(bool value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.allowwatchbookmarks_ = value;
}
inline void ListOptions::set_allowwatchbookmarks(bool value) {
  _internal_set_allowwatchbookmarks(value);
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.ListOptions.allowWatchBookmarks)
}

// optional string resourceVersion = 4;
inline bool ListOptions::_internal_has_resourceversion() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ListOptions::has_resourceversion() const {
  return _internal_has_resourceversion();
}
inline void ListOptions::clear_resourceversion() {
  _impl_.resourceversion_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ListOptions::resourceversion() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.ListOptions.resourceVersion)
  return _internal_resourceversion();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListOptions::set_resourceversion(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.resourceversion_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.ListOptions.resourceVersion)
}
inline std::string* ListOptions::mutable_resourceversion() {
  std::string* _s = _internal_mutable_resourceversion();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.ListOptions.resourceVersion)
  return _s;
}
inline const std::string& ListOptions::_internal_resourceversion() const {
  return _impl_.resourceversion_.Get();
}
inline void ListOptions::_internal_set_resourceversion(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.resourceversion_.Set(value, GetArenaForAllocation());
}
inline std::string* ListOptions::_internal_mutable_resourceversion() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.resourceversion_.Mutable(GetArenaForAllocation());
}
inline std::string* ListOptions::release_resourceversion() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.ListOptions.resourceVersion)
  if (!_internal_has_resourceversion()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.resourceversion_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.resourceversion_.IsDefault()) {
    _impl_.resourceversion_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ListOptions::set_allocated_resourceversion(std::string* resourceversion) {
  if (resourceversion != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.resourceversion_.SetAllocated(resourceversion, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.resourceversion_.IsDefault()) {
    _impl_.resourceversion_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.ListOptions.resourceVersion)
}

// optional string resourceVersionMatch = 10;
inline bool ListOptions::_internal_has_resourceversionmatch() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ListOptions::has_resourceversionmatch() const {
  return _internal_has_resourceversionmatch();
}
inline void ListOptions::clear_resourceversionmatch() {
  _impl_.resourceversionmatch_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& ListOptions::resourceversionmatch() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.ListOptions.resourceVersionMatch)
  return _internal_resourceversionmatch();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListOptions::set_resourceversionmatch(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.resourceversionmatch_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.ListOptions.resourceVersionMatch)
}
inline std::string* ListOptions::mutable_resourceversionmatch() {
  std::string* _s = _internal_mutable_resourceversionmatch();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.ListOptions.resourceVersionMatch)
  return _s;
}
inline const std::string& ListOptions::_internal_resourceversionmatch() const {
  return _impl_.resourceversionmatch_.Get();
}
inline void ListOptions::_internal_set_resourceversionmatch(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.resourceversionmatch_.Set(value, GetArenaForAllocation());
}
inline std::string* ListOptions::_internal_mutable_resourceversionmatch() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.resourceversionmatch_.Mutable(GetArenaForAllocation());
}
inline std::string* ListOptions::release_resourceversionmatch() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.ListOptions.resourceVersionMatch)
  if (!_internal_has_resourceversionmatch()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.resourceversionmatch_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.resourceversionmatch_.IsDefault()) {
    _impl_.resourceversionmatch_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ListOptions::set_allocated_resourceversionmatch(std::string* resourceversionmatch) {
  if (resourceversionmatch != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.resourceversionmatch_.SetAllocated(resourceversionmatch, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.resourceversionmatch_.IsDefault()) {
    _impl_.resourceversionmatch_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.ListOptions.resourceVersionMatch)
}

// optional int64 timeoutSeconds = 5;
inline bool ListOptions::_internal_has_timeoutseconds() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ListOptions::has_timeoutseconds() const {
  return _internal_has_timeoutseconds();
}
inline void ListOptions::clear_timeoutseconds() {
  _impl_.timeoutseconds_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline int64_t ListOptions::_internal_timeoutseconds() const {
  return _impl_.timeoutseconds_;
}
inline int64_t ListOptions::timeoutseconds() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.ListOptions.timeoutSeconds)
  return _internal_timeoutseconds();
}
inline void ListOptions::_internal_set_timeoutseconds(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.timeoutseconds_ = value;
}
inline void ListOptions::set_timeoutseconds(int64_t value) {
  _internal_set_timeoutseconds(value);
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.ListOptions.timeoutSeconds)
}

// optional int64 limit = 7;
inline bool ListOptions::_internal_has_limit() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ListOptions::has_limit() const {
  return _internal_has_limit();
}
inline void ListOptions::clear_limit() {
  _impl_.limit_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline int64_t ListOptions::_internal_limit() const {
  return _impl_.limit_;
}
inline int64_t ListOptions::limit() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.ListOptions.limit)
  return _internal_limit();
}
inline void ListOptions::_internal_set_limit(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.limit_ = value;
}
inline void ListOptions::set_limit(int64_t value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.ListOptions.limit)
}

// optional string continue = 8;
inline bool ListOptions::_internal_has_continue_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ListOptions::has_continue_() const {
  return _internal_has_continue_();
}
inline void ListOptions::clear_continue_() {
  _impl_.continue__.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& ListOptions::continue_() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.ListOptions.continue)
  return _internal_continue_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListOptions::set_continue_(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.continue__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.ListOptions.continue)
}
inline std::string* ListOptions::mutable_continue_() {
  std::string* _s = _internal_mutable_continue_();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.ListOptions.continue)
  return _s;
}
inline const std::string& ListOptions::_internal_continue_() const {
  return _impl_.continue__.Get();
}
inline void ListOptions::_internal_set_continue_(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.continue__.Set(value, GetArenaForAllocation());
}
inline std::string* ListOptions::_internal_mutable_continue_() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.continue__.Mutable(GetArenaForAllocation());
}
inline std::string* ListOptions::release_continue_() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.ListOptions.continue)
  if (!_internal_has_continue_()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.continue__.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.continue__.IsDefault()) {
    _impl_.continue__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ListOptions::set_allocated_continue_(std::string* continue_) {
  if (continue_ != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.continue__.SetAllocated(continue_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.continue__.IsDefault()) {
    _impl_.continue__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.ListOptions.continue)
}

// optional bool sendInitialEvents = 11;
inline bool ListOptions::_internal_has_sendinitialevents() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool ListOptions::has_sendinitialevents() const {
  return _internal_has_sendinitialevents();
}
inline void ListOptions::clear_sendinitialevents() {
  _impl_.sendinitialevents_ = false;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline bool ListOptions::_internal_sendinitialevents() const {
  return _impl_.sendinitialevents_;
}
inline bool ListOptions::sendinitialevents() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.ListOptions.sendInitialEvents)
  return _internal_sendinitialevents();
}
inline void ListOptions::_internal_set_sendinitialevents(bool value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.sendinitialevents_ = value;
}
inline void ListOptions::set_sendinitialevents(bool value) {
  _internal_set_sendinitialevents(value);
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.ListOptions.sendInitialEvents)
}

// -------------------------------------------------------------------

// ManagedFieldsEntry

// optional string manager = 1;
inline bool ManagedFieldsEntry::_internal_has_manager() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ManagedFieldsEntry::has_manager() const {
  return _internal_has_manager();
}
inline void ManagedFieldsEntry::clear_manager() {
  _impl_.manager_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ManagedFieldsEntry::manager() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry.manager)
  return _internal_manager();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ManagedFieldsEntry::set_manager(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.manager_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry.manager)
}
inline std::string* ManagedFieldsEntry::mutable_manager() {
  std::string* _s = _internal_mutable_manager();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry.manager)
  return _s;
}
inline const std::string& ManagedFieldsEntry::_internal_manager() const {
  return _impl_.manager_.Get();
}
inline void ManagedFieldsEntry::_internal_set_manager(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.manager_.Set(value, GetArenaForAllocation());
}
inline std::string* ManagedFieldsEntry::_internal_mutable_manager() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.manager_.Mutable(GetArenaForAllocation());
}
inline std::string* ManagedFieldsEntry::release_manager() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry.manager)
  if (!_internal_has_manager()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.manager_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.manager_.IsDefault()) {
    _impl_.manager_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ManagedFieldsEntry::set_allocated_manager(std::string* manager) {
  if (manager != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.manager_.SetAllocated(manager, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.manager_.IsDefault()) {
    _impl_.manager_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry.manager)
}

// optional string operation = 2;
inline bool ManagedFieldsEntry::_internal_has_operation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ManagedFieldsEntry::has_operation() const {
  return _internal_has_operation();
}
inline void ManagedFieldsEntry::clear_operation() {
  _impl_.operation_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ManagedFieldsEntry::operation() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry.operation)
  return _internal_operation();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ManagedFieldsEntry::set_operation(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.operation_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry.operation)
}
inline std::string* ManagedFieldsEntry::mutable_operation() {
  std::string* _s = _internal_mutable_operation();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry.operation)
  return _s;
}
inline const std::string& ManagedFieldsEntry::_internal_operation() const {
  return _impl_.operation_.Get();
}
inline void ManagedFieldsEntry::_internal_set_operation(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.operation_.Set(value, GetArenaForAllocation());
}
inline std::string* ManagedFieldsEntry::_internal_mutable_operation() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.operation_.Mutable(GetArenaForAllocation());
}
inline std::string* ManagedFieldsEntry::release_operation() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry.operation)
  if (!_internal_has_operation()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.operation_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.operation_.IsDefault()) {
    _impl_.operation_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ManagedFieldsEntry::set_allocated_operation(std::string* operation) {
  if (operation != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.operation_.SetAllocated(operation, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.operation_.IsDefault()) {
    _impl_.operation_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry.operation)
}

// optional string apiVersion = 3;
inline bool ManagedFieldsEntry::_internal_has_apiversion() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ManagedFieldsEntry::has_apiversion() const {
  return _internal_has_apiversion();
}
inline void ManagedFieldsEntry::clear_apiversion() {
  _impl_.apiversion_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ManagedFieldsEntry::apiversion() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry.apiVersion)
  return _internal_apiversion();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ManagedFieldsEntry::set_apiversion(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.apiversion_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry.apiVersion)
}
inline std::string* ManagedFieldsEntry::mutable_apiversion() {
  std::string* _s = _internal_mutable_apiversion();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry.apiVersion)
  return _s;
}
inline const std::string& ManagedFieldsEntry::_internal_apiversion() const {
  return _impl_.apiversion_.Get();
}
inline void ManagedFieldsEntry::_internal_set_apiversion(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.apiversion_.Set(value, GetArenaForAllocation());
}
inline std::string* ManagedFieldsEntry::_internal_mutable_apiversion() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.apiversion_.Mutable(GetArenaForAllocation());
}
inline std::string* ManagedFieldsEntry::release_apiversion() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry.apiVersion)
  if (!_internal_has_apiversion()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.apiversion_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.apiversion_.IsDefault()) {
    _impl_.apiversion_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ManagedFieldsEntry::set_allocated_apiversion(std::string* apiversion) {
  if (apiversion != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.apiversion_.SetAllocated(apiversion, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.apiversion_.IsDefault()) {
    _impl_.apiversion_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry.apiVersion)
}

// optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time time = 4;
inline bool ManagedFieldsEntry::_internal_has_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.time_ != nullptr);
  return value;
}
inline bool ManagedFieldsEntry::has_time() const {
  return _internal_has_time();
}
inline void ManagedFieldsEntry::clear_time() {
  if (_impl_.time_ != nullptr) _impl_.time_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::Time& ManagedFieldsEntry::_internal_time() const {
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* p = _impl_.time_;
  return p != nullptr ? *p : reinterpret_cast<const ::k8s::io::apimachinery::pkg::apis::meta::v1::Time&>(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::_Time_default_instance_);
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::Time& ManagedFieldsEntry::time() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry.time)
  return _internal_time();
}
inline void ManagedFieldsEntry::unsafe_arena_set_allocated_time(
    ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.time_);
  }
  _impl_.time_ = time;
  if (time) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry.time)
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* ManagedFieldsEntry::release_time() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* temp = _impl_.time_;
  _impl_.time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* ManagedFieldsEntry::unsafe_arena_release_time() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry.time)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* temp = _impl_.time_;
  _impl_.time_ = nullptr;
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* ManagedFieldsEntry::_internal_mutable_time() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.time_ == nullptr) {
    auto* p = CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::Time>(GetArenaForAllocation());
    _impl_.time_ = p;
  }
  return _impl_.time_;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* ManagedFieldsEntry::mutable_time() {
  ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* _msg = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry.time)
  return _msg;
}
inline void ManagedFieldsEntry::set_allocated_time(::k8s::io::apimachinery::pkg::apis::meta::v1::Time* time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.time_;
  }
  if (time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(time);
    if (message_arena != submessage_arena) {
      time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.time_ = time;
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry.time)
}

// optional string fieldsType = 6;
inline bool ManagedFieldsEntry::_internal_has_fieldstype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ManagedFieldsEntry::has_fieldstype() const {
  return _internal_has_fieldstype();
}
inline void ManagedFieldsEntry::clear_fieldstype() {
  _impl_.fieldstype_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& ManagedFieldsEntry::fieldstype() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry.fieldsType)
  return _internal_fieldstype();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ManagedFieldsEntry::set_fieldstype(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.fieldstype_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry.fieldsType)
}
inline std::string* ManagedFieldsEntry::mutable_fieldstype() {
  std::string* _s = _internal_mutable_fieldstype();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry.fieldsType)
  return _s;
}
inline const std::string& ManagedFieldsEntry::_internal_fieldstype() const {
  return _impl_.fieldstype_.Get();
}
inline void ManagedFieldsEntry::_internal_set_fieldstype(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.fieldstype_.Set(value, GetArenaForAllocation());
}
inline std::string* ManagedFieldsEntry::_internal_mutable_fieldstype() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.fieldstype_.Mutable(GetArenaForAllocation());
}
inline std::string* ManagedFieldsEntry::release_fieldstype() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry.fieldsType)
  if (!_internal_has_fieldstype()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.fieldstype_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fieldstype_.IsDefault()) {
    _impl_.fieldstype_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ManagedFieldsEntry::set_allocated_fieldstype(std::string* fieldstype) {
  if (fieldstype != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.fieldstype_.SetAllocated(fieldstype, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fieldstype_.IsDefault()) {
    _impl_.fieldstype_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry.fieldsType)
}

// optional .k8s.io.apimachinery.pkg.apis.meta.v1.FieldsV1 fieldsV1 = 7;
inline bool ManagedFieldsEntry::_internal_has_fieldsv1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.fieldsv1_ != nullptr);
  return value;
}
inline bool ManagedFieldsEntry::has_fieldsv1() const {
  return _internal_has_fieldsv1();
}
inline void ManagedFieldsEntry::clear_fieldsv1() {
  if (_impl_.fieldsv1_ != nullptr) _impl_.fieldsv1_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::FieldsV1& ManagedFieldsEntry::_internal_fieldsv1() const {
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::FieldsV1* p = _impl_.fieldsv1_;
  return p != nullptr ? *p : reinterpret_cast<const ::k8s::io::apimachinery::pkg::apis::meta::v1::FieldsV1&>(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::_FieldsV1_default_instance_);
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::FieldsV1& ManagedFieldsEntry::fieldsv1() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry.fieldsV1)
  return _internal_fieldsv1();
}
inline void ManagedFieldsEntry::unsafe_arena_set_allocated_fieldsv1(
    ::k8s::io::apimachinery::pkg::apis::meta::v1::FieldsV1* fieldsv1) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fieldsv1_);
  }
  _impl_.fieldsv1_ = fieldsv1;
  if (fieldsv1) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry.fieldsV1)
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::FieldsV1* ManagedFieldsEntry::release_fieldsv1() {
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::FieldsV1* temp = _impl_.fieldsv1_;
  _impl_.fieldsv1_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::FieldsV1* ManagedFieldsEntry::unsafe_arena_release_fieldsv1() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry.fieldsV1)
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::FieldsV1* temp = _impl_.fieldsv1_;
  _impl_.fieldsv1_ = nullptr;
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::FieldsV1* ManagedFieldsEntry::_internal_mutable_fieldsv1() {
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.fieldsv1_ == nullptr) {
    auto* p = CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::FieldsV1>(GetArenaForAllocation());
    _impl_.fieldsv1_ = p;
  }
  return _impl_.fieldsv1_;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::FieldsV1* ManagedFieldsEntry::mutable_fieldsv1() {
  ::k8s::io::apimachinery::pkg::apis::meta::v1::FieldsV1* _msg = _internal_mutable_fieldsv1();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry.fieldsV1)
  return _msg;
}
inline void ManagedFieldsEntry::set_allocated_fieldsv1(::k8s::io::apimachinery::pkg::apis::meta::v1::FieldsV1* fieldsv1) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.fieldsv1_;
  }
  if (fieldsv1) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(fieldsv1);
    if (message_arena != submessage_arena) {
      fieldsv1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fieldsv1, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.fieldsv1_ = fieldsv1;
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry.fieldsV1)
}

// optional string subresource = 8;
inline bool ManagedFieldsEntry::_internal_has_subresource() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ManagedFieldsEntry::has_subresource() const {
  return _internal_has_subresource();
}
inline void ManagedFieldsEntry::clear_subresource() {
  _impl_.subresource_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& ManagedFieldsEntry::subresource() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry.subresource)
  return _internal_subresource();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ManagedFieldsEntry::set_subresource(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.subresource_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry.subresource)
}
inline std::string* ManagedFieldsEntry::mutable_subresource() {
  std::string* _s = _internal_mutable_subresource();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry.subresource)
  return _s;
}
inline const std::string& ManagedFieldsEntry::_internal_subresource() const {
  return _impl_.subresource_.Get();
}
inline void ManagedFieldsEntry::_internal_set_subresource(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.subresource_.Set(value, GetArenaForAllocation());
}
inline std::string* ManagedFieldsEntry::_internal_mutable_subresource() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.subresource_.Mutable(GetArenaForAllocation());
}
inline std::string* ManagedFieldsEntry::release_subresource() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry.subresource)
  if (!_internal_has_subresource()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.subresource_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.subresource_.IsDefault()) {
    _impl_.subresource_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ManagedFieldsEntry::set_allocated_subresource(std::string* subresource) {
  if (subresource != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.subresource_.SetAllocated(subresource, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.subresource_.IsDefault()) {
    _impl_.subresource_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry.subresource)
}

// -------------------------------------------------------------------

// MicroTime

// optional int64 seconds = 1;
inline bool MicroTime::_internal_has_seconds() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MicroTime::has_seconds() const {
  return _internal_has_seconds();
}
inline void MicroTime::clear_seconds() {
  _impl_.seconds_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t MicroTime::_internal_seconds() const {
  return _impl_.seconds_;
}
inline int64_t MicroTime::seconds() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime.seconds)
  return _internal_seconds();
}
inline void MicroTime::_internal_set_seconds(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.seconds_ = value;
}
inline void MicroTime::set_seconds(int64_t value) {
  _internal_set_seconds(value);
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime.seconds)
}

// optional int32 nanos = 2;
inline bool MicroTime::_internal_has_nanos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MicroTime::has_nanos() const {
  return _internal_has_nanos();
}
inline void MicroTime::clear_nanos() {
  _impl_.nanos_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t MicroTime::_internal_nanos() const {
  return _impl_.nanos_;
}
inline int32_t MicroTime::nanos() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime.nanos)
  return _internal_nanos();
}
inline void MicroTime::_internal_set_nanos(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.nanos_ = value;
}
inline void MicroTime::set_nanos(int32_t value) {
  _internal_set_nanos(value);
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime.nanos)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ObjectMeta

// optional string name = 1;
inline bool ObjectMeta::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ObjectMeta::has_name() const {
  return _internal_has_name();
}
inline void ObjectMeta::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ObjectMeta::name() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ObjectMeta::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta.name)
}
inline std::string* ObjectMeta::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta.name)
  return _s;
}
inline const std::string& ObjectMeta::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ObjectMeta::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ObjectMeta::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ObjectMeta::release_name() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ObjectMeta::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta.name)
}

// optional string generateName = 2;
inline bool ObjectMeta::_internal_has_generatename() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ObjectMeta::has_generatename() const {
  return _internal_has_generatename();
}
inline void ObjectMeta::clear_generatename() {
  _impl_.generatename_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ObjectMeta::generatename() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta.generateName)
  return _internal_generatename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ObjectMeta::set_generatename(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.generatename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta.generateName)
}
inline std::string* ObjectMeta::mutable_generatename() {
  std::string* _s = _internal_mutable_generatename();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta.generateName)
  return _s;
}
inline const std::string& ObjectMeta::_internal_generatename() const {
  return _impl_.generatename_.Get();
}
inline void ObjectMeta::_internal_set_generatename(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.generatename_.Set(value, GetArenaForAllocation());
}
inline std::string* ObjectMeta::_internal_mutable_generatename() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.generatename_.Mutable(GetArenaForAllocation());
}
inline std::string* ObjectMeta::release_generatename() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta.generateName)
  if (!_internal_has_generatename()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.generatename_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.generatename_.IsDefault()) {
    _impl_.generatename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ObjectMeta::set_allocated_generatename(std::string* generatename) {
  if (generatename != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.generatename_.SetAllocated(generatename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.generatename_.IsDefault()) {
    _impl_.generatename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta.generateName)
}

// optional string namespace = 3;
inline bool ObjectMeta::_internal_has_namespace_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ObjectMeta::has_namespace_() const {
  return _internal_has_namespace_();
}
inline void ObjectMeta::clear_namespace_() {
  _impl_.namespace__.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ObjectMeta::namespace_() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta.namespace)
  return _internal_namespace_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ObjectMeta::set_namespace_(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.namespace__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta.namespace)
}
inline std::string* ObjectMeta::mutable_namespace_() {
  std::string* _s = _internal_mutable_namespace_();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta.namespace)
  return _s;
}
inline const std::string& ObjectMeta::_internal_namespace_() const {
  return _impl_.namespace__.Get();
}
inline void ObjectMeta::_internal_set_namespace_(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.namespace__.Set(value, GetArenaForAllocation());
}
inline std::string* ObjectMeta::_internal_mutable_namespace_() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.namespace__.Mutable(GetArenaForAllocation());
}
inline std::string* ObjectMeta::release_namespace_() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta.namespace)
  if (!_internal_has_namespace_()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.namespace__.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.namespace__.IsDefault()) {
    _impl_.namespace__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ObjectMeta::set_allocated_namespace_(std::string* namespace_) {
  if (namespace_ != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.namespace__.SetAllocated(namespace_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.namespace__.IsDefault()) {
    _impl_.namespace__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta.namespace)
}

// optional string selfLink = 4;
inline bool ObjectMeta::_internal_has_selflink() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ObjectMeta::has_selflink() const {
  return _internal_has_selflink();
}
inline void ObjectMeta::clear_selflink() {
  _impl_.selflink_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& ObjectMeta::selflink() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta.selfLink)
  return _internal_selflink();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ObjectMeta::set_selflink(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.selflink_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta.selfLink)
}
inline std::string* ObjectMeta::mutable_selflink() {
  std::string* _s = _internal_mutable_selflink();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta.selfLink)
  return _s;
}
inline const std::string& ObjectMeta::_internal_selflink() const {
  return _impl_.selflink_.Get();
}
inline void ObjectMeta::_internal_set_selflink(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.selflink_.Set(value, GetArenaForAllocation());
}
inline std::string* ObjectMeta::_internal_mutable_selflink() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.selflink_.Mutable(GetArenaForAllocation());
}
inline std::string* ObjectMeta::release_selflink() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta.selfLink)
  if (!_internal_has_selflink()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.selflink_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.selflink_.IsDefault()) {
    _impl_.selflink_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ObjectMeta::set_allocated_selflink(std::string* selflink) {
  if (selflink != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.selflink_.SetAllocated(selflink, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.selflink_.IsDefault()) {
    _impl_.selflink_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta.selfLink)
}

// optional string uid = 5;
inline bool ObjectMeta::_internal_has_uid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ObjectMeta::has_uid() const {
  return _internal_has_uid();
}
inline void ObjectMeta::clear_uid() {
  _impl_.uid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& ObjectMeta::uid() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta.uid)
  return _internal_uid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ObjectMeta::set_uid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.uid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta.uid)
}
inline std::string* ObjectMeta::mutable_uid() {
  std::string* _s = _internal_mutable_uid();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta.uid)
  return _s;
}
inline const std::string& ObjectMeta::_internal_uid() const {
  return _impl_.uid_.Get();
}
inline void ObjectMeta::_internal_set_uid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.uid_.Set(value, GetArenaForAllocation());
}
inline std::string* ObjectMeta::_internal_mutable_uid() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.uid_.Mutable(GetArenaForAllocation());
}
inline std::string* ObjectMeta::release_uid() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta.uid)
  if (!_internal_has_uid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.uid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uid_.IsDefault()) {
    _impl_.uid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ObjectMeta::set_allocated_uid(std::string* uid) {
  if (uid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.uid_.SetAllocated(uid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uid_.IsDefault()) {
    _impl_.uid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta.uid)
}

// optional string resourceVersion = 6;
inline bool ObjectMeta::_internal_has_resourceversion() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ObjectMeta::has_resourceversion() const {
  return _internal_has_resourceversion();
}
inline void ObjectMeta::clear_resourceversion() {
  _impl_.resourceversion_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& ObjectMeta::resourceversion() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta.resourceVersion)
  return _internal_resourceversion();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ObjectMeta::set_resourceversion(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000020u;
 _impl_.resourceversion_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta.resourceVersion)
}
inline std::string* ObjectMeta::mutable_resourceversion() {
  std::string* _s = _internal_mutable_resourceversion();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta.resourceVersion)
  return _s;
}
inline const std::string& ObjectMeta::_internal_resourceversion() const {
  return _impl_.resourceversion_.Get();
}
inline void ObjectMeta::_internal_set_resourceversion(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.resourceversion_.Set(value, GetArenaForAllocation());
}
inline std::string* ObjectMeta::_internal_mutable_resourceversion() {
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.resourceversion_.Mutable(GetArenaForAllocation());
}
inline std::string* ObjectMeta::release_resourceversion() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta.resourceVersion)
  if (!_internal_has_resourceversion()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* p = _impl_.resourceversion_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.resourceversion_.IsDefault()) {
    _impl_.resourceversion_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ObjectMeta::set_allocated_resourceversion(std::string* resourceversion) {
  if (resourceversion != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.resourceversion_.SetAllocated(resourceversion, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.resourceversion_.IsDefault()) {
    _impl_.resourceversion_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta.resourceVersion)
}

// optional int64 generation = 7;
inline bool ObjectMeta::_internal_has_generation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool ObjectMeta::has_generation() const {
  return _internal_has_generation();
}
inline void ObjectMeta::clear_generation() {
  _impl_.generation_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline int64_t ObjectMeta::_internal_generation() const {
  return _impl_.generation_;
}
inline int64_t ObjectMeta::generation() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta.generation)
  return _internal_generation();
}
inline void ObjectMeta::_internal_set_generation(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.generation_ = value;
}
inline void ObjectMeta::set_generation(int64_t value) {
  _internal_set_generation(value);
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta.generation)
}

// optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time creationTimestamp = 8;
inline bool ObjectMeta::_internal_has_creationtimestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.creationtimestamp_ != nullptr);
  return value;
}
inline bool ObjectMeta::has_creationtimestamp() const {
  return _internal_has_creationtimestamp();
}
inline void ObjectMeta::clear_creationtimestamp() {
  if (_impl_.creationtimestamp_ != nullptr) _impl_.creationtimestamp_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::Time& ObjectMeta::_internal_creationtimestamp() const {
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* p = _impl_.creationtimestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::k8s::io::apimachinery::pkg::apis::meta::v1::Time&>(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::_Time_default_instance_);
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::Time& ObjectMeta::creationtimestamp() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta.creationTimestamp)
  return _internal_creationtimestamp();
}
inline void ObjectMeta::unsafe_arena_set_allocated_creationtimestamp(
    ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* creationtimestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.creationtimestamp_);
  }
  _impl_.creationtimestamp_ = creationtimestamp;
  if (creationtimestamp) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta.creationTimestamp)
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* ObjectMeta::release_creationtimestamp() {
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* temp = _impl_.creationtimestamp_;
  _impl_.creationtimestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* ObjectMeta::unsafe_arena_release_creationtimestamp() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta.creationTimestamp)
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* temp = _impl_.creationtimestamp_;
  _impl_.creationtimestamp_ = nullptr;
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* ObjectMeta::_internal_mutable_creationtimestamp() {
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.creationtimestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::Time>(GetArenaForAllocation());
    _impl_.creationtimestamp_ = p;
  }
  return _impl_.creationtimestamp_;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* ObjectMeta::mutable_creationtimestamp() {
  ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* _msg = _internal_mutable_creationtimestamp();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta.creationTimestamp)
  return _msg;
}
inline void ObjectMeta::set_allocated_creationtimestamp(::k8s::io::apimachinery::pkg::apis::meta::v1::Time* creationtimestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.creationtimestamp_;
  }
  if (creationtimestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(creationtimestamp);
    if (message_arena != submessage_arena) {
      creationtimestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, creationtimestamp, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.creationtimestamp_ = creationtimestamp;
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta.creationTimestamp)
}

// optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time deletionTimestamp = 9;
inline bool ObjectMeta::_internal_has_deletiontimestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.deletiontimestamp_ != nullptr);
  return value;
}
inline bool ObjectMeta::has_deletiontimestamp() const {
  return _internal_has_deletiontimestamp();
}
inline void ObjectMeta::clear_deletiontimestamp() {
  if (_impl_.deletiontimestamp_ != nullptr) _impl_.deletiontimestamp_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::Time& ObjectMeta::_internal_deletiontimestamp() const {
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* p = _impl_.deletiontimestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::k8s::io::apimachinery::pkg::apis::meta::v1::Time&>(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::_Time_default_instance_);
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::Time& ObjectMeta::deletiontimestamp() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta.deletionTimestamp)
  return _internal_deletiontimestamp();
}
inline void ObjectMeta::unsafe_arena_set_allocated_deletiontimestamp(
    ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* deletiontimestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.deletiontimestamp_);
  }
  _impl_.deletiontimestamp_ = deletiontimestamp;
  if (deletiontimestamp) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta.deletionTimestamp)
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* ObjectMeta::release_deletiontimestamp() {
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* temp = _impl_.deletiontimestamp_;
  _impl_.deletiontimestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* ObjectMeta::unsafe_arena_release_deletiontimestamp() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta.deletionTimestamp)
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* temp = _impl_.deletiontimestamp_;
  _impl_.deletiontimestamp_ = nullptr;
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* ObjectMeta::_internal_mutable_deletiontimestamp() {
  _impl_._has_bits_[0] |= 0x00000080u;
  if (_impl_.deletiontimestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::Time>(GetArenaForAllocation());
    _impl_.deletiontimestamp_ = p;
  }
  return _impl_.deletiontimestamp_;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* ObjectMeta::mutable_deletiontimestamp() {
  ::k8s::io::apimachinery::pkg::apis::meta::v1::Time* _msg = _internal_mutable_deletiontimestamp();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta.deletionTimestamp)
  return _msg;
}
inline void ObjectMeta::set_allocated_deletiontimestamp(::k8s::io::apimachinery::pkg::apis::meta::v1::Time* deletiontimestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.deletiontimestamp_;
  }
  if (deletiontimestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(deletiontimestamp);
    if (message_arena != submessage_arena) {
      deletiontimestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, deletiontimestamp, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.deletiontimestamp_ = deletiontimestamp;
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta.deletionTimestamp)
}

// optional int64 deletionGracePeriodSeconds = 10;
inline bool ObjectMeta::_internal_has_deletiongraceperiodseconds() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool ObjectMeta::has_deletiongraceperiodseconds() const {
  return _internal_has_deletiongraceperiodseconds();
}
inline void ObjectMeta::clear_deletiongraceperiodseconds() {
  _impl_.deletiongraceperiodseconds_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline int64_t ObjectMeta::_internal_deletiongraceperiodseconds() const {
  return _impl_.deletiongraceperiodseconds_;
}
inline int64_t ObjectMeta::deletiongraceperiodseconds() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta.deletionGracePeriodSeconds)
  return _internal_deletiongraceperiodseconds();
}
inline void ObjectMeta::_internal_set_deletiongraceperiodseconds(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.deletiongraceperiodseconds_ = value;
}
inline void ObjectMeta::set_deletiongraceperiodseconds(int64_t value) {
  _internal_set_deletiongraceperiodseconds(value);
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta.deletionGracePeriodSeconds)
}

// map<string, string> labels = 11;
inline int ObjectMeta::_internal_labels_size() const {
  return _impl_.labels_.size();
}
inline int ObjectMeta::labels_size() const {
  return _internal_labels_size();
}
inline void ObjectMeta::clear_labels() {
  _impl_.labels_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ObjectMeta::_internal_labels() const {
  return _impl_.labels_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ObjectMeta::labels() const {
  // @@protoc_insertion_point(field_map:k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta.labels)
  return _internal_labels();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ObjectMeta::_internal_mutable_labels() {
  return _impl_.labels_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ObjectMeta::mutable_labels() {
  // @@protoc_insertion_point(field_mutable_map:k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta.labels)
  return _internal_mutable_labels();
}

// map<string, string> annotations = 12;
inline int ObjectMeta::_internal_annotations_size() const {
  return _impl_.annotations_.size();
}
inline int ObjectMeta::annotations_size() const {
  return _internal_annotations_size();
}
inline void ObjectMeta::clear_annotations() {
  _impl_.annotations_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ObjectMeta::_internal_annotations() const {
  return _impl_.annotations_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ObjectMeta::annotations() const {
  // @@protoc_insertion_point(field_map:k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta.annotations)
  return _internal_annotations();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ObjectMeta::_internal_mutable_annotations() {
  return _impl_.annotations_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ObjectMeta::mutable_annotations() {
  // @@protoc_insertion_point(field_mutable_map:k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta.annotations)
  return _internal_mutable_annotations();
}

// repeated .k8s.io.apimachinery.pkg.apis.meta.v1.OwnerReference ownerReferences = 13;
inline int ObjectMeta::_internal_ownerreferences_size() const {
  return _impl_.ownerreferences_.size();
}
inline int ObjectMeta::ownerreferences_size() const {
  return _internal_ownerreferences_size();
}
inline void ObjectMeta::clear_ownerreferences() {
  _impl_.ownerreferences_.Clear();
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::OwnerReference* ObjectMeta::mutable_ownerreferences(int index) {
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta.ownerReferences)
  return _impl_.ownerreferences_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::k8s::io::apimachinery::pkg::apis::meta::v1::OwnerReference >*
ObjectMeta::mutable_ownerreferences() {
  // @@protoc_insertion_point(field_mutable_list:k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta.ownerReferences)
  return &_impl_.ownerreferences_;
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::OwnerReference& ObjectMeta::_internal_ownerreferences(int index) const {
  return _impl_.ownerreferences_.Get(index);
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::OwnerReference& ObjectMeta::ownerreferences(int index) const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta.ownerReferences)
  return _internal_ownerreferences(index);
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::OwnerReference* ObjectMeta::_internal_add_ownerreferences() {
  return _impl_.ownerreferences_.Add();
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::OwnerReference* ObjectMeta::add_ownerreferences() {
  ::k8s::io::apimachinery::pkg::apis::meta::v1::OwnerReference* _add = _internal_add_ownerreferences();
  // @@protoc_insertion_point(field_add:k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta.ownerReferences)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::k8s::io::apimachinery::pkg::apis::meta::v1::OwnerReference >&
ObjectMeta::ownerreferences() const {
  // @@protoc_insertion_point(field_list:k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta.ownerReferences)
  return _impl_.ownerreferences_;
}

// repeated string finalizers = 14;
inline int ObjectMeta::_internal_finalizers_size() const {
  return _impl_.finalizers_.size();
}
inline int ObjectMeta::finalizers_size() const {
  return _internal_finalizers_size();
}
inline void ObjectMeta::clear_finalizers() {
  _impl_.finalizers_.Clear();
}
inline std::string* ObjectMeta::add_finalizers() {
  std::string* _s = _internal_add_finalizers();
  // @@protoc_insertion_point(field_add_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta.finalizers)
  return _s;
}
inline const std::string& ObjectMeta::_internal_finalizers(int index) const {
  return _impl_.finalizers_.Get(index);
}
inline const std::string& ObjectMeta::finalizers(int index) const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta.finalizers)
  return _internal_finalizers(index);
}
inline std::string* ObjectMeta::mutable_finalizers(int index) {
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta.finalizers)
  return _impl_.finalizers_.Mutable(index);
}
inline void ObjectMeta::set_finalizers(int index, const std::string& value) {
  _impl_.finalizers_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta.finalizers)
}
inline void ObjectMeta::set_finalizers(int index, std::string&& value) {
  _impl_.finalizers_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta.finalizers)
}
inline void ObjectMeta::set_finalizers(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.finalizers_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta.finalizers)
}
inline void ObjectMeta::set_finalizers(int index, const char* value, size_t size) {
  _impl_.finalizers_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta.finalizers)
}
inline std::string* ObjectMeta::_internal_add_finalizers() {
  return _impl_.finalizers_.Add();
}
inline void ObjectMeta::add_finalizers(const std::string& value) {
  _impl_.finalizers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta.finalizers)
}
inline void ObjectMeta::add_finalizers(std::string&& value) {
  _impl_.finalizers_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta.finalizers)
}
inline void ObjectMeta::add_finalizers(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.finalizers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta.finalizers)
}
inline void ObjectMeta::add_finalizers(const char* value, size_t size) {
  _impl_.finalizers_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta.finalizers)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ObjectMeta::finalizers() const {
  // @@protoc_insertion_point(field_list:k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta.finalizers)
  return _impl_.finalizers_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ObjectMeta::mutable_finalizers() {
  // @@protoc_insertion_point(field_mutable_list:k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta.finalizers)
  return &_impl_.finalizers_;
}

// repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry managedFields = 17;
inline int ObjectMeta::_internal_managedfields_size() const {
  return _impl_.managedfields_.size();
}
inline int ObjectMeta::managedfields_size() const {
  return _internal_managedfields_size();
}
inline void ObjectMeta::clear_managedfields() {
  _impl_.managedfields_.Clear();
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ManagedFieldsEntry* ObjectMeta::mutable_managedfields(int index) {
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta.managedFields)
  return _impl_.managedfields_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::k8s::io::apimachinery::pkg::apis::meta::v1::ManagedFieldsEntry >*
ObjectMeta::mutable_managedfields() {
  // @@protoc_insertion_point(field_mutable_list:k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta.managedFields)
  return &_impl_.managedfields_;
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ManagedFieldsEntry& ObjectMeta::_internal_managedfields(int index) const {
  return _impl_.managedfields_.Get(index);
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ManagedFieldsEntry& ObjectMeta::managedfields(int index) const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta.managedFields)
  return _internal_managedfields(index);
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ManagedFieldsEntry* ObjectMeta::_internal_add_managedfields() {
  return _impl_.managedfields_.Add();
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ManagedFieldsEntry* ObjectMeta::add_managedfields() {
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ManagedFieldsEntry* _add = _internal_add_managedfields();
  // @@protoc_insertion_point(field_add:k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta.managedFields)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::k8s::io::apimachinery::pkg::apis::meta::v1::ManagedFieldsEntry >&
ObjectMeta::managedfields() const {
  // @@protoc_insertion_point(field_list:k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta.managedFields)
  return _impl_.managedfields_;
}

// -------------------------------------------------------------------

// OwnerReference

// optional string apiVersion = 5;
inline bool OwnerReference::_internal_has_apiversion() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool OwnerReference::has_apiversion() const {
  return _internal_has_apiversion();
}
inline void OwnerReference::clear_apiversion() {
  _impl_.apiversion_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& OwnerReference::apiversion() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.OwnerReference.apiVersion)
  return _internal_apiversion();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OwnerReference::set_apiversion(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.apiversion_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.OwnerReference.apiVersion)
}
inline std::string* OwnerReference::mutable_apiversion() {
  std::string* _s = _internal_mutable_apiversion();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.OwnerReference.apiVersion)
  return _s;
}
inline const std::string& OwnerReference::_internal_apiversion() const {
  return _impl_.apiversion_.Get();
}
inline void OwnerReference::_internal_set_apiversion(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.apiversion_.Set(value, GetArenaForAllocation());
}
inline std::string* OwnerReference::_internal_mutable_apiversion() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.apiversion_.Mutable(GetArenaForAllocation());
}
inline std::string* OwnerReference::release_apiversion() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.OwnerReference.apiVersion)
  if (!_internal_has_apiversion()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.apiversion_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.apiversion_.IsDefault()) {
    _impl_.apiversion_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void OwnerReference::set_allocated_apiversion(std::string* apiversion) {
  if (apiversion != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.apiversion_.SetAllocated(apiversion, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.apiversion_.IsDefault()) {
    _impl_.apiversion_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.OwnerReference.apiVersion)
}

// optional string kind = 1;
inline bool OwnerReference::_internal_has_kind() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool OwnerReference::has_kind() const {
  return _internal_has_kind();
}
inline void OwnerReference::clear_kind() {
  _impl_.kind_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& OwnerReference::kind() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.OwnerReference.kind)
  return _internal_kind();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OwnerReference::set_kind(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.kind_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.OwnerReference.kind)
}
inline std::string* OwnerReference::mutable_kind() {
  std::string* _s = _internal_mutable_kind();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.OwnerReference.kind)
  return _s;
}
inline const std::string& OwnerReference::_internal_kind() const {
  return _impl_.kind_.Get();
}
inline void OwnerReference::_internal_set_kind(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.kind_.Set(value, GetArenaForAllocation());
}
inline std::string* OwnerReference::_internal_mutable_kind() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.kind_.Mutable(GetArenaForAllocation());
}
inline std::string* OwnerReference::release_kind() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.OwnerReference.kind)
  if (!_internal_has_kind()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.kind_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.kind_.IsDefault()) {
    _impl_.kind_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void OwnerReference::set_allocated_kind(std::string* kind) {
  if (kind != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.kind_.SetAllocated(kind, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.kind_.IsDefault()) {
    _impl_.kind_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.OwnerReference.kind)
}

// optional string name = 3;
inline bool OwnerReference::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool OwnerReference::has_name() const {
  return _internal_has_name();
}
inline void OwnerReference::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& OwnerReference::name() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.OwnerReference.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OwnerReference::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.OwnerReference.name)
}
inline std::string* OwnerReference::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.OwnerReference.name)
  return _s;
}
inline const std::string& OwnerReference::_internal_name() const {
  return _impl_.name_.Get();
}
inline void OwnerReference::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* OwnerReference::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* OwnerReference::release_name() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.OwnerReference.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void OwnerReference::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.OwnerReference.name)
}

// optional string uid = 4;
inline bool OwnerReference::_internal_has_uid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool OwnerReference::has_uid() const {
  return _internal_has_uid();
}
inline void OwnerReference::clear_uid() {
  _impl_.uid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& OwnerReference::uid() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.OwnerReference.uid)
  return _internal_uid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OwnerReference::set_uid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.uid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.OwnerReference.uid)
}
inline std::string* OwnerReference::mutable_uid() {
  std::string* _s = _internal_mutable_uid();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.OwnerReference.uid)
  return _s;
}
inline const std::string& OwnerReference::_internal_uid() const {
  return _impl_.uid_.Get();
}
inline void OwnerReference::_internal_set_uid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.uid_.Set(value, GetArenaForAllocation());
}
inline std::string* OwnerReference::_internal_mutable_uid() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.uid_.Mutable(GetArenaForAllocation());
}
inline std::string* OwnerReference::release_uid() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.OwnerReference.uid)
  if (!_internal_has_uid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.uid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uid_.IsDefault()) {
    _impl_.uid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void OwnerReference::set_allocated_uid(std::string* uid) {
  if (uid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.uid_.SetAllocated(uid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uid_.IsDefault()) {
    _impl_.uid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.OwnerReference.uid)
}

// optional bool controller = 6;
inline bool OwnerReference::_internal_has_controller() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool OwnerReference::has_controller() const {
  return _internal_has_controller();
}
inline void OwnerReference::clear_controller() {
  _impl_.controller_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool OwnerReference::_internal_controller() const {
  return _impl_.controller_;
}
inline bool OwnerReference::controller() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.OwnerReference.controller)
  return _internal_controller();
}
inline void OwnerReference::_internal_set_controller(bool value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.controller_ = value;
}
inline void OwnerReference::set_controller(bool value) {
  _internal_set_controller(value);
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.OwnerReference.controller)
}

// optional bool blockOwnerDeletion = 7;
inline bool OwnerReference::_internal_has_blockownerdeletion() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool OwnerReference::has_blockownerdeletion() const {
  return _internal_has_blockownerdeletion();
}
inline void OwnerReference::clear_blockownerdeletion() {
  _impl_.blockownerdeletion_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool OwnerReference::_internal_blockownerdeletion() const {
  return _impl_.blockownerdeletion_;
}
inline bool OwnerReference::blockownerdeletion() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.OwnerReference.blockOwnerDeletion)
  return _internal_blockownerdeletion();
}
inline void OwnerReference::_internal_set_blockownerdeletion(bool value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.blockownerdeletion_ = value;
}
inline void OwnerReference::set_blockownerdeletion(bool value) {
  _internal_set_blockownerdeletion(value);
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.OwnerReference.blockOwnerDeletion)
}

// -------------------------------------------------------------------

// PartialObjectMetadata

// optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
inline bool PartialObjectMetadata::_internal_has_metadata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.metadata_ != nullptr);
  return value;
}
inline bool PartialObjectMetadata::has_metadata() const {
  return _internal_has_metadata();
}
inline void PartialObjectMetadata::clear_metadata() {
  if (_impl_.metadata_ != nullptr) _impl_.metadata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& PartialObjectMetadata::_internal_metadata() const {
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* p = _impl_.metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta&>(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::_ObjectMeta_default_instance_);
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta& PartialObjectMetadata::metadata() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.PartialObjectMetadata.metadata)
  return _internal_metadata();
}
inline void PartialObjectMetadata::unsafe_arena_set_allocated_metadata(
    ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  _impl_.metadata_ = metadata;
  if (metadata) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.PartialObjectMetadata.metadata)
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* PartialObjectMetadata::release_metadata() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* PartialObjectMetadata::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.PartialObjectMetadata.metadata)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* PartialObjectMetadata::_internal_mutable_metadata() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta>(GetArenaForAllocation());
    _impl_.metadata_ = p;
  }
  return _impl_.metadata_;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* PartialObjectMetadata::mutable_metadata() {
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.PartialObjectMetadata.metadata)
  return _msg;
}
inline void PartialObjectMetadata::set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ObjectMeta* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.metadata_;
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(metadata);
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.PartialObjectMetadata.metadata)
}

// -------------------------------------------------------------------

// PartialObjectMetadataList

// optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
inline bool PartialObjectMetadataList::_internal_has_metadata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.metadata_ != nullptr);
  return value;
}
inline bool PartialObjectMetadataList::has_metadata() const {
  return _internal_has_metadata();
}
inline void PartialObjectMetadataList::clear_metadata() {
  if (_impl_.metadata_ != nullptr) _impl_.metadata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& PartialObjectMetadataList::_internal_metadata() const {
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* p = _impl_.metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta&>(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::_ListMeta_default_instance_);
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& PartialObjectMetadataList::metadata() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.PartialObjectMetadataList.metadata)
  return _internal_metadata();
}
inline void PartialObjectMetadataList::unsafe_arena_set_allocated_metadata(
    ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  _impl_.metadata_ = metadata;
  if (metadata) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.PartialObjectMetadataList.metadata)
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* PartialObjectMetadataList::release_metadata() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* PartialObjectMetadataList::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.PartialObjectMetadataList.metadata)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* PartialObjectMetadataList::_internal_mutable_metadata() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta>(GetArenaForAllocation());
    _impl_.metadata_ = p;
  }
  return _impl_.metadata_;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* PartialObjectMetadataList::mutable_metadata() {
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.PartialObjectMetadataList.metadata)
  return _msg;
}
inline void PartialObjectMetadataList::set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.metadata_;
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(metadata);
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.PartialObjectMetadataList.metadata)
}

// repeated .k8s.io.apimachinery.pkg.apis.meta.v1.PartialObjectMetadata items = 2;
inline int PartialObjectMetadataList::_internal_items_size() const {
  return _impl_.items_.size();
}
inline int PartialObjectMetadataList::items_size() const {
  return _internal_items_size();
}
inline void PartialObjectMetadataList::clear_items() {
  _impl_.items_.Clear();
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::PartialObjectMetadata* PartialObjectMetadataList::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.PartialObjectMetadataList.items)
  return _impl_.items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::k8s::io::apimachinery::pkg::apis::meta::v1::PartialObjectMetadata >*
PartialObjectMetadataList::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:k8s.io.apimachinery.pkg.apis.meta.v1.PartialObjectMetadataList.items)
  return &_impl_.items_;
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::PartialObjectMetadata& PartialObjectMetadataList::_internal_items(int index) const {
  return _impl_.items_.Get(index);
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::PartialObjectMetadata& PartialObjectMetadataList::items(int index) const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.PartialObjectMetadataList.items)
  return _internal_items(index);
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::PartialObjectMetadata* PartialObjectMetadataList::_internal_add_items() {
  return _impl_.items_.Add();
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::PartialObjectMetadata* PartialObjectMetadataList::add_items() {
  ::k8s::io::apimachinery::pkg::apis::meta::v1::PartialObjectMetadata* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:k8s.io.apimachinery.pkg.apis.meta.v1.PartialObjectMetadataList.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::k8s::io::apimachinery::pkg::apis::meta::v1::PartialObjectMetadata >&
PartialObjectMetadataList::items() const {
  // @@protoc_insertion_point(field_list:k8s.io.apimachinery.pkg.apis.meta.v1.PartialObjectMetadataList.items)
  return _impl_.items_;
}

// -------------------------------------------------------------------

// Patch

// -------------------------------------------------------------------

// PatchOptions

// repeated string dryRun = 1;
inline int PatchOptions::_internal_dryrun_size() const {
  return _impl_.dryrun_.size();
}
inline int PatchOptions::dryrun_size() const {
  return _internal_dryrun_size();
}
inline void PatchOptions::clear_dryrun() {
  _impl_.dryrun_.Clear();
}
inline std::string* PatchOptions::add_dryrun() {
  std::string* _s = _internal_add_dryrun();
  // @@protoc_insertion_point(field_add_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.PatchOptions.dryRun)
  return _s;
}
inline const std::string& PatchOptions::_internal_dryrun(int index) const {
  return _impl_.dryrun_.Get(index);
}
inline const std::string& PatchOptions::dryrun(int index) const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.PatchOptions.dryRun)
  return _internal_dryrun(index);
}
inline std::string* PatchOptions::mutable_dryrun(int index) {
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.PatchOptions.dryRun)
  return _impl_.dryrun_.Mutable(index);
}
inline void PatchOptions::set_dryrun(int index, const std::string& value) {
  _impl_.dryrun_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.PatchOptions.dryRun)
}
inline void PatchOptions::set_dryrun(int index, std::string&& value) {
  _impl_.dryrun_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.PatchOptions.dryRun)
}
inline void PatchOptions::set_dryrun(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.dryrun_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:k8s.io.apimachinery.pkg.apis.meta.v1.PatchOptions.dryRun)
}
inline void PatchOptions::set_dryrun(int index, const char* value, size_t size) {
  _impl_.dryrun_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:k8s.io.apimachinery.pkg.apis.meta.v1.PatchOptions.dryRun)
}
inline std::string* PatchOptions::_internal_add_dryrun() {
  return _impl_.dryrun_.Add();
}
inline void PatchOptions::add_dryrun(const std::string& value) {
  _impl_.dryrun_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:k8s.io.apimachinery.pkg.apis.meta.v1.PatchOptions.dryRun)
}
inline void PatchOptions::add_dryrun(std::string&& value) {
  _impl_.dryrun_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:k8s.io.apimachinery.pkg.apis.meta.v1.PatchOptions.dryRun)
}
inline void PatchOptions::add_dryrun(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.dryrun_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:k8s.io.apimachinery.pkg.apis.meta.v1.PatchOptions.dryRun)
}
inline void PatchOptions::add_dryrun(const char* value, size_t size) {
  _impl_.dryrun_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:k8s.io.apimachinery.pkg.apis.meta.v1.PatchOptions.dryRun)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
PatchOptions::dryrun() const {
  // @@protoc_insertion_point(field_list:k8s.io.apimachinery.pkg.apis.meta.v1.PatchOptions.dryRun)
  return _impl_.dryrun_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
PatchOptions::mutable_dryrun() {
  // @@protoc_insertion_point(field_mutable_list:k8s.io.apimachinery.pkg.apis.meta.v1.PatchOptions.dryRun)
  return &_impl_.dryrun_;
}

// optional bool force = 2;
inline bool PatchOptions::_internal_has_force() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PatchOptions::has_force() const {
  return _internal_has_force();
}
inline void PatchOptions::clear_force() {
  _impl_.force_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool PatchOptions::_internal_force() const {
  return _impl_.force_;
}
inline bool PatchOptions::force() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.PatchOptions.force)
  return _internal_force();
}
inline void PatchOptions::_internal_set_force(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.force_ = value;
}
inline void PatchOptions::set_force(bool value) {
  _internal_set_force(value);
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.PatchOptions.force)
}

// optional string fieldManager = 3;
inline bool PatchOptions::_internal_has_fieldmanager() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PatchOptions::has_fieldmanager() const {
  return _internal_has_fieldmanager();
}
inline void PatchOptions::clear_fieldmanager() {
  _impl_.fieldmanager_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PatchOptions::fieldmanager() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.PatchOptions.fieldManager)
  return _internal_fieldmanager();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PatchOptions::set_fieldmanager(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.fieldmanager_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.PatchOptions.fieldManager)
}
inline std::string* PatchOptions::mutable_fieldmanager() {
  std::string* _s = _internal_mutable_fieldmanager();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.PatchOptions.fieldManager)
  return _s;
}
inline const std::string& PatchOptions::_internal_fieldmanager() const {
  return _impl_.fieldmanager_.Get();
}
inline void PatchOptions::_internal_set_fieldmanager(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.fieldmanager_.Set(value, GetArenaForAllocation());
}
inline std::string* PatchOptions::_internal_mutable_fieldmanager() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.fieldmanager_.Mutable(GetArenaForAllocation());
}
inline std::string* PatchOptions::release_fieldmanager() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.PatchOptions.fieldManager)
  if (!_internal_has_fieldmanager()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.fieldmanager_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fieldmanager_.IsDefault()) {
    _impl_.fieldmanager_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PatchOptions::set_allocated_fieldmanager(std::string* fieldmanager) {
  if (fieldmanager != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.fieldmanager_.SetAllocated(fieldmanager, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fieldmanager_.IsDefault()) {
    _impl_.fieldmanager_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.PatchOptions.fieldManager)
}

// optional string fieldValidation = 4;
inline bool PatchOptions::_internal_has_fieldvalidation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PatchOptions::has_fieldvalidation() const {
  return _internal_has_fieldvalidation();
}
inline void PatchOptions::clear_fieldvalidation() {
  _impl_.fieldvalidation_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PatchOptions::fieldvalidation() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.PatchOptions.fieldValidation)
  return _internal_fieldvalidation();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PatchOptions::set_fieldvalidation(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.fieldvalidation_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.PatchOptions.fieldValidation)
}
inline std::string* PatchOptions::mutable_fieldvalidation() {
  std::string* _s = _internal_mutable_fieldvalidation();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.PatchOptions.fieldValidation)
  return _s;
}
inline const std::string& PatchOptions::_internal_fieldvalidation() const {
  return _impl_.fieldvalidation_.Get();
}
inline void PatchOptions::_internal_set_fieldvalidation(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.fieldvalidation_.Set(value, GetArenaForAllocation());
}
inline std::string* PatchOptions::_internal_mutable_fieldvalidation() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.fieldvalidation_.Mutable(GetArenaForAllocation());
}
inline std::string* PatchOptions::release_fieldvalidation() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.PatchOptions.fieldValidation)
  if (!_internal_has_fieldvalidation()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.fieldvalidation_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fieldvalidation_.IsDefault()) {
    _impl_.fieldvalidation_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PatchOptions::set_allocated_fieldvalidation(std::string* fieldvalidation) {
  if (fieldvalidation != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.fieldvalidation_.SetAllocated(fieldvalidation, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fieldvalidation_.IsDefault()) {
    _impl_.fieldvalidation_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.PatchOptions.fieldValidation)
}

// -------------------------------------------------------------------

// Preconditions

// optional string uid = 1;
inline bool Preconditions::_internal_has_uid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Preconditions::has_uid() const {
  return _internal_has_uid();
}
inline void Preconditions::clear_uid() {
  _impl_.uid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Preconditions::uid() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.Preconditions.uid)
  return _internal_uid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Preconditions::set_uid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.uid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.Preconditions.uid)
}
inline std::string* Preconditions::mutable_uid() {
  std::string* _s = _internal_mutable_uid();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.Preconditions.uid)
  return _s;
}
inline const std::string& Preconditions::_internal_uid() const {
  return _impl_.uid_.Get();
}
inline void Preconditions::_internal_set_uid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.uid_.Set(value, GetArenaForAllocation());
}
inline std::string* Preconditions::_internal_mutable_uid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.uid_.Mutable(GetArenaForAllocation());
}
inline std::string* Preconditions::release_uid() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.Preconditions.uid)
  if (!_internal_has_uid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.uid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uid_.IsDefault()) {
    _impl_.uid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Preconditions::set_allocated_uid(std::string* uid) {
  if (uid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.uid_.SetAllocated(uid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uid_.IsDefault()) {
    _impl_.uid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.Preconditions.uid)
}

// optional string resourceVersion = 2;
inline bool Preconditions::_internal_has_resourceversion() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Preconditions::has_resourceversion() const {
  return _internal_has_resourceversion();
}
inline void Preconditions::clear_resourceversion() {
  _impl_.resourceversion_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Preconditions::resourceversion() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.Preconditions.resourceVersion)
  return _internal_resourceversion();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Preconditions::set_resourceversion(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.resourceversion_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.Preconditions.resourceVersion)
}
inline std::string* Preconditions::mutable_resourceversion() {
  std::string* _s = _internal_mutable_resourceversion();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.Preconditions.resourceVersion)
  return _s;
}
inline const std::string& Preconditions::_internal_resourceversion() const {
  return _impl_.resourceversion_.Get();
}
inline void Preconditions::_internal_set_resourceversion(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.resourceversion_.Set(value, GetArenaForAllocation());
}
inline std::string* Preconditions::_internal_mutable_resourceversion() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.resourceversion_.Mutable(GetArenaForAllocation());
}
inline std::string* Preconditions::release_resourceversion() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.Preconditions.resourceVersion)
  if (!_internal_has_resourceversion()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.resourceversion_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.resourceversion_.IsDefault()) {
    _impl_.resourceversion_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Preconditions::set_allocated_resourceversion(std::string* resourceversion) {
  if (resourceversion != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.resourceversion_.SetAllocated(resourceversion, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.resourceversion_.IsDefault()) {
    _impl_.resourceversion_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.Preconditions.resourceVersion)
}

// -------------------------------------------------------------------

// RootPaths

// repeated string paths = 1;
inline int RootPaths::_internal_paths_size() const {
  return _impl_.paths_.size();
}
inline int RootPaths::paths_size() const {
  return _internal_paths_size();
}
inline void RootPaths::clear_paths() {
  _impl_.paths_.Clear();
}
inline std::string* RootPaths::add_paths() {
  std::string* _s = _internal_add_paths();
  // @@protoc_insertion_point(field_add_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.RootPaths.paths)
  return _s;
}
inline const std::string& RootPaths::_internal_paths(int index) const {
  return _impl_.paths_.Get(index);
}
inline const std::string& RootPaths::paths(int index) const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.RootPaths.paths)
  return _internal_paths(index);
}
inline std::string* RootPaths::mutable_paths(int index) {
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.RootPaths.paths)
  return _impl_.paths_.Mutable(index);
}
inline void RootPaths::set_paths(int index, const std::string& value) {
  _impl_.paths_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.RootPaths.paths)
}
inline void RootPaths::set_paths(int index, std::string&& value) {
  _impl_.paths_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.RootPaths.paths)
}
inline void RootPaths::set_paths(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.paths_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:k8s.io.apimachinery.pkg.apis.meta.v1.RootPaths.paths)
}
inline void RootPaths::set_paths(int index, const char* value, size_t size) {
  _impl_.paths_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:k8s.io.apimachinery.pkg.apis.meta.v1.RootPaths.paths)
}
inline std::string* RootPaths::_internal_add_paths() {
  return _impl_.paths_.Add();
}
inline void RootPaths::add_paths(const std::string& value) {
  _impl_.paths_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:k8s.io.apimachinery.pkg.apis.meta.v1.RootPaths.paths)
}
inline void RootPaths::add_paths(std::string&& value) {
  _impl_.paths_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:k8s.io.apimachinery.pkg.apis.meta.v1.RootPaths.paths)
}
inline void RootPaths::add_paths(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.paths_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:k8s.io.apimachinery.pkg.apis.meta.v1.RootPaths.paths)
}
inline void RootPaths::add_paths(const char* value, size_t size) {
  _impl_.paths_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:k8s.io.apimachinery.pkg.apis.meta.v1.RootPaths.paths)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
RootPaths::paths() const {
  // @@protoc_insertion_point(field_list:k8s.io.apimachinery.pkg.apis.meta.v1.RootPaths.paths)
  return _impl_.paths_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
RootPaths::mutable_paths() {
  // @@protoc_insertion_point(field_mutable_list:k8s.io.apimachinery.pkg.apis.meta.v1.RootPaths.paths)
  return &_impl_.paths_;
}

// -------------------------------------------------------------------

// ServerAddressByClientCIDR

// optional string clientCIDR = 1;
inline bool ServerAddressByClientCIDR::_internal_has_clientcidr() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ServerAddressByClientCIDR::has_clientcidr() const {
  return _internal_has_clientcidr();
}
inline void ServerAddressByClientCIDR::clear_clientcidr() {
  _impl_.clientcidr_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ServerAddressByClientCIDR::clientcidr() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR.clientCIDR)
  return _internal_clientcidr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServerAddressByClientCIDR::set_clientcidr(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.clientcidr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR.clientCIDR)
}
inline std::string* ServerAddressByClientCIDR::mutable_clientcidr() {
  std::string* _s = _internal_mutable_clientcidr();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR.clientCIDR)
  return _s;
}
inline const std::string& ServerAddressByClientCIDR::_internal_clientcidr() const {
  return _impl_.clientcidr_.Get();
}
inline void ServerAddressByClientCIDR::_internal_set_clientcidr(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.clientcidr_.Set(value, GetArenaForAllocation());
}
inline std::string* ServerAddressByClientCIDR::_internal_mutable_clientcidr() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.clientcidr_.Mutable(GetArenaForAllocation());
}
inline std::string* ServerAddressByClientCIDR::release_clientcidr() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR.clientCIDR)
  if (!_internal_has_clientcidr()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.clientcidr_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.clientcidr_.IsDefault()) {
    _impl_.clientcidr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ServerAddressByClientCIDR::set_allocated_clientcidr(std::string* clientcidr) {
  if (clientcidr != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.clientcidr_.SetAllocated(clientcidr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.clientcidr_.IsDefault()) {
    _impl_.clientcidr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR.clientCIDR)
}

// optional string serverAddress = 2;
inline bool ServerAddressByClientCIDR::_internal_has_serveraddress() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ServerAddressByClientCIDR::has_serveraddress() const {
  return _internal_has_serveraddress();
}
inline void ServerAddressByClientCIDR::clear_serveraddress() {
  _impl_.serveraddress_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ServerAddressByClientCIDR::serveraddress() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR.serverAddress)
  return _internal_serveraddress();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServerAddressByClientCIDR::set_serveraddress(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.serveraddress_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR.serverAddress)
}
inline std::string* ServerAddressByClientCIDR::mutable_serveraddress() {
  std::string* _s = _internal_mutable_serveraddress();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR.serverAddress)
  return _s;
}
inline const std::string& ServerAddressByClientCIDR::_internal_serveraddress() const {
  return _impl_.serveraddress_.Get();
}
inline void ServerAddressByClientCIDR::_internal_set_serveraddress(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.serveraddress_.Set(value, GetArenaForAllocation());
}
inline std::string* ServerAddressByClientCIDR::_internal_mutable_serveraddress() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.serveraddress_.Mutable(GetArenaForAllocation());
}
inline std::string* ServerAddressByClientCIDR::release_serveraddress() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR.serverAddress)
  if (!_internal_has_serveraddress()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.serveraddress_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.serveraddress_.IsDefault()) {
    _impl_.serveraddress_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ServerAddressByClientCIDR::set_allocated_serveraddress(std::string* serveraddress) {
  if (serveraddress != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.serveraddress_.SetAllocated(serveraddress, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.serveraddress_.IsDefault()) {
    _impl_.serveraddress_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR.serverAddress)
}

// -------------------------------------------------------------------

// Status

// optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
inline bool Status::_internal_has_metadata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.metadata_ != nullptr);
  return value;
}
inline bool Status::has_metadata() const {
  return _internal_has_metadata();
}
inline void Status::clear_metadata() {
  if (_impl_.metadata_ != nullptr) _impl_.metadata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& Status::_internal_metadata() const {
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* p = _impl_.metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta&>(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::_ListMeta_default_instance_);
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta& Status::metadata() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.Status.metadata)
  return _internal_metadata();
}
inline void Status::unsafe_arena_set_allocated_metadata(
    ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  _impl_.metadata_ = metadata;
  if (metadata) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.Status.metadata)
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* Status::release_metadata() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* Status::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.Status.metadata)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* Status::_internal_mutable_metadata() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta>(GetArenaForAllocation());
    _impl_.metadata_ = p;
  }
  return _impl_.metadata_;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* Status::mutable_metadata() {
  ::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.Status.metadata)
  return _msg;
}
inline void Status::set_allocated_metadata(::k8s::io::apimachinery::pkg::apis::meta::v1::ListMeta* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.metadata_;
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(metadata);
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.Status.metadata)
}

// optional string status = 2;
inline bool Status::_internal_has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Status::has_status() const {
  return _internal_has_status();
}
inline void Status::clear_status() {
  _impl_.status_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Status::status() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.Status.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Status::set_status(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.status_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.Status.status)
}
inline std::string* Status::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.Status.status)
  return _s;
}
inline const std::string& Status::_internal_status() const {
  return _impl_.status_.Get();
}
inline void Status::_internal_set_status(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.status_.Set(value, GetArenaForAllocation());
}
inline std::string* Status::_internal_mutable_status() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.status_.Mutable(GetArenaForAllocation());
}
inline std::string* Status::release_status() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.Status.status)
  if (!_internal_has_status()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.status_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.status_.IsDefault()) {
    _impl_.status_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Status::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.status_.SetAllocated(status, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.status_.IsDefault()) {
    _impl_.status_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.Status.status)
}

// optional string message = 3;
inline bool Status::_internal_has_message() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Status::has_message() const {
  return _internal_has_message();
}
inline void Status::clear_message() {
  _impl_.message_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Status::message() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.Status.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Status::set_message(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.Status.message)
}
inline std::string* Status::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.Status.message)
  return _s;
}
inline const std::string& Status::_internal_message() const {
  return _impl_.message_.Get();
}
inline void Status::_internal_set_message(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* Status::_internal_mutable_message() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* Status::release_message() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.Status.message)
  if (!_internal_has_message()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.message_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Status::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.Status.message)
}

// optional string reason = 4;
inline bool Status::_internal_has_reason() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Status::has_reason() const {
  return _internal_has_reason();
}
inline void Status::clear_reason() {
  _impl_.reason_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Status::reason() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.Status.reason)
  return _internal_reason();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Status::set_reason(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.reason_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.Status.reason)
}
inline std::string* Status::mutable_reason() {
  std::string* _s = _internal_mutable_reason();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.Status.reason)
  return _s;
}
inline const std::string& Status::_internal_reason() const {
  return _impl_.reason_.Get();
}
inline void Status::_internal_set_reason(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.reason_.Set(value, GetArenaForAllocation());
}
inline std::string* Status::_internal_mutable_reason() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.reason_.Mutable(GetArenaForAllocation());
}
inline std::string* Status::release_reason() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.Status.reason)
  if (!_internal_has_reason()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.reason_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.reason_.IsDefault()) {
    _impl_.reason_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Status::set_allocated_reason(std::string* reason) {
  if (reason != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.reason_.SetAllocated(reason, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.reason_.IsDefault()) {
    _impl_.reason_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.Status.reason)
}

// optional .k8s.io.apimachinery.pkg.apis.meta.v1.StatusDetails details = 5;
inline bool Status::_internal_has_details() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.details_ != nullptr);
  return value;
}
inline bool Status::has_details() const {
  return _internal_has_details();
}
inline void Status::clear_details() {
  if (_impl_.details_ != nullptr) _impl_.details_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::StatusDetails& Status::_internal_details() const {
  const ::k8s::io::apimachinery::pkg::apis::meta::v1::StatusDetails* p = _impl_.details_;
  return p != nullptr ? *p : reinterpret_cast<const ::k8s::io::apimachinery::pkg::apis::meta::v1::StatusDetails&>(
      ::k8s::io::apimachinery::pkg::apis::meta::v1::_StatusDetails_default_instance_);
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::StatusDetails& Status::details() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.Status.details)
  return _internal_details();
}
inline void Status::unsafe_arena_set_allocated_details(
    ::k8s::io::apimachinery::pkg::apis::meta::v1::StatusDetails* details) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.details_);
  }
  _impl_.details_ = details;
  if (details) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.Status.details)
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::StatusDetails* Status::release_details() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::StatusDetails* temp = _impl_.details_;
  _impl_.details_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::StatusDetails* Status::unsafe_arena_release_details() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.Status.details)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::k8s::io::apimachinery::pkg::apis::meta::v1::StatusDetails* temp = _impl_.details_;
  _impl_.details_ = nullptr;
  return temp;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::StatusDetails* Status::_internal_mutable_details() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.details_ == nullptr) {
    auto* p = CreateMaybeMessage<::k8s::io::apimachinery::pkg::apis::meta::v1::StatusDetails>(GetArenaForAllocation());
    _impl_.details_ = p;
  }
  return _impl_.details_;
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::StatusDetails* Status::mutable_details() {
  ::k8s::io::apimachinery::pkg::apis::meta::v1::StatusDetails* _msg = _internal_mutable_details();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.Status.details)
  return _msg;
}
inline void Status::set_allocated_details(::k8s::io::apimachinery::pkg::apis::meta::v1::StatusDetails* details) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.details_;
  }
  if (details) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(details);
    if (message_arena != submessage_arena) {
      details = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, details, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.details_ = details;
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.Status.details)
}

// optional int32 code = 6;
inline bool Status::_internal_has_code() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Status::has_code() const {
  return _internal_has_code();
}
inline void Status::clear_code() {
  _impl_.code_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline int32_t Status::_internal_code() const {
  return _impl_.code_;
}
inline int32_t Status::code() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.Status.code)
  return _internal_code();
}
inline void Status::_internal_set_code(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.code_ = value;
}
inline void Status::set_code(int32_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.Status.code)
}

// -------------------------------------------------------------------

// StatusCause

// optional string reason = 1;
inline bool StatusCause::_internal_has_reason() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StatusCause::has_reason() const {
  return _internal_has_reason();
}
inline void StatusCause::clear_reason() {
  _impl_.reason_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StatusCause::reason() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.StatusCause.reason)
  return _internal_reason();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StatusCause::set_reason(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.reason_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.StatusCause.reason)
}
inline std::string* StatusCause::mutable_reason() {
  std::string* _s = _internal_mutable_reason();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.StatusCause.reason)
  return _s;
}
inline const std::string& StatusCause::_internal_reason() const {
  return _impl_.reason_.Get();
}
inline void StatusCause::_internal_set_reason(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.reason_.Set(value, GetArenaForAllocation());
}
inline std::string* StatusCause::_internal_mutable_reason() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.reason_.Mutable(GetArenaForAllocation());
}
inline std::string* StatusCause::release_reason() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.StatusCause.reason)
  if (!_internal_has_reason()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.reason_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.reason_.IsDefault()) {
    _impl_.reason_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StatusCause::set_allocated_reason(std::string* reason) {
  if (reason != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.reason_.SetAllocated(reason, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.reason_.IsDefault()) {
    _impl_.reason_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.StatusCause.reason)
}

// optional string message = 2;
inline bool StatusCause::_internal_has_message() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StatusCause::has_message() const {
  return _internal_has_message();
}
inline void StatusCause::clear_message() {
  _impl_.message_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& StatusCause::message() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.StatusCause.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StatusCause::set_message(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.StatusCause.message)
}
inline std::string* StatusCause::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.StatusCause.message)
  return _s;
}
inline const std::string& StatusCause::_internal_message() const {
  return _impl_.message_.Get();
}
inline void StatusCause::_internal_set_message(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* StatusCause::_internal_mutable_message() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* StatusCause::release_message() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.StatusCause.message)
  if (!_internal_has_message()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.message_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StatusCause::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.StatusCause.message)
}

// optional string field = 3;
inline bool StatusCause::_internal_has_field() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool StatusCause::has_field() const {
  return _internal_has_field();
}
inline void StatusCause::clear_field() {
  _impl_.field_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& StatusCause::field() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.StatusCause.field)
  return _internal_field();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StatusCause::set_field(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.field_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.StatusCause.field)
}
inline std::string* StatusCause::mutable_field() {
  std::string* _s = _internal_mutable_field();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.StatusCause.field)
  return _s;
}
inline const std::string& StatusCause::_internal_field() const {
  return _impl_.field_.Get();
}
inline void StatusCause::_internal_set_field(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.field_.Set(value, GetArenaForAllocation());
}
inline std::string* StatusCause::_internal_mutable_field() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.field_.Mutable(GetArenaForAllocation());
}
inline std::string* StatusCause::release_field() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.StatusCause.field)
  if (!_internal_has_field()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.field_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field_.IsDefault()) {
    _impl_.field_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StatusCause::set_allocated_field(std::string* field) {
  if (field != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.field_.SetAllocated(field, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field_.IsDefault()) {
    _impl_.field_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.StatusCause.field)
}

// -------------------------------------------------------------------

// StatusDetails

// optional string name = 1;
inline bool StatusDetails::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StatusDetails::has_name() const {
  return _internal_has_name();
}
inline void StatusDetails::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StatusDetails::name() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.StatusDetails.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StatusDetails::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.StatusDetails.name)
}
inline std::string* StatusDetails::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.StatusDetails.name)
  return _s;
}
inline const std::string& StatusDetails::_internal_name() const {
  return _impl_.name_.Get();
}
inline void StatusDetails::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* StatusDetails::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* StatusDetails::release_name() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.StatusDetails.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StatusDetails::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.StatusDetails.name)
}

// optional string group = 2;
inline bool StatusDetails::_internal_has_group() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StatusDetails::has_group() const {
  return _internal_has_group();
}
inline void StatusDetails::clear_group() {
  _impl_.group_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& StatusDetails::group() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.StatusDetails.group)
  return _internal_group();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StatusDetails::set_group(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.group_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.StatusDetails.group)
}
inline std::string* StatusDetails::mutable_group() {
  std::string* _s = _internal_mutable_group();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.StatusDetails.group)
  return _s;
}
inline const std::string& StatusDetails::_internal_group() const {
  return _impl_.group_.Get();
}
inline void StatusDetails::_internal_set_group(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.group_.Set(value, GetArenaForAllocation());
}
inline std::string* StatusDetails::_internal_mutable_group() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.group_.Mutable(GetArenaForAllocation());
}
inline std::string* StatusDetails::release_group() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.StatusDetails.group)
  if (!_internal_has_group()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.group_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.group_.IsDefault()) {
    _impl_.group_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StatusDetails::set_allocated_group(std::string* group) {
  if (group != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.group_.SetAllocated(group, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.group_.IsDefault()) {
    _impl_.group_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.StatusDetails.group)
}

// optional string kind = 3;
inline bool StatusDetails::_internal_has_kind() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool StatusDetails::has_kind() const {
  return _internal_has_kind();
}
inline void StatusDetails::clear_kind() {
  _impl_.kind_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& StatusDetails::kind() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.StatusDetails.kind)
  return _internal_kind();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StatusDetails::set_kind(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.kind_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.StatusDetails.kind)
}
inline std::string* StatusDetails::mutable_kind() {
  std::string* _s = _internal_mutable_kind();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.StatusDetails.kind)
  return _s;
}
inline const std::string& StatusDetails::_internal_kind() const {
  return _impl_.kind_.Get();
}
inline void StatusDetails::_internal_set_kind(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.kind_.Set(value, GetArenaForAllocation());
}
inline std::string* StatusDetails::_internal_mutable_kind() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.kind_.Mutable(GetArenaForAllocation());
}
inline std::string* StatusDetails::release_kind() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.StatusDetails.kind)
  if (!_internal_has_kind()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.kind_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.kind_.IsDefault()) {
    _impl_.kind_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StatusDetails::set_allocated_kind(std::string* kind) {
  if (kind != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.kind_.SetAllocated(kind, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.kind_.IsDefault()) {
    _impl_.kind_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.StatusDetails.kind)
}

// optional string uid = 6;
inline bool StatusDetails::_internal_has_uid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool StatusDetails::has_uid() const {
  return _internal_has_uid();
}
inline void StatusDetails::clear_uid() {
  _impl_.uid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& StatusDetails::uid() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.StatusDetails.uid)
  return _internal_uid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StatusDetails::set_uid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.uid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.StatusDetails.uid)
}
inline std::string* StatusDetails::mutable_uid() {
  std::string* _s = _internal_mutable_uid();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.StatusDetails.uid)
  return _s;
}
inline const std::string& StatusDetails::_internal_uid() const {
  return _impl_.uid_.Get();
}
inline void StatusDetails::_internal_set_uid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.uid_.Set(value, GetArenaForAllocation());
}
inline std::string* StatusDetails::_internal_mutable_uid() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.uid_.Mutable(GetArenaForAllocation());
}
inline std::string* StatusDetails::release_uid() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.StatusDetails.uid)
  if (!_internal_has_uid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.uid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uid_.IsDefault()) {
    _impl_.uid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StatusDetails::set_allocated_uid(std::string* uid) {
  if (uid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.uid_.SetAllocated(uid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uid_.IsDefault()) {
    _impl_.uid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.StatusDetails.uid)
}

// repeated .k8s.io.apimachinery.pkg.apis.meta.v1.StatusCause causes = 4;
inline int StatusDetails::_internal_causes_size() const {
  return _impl_.causes_.size();
}
inline int StatusDetails::causes_size() const {
  return _internal_causes_size();
}
inline void StatusDetails::clear_causes() {
  _impl_.causes_.Clear();
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::StatusCause* StatusDetails::mutable_causes(int index) {
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.StatusDetails.causes)
  return _impl_.causes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::k8s::io::apimachinery::pkg::apis::meta::v1::StatusCause >*
StatusDetails::mutable_causes() {
  // @@protoc_insertion_point(field_mutable_list:k8s.io.apimachinery.pkg.apis.meta.v1.StatusDetails.causes)
  return &_impl_.causes_;
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::StatusCause& StatusDetails::_internal_causes(int index) const {
  return _impl_.causes_.Get(index);
}
inline const ::k8s::io::apimachinery::pkg::apis::meta::v1::StatusCause& StatusDetails::causes(int index) const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.StatusDetails.causes)
  return _internal_causes(index);
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::StatusCause* StatusDetails::_internal_add_causes() {
  return _impl_.causes_.Add();
}
inline ::k8s::io::apimachinery::pkg::apis::meta::v1::StatusCause* StatusDetails::add_causes() {
  ::k8s::io::apimachinery::pkg::apis::meta::v1::StatusCause* _add = _internal_add_causes();
  // @@protoc_insertion_point(field_add:k8s.io.apimachinery.pkg.apis.meta.v1.StatusDetails.causes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::k8s::io::apimachinery::pkg::apis::meta::v1::StatusCause >&
StatusDetails::causes() const {
  // @@protoc_insertion_point(field_list:k8s.io.apimachinery.pkg.apis.meta.v1.StatusDetails.causes)
  return _impl_.causes_;
}

// optional int32 retryAfterSeconds = 5;
inline bool StatusDetails::_internal_has_retryafterseconds() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool StatusDetails::has_retryafterseconds() const {
  return _internal_has_retryafterseconds();
}
inline void StatusDetails::clear_retryafterseconds() {
  _impl_.retryafterseconds_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t StatusDetails::_internal_retryafterseconds() const {
  return _impl_.retryafterseconds_;
}
inline int32_t StatusDetails::retryafterseconds() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.StatusDetails.retryAfterSeconds)
  return _internal_retryafterseconds();
}
inline void StatusDetails::_internal_set_retryafterseconds(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.retryafterseconds_ = value;
}
inline void StatusDetails::set_retryafterseconds(int32_t value) {
  _internal_set_retryafterseconds(value);
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.StatusDetails.retryAfterSeconds)
}

// -------------------------------------------------------------------

// TableOptions

// optional string includeObject = 1;
inline bool TableOptions::_internal_has_includeobject() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TableOptions::has_includeobject() const {
  return _internal_has_includeobject();
}
inline void TableOptions::clear_includeobject() {
  _impl_.includeobject_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TableOptions::includeobject() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.TableOptions.includeObject)
  return _internal_includeobject();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TableOptions::set_includeobject(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.includeobject_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.TableOptions.includeObject)
}
inline std::string* TableOptions::mutable_includeobject() {
  std::string* _s = _internal_mutable_includeobject();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.TableOptions.includeObject)
  return _s;
}
inline const std::string& TableOptions::_internal_includeobject() const {
  return _impl_.includeobject_.Get();
}
inline void TableOptions::_internal_set_includeobject(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.includeobject_.Set(value, GetArenaForAllocation());
}
inline std::string* TableOptions::_internal_mutable_includeobject() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.includeobject_.Mutable(GetArenaForAllocation());
}
inline std::string* TableOptions::release_includeobject() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.TableOptions.includeObject)
  if (!_internal_has_includeobject()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.includeobject_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.includeobject_.IsDefault()) {
    _impl_.includeobject_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TableOptions::set_allocated_includeobject(std::string* includeobject) {
  if (includeobject != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.includeobject_.SetAllocated(includeobject, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.includeobject_.IsDefault()) {
    _impl_.includeobject_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.TableOptions.includeObject)
}

// -------------------------------------------------------------------

// Time

// optional int64 seconds = 1;
inline bool Time::_internal_has_seconds() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Time::has_seconds() const {
  return _internal_has_seconds();
}
inline void Time::clear_seconds() {
  _impl_.seconds_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t Time::_internal_seconds() const {
  return _impl_.seconds_;
}
inline int64_t Time::seconds() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.Time.seconds)
  return _internal_seconds();
}
inline void Time::_internal_set_seconds(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.seconds_ = value;
}
inline void Time::set_seconds(int64_t value) {
  _internal_set_seconds(value);
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.Time.seconds)
}

// optional int32 nanos = 2;
inline bool Time::_internal_has_nanos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Time::has_nanos() const {
  return _internal_has_nanos();
}
inline void Time::clear_nanos() {
  _impl_.nanos_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t Time::_internal_nanos() const {
  return _impl_.nanos_;
}
inline int32_t Time::nanos() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.Time.nanos)
  return _internal_nanos();
}
inline void Time::_internal_set_nanos(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.nanos_ = value;
}
inline void Time::set_nanos(int32_t value) {
  _internal_set_nanos(value);
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.Time.nanos)
}

// -------------------------------------------------------------------

// Timestamp

// optional int64 seconds = 1;
inline bool Timestamp::_internal_has_seconds() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Timestamp::has_seconds() const {
  return _internal_has_seconds();
}
inline void Timestamp::clear_seconds() {
  _impl_.seconds_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t Timestamp::_internal_seconds() const {
  return _impl_.seconds_;
}
inline int64_t Timestamp::seconds() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.Timestamp.seconds)
  return _internal_seconds();
}
inline void Timestamp::_internal_set_seconds(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.seconds_ = value;
}
inline void Timestamp::set_seconds(int64_t value) {
  _internal_set_seconds(value);
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.Timestamp.seconds)
}

// optional int32 nanos = 2;
inline bool Timestamp::_internal_has_nanos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Timestamp::has_nanos() const {
  return _internal_has_nanos();
}
inline void Timestamp::clear_nanos() {
  _impl_.nanos_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t Timestamp::_internal_nanos() const {
  return _impl_.nanos_;
}
inline int32_t Timestamp::nanos() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.Timestamp.nanos)
  return _internal_nanos();
}
inline void Timestamp::_internal_set_nanos(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.nanos_ = value;
}
inline void Timestamp::set_nanos(int32_t value) {
  _internal_set_nanos(value);
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.Timestamp.nanos)
}

// -------------------------------------------------------------------

// TypeMeta

// optional string kind = 1;
inline bool TypeMeta::_internal_has_kind() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TypeMeta::has_kind() const {
  return _internal_has_kind();
}
inline void TypeMeta::clear_kind() {
  _impl_.kind_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TypeMeta::kind() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta.kind)
  return _internal_kind();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TypeMeta::set_kind(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.kind_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta.kind)
}
inline std::string* TypeMeta::mutable_kind() {
  std::string* _s = _internal_mutable_kind();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta.kind)
  return _s;
}
inline const std::string& TypeMeta::_internal_kind() const {
  return _impl_.kind_.Get();
}
inline void TypeMeta::_internal_set_kind(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.kind_.Set(value, GetArenaForAllocation());
}
inline std::string* TypeMeta::_internal_mutable_kind() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.kind_.Mutable(GetArenaForAllocation());
}
inline std::string* TypeMeta::release_kind() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta.kind)
  if (!_internal_has_kind()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.kind_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.kind_.IsDefault()) {
    _impl_.kind_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TypeMeta::set_allocated_kind(std::string* kind) {
  if (kind != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.kind_.SetAllocated(kind, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.kind_.IsDefault()) {
    _impl_.kind_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta.kind)
}

// optional string apiVersion = 2;
inline bool TypeMeta::_internal_has_apiversion() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TypeMeta::has_apiversion() const {
  return _internal_has_apiversion();
}
inline void TypeMeta::clear_apiversion() {
  _impl_.apiversion_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TypeMeta::apiversion() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta.apiVersion)
  return _internal_apiversion();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TypeMeta::set_apiversion(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.apiversion_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta.apiVersion)
}
inline std::string* TypeMeta::mutable_apiversion() {
  std::string* _s = _internal_mutable_apiversion();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta.apiVersion)
  return _s;
}
inline const std::string& TypeMeta::_internal_apiversion() const {
  return _impl_.apiversion_.Get();
}
inline void TypeMeta::_internal_set_apiversion(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.apiversion_.Set(value, GetArenaForAllocation());
}
inline std::string* TypeMeta::_internal_mutable_apiversion() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.apiversion_.Mutable(GetArenaForAllocation());
}
inline std::string* TypeMeta::release_apiversion() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta.apiVersion)
  if (!_internal_has_apiversion()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.apiversion_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.apiversion_.IsDefault()) {
    _impl_.apiversion_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TypeMeta::set_allocated_apiversion(std::string* apiversion) {
  if (apiversion != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.apiversion_.SetAllocated(apiversion, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.apiversion_.IsDefault()) {
    _impl_.apiversion_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta.apiVersion)
}

// -------------------------------------------------------------------

// UpdateOptions

// repeated string dryRun = 1;
inline int UpdateOptions::_internal_dryrun_size() const {
  return _impl_.dryrun_.size();
}
inline int UpdateOptions::dryrun_size() const {
  return _internal_dryrun_size();
}
inline void UpdateOptions::clear_dryrun() {
  _impl_.dryrun_.Clear();
}
inline std::string* UpdateOptions::add_dryrun() {
  std::string* _s = _internal_add_dryrun();
  // @@protoc_insertion_point(field_add_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.UpdateOptions.dryRun)
  return _s;
}
inline const std::string& UpdateOptions::_internal_dryrun(int index) const {
  return _impl_.dryrun_.Get(index);
}
inline const std::string& UpdateOptions::dryrun(int index) const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.UpdateOptions.dryRun)
  return _internal_dryrun(index);
}
inline std::string* UpdateOptions::mutable_dryrun(int index) {
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.UpdateOptions.dryRun)
  return _impl_.dryrun_.Mutable(index);
}
inline void UpdateOptions::set_dryrun(int index, const std::string& value) {
  _impl_.dryrun_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.UpdateOptions.dryRun)
}
inline void UpdateOptions::set_dryrun(int index, std::string&& value) {
  _impl_.dryrun_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.UpdateOptions.dryRun)
}
inline void UpdateOptions::set_dryrun(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.dryrun_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:k8s.io.apimachinery.pkg.apis.meta.v1.UpdateOptions.dryRun)
}
inline void UpdateOptions::set_dryrun(int index, const char* value, size_t size) {
  _impl_.dryrun_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:k8s.io.apimachinery.pkg.apis.meta.v1.UpdateOptions.dryRun)
}
inline std::string* UpdateOptions::_internal_add_dryrun() {
  return _impl_.dryrun_.Add();
}
inline void UpdateOptions::add_dryrun(const std::string& value) {
  _impl_.dryrun_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:k8s.io.apimachinery.pkg.apis.meta.v1.UpdateOptions.dryRun)
}
inline void UpdateOptions::add_dryrun(std::string&& value) {
  _impl_.dryrun_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:k8s.io.apimachinery.pkg.apis.meta.v1.UpdateOptions.dryRun)
}
inline void UpdateOptions::add_dryrun(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.dryrun_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:k8s.io.apimachinery.pkg.apis.meta.v1.UpdateOptions.dryRun)
}
inline void UpdateOptions::add_dryrun(const char* value, size_t size) {
  _impl_.dryrun_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:k8s.io.apimachinery.pkg.apis.meta.v1.UpdateOptions.dryRun)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
UpdateOptions::dryrun() const {
  // @@protoc_insertion_point(field_list:k8s.io.apimachinery.pkg.apis.meta.v1.UpdateOptions.dryRun)
  return _impl_.dryrun_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
UpdateOptions::mutable_dryrun() {
  // @@protoc_insertion_point(field_mutable_list:k8s.io.apimachinery.pkg.apis.meta.v1.UpdateOptions.dryRun)
  return &_impl_.dryrun_;
}

// optional string fieldManager = 2;
inline bool UpdateOptions::_internal_has_fieldmanager() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UpdateOptions::has_fieldmanager() const {
  return _internal_has_fieldmanager();
}
inline void UpdateOptions::clear_fieldmanager() {
  _impl_.fieldmanager_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UpdateOptions::fieldmanager() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.UpdateOptions.fieldManager)
  return _internal_fieldmanager();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateOptions::set_fieldmanager(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.fieldmanager_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.UpdateOptions.fieldManager)
}
inline std::string* UpdateOptions::mutable_fieldmanager() {
  std::string* _s = _internal_mutable_fieldmanager();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.UpdateOptions.fieldManager)
  return _s;
}
inline const std::string& UpdateOptions::_internal_fieldmanager() const {
  return _impl_.fieldmanager_.Get();
}
inline void UpdateOptions::_internal_set_fieldmanager(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.fieldmanager_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateOptions::_internal_mutable_fieldmanager() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.fieldmanager_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateOptions::release_fieldmanager() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.UpdateOptions.fieldManager)
  if (!_internal_has_fieldmanager()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.fieldmanager_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fieldmanager_.IsDefault()) {
    _impl_.fieldmanager_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UpdateOptions::set_allocated_fieldmanager(std::string* fieldmanager) {
  if (fieldmanager != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.fieldmanager_.SetAllocated(fieldmanager, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fieldmanager_.IsDefault()) {
    _impl_.fieldmanager_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.UpdateOptions.fieldManager)
}

// optional string fieldValidation = 3;
inline bool UpdateOptions::_internal_has_fieldvalidation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UpdateOptions::has_fieldvalidation() const {
  return _internal_has_fieldvalidation();
}
inline void UpdateOptions::clear_fieldvalidation() {
  _impl_.fieldvalidation_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& UpdateOptions::fieldvalidation() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.UpdateOptions.fieldValidation)
  return _internal_fieldvalidation();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateOptions::set_fieldvalidation(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.fieldvalidation_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.UpdateOptions.fieldValidation)
}
inline std::string* UpdateOptions::mutable_fieldvalidation() {
  std::string* _s = _internal_mutable_fieldvalidation();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.UpdateOptions.fieldValidation)
  return _s;
}
inline const std::string& UpdateOptions::_internal_fieldvalidation() const {
  return _impl_.fieldvalidation_.Get();
}
inline void UpdateOptions::_internal_set_fieldvalidation(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.fieldvalidation_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateOptions::_internal_mutable_fieldvalidation() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.fieldvalidation_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateOptions::release_fieldvalidation() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.UpdateOptions.fieldValidation)
  if (!_internal_has_fieldvalidation()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.fieldvalidation_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fieldvalidation_.IsDefault()) {
    _impl_.fieldvalidation_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UpdateOptions::set_allocated_fieldvalidation(std::string* fieldvalidation) {
  if (fieldvalidation != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.fieldvalidation_.SetAllocated(fieldvalidation, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fieldvalidation_.IsDefault()) {
    _impl_.fieldvalidation_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.UpdateOptions.fieldValidation)
}

// -------------------------------------------------------------------

// Verbs

// repeated string items = 1;
inline int Verbs::_internal_items_size() const {
  return _impl_.items_.size();
}
inline int Verbs::items_size() const {
  return _internal_items_size();
}
inline void Verbs::clear_items() {
  _impl_.items_.Clear();
}
inline std::string* Verbs::add_items() {
  std::string* _s = _internal_add_items();
  // @@protoc_insertion_point(field_add_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.Verbs.items)
  return _s;
}
inline const std::string& Verbs::_internal_items(int index) const {
  return _impl_.items_.Get(index);
}
inline const std::string& Verbs::items(int index) const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.Verbs.items)
  return _internal_items(index);
}
inline std::string* Verbs::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.Verbs.items)
  return _impl_.items_.Mutable(index);
}
inline void Verbs::set_items(int index, const std::string& value) {
  _impl_.items_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.Verbs.items)
}
inline void Verbs::set_items(int index, std::string&& value) {
  _impl_.items_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.Verbs.items)
}
inline void Verbs::set_items(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.items_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:k8s.io.apimachinery.pkg.apis.meta.v1.Verbs.items)
}
inline void Verbs::set_items(int index, const char* value, size_t size) {
  _impl_.items_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:k8s.io.apimachinery.pkg.apis.meta.v1.Verbs.items)
}
inline std::string* Verbs::_internal_add_items() {
  return _impl_.items_.Add();
}
inline void Verbs::add_items(const std::string& value) {
  _impl_.items_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:k8s.io.apimachinery.pkg.apis.meta.v1.Verbs.items)
}
inline void Verbs::add_items(std::string&& value) {
  _impl_.items_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:k8s.io.apimachinery.pkg.apis.meta.v1.Verbs.items)
}
inline void Verbs::add_items(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.items_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:k8s.io.apimachinery.pkg.apis.meta.v1.Verbs.items)
}
inline void Verbs::add_items(const char* value, size_t size) {
  _impl_.items_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:k8s.io.apimachinery.pkg.apis.meta.v1.Verbs.items)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Verbs::items() const {
  // @@protoc_insertion_point(field_list:k8s.io.apimachinery.pkg.apis.meta.v1.Verbs.items)
  return _impl_.items_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Verbs::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:k8s.io.apimachinery.pkg.apis.meta.v1.Verbs.items)
  return &_impl_.items_;
}

// -------------------------------------------------------------------

// WatchEvent

// optional string type = 1;
inline bool WatchEvent::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool WatchEvent::has_type() const {
  return _internal_has_type();
}
inline void WatchEvent::clear_type() {
  _impl_.type_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& WatchEvent::type() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.WatchEvent.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WatchEvent::set_type(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:k8s.io.apimachinery.pkg.apis.meta.v1.WatchEvent.type)
}
inline std::string* WatchEvent::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.WatchEvent.type)
  return _s;
}
inline const std::string& WatchEvent::_internal_type() const {
  return _impl_.type_.Get();
}
inline void WatchEvent::_internal_set_type(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* WatchEvent::_internal_mutable_type() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* WatchEvent::release_type() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.WatchEvent.type)
  if (!_internal_has_type()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.type_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void WatchEvent::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.WatchEvent.type)
}

// optional .k8s.io.apimachinery.pkg.runtime.RawExtension object = 2;
inline bool WatchEvent::_internal_has_object() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.object_ != nullptr);
  return value;
}
inline bool WatchEvent::has_object() const {
  return _internal_has_object();
}
inline const ::k8s::io::apimachinery::pkg::runtime::RawExtension& WatchEvent::_internal_object() const {
  const ::k8s::io::apimachinery::pkg::runtime::RawExtension* p = _impl_.object_;
  return p != nullptr ? *p : reinterpret_cast<const ::k8s::io::apimachinery::pkg::runtime::RawExtension&>(
      ::k8s::io::apimachinery::pkg::runtime::_RawExtension_default_instance_);
}
inline const ::k8s::io::apimachinery::pkg::runtime::RawExtension& WatchEvent::object() const {
  // @@protoc_insertion_point(field_get:k8s.io.apimachinery.pkg.apis.meta.v1.WatchEvent.object)
  return _internal_object();
}
inline void WatchEvent::unsafe_arena_set_allocated_object(
    ::k8s::io::apimachinery::pkg::runtime::RawExtension* object) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.object_);
  }
  _impl_.object_ = object;
  if (object) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.WatchEvent.object)
}
inline ::k8s::io::apimachinery::pkg::runtime::RawExtension* WatchEvent::release_object() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::k8s::io::apimachinery::pkg::runtime::RawExtension* temp = _impl_.object_;
  _impl_.object_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::k8s::io::apimachinery::pkg::runtime::RawExtension* WatchEvent::unsafe_arena_release_object() {
  // @@protoc_insertion_point(field_release:k8s.io.apimachinery.pkg.apis.meta.v1.WatchEvent.object)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::k8s::io::apimachinery::pkg::runtime::RawExtension* temp = _impl_.object_;
  _impl_.object_ = nullptr;
  return temp;
}
inline ::k8s::io::apimachinery::pkg::runtime::RawExtension* WatchEvent::_internal_mutable_object() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.object_ == nullptr) {
    auto* p = CreateMaybeMessage<::k8s::io::apimachinery::pkg::runtime::RawExtension>(GetArenaForAllocation());
    _impl_.object_ = p;
  }
  return _impl_.object_;
}
inline ::k8s::io::apimachinery::pkg::runtime::RawExtension* WatchEvent::mutable_object() {
  ::k8s::io::apimachinery::pkg::runtime::RawExtension* _msg = _internal_mutable_object();
  // @@protoc_insertion_point(field_mutable:k8s.io.apimachinery.pkg.apis.meta.v1.WatchEvent.object)
  return _msg;
}
inline void WatchEvent::set_allocated_object(::k8s::io::apimachinery::pkg::runtime::RawExtension* object) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.object_);
  }
  if (object) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(object));
    if (message_arena != submessage_arena) {
      object = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, object, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.object_ = object;
  // @@protoc_insertion_point(field_set_allocated:k8s.io.apimachinery.pkg.apis.meta.v1.WatchEvent.object)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace meta
}  // namespace apis
}  // namespace pkg
}  // namespace apimachinery
}  // namespace io
}  // namespace k8s

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_staging_5fsrc_5fk8s_2eio_5fapimachinery_5fpkg_5fapis_5fmeta_5fv1_5fgenerated_2eproto
